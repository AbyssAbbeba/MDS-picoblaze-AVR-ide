// =============================================================================
/**
 * @brief
 * C++ Interface: ...
 *
 * ...
 *
 * (C) copyright 2013, 2014 Moravia Microsystems, s.r.o.
 *
 * @author Martin OÅ¡mera <martin.osmera@moravia-microsystems.com>
 * @ingroup AdaptableSim
 * @file AdaptableSimStatusFlags.h
 */
// =============================================================================

#ifndef ADAPTABLESIMSTATUSFLAGS_H
#define ADAPTABLESIMSTATUSFLAGS_H

#include "../MCUSim.h"

#include "AdaptableSimInstruction.h"
#include "AdaptableSimStatusFlagsBase.h"

/**
 * @brief
 * @ingroup AdaptableSim
 * @class AdaptableSimStatusFlags
 */
class AdaptableSimStatusFlags : public MCUSimSubsys,
                                public AdaptableSimStatusFlagsBase
{
    ////    Public Datatypes    ////
    public:
        /**
         * @brief Events generated by the subsystem.
         */
        enum Event
        {
            EVENT_FLAGS_ZERO_CHANGED,           ///<
            EVENT_FLAGS_CARRY_CHANGED,          ///<
            EVENT_FLAGS_OVERFLOW_CHANGED,       ///<
            EVENT_FLAGS_NEGATIVE_CHANGED,       ///<
            EVENT_FLAGS_HALF_CARRY_CHANGED,     ///<
            EVENT_FLAGS_FLAG_PARITY_CHANGED,    ///<
            EVENT_FLAGS_FLAG_CHANGED,           ///<
            EVENT_FLAGS_PZ_CHANGED,             ///<
            EVENT_FLAGS_PC_CHANGED,             ///<
            EVENT_FLAGS_IE_CHANGED,             ///<
            EVENT_FLAGS_INT_CHANGED,            ///<

            EVENT_FLAGS__MAX__                  ///<
        };

        /**
         * @brief Subsystem configuration.
         */
        struct Config
        {
            bool m_backupWhenInterrupted;
            bool m_autoDisableInterrupts; // When when entering ISR.
            bool m_autoEnableInterrupts; // When when leaving ISR.

            bool m_hasZero;
            bool m_hasCarry;
            bool m_hasOverflow;
            bool m_hasNegative;
            bool m_hasHalfCarry;
            bool m_hasParity;
        };

    ////    Constructors and Destructors    ////
    public:
        /**
         * @brief
         */
        AdaptableSimStatusFlags();

    ////    Public Operations    ////
    public:
        /**
         * @brief
         * @param[in] mode
         */
        virtual void reset ( MCUSimBase::ResetMode mode ) override;

        /**
         * @brief
         * @param[in,out] eventLogger
         * @return
         */
        AdaptableSimStatusFlags * link ( MCUSimEventLogger * eventLogger );

        /**
         * @brief
         */
        void interrupt();

        /**
         * @brief
         */
        void returni();

        /// @name Accessors methods.
        //@{
            /**
             * @brief
             * @return
             */
            int getInterrupted() const
            {
                return m_interrupted;
            }

            /**
             * @brief
             * @return
             */
            bool getCarry() const
            {
                return m_carry;
            }

            /**
             * @brief
             * @return
             */
            bool getZero() const
            {
                return m_zero;
            }

            /**
             * @brief
             * @return
             */
            bool getPreCarry() const
            {
                return m_preCarry;
            }

            /**
             * @brief
             * @return
             */
            bool getPreZero() const
            {
                return m_preZero;
            }

            /**
             * @brief
             * @return
             */
            bool getInte() const
            {
                return m_inte;
            }

            /**
             * @brief
             * @return
             */
            bool getFlag ( AdaptableSimInstruction::OperParam::ProcFlag flag ) const;
        //@}

        /// @name Mutator methods.
        //@{
            /**
             * @brief
             * @param[in] value
             */
            void setInterrupted ( int value )
            {
                m_interrupted = value;
                logEvent(EVENT_FLAGS_INT_CHANGED, 0, value);
            }

            /**
             * @brief
             * @param[in] flag
             */
            void setCarry ( bool flag )
            {
                m_carry = flag;
                logEvent(EVENT_FLAGS_CARRY_CHANGED, 0, flag);
            }

            /**
             * @brief
             * @param[in] flag
             */
            void setZero ( bool flag )
            {
                m_zero = flag;
                logEvent(EVENT_FLAGS_ZERO_CHANGED, 0, flag);
            }

            /**
             * @brief
             * @param[in] flag
             */
            void setPreCarry ( bool flag )
            {
                m_preCarry = flag;
                logEvent(EVENT_FLAGS_PC_CHANGED, 0, flag);
            }

            /**
             * @brief
             * @param[in] flag
             */
            void setPreZero ( bool flag )
            {
                m_preZero = flag;
                logEvent(EVENT_FLAGS_PZ_CHANGED, 0, flag);
            }

            /**
             * @brief
             * @param[in] flag
             */
            void setInte ( bool flag )
            {
                m_inte = flag;
                logEvent(EVENT_FLAGS_IE_CHANGED, 0, flag);
            }

            /**
             * @brief
             * @param[in] flag
             * @param[in] value
             */
            void setFlag ( AdaptableSimInstruction::OperParam::ProcFlag flag,
                           bool value );
        //@}

    ////    Public Attributes    ////
    public:
        /// Subsystem configuration.
        Config m_config;
};

#endif // ADAPTABLESIMSTATUSFLAGS_H
