In this chapter, we will be concerned with build-in macro assembler. With syntax of its statements, directives, and PicoBlaze assembler instructions. It is assumed, that the reader is familiar with general concepts of assembly language programming and PicoBlaze architecture.

MDS assembler for PicoBlaze is a two stage fast macro-assembler inspired by Intel assemblers and the C language. It supports wide range of output data formats, and when you master its advanced features like macro processing, conditions, loops, etc. it might give you means to write code with run-time efficiency typical for an assembly language while giving you some of the comfort of a more high-level language like C. For instance you may use ``\verb'if ( S0 == S1 )''' to easy write conditions instead of compares and conditional jumps, ``\verb'for ( S0, 0 .. 9 )''' for loops, ``\verb'#if my_constant > 20''' for conditional compilation, ``\verb'abc macro x, y, z''' for defining your own macros, and more. MDS macro-assembler is enhanced with features in hope it will help you save your time and make programming a little bit easier. MDS assembler supports features for smooth and transparent debugging and it is regularly subjected to extensive automated testing to ensure its very functionality and to provide high reliability. For these reasons we are convinced that this is the most advanced assembler for PicoBlaze currently available on the market.

\paragraph{Note about this documentation:}to write a document properly describing basically any programming language, including the assembly language, is always a challenging task. If you find a mistake or improperly covered area in this documentation, please let us know, we will fix that and provide you with the fixed version right away.

\section{Basics}
    \subsection{Main differences from the Xilinx assembler}
        \begin{description}
            \item[Default radix is decimal, not hexadecimal.]~\\
                You can use different radix for each numerical literal, if you do not specify radix, it is decimal by default. For hexadecimal radix use `0x' prefix: 0x1a, 0xbc, 0x23, ...; for octal radix use `0' (zero) prefix: 076, 011, 027, ...; for binary radix use `0b' prefix: 0b11001100, 0b10101010, 0b11111111, ...; for ASCII value put the character in single quotes: 'a', 'A', '3', ... Suffix notation is also supported: 80h (hex.), 128d (dec.), 200q (oct.), 10000000b (bin.), for ASCII characters, you can also use C language escape sequences: \verb"'\0'"~(NUL), \verb"'\n'"~(LF), \verb"'\r"~(CR), \verb"'\t"~(TAB), ...
            \item[Addressing mode specification is mandatory.]~\\
                For immediate addressing use `\#' prefix: \texttt{LOAD~S0,~\#0xAB}; for indirect addressing you ``@'' prefix: ``\texttt{STORE~S0,~@S1}''; for direct addressing use no prefix: ``\texttt{LOAD~S0,~S1~+~3}'' (this loads S0 with S4).
            \item[This assembler is case insensitive.]~\\
                ``\texttt{load~S0,~S1}'' is the same as ``\texttt{LOAD~s0,~s1}'', or ``\texttt{Load~S0,~s1}''.
            \item[This assembler supports user defined macro instructions, and expressions.]~\\
                ``\texttt{LOAD~S0,~\#(2~+~3~*~8)}'', etc. please refer to the Tutorial Project, and the Quick User Guide for brief introduction, or to later pages in this manual for detailed description.
        \end{description}

    \subsection{Statements}
        Source code files for this assembler have to be text files formed like:\\
        ~\\
        \verb'[ label: ]  [ instruction  [ operand  [ , operand  ] ]    [ ;comment ]'\\
        \verb'[ label: ]  directive      [ argument [ , argument ] ]    [ ;comment ]'\\
        \verb'[ symbol ]  directive      [ argument [ , argument ... ]  [ ;comment ]'\\
        \verb'            directive      symbol, argument               [ ;comment ]'\\

        Tokens in square brackets are optional. Compilation does not continue beyond line containing the \texttt{END} directive so after that directive the code does not have to be syntactically valid. Empty lines are valid, as well as lines containing only comment or label. Statements are separated by white space (spaces or tabs). Statements are case insensitive and their length is not limited, overall line length is also not limited.

    \subsection{Comments}
        Comments in source code are ignored by the assembler (the are supposed to serve only as notes to the developer). MDS assembler uses two types of comments: single-line comment starting with ``\texttt{;}'' (semicolon) character and ending with the end of line, and multi-line comments starting with ``\texttt{/*}'' (slash followed by asterisk) sequence and ending with ``\texttt{*/}'' (asterisk followed by slash) sequence (just like in C language).

        \paragraph{Example}
            ~\\
            \verb'    ; Single-line comment'\\
            \verb'    '\\
            \verb'    /*'\\
            \verb'     * Multi-line comment ...'\\
            \verb'     */'\\
            \verb'    '\\
            \verb'    LOAD /* Comment, */ S0, /* another comment, */ S1 ; more comment.'

    \clearpage
    \subsection{Numeric constants}
        MDS assembler supports multiple radixes for numeric constants, radix is specified wither using prefix or suffix notation.

        ~\\
        \verb"    ; Hexadecimal."\\
        \verb"    ld          S0, #0xAB       ; prefix notation (`0x...')"\\
        \verb"    ld          S0, #0ABh       ; suffix notation (`...h')"\\
        \verb""\\
        \verb"    ; Decimal."\\
        \verb"    ld          S0, #123        ; no prefix - default radix - decimal"\\
        \verb"    ld          S0, #123d       ; suffix notation (`d')"\\
        \verb""\\
        \verb"    ; Octal."\\
        \verb"    ld          S0, #076        ; prefix notation (`0...')"\\
        \verb"    ld          S0, #76q        ; suffix notation (`...q')"\\
        \verb"    ld          S0, #76o        ; suffix notation (`...o')"\\
        \verb""\\
        \verb"    ; Binary."\\
        \verb"    ld          S0, #0b1100     ; prefix notation (`0b...')"\\
        \verb"    ld          S0, #1100b      ; suffix notation (`...b')"\\
        \verb""\\
        \verb"    ; ASCII."\\
        \verb"    ld          S0, #'A'        ; ASCII value of capital A."\\
        \verb"    ld          S0, #'\t'       ; ASCII value of the tab character (escape sequence)."

        \subsubsection{Escape sequences}
            \index{Escape sequences}
            In place of ASCII value you can also use a single escape sequence, escape sequences can also be used in strings (\verb'"abc\nabc"'). Escape sequences in MDS assembler are exactly the same as in the C language.

            \begin{table}[h!]
                \centering
                \begin{tabular}{|c|l|c|}
                    \hline
                    \textbf{Sequence} & \textbf{Description} & \textbf{Value} \\\hline
                    \verb'\a'         & alarm (bell)         & 0x07 \\\hline
                    \verb'\b'         & backspace            & 0x08 \\\hline
                    \verb"\'"         & single quote         & 0x27 \\\hline
                    \verb'\"'         & double quote         & 0x22 \\\hline
                    \verb'\?'         & question mark        & 0x3F \\\hline
                    \verb'\\'         & backslash            & 0x5C \\\hline
                    \verb'\f'         & form feed            & 0x0C \\\hline
                    \verb'\n'         & line feed            & 0x0A \\\hline
                    \verb'\r'         & carriage return      & 0x0D \\\hline
                    \verb'\t'         & horizontal tab       & 0x09 \\\hline
                    \verb'\v'         & vertical tab         & 0x0B \\\hline
                    \verb'\e'         & escape               & 0x1B \\\hline
                \end{tabular}
                \caption{Escape sequences.}
            \end{table}

            In addition to the escape sequences sequences described int the table above, MDS assembler also supports these escape sequences:
            \begin{description}
                \item[$\backslash$NNN]~\\
                    To write a character whose numerical value is given by \texttt{NNN} interpreted as an octal number (e.g. \verb'\0', \verb'\22', \verb'\377', etc.).
                \item[$\backslash$xHH]~\\
                    To write a character whose numerical value is given by \texttt{HH} interpreted as an hexadecimal number (e.g. \verb'\x0F', \verb'\x2A', \verb'\xC7', etc.).
                \item[$\backslash$uXX]~\\
                    To write a unicode character specified by max. 4 hexadecimal digits.
                \item[$\backslash$uXXXX]~\\
                    To write a unicode character specified by max. 8 hexadecimal digits.
            \end{description}

    \subsection{Symbols}
        \index{Symbols}
        Symbols are user defined symbolic names for numbers or addresses. Symbol names consist of upper and lower case letters, digits, and underscore character (``\_''), their length is not limited, they are case insensitive and they have to be different from language keywords. Be aware of that there cannot coexists two or more symbols which differs only by letter casing, for instance ``\texttt{abc}'' and ``\texttt{ABC}'' are considered by this assembler to be one symbol.

        \paragraph{Example}
        ~\\
        \verb'    first_symbol      EQU     0b100111 ; Binary radix, number.'\\
        \verb'    second_symbol     SET     047      ; Octal radix, number.'\\
        \verb'    third_symbol      REG     39       ; Decimal radix, register address.'\\
        \verb'    fourth_symbol     DATA    0x27     ; Hexadecimal radix, scratch-pad ram address.'\\
        \verb'    fifth_symbol      CODE    0x27     ; Hexadecimal radix, program memory address.'

        \subsubsection{Special Symbols}
            MDS assembler support only one special symbol which is always defined on every line containing an instruction (or the \texttt{DB} directive), symbol ``\texttt{\$}'' contains address in program memory where this instruction is going to be placed by the assembler.

            \paragraph{Example}
                ~\\
                \verb'    ; Since $ conatins the address of the JUMP instruction,'\\
                \verb'    ; this jump results in infinite loop.'\\
                \verb'    JUMP    $'\\
                \verb''\\
                \verb'    ; Skip the next instruction ($+1 would "skip" only the jump itself).'\\
                \verb'    JUMP    $+2'\\
                \verb'    LOAD    S0, S1   ; <-- This instruction is goigh to be skipped.'\\
                \verb'    LOAD    S2, S3'

        \clearpage
        \subsubsection{Predefined Symbols}
            These symbols are defined by default when you specify the target device (directive ``device''). Symbols S10..S1F are defined for KCPSM2 only, and S8..S1F are not defined for KCPSM1-CPLD. All these symbols are defined as register addresses.

            \begin{table}[h!]
                \centering
                \begin{tabular}{|cc|cc|}
                    \hline
                    \textbf{Symbol} & \textbf{Value} & \textbf{Symbol} & \textbf{Value} \\\hline
                    \texttt{S0}     & 0x00           & \texttt{S10}    & 0x10           \\\hline
                    \texttt{S1}     & 0x01           & \texttt{S11}    & 0x11           \\\hline
                    \texttt{S2}     & 0x02           & \texttt{S12}    & 0x12           \\\hline
                    \texttt{S3}     & 0x03           & \texttt{S13}    & 0x13           \\\hline
                    \texttt{S4}     & 0x04           & \texttt{S14}    & 0x14           \\\hline
                    \texttt{S5}     & 0x05           & \texttt{S15}    & 0x15           \\\hline
                    \texttt{S6}     & 0x06           & \texttt{S16}    & 0x16           \\\hline
                    \texttt{S7}     & 0x07           & \texttt{S17}    & 0x17           \\\hline
                    \texttt{S8}     & 0x08           & \texttt{S18}    & 0x18           \\\hline
                    \texttt{S9}     & 0x09           & \texttt{S19}    & 0x19           \\\hline
                    \texttt{SA}     & 0x0A           & \texttt{S1A}    & 0x1A           \\\hline
                    \texttt{SB}     & 0x0B           & \texttt{S1B}    & 0x1B           \\\hline
                    \texttt{SC}     & 0x0C           & \texttt{S1C}    & 0x1C           \\\hline
                    \texttt{SD}     & 0x0D           & \texttt{S1D}    & 0x1D           \\\hline
                    \texttt{SE}     & 0x0E           & \texttt{S1E}    & 0x1E           \\\hline
                    \texttt{SF}     & 0x0F           & \texttt{S1F}    & 0x1F           \\\hline
                \end{tabular}
                \caption{Predefined symbols}
            \end{table}

    \subsection{Expressions}
        \index{Expressions}
        Arithmetical expressions are evaluated at compilation time and replaced with constants corresponding to their resulting value. Expression calculation is performed on 32-bit unsigned integers, the resulting values are trimmed to 16-bits at most (with exception for DB where values might be trimmed to 18 bits). Expressions comprise of arithmetical operators, constants, and symbols. Examples of such expressions:

        \begin{itemize}
            \item \texttt{2+1}
            \item \texttt{(2 + 4) - ABC}
            \item \texttt{A \& B}
            \item \texttt{X / 0FF00h}
            \item \texttt{X * Y + X \% Y}
        \end{itemize}

        When operators with different priority levels appear in an expression, operations are evaluated according to priorities. When operators of the same priority appear in an expression, operations are evaluated from left to right. Parenthesis may be used to force order of evaluation, for example \texttt{2 + 2 * 2} is evaluated as 6 because multiplication has higher priority than addition, but \texttt{( 2 + 2 ) * 2} results in 8 because addition is enclosed by parenthesis and therefore it is evaluated prior to the multiplication.

        The table below show priorities for all supported operators, priority 1 is the highest priority, and priority 9 is the lowest priority. All logical operators have priorities lower than arithmetic and relational operators.

        \begin{table}[h!]
            \centering
            \begin{tabular}{|c|c|l|l|}
                \hline
                \textbf{Priority} & \textbf{Operator} & \textbf{Description} & \textbf{Example} \\\hline
                1        & \texttt{+}    & unary plus sign         & \texttt{+12}               \\\hline
                1        & \texttt{-}    & unary minus sign        & \texttt{-5}                \\\hline
                2        & \texttt{\~{}} & bitwise NOT             & \texttt{\~{}0a55ah}        \\\hline
                2        & \texttt{!}    & logical NOT             & \texttt{!0a55ah}           \\\hline
                3        & \texttt{*}    & unsigned multiplication & \texttt{11 * 12}           \\\hline
                3        & \texttt{/}    & unsigned division       & \texttt{11 / 12}           \\\hline
                3        & \texttt{\%}   & unsigned modulo         & \texttt{13 \% 11}          \\\hline
                4        & \texttt{+}    & unsigned addition       & \texttt{3 + 5}             \\\hline
                4        & \texttt{-}    & unsigned subtraction    & \texttt{20 - 4}            \\\hline
                5        & \texttt{<{}<} & binary shift left       & \texttt{21 <{}< 4}         \\\hline
                5        & \texttt{>{}>} & binary shift right      & \texttt{32 >{}> 2}         \\\hline
                6        & \texttt{<}    & less than               & \texttt{11 < 12}           \\\hline
                6        & \texttt{<=}   & less or equal than      & \texttt{11 <= 11}          \\\hline
                6        & \texttt{>}    & greater than            & \texttt{12 > 11}           \\\hline
                6        & \texttt{>=}   & greater or equal than   & \texttt{12 >= 11}          \\\hline
                7        & \texttt{==}   & equal to                & \texttt{11 == 11}          \\\hline
                7        & \texttt{!=}   & not equal to            & \texttt{A != B}           \\\hline
                7        & \texttt{<>}   & not equal to            & \texttt{A <> B}           \\\hline
                8        & \texttt{\&}   & bitwise AND             & \texttt{48 \& 16}          \\\hline
                8        & \texttt{|}    & bitwise OR              & \texttt{370q | 7}          \\\hline
                9        & \texttt{\&\&} & logical AND             & \texttt{48 \&\& 16}        \\\hline
                9        & \texttt{||}   & logical OR              & \texttt{370q || 7}         \\\hline
                9        & \texttt{\^{}} & bitwise XOR             & \texttt{00fh \^{} 005h}    \\\hline
            \end{tabular}
            \caption{Operators priorities.}
        \end{table}

        \subsubsection{Special operators}
            Special operators can appear only at certain places and servers special purpose.
            \begin{description}
                \item[high(...)]~\\
                    Operator \texttt{HIGH(...)} extract the high order byte from 16 bit value. For example \texttt{LOAD  S0, \#high(0x2233)} would load S0 with immediate value of 0x22.
                \item[low(...)]~\\
                    Operator \texttt{LOW(...)} extract the low order byte from 16 bit value. For example \texttt{LOAD  S0, \#low(0x2233)} would load S0 with immediate value of 0x33.
                \item[at]~\\
                    Operator \texttt{AT} is used only in conjunction with \texttt{AUTOREG} and \texttt{AUTOSPR} directives to set address counter to the specified value.
                \item[..]~\\
                    Operator \texttt{..} is used only with the \texttt{FOR} directive to specify loop interval.
            \end{description}

    \subsection{Reserved keywords}
        Please remember that the assembler is case insensitive.
        \subsubsection{Instruction mnemonics}
            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|}
                        \hline
                        cpl2 & cpl  & inc  & dec  & setr & clrr \\\hline
                        setb & clrb & notb & djnz & ijnz & nop  \\\hline
                    \end{tabular}
                }
                \caption{Pseudo-instructions}
            \end{table}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|l|}
                        \hline
                        ldret & ena  & dis & retie & retid & cmp & in  \\\hline
                        out   & outk & ld  & cmpcy & st    & ft  & ret \\\hline
                    \end{tabular}
                }
                \caption{Instruction shorthands}
            \end{table}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|l|}
                        \hline
                        add     & addcy & sub    & subcy   & compare & load      & return \\\hline
                        and     & or    & xor    & test    & store   & fetch     & jump   \\\hline
                        sr0     & sr1   & srx    & sra     & rr      & sl0       & call   \\\hline
                        sl1     & slx   & sla    & rl      & input   & output    &        \\\hline
                        hwbuild & star  & testcy & outputk & jump    & comparecy &        \\\hline
                    \end{tabular}
                }
                \caption{Regular instructions}
            \end{table}

        \subsubsection{Directives}
            Regular directives directives can be prefixed with ``\texttt{.}'' (period) character without any effect on their meaning and function.

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|}
                        \hline
                        if       & elseif & else & endif & while  \\\hline
                        endwhile & endw   & for  & endf  & endfor \\\hline
                    \end{tabular}
                }
                \caption{Special macros}
            \end{table}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|}
                        \hline
                        \#if         & \#ifn   & \#ifdef  & \#ifndef  & \#elseifb   & \#endwhile \\\hline
                        \#elseifnb   & \#else  & \#elseif & \#elseifn & \#elseifdef & \#endw     \\\hline
                        \#elseifndef & \#endif & \#ifnb   & \#ifb     & \#while     &            \\\hline
                    \end{tabular}
                }
                \caption{Conditional compilation \& the \texttt{\#WHILE}}
            \end{table}

            \enlargethispage{6\baselineskip}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|}
                        \hline
                        failjmp & device   & limit    & reg       & string   & default\_jump \\\hline
                        namereg & address  & org      & define    & undefine & undef         \\\hline
                        equ     & constant & set      & variable  & port     & portin        \\\hline
                        portout & data     & code     & string    & db       & error         \\\hline
                        warning & list     & message  & messg     & nolist   & skip          \\\hline
                        title   & expand   & noexpand & local     & endmacro & endm          \\\hline
                        exitm   & repeat   & rept     & endrepeat & endr     & autoreg       \\\hline
                        autospr & orgspr   & initspr  & mergespr  & macro    & end           \\\hline
                    \end{tabular}
                }
                \caption{Regular directives}
            \end{table}

\clearpage
\section{Instructions}
    \input{chapter_Built-in_Macro_assembler_instructions.tex}

\clearpage
\section{Pseudo Instructions}
    \input{chapter_Built-in_Macro_assembler_pseudo-instructions.tex}

\clearpage
\input{chapter_Built-in_Macro_assembler_directives.tex}

\clearpage
\section{Compiler messages}
    This chapter lists the error messages generated by MDS. The following sections include a brief description of the possible error messages along with a description of the error and any corrective actions you can take to avoid or eliminate the error. Errors terminate the assembly and generate a message that is displayed on the console. Warnings generate a message in the assembly listing file but do not terminate the assembly.

    \begin{description}
        \item[Unable to open file]~\\
            The given file cannot be opened, probably does not exists or your operating system refuses to grad you access to it. Check whether the file exists, and check your permissions.
        \item[Unable to write to file]~\\
            It is not possible to write into the given file. This is in most cases caused by wrong permissions on file or directory, or nonexistent directory in the file path.
        \item[Unable to save file]~\\
            The given file cannot be saved. This might indicate that there is something badly wrong, like not enough space left on your storage device (HDD, etc.).
        \item[The resulting machine code is too big to be stored in a file]~\\
            Size of the resulting machine code is bigger than your processor could possibly handle in its current configuration.
        \item[Some of the source code files were apparently changed during compilation]~\\
            Solution to that is: do not change source files during the compilation, wait for the compilation finish first.
        \item[User defined memory limit for X exceeded]~\\
            You have exceeded boundary of X memory defined for your processor configuration.
        \item[User defined memory limit for X exceeded]~\\
            You have exceeded boundary of X memory defined for the \texttt{LIMIT} directive.
        \item[Instruction X requires operand Y to be of type(s) Z]~\\
            This means you are for example trying to use a symbol defined as port address in place of register address.
        \item[Macro not defined ]~\\
            The macro you are attempting to use has not (yet) been defined, possibly you are trying to expand a macro before its definition.
        \item[Too many arguments given, expecting at most X arguments]~\\
            Directives require certain number of arguments, when you provide different number of arguments, the directive would in certain cases just not make sense.
        \item[Attempting to use unavailable space in X memory at address: Y]~\\
            Suppose you have 8 registers and you try for example to write to register at address 10, the assembler will then give you this error. The same, of course, apply also to program memory, or any other memory.
        \item[The last error was critical, compilation aborted]~\\
            Normally the assembler tries to carry on compiling for as long as possible despite errors, it is implemented that way to provide you with as many error message at the time as possible. But in certain cases it is not possible and compilation has to aborted instantaneously.
        \item[Device not supported]~\\
            The given processor is not supported, this usually happens due to some typo.
        \item[Device specification code is already loaded ]~\\
            The processor architecture has to be specified only once, multiple specifications for one source code would not make sense because they could "collide" with each other.
        \item[Limit value X is not valid]~\\
            Invalid limit specifier for the \texttt{LIMIT} directive.
        \item[Directive `LOCAL' cannot appear outside of macro definition ]~\\
            Directive \texttt{LOCAL} can be only used inside of macro definition, outside macro definition it has no meaning and therefore cannot be used.
        \item[Directive `EXITM' cannot appear outside macro definition]~\\
            Directive \texttt{EXITM} can be only used inside of macro definition, outside macro definition it has no meaning and therefore cannot be used.
        \item[Maximum macro expansion level X reached]~\\
            Maximum macro expansion level reached. You can change your compiler settings and set higher expansion level. By default, maximum macro expansion level is unlimited, which is possibly dangerous and users should set some limit for them selfs.
        \item[Maximum number of \#WHILE directive iterations reached]~\\
            Maximum number of the \texttt{\#WHILE} directive iterations has been reached. You can change your compiler settings to allow more iterations. By default, maximum number of \texttt{\#WHILE} iterations is unlimited, which is possibly dangerous and users should set some limit for them selfs.
        \item[Maximum number of REPEAT directive iterations reached]~\\
            Maximum number of the \texttt{REPEAT} directive iterations has been reached. You can change your compiler settings to allow more iterations. By default, maximum number of \texttt{REPEAT} iterations is unlimited, which is possibly dangerous and users should set some limit for them selfs.
        \item[Instruction word is only X bits wide, value Y trimmed to Z]~\\
            You have exceeded instruction word length, opcode value has been trimmed to X bits which reduces value Y to value Z.
        \item[Symbol already defined]~\\
            The given symbol has been already defined, there cannot coexist more symbols with the same name in one compilation unit.
        \item[Symbol not defined: X]~\\
            The given symbol has not been defined, maybe you are just trying to use it prior to its definition.
        \item[Symbol X already defined with type Y]~\\
            The given symbol has been already defined with type Y, you are trying to define more symbols with the same name but with different types. This is not allowed in this assembler because such practice tends to lower software quality.
        \item[Undefined value]~\\
            You are attempting to use some value whose numerical representation is unknown.
        \item[Real numbers are not supported in assembler]~\\
            Real numbers (1.8, 22.65, etc.) are not supported by this assembler.
        \item[Undefined symbol: X]~\\
            Symbol X has been undefined, i.e. deleted from the symbol table using the \texttt{UNDEFINE} directive and therefore can be no longer used.
        \item[This value is not valid inside of expression ]~\\
            Expressions in this assembler can be calculated only from integer values, strings, etc. are not allowed.
        \item[Division by zero]~\\
            Division by zero has been detected. It is not possible to divide with zero, therefore compilation is aborted.
        \item[Unable to resolve this expression]~\\
            The given expression cannot be resolved, check if expression is syntactically correct.
        \item[Syntax not understood]~\\
            There is syntax error in your source code which is for this assembler completely ununderstandable.
        \item[Character constant is too long]~\\
            Character constant is one letter only.
        \item[Unterminated string or character constant]~\\
            Strings and character constants start with ``\texttt{"}'' respectively ``\texttt{'}'', and has to end with the same character, i.e. ``\texttt{"}'' respectively ``\texttt{'}''.
        \item[Unrecognized escape sequence:]~\\
            Unrecognized escape sequence, please check the table of escape sequences for reference.
        \item[No file name specified]~\\
            You are trying to compile something but you did not provide file name of the source code file.
        \item[Unable to open the specified file: X]~\\
            The specified file cannot be opened, probably does not exists or your operating system refuses to grad you access to it. Check whether the file exists, and check your permissions.
        \item[Unrecognized token: X]~\\
            Lexical analyzer was unable to recognize this token. Normally this does not happen but in case your code contains some binary values with no printable representation or something like that, this may happen.
        \item[Maximum number of messages reached, suppressing compiler message generation]~\\
            Source code contains a huge number of errors, further error messages are from now on suppressed in order to prevent enormous size of code listing file, and enormous and impractical assembler console output.
        \item[Redefinition macro]~\\
            Once a macro is defined, it cannot be redefined.
        \item[Macro X will not be expanded because macro expansion has been disabled]~\\
            The given macro cannot be expanded because macro expansion has been temporarily disabled by \texttt{NOEXPAND} directive. You can use \texttt{EXPAND} directive to enable the expansion.
        \item[Parameter X substituted for blank value ]~\\
            Macros parameters are optional, those parameters which has not been substituted with arguments are filled with blank values. Parameters can be checked if they are blanks using \texttt{\#IFB} and \texttt{\#IFNB} directives.
        \item[Symbol X already declared as local]~\\
            You are trying to declare a symbol as local macro symbol multiple times.
        \item[Reusing already reserved space in X memory at address: Y]~\\
            There is a collision in two different attempts to utilize a memory space. For instance with the \texttt{ORG} directive you can easily by mistake attempt to put two instruction at the same location in the program memory.
        \item[Limit value -1 means unlimited]~\\
            Using -1 as directive argument for the \texttt{LIMIT} directive removes the limit, there is nothing bat at all about that but for some people it might be surprising so the assembler notifies you about it.
        \item[Symbol X declared as local but never used, declaration ignored]~\\
            What is the point of having a local symbol inside a macro and do not use it? This is not an error but its possible side effect from some error or mistake, that is why the compiler warns you about it.
        \item[Comparing two immediate constants, result is always positive]~\\
            When using autogenerated run-time conditions, it does not make much sense to write a condition which result is always known in advance, that is why you get this warning message.
        \item[Comparing two immediate constants, result is always negative]~\\
            When using autogenerated run-time conditions, it does not make much sense to write a condition which result is always known in advance, that is why you get this warning message.
        \item[Sign overflow. Result is negative number lower than the lowest negative...]~\\
            Two's complement signed arithmetic overflow occurred during expression evaluation.
        \item[File name contains a null character]~\\
            This is a very unlikely error message, it means that the provided file name contains an invalid character, in this case it is the NULL character.
        \item[Result is negative number X, this will be represented as X-bit number...]~\\
            Result is negative number, in two's complement signed arithmetic that means the number contains binary ones in high order bits, after the values is trimmed to fit binary width required for the specific purpose, it might result in a different value, even a positive number.
        \item[Value out of range, allowed range is [X,Y] (trimmed to Z bits) which makes it N]~\\
            Value exceeds the required range for the specific purpose.
    \end{description}

\clearpage
\section{Generated VHDL and Verilog files}
    As you know, the PicoBlaze microcontroller is primarily designed for use in a VHDL design flow. MDS will generate all necessary files that are needed for implementation in FPGA. The compiler will read a VHDL template and insert the generated machine code for PicoBlaze to complete the definition of program ROM and write the result into a new 'VHDL file that is ready for synthesis and simulation.

    Template can be modified to define alternative memory definitions. However, you are responsible for ensuring the template is correct as the compiler does not perform any checking of the validity VHDL template.

    The compiler identifies all text enclosed by {} characters, and replaces these character strings. Templates have to contain these {} characters enclosed strings for the compiler to work correctly. The MDS assembler replaces instances on {INIT\_XX}, {INITP\_XX} and {INIT64\_X}, {INIT128\_X}, {INIT256\_X} by constant strings with the appropriate values, similar to the kcpsmX tools from Xilinx.

\section{Raw binary file}
    Raw binary file file contains machine code generated by the assembler in raw form. It contains opodes of instructions in formatted as either as sequence of byte triplets (in case of 18 bit instruction opcodes), or sequence of byte pairs (in case of 16 bit instructions opcodes). Unused memory locations and higher bits of bytes which are not used in their entire width are filled with binary zeros. Byte order is big-endian.

\section{String table}
    String table contains list of strings defined in your source code with additional information.\\

    \paragraph{File format}
        ~\\
        The table of strings is text file consisting of a number of lines with following format:\\
        \begin{tabular}{|ccc|}
            \hline
            Name & Location & "Value" \\
            \hline
        \end{tabular}

    \begin{description}
        \item[Name]~\\
            Name of string.
        \item[Location]~\\
            Location of string definition formatted as: <file-name>:<line-number>.<column>.<line-number>.<column>
        \item[Value]~\\
            The character string assigned to the name.
    \end{description}

\clearpage
\section{Macro table}
    Macro table contains list of macros in your source code with additional information.\\

    \paragraph{File format}
        ~\\
        The table of symbols is text file consisting of a number of lines with following format:\\
        \begin{tabular}{|ccc|}
            \hline
            Name & Usage & Location \\
            \hline
        \end{tabular}

    \begin{description}
        \item[Name]~\\
            Name of macro.
        \item[Usage]~\\
            It tells you how many times the macro was used.
        \item[Location]~\\
            Location of macro definition formatted as: <file-name>:<line-number>.<column>.<line-number>.<column>
    \end{description}

\section{Symbol table}
    Symbol table contains list of symbols defined in your source code with additional information.

    \paragraph{File format}
        ~\\
        The table of symbols is text file consisting of a number of lines with following format:\\
        \begin{tabular}{|cccccc|}
            \hline
            Name & Type & Value & Usage & Parameter & Location \\
            \hline
        \end{tabular}

    \begin{description}
        \item[Name]
            Symbol name.

        \item[Type]
            Defines symbol type.
            \begin{itemize}
                \item PORT: Symbol should be used as PORT\_ID indicator.
                \item DATA: Symbol should be used only as a scatch-pad ram data.
                \item LABEL: Symbol is label defining address in program memory.
                \item REGISTER: Symbol represents one of the internal registers.
                \item EXPRESION: Symbol is defined as an expression.
                \item NUMBER: Symbol does not have specific type.
            \end{itemize}

        \item[Value]
            Value assigned to the symbol.

        \item[Usage]
            USED or NOT USED.

        \item[Parameter]
            \begin{itemize}
                \item IMPLICIT: Symbol is defined implicitly for your architecture.
                \item LOCAL: Local symbol in some macro.
                \item REDEFINABLE: Symbol is re-definable, i.e. is not constant.
                \item CONSTANT: Symbol cannot be redefined, i.e. is constant.
            \end{itemize}

        \item[Location]
            Location of symbol definition formatted as: <file-name>:<line-number>.<column>.<line-number>.<column>
    \end{description}

\clearpage
\section{MEM File}
    MEM file contains machine code generated by the assembler. There are 17 columns 4 byte wide, the first column starts with ``\@'' and represents address, other columns contain instruction opcodes. Unused locations are filled with zeros, i.e. if there is no instruction on a certain address, it is filled with zeros.

    \paragraph{Example}
        ~\\
        \verb'@0000 000011F7 00001299 0000132E ... ... ... 00004577 00007789 000015A4'\\
        \verb'...'\\
        \verb'...'\\
        \verb'...'\\
        \verb'@0040 000004DF 000047F4 00000000 ... ... ... 00000000 00000000 00000000'\\
        \verb'@0080 00000000 00000000 00000000 ... ... ... 00000000 00000000 00000000'\\
        \verb'@00C0 00000000 00000000 00000000 ... ... ... 00000000 00000000 00000000'\\
        \verb'@0100 00000000 00000000 00000000 ... ... ... 00000000 00000000 00000000'\\
        \verb'...'\\
        \verb'...'\\
        \verb'...'\\
        \verb'@3F80 000011F7 00001299 0000132E ... ... ... 00000000 00000000 00000000'\\
        \verb'@3FC0 000011F7 00001299 0000132E ... ... ... 00000000 00000000 00000000'\\

\section{Raw Hex Dump file}
    Raw Hex Dump is very simple: file starts with hexadecimal representation of opcode of the first instruction in your program at address 0 then it is followed by opcode at address 0x1, 0x2, and so on. Unused locations are filled with zeros.

    \paragraph{Example}
        ~\\
        \verb'011F7'\\
        \verb'01299'\\
        \verb'0132E'\\
        \verb'19101'\\
        \verb'00000'\\
        \verb'19201'\\
        \verb'00000'\\
        \verb'19301'\\
        \verb'00000'\\
        \verb'00000'\\
        \verb'00...'\\
        \verb'.....'\\
        \verb'...00'\\

\clearpage
\section{Motorola S-Rec format}
    Motorola S-records are a form of simple ASCII encoding for binary data. An S-record file consists of a sequence of specially formatted ASCII character strings. An S-record will be less than or equal to 78 bytes in length. The order of S-records within a file is of no significance and no particular order may be assumed.

    \paragraph{File format}
        ~\\
        The Motorola S-Rec file consists of a number of lines with following format:\\
        \begin{tabular}{|ccccc|}
            \hline
            Type & Count & Address & Data & Checksum \\
            \hline
        \end{tabular}

    \begin{description}
        \item[Type]~\\
            A char[2] field. These characters describe the type of record (S0,S1, S2, S3, S5, S7, S8, or S9).

        \item[Count]~\\
            A char[2] field. These characters when paired and interpreted as a hexadecimal value, display the count of remaining character pairs in the record.

        \item[Address]~\\
            A char[4,6, or 8] field. These characters grouped and interpreted as a hexadecimal value, display the address at which the data field is to be loaded into memory. The length of the field depends on the number of bytes necessary to hold the address. A 2-byte address uses 4 characters, a 3-byte address uses 6 characters, and a 4-byte address uses 8 characters.

        \item[Data]~\\
            A char [0-64] field. These characters when paired and interpreted as hexadecimal values represent the memory loadable data or descriptive information.

        \item[Checksum]~\\
            A char[2] field. These characters when paired and interpreted as a hexadecimal value display the least significant byte of the ones complement of the sum of the byte values represented by the pairs of characters making up the count, the address, and the data fields.
    \end{description}

    Each record is terminated with a line feed. If any additional or different record terminator(s) or delay characters are needed during transmission to the target system it is the responsibility of the transmitting program to provide them.

    \subsection{Record types}
        \begin{description}
            \item[S0]~\\
                The type of record is S0 (0x5330). The address field is unused and will be filled with zeros (0x0000). The header information within the data field is divided into the following subfields.

                \begin{itemize}
                    \item mname is char[20] and is the module name.
                    \item ver is char[2] and is the version number.
                    \item rev is char[2] and is the revision number.
                    \item description is char[0-36] and is a text comment.
                \end{itemize}

                Each of the subfields is composed of ASCII bytes whose associated characters when paired, represent one byte hexadecimal values in the case of the version and revision numbers, or represent the hexadecimal values of the ASCII characters comprising the module name and description.

            \item[S1]~\\
                The type of record field is S1 (0x5331). The address field is interpreted as a 2-byte address. The data field is composed of memory loadable data.

            \item[S2]~\\
                The type of record field is S2 (0x5332). The address field is interpreted as a 3-byte address. The data field is composed of memory loadable data.

            \item[S3]~\\
                The type of record field is S3 (0x5333). The address field is interpreted as a 4-byte address. The data field is composed of memory loadable data.

            \item[S5]~\\
                The type of record field is S5 (0x5335). The address field is interpreted as a 2-byte value and contains the count of S1, S2, and S3 records previously transmitted. There is no data field.

            \item[S7]~\\
                The type of record field is S7 (0x5337). The address field contains the starting execution address and is interpreted as a 4-byte address. There is no data field.

            \item[S8]~\\
                The type of record field is S8 (0x5338). The address field contains the starting execution address and is interpreted as a 3-byte address. There is no data field.

            \item[S9]~\\
                The type of record field is S9 (0x5339). The address field contains the starting execution address and is interpreted as a 2-byte address. There is no data field.
        \end{description}

    \subsection{Example}
        ~\\
        \verb'S00600004844521B'\\
        \verb'S1130000285F245F2212226A000424290008237C2A'\\
        \verb'S11300100002000800082629001853812341001813'\\
        \verb'S113002041E900084E42234300182342000824A952'\\
        \verb'S107003000144ED492'\\
        \verb'S5030004F8'\\
        \verb'S9030000FC'

        ~\\This file consists of one S0 record, four S1 records, one S5 record and an S9 record.

    \subsubsection{The S0 record is comprised as follows:}
        \begin{itemize}
            \item S0 S-record type S0, indicating it is a header record.
            \item 06 Hexadecimal 06 (decimal 6), indicating that six character pairs (or ASCII bytes) follow.
            \item 00 00 Four character 2-byte address field, zeros in this example.
            \item 48 44 52 ASCII H, D, and R - "HDR".
            \item 1B The checksum.
        \end{itemize}

    \subsubsection{The first S1 record is comprised as follows:}
        \begin{itemize}
            \item S1 S-record type S1, indicating it is a data record to be loaded at a 2-byte address.
            \item 13 Hexadecimal 13 (decimal 19), indicating that nineteen character pairs, representing a 2 byte address, 16 bytes of binary data, and a 1 byte checksum, follow.
            \item 00 00 Four character 2-byte address field; hexadecimal address 0x0000 where the data which follows is to be loaded.
            \item 28 5F 24 5F 22 12 22 6A 00 04 24 29 00 08 23 7C Sixteen character pairs representing the actual binary data.
            \item 2A The checksum.
        \end{itemize}

    \subsubsection{The second and third S1 records are comprised as follows:}
        The second and third S1 records each contain 0x13 (19) character pairs and are ended with checksums of 13 and 52, respectively. The fourth S1 record contains 07 character pairs and has a checksum of 92.

    \subsubsection{The S5 record is comprised as follows:}
        \begin{itemize}
            \item S5 S-record type S5, indicating it is a count record indicating the number of S1 records
            \item 03 Hexadecimal 03 (decimal 3), indicating that three character pairs follow.
            \item 00 04 Hexadecimal 0004 (decimal 4), indicating that there are four data records previous to this record.
            \item F8 The checksum.
        \end{itemize}

    \subsubsection{The S9 record is comprised as follows:}
        \begin{itemize}
            \item S9 S-record type S9, indicating it is a termination record.
            \item 03 Hexadecimal 03 (decimal 3), indicating that three character pairs follow.
            \item 00 00 The address field, hexadecimal 0 (decimal 0) indicating the starting execution address.
            \item FC The checksum.
        \end{itemize}

\clearpage
\section{List File Format}
    Code listing serves as an additional information about the assembled code and the progress of the assembly process. It contains information about all symbols defined in the code. Where and how they have been defined, what are their values and whether they are used in the code. Also detailed information about all macros defined in the code and/or expanded in the code. Conditional compilation configuration, instruction opcodes, address space reservations, inclusion of code from other files. And all warnings, errors, and notes generated during the assembly by the assembler. There are assembler directives which alters formatting of the code listing file.

    \begin{code}[h]
        \verb'                         1     ; Comment.'\\
        \verb'                         2             org     0'\\
        \verb'                         3'\\
        \verb'0000 01001               4     main:   load    s0, #1'\\
        \verb'0001 01102               5             load    s1, #2'\\
        \verb'0005 01203               6             load    s2, #3'\\
        \verb'0007 3E000               7             jump    main'\\
        \verb'                         8'\\
        \verb'                         9             end'\\
        \caption{A simple code listing.}
    \end{code}

    Code listing contains entire source code which has been assembled but with each line prefixed with line number and some additional information which will be explained later. Each line of the code listing which contains an original source code line may contain besides line number also some additional information regarding the compilation of the given line of code. Such a additional information might look like this and is composed of these parts:

    \begin{code}[h]
        \verb'  '{\color{highlight_lst_number}\verb'00055'}\verb'                  '{\color{highlight_lst_line}\verb'1'}\verb'      '{\color{highlight_comment}\verb'X           EQU         0x55'}\\
        \verb'                         '{\color{highlight_lst_line}\verb'2'}\verb'      '{\color{highlight_comment}\verb'            INCLUDE     "file.asm"'}\\
        {\color{highlight_lst_address}\verb'0007'}\verb' '{\color{highlight_lst_code}\verb'00100'}\verb'      '{\color{highlight_label}\verb'=1'}\verb'       '{\color{highlight_lst_line}\verb'3'}\verb' '{\color{highlight_constant}\verb'+1'}\verb'   '{\color{highlight_comment}\verb'label:      LOAD        S1, S0'}\\

        \colorbox{highlight_lst_number}{\color{highlight_lst_number}X} Expression value\\
        \colorbox{highlight_lst_address}{\color{highlight_lst_address}X} Address in program memory\\
        \colorbox{highlight_lst_code}{\color{highlight_lst_code}X} Machine code\\
        \colorbox{highlight_label}{\color{highlight_label}X} Level of file inclusion\\
        \colorbox{highlight_lst_line}{\color{highlight_lst_line}X} Line number\\
        \colorbox{highlight_constant}{\color{highlight_constant}X} Level of macro expansion\\
        \colorbox{highlight_comment}{\color{highlight_comment}X} Original line
        \caption{Format of code listing}
    \end{code}

    \begin{code}[h]
        \verb'complicated_lst                                                         PAGE 1'\\
        {\color{highlight_lst_number}\verb' 0001C'}{\color{highlight_lst_line}\verb'               1'}\verb'     '{\color{highlight_constant}\verb'abc'}\verb'     '{\color{highlight_directive}\verb'equ'}\verb'     '{\color{highlight_symbol}\verb'('}\verb' '{\color{highlight_unknown_base}\verb'14'}\verb' '{\color{highlight_symbol}\verb'*'}\verb' '{\color{highlight_unknown_base}\verb'2'}\verb' '{\color{highlight_symbol}\verb')'}\verb'      '{\color{highlight_comment}\verb'; Define symbol abc.'}\\
        {\color{highlight_lst_line}\verb'                     2'}\verb'             '{\color{highlight_directive}\verb'org'}\verb'     '{\color{highlight_unknown_base}\verb'0'}\verb'               '{\color{highlight_comment}\verb'; Code at address 0.'}\\
        {\color{highlight_lst_line}\verb'                     3'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      4'}\verb'             '{\color{highlight_directive}\verb'include'}\verb' '{\color{highlight_string}\verb''\verb"'"\verb'macros.asm'\verb"'"\verb' '{\color{highlight_comment}\verb'; Include macros.asm'}}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      5'}\verb'     '{\color{highlight_comment}\verb'; This is the beginning of file macros.asm.'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      6'}\verb'     '{\color{highlight_macro}\verb'xyz'}\verb'     '{\color{highlight_directive}\verb'macro'}\verb'    '{\color{highlight_constant}\verb'arg'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      7'}\verb'             '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's1'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_constant}\verb'arg'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      8'}\verb'             '{\color{highlight_instruction}\verb'nop'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      9'}\verb'             '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_constant}\verb'arg'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's1'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'     10'}\verb'     '{\color{highlight_directive}\verb'endm'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'     11'}\verb'     '{\color{highlight_comment}\verb'; This is the end of file macros.asm.'}\\
        {\color{highlight_lst_line}\verb'                    12'}\\
        {\color{highlight_lst_line}\verb'                    13'}\verb'     '{\color{highlight_label}\verb'main:'}\verb'   '{\color{highlight_macro}\verb'xyz'}\verb'     '{\color{highlight_sfr}\verb's0'}\verb'          '{\color{highlight_comment}\verb'; Expand macro xyz here.'}\\
        {\color{highlight_lst_address}\verb'0000'}{\color{highlight_lst_code}\verb' 00100'}{\color{highlight_lst_line}\verb'          14'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's1'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's0'}\\
        {\color{highlight_lst_address}\verb'0002'}{\color{highlight_lst_code}\verb' 00000'}{\color{highlight_lst_line}\verb'          15'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'nop'}\\
        {\color{highlight_lst_address}\verb'0003'}{\color{highlight_lst_code}\verb' 00010'}{\color{highlight_lst_line}\verb'          16'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's0'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's1'}\\
        {\color{highlight_lst_address}\verb'0005'}{\color{highlight_lst_code}\verb' 22000'}{\color{highlight_lst_line}\verb'          17'}\verb'             '{\color{highlight_instruction}\verb'jump'}\verb'    '{\color{highlight_constant}\verb'main'}\verb'        '{\color{highlight_comment}\verb'; Jump back to main:.'}\\
        {\color{highlight_lst_line}\verb'                    18'}\verb'             '{\color{highlight_directive}\verb'end'}\verb'                 '{\color{highlight_comment}\verb'; End of assembly.'}\\
        \caption{A more complicated example of code listing}
    \end{code}

\section{Specification of the Intel 8 HEX Format}
    Intel 8 HEX is a popular object file format capable of containing up to 64kB of data. Hex files have usually extension .hex or .ihx. These files are text files consisting of a sequence of records, each line line can contain at most one record. Records starts with ``\texttt{:}'' (colon) character at the beginning of the line and ends by end of the line. Everything else besides records should be ignored. Records consist of a sequence of 8-bit hexadecimal numbers (e.g. ``a2'' or ``8c''). These numbers are divided into ``fields'' with different meaning, see the example below.

    \paragraph{Example of an Intel 8 HEX code:}
        ~\\\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{0000}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{57}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{000F}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{48}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{001E}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{39}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{002D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F5907410B3758010B2907410B3}\colorbox{Lavender}{30}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{003D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{758010B2902694052600940426940526}\colorbox{Lavender}{0A}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{004D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{00940426009404269405E580F4F59026}\colorbox{Lavender}{8A}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0B}\colorbox{blue}{005D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{009404269405E580F4F590}\colorbox{Lavender}{63}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{00}\colorbox{blue}{0000}\colorbox{Apricot}{01}\colorbox{Lavender}{FF}}\\\\
        \indent\colorbox{Goldenrod}{\color{Goldenrod}X} Start code\\
        \indent\colorbox{green}{\color{green}X} Byte count\\
        \indent\colorbox{blue}{\color{blue}X} Address\\
        \indent\colorbox{Apricot}{\color{Apricot}X} Record type\\
        \indent\colorbox{GreenYellow}{\color{GreenYellow}X} Data\\
        \indent\colorbox{Lavender}{\color{Lavender}X} Checksum\footnote{Checksum is two's complement of 8-bit sum of entire record, except for the start code and the checksum itself.}
