In this chapter, we will be concerned with build-in macro assembler. With syntax of its statements, directives, and PicoBlaze assembler instructions. It is assumed, that the reader is familiar with general concepts of assembly language programming and PicoBlaze architecture.

MDS has the most advanced assembler for PicoBlaze currently available on the market. MDS macro-assembler is enhanced with features designed to save your time and make programming a little bit easier. For instance you may use "if ( S0 == S1 )" to easy write conditions instead of compares and conditional jumps, "for ( S0, 0 .. 9 )" for loops, "\#if my\_constant > 20" for conditional compilation, "abc macro x, y, z" for defining your own macros, and plenty more... It supports features for smooth and transparent debugging and it's regularly subjected to extensive automated testing to ensure its very functionality and to provide high reliability.

\section{Basics}
    \subsection{Differences from Xilinx assembler}
        \begin{itemize}
            \item Code is case insensitive.
            \item Default radix is decimal.
            \item Immediate addressing requires ``\#'' prefix, and indirect addressing requires ``@'' prefix.
        \end{itemize}

    \subsection{Statements}
        Source code files for this assembler must be text files where lines are formed like these:\\
        {
            \usecodefont
            \verb'[ label: ]  [ instruction  [ operand [ , operand [ , operand ] ] ]  [ ;comment ]'\\
            \verb'[ label: ]  directive      [ argument ]                             [ ;comment ]'\\
            \verb'            symbol         directive argument                       [ ;comment ]'\\
            \verb'            directive      symbol, argument                         [ ;comment ]'
        }

        Everything in square brackets is optional. Compilation does not go beyond line containing "end" directive so after that directive the code does not have to be syntactically valid. Empty lines are allowed as well as lines containing only comment or label. Statements are be separated by white spaces or tabs. Statements are case insensitive and their length is not limited, overall line length is also not limited.

    \subsection{Symbols}
        Symbolic names for numbers, macros or addresses defined by user in the code using appropriate directive. Like with ``\texttt{equ}'' directive you can define a new symbol and assign a value to it right away. Symbols may consist of upper and lower case letters, digits, and underscore character (``\_''), their length is not limited, they are case insensitive and they cannot be the same as language keywords. Be aware of that there cannot coexists two or more symbols only by letter casing, in other words symbols ``\texttt{abc}'' and ``\texttt{ABC}'' are completely the same thing.

        ~\\
        {
            \usecodefont
            \verb'First_symb      EQU     0b100111 ; Number in binary'\\
            \verb'Second_symb     SET     47q      ; Octal'\\
            \verb'Third_symb      REG     39d      ; Decimal'\\
            \verb'Fourth_symb     DATA    27h      ; Hexadecimal'\\
            \verb'Fifth_symb      CODE    27h      ; Hexadecimal'
        }

    \subsection{Constants}
        MDS supports multiple radixes for numeric constants, radix can be specified using both prefix and suffix notation.

        \begin{code}[h!]
        {
            \usecodefont

            \verb'x       equ     10         ; Decimal'\\
            \verb'x       equ     10D        ; Decimal'\\
            \verb'x       equ     0xFE       ; Hexadecimal'\\
            \verb'x       equ     FEh        ; Hexadecimal'\\
            \verb'x       equ     O52        ; Octal'\\
            \verb'x       equ     52q        ; Octal'\\
            \verb'x       equ     52o        ; Octal'\\
            \verb'x       equ     01011110b  ; Binary'\\
            \verb'x       equ     0b00100001 ; Binary'\\
            \verb'x       equ     0b01       ; Binary'\\
            \verb'x       equ     01b        ; Binary'\\
            \verb"x       equ     'x'        ; ASCII"

            \caption{Examples}
            \label{code:svcb}
        }
        \end{code}

    \subsection{Expressions}
        Arithmetical expressions are evaluated at compilation time and replaced with constants corresponding to their resulting value. Expressions comprise of arithmetical operators, constants, and symbols. Example of such expressions:

        \begin{itemize}
            \item \texttt{2+1}
            \item \texttt{(2 + 4) - ABC}
            \item \texttt{A \&\& B}
            \item \texttt{X XOR 0FF00h}
            \item \texttt{X * Y + X \% Y}
        \end{itemize}

        When multiple operators occur in an expression, the expression is evaluated in a specific order depending upon the operators in the expression. All logical operators have priorities lower than arithmetic and relational operators.

        The following table shows priority of expression operators.
        \begin{table}[h!]
            \centering{}
            \mysmallfont{}

            \begin{tabular}{|l|l|l|l|}
                \hline
                Priority & Operator & Description             & Example         \\\hline
                1        & +        & unary plus sign         & +12             \\\hline
                1        & -        & unary minus sign        & -5              \\\hline
                2        & \~{}     & bitwise NOT             & \~{}0a55ah      \\\hline
                2        & !        & logical NOT             & !0a55ah         \\\hline
                3        & *        & unsigned multiplication & 11 * 12         \\\hline
                3        & /        & unsigned divisiono      & 11 / 12         \\\hline
                3        & \%       & unsigned remainder      & 13 \% 11        \\\hline
                4        & +        & unsigned addition       & 3 + 5           \\\hline
                4        & -        & unsigned substraction   & 20 - 4          \\\hline
                5        & <{}<     & binary shift left       & 21 <{}< 4       \\\hline
                5        & >{}>     & binary shift right      & 32 >{}> 2       \\\hline
                6        & <        & less than               & 11 < 12         \\\hline
                6        & <=       & less or equal than      & 11 <= 11        \\\hline
                6        &  >       & greater than            & 12 > 11         \\\hline
                6        & >=       & greater or equal than   & 12 >= 11        \\\hline
                7        & ==       & equal to                & 11 == 11        \\\hline
                7        & !=       & not equal to            &  A != B         \\\hline
                8        & \&       & bitwise and             & 48 \& 16        \\\hline
                8        & |        & bitwise or              & 370q | 7        \\\hline
                9        & \&\&     & logical and             & 48 \&\& 16      \\\hline
                9        & ||       & logical or              & 370q || 7       \\\hline
                9        & \^{}     & exclusive or            & 00fh \^{} 005h  \\\hline
            \end{tabular}

            \caption{Expression operators priority}
        \end{table}

        Priority 1 is the highest priority, and priority 9 is the lowest priority. When operators with different priority levels appear in an expression, operations are evaluated according to priorities. When operators of the same priority appear in an expression, operations are evaluated from left to right.

    \subsection{Predefined Symbols}
        These symbols are defined by default when you specify the target device (directive ``device''). Symbols S10..S1F are defined for KCPSM2 only, and S8..S1F are not defined for KCPSM1-CPLD.

        \begin{table}[h!]
            \begin{tabular}{|cc|cc|}
                \hline
                Symbol & Value & Symbol & Value \\\hline
                S0     & 0x00  & S10    & 0x10  \\\hline
                S1     & 0x01  & S11    & 0x11  \\\hline
                S2     & 0x02  & S12    & 0x12  \\\hline
                S3     & 0x03  & S13    & 0x13  \\\hline
                S4     & 0x04  & S14    & 0x14  \\\hline
                S5     & 0x05  & S15    & 0x15  \\\hline
                S6     & 0x06  & S16    & 0x16  \\\hline
                S7     & 0x07  & S17    & 0x17  \\\hline
                S8     & 0x08  & S18    & 0x18  \\\hline
                S9     & 0x09  & S19    & 0x19  \\\hline
                SA     & 0x0A  & S1A    & 0x1A  \\\hline
                SB     & 0x0B  & S1B    & 0x1B  \\\hline
                SC     & 0x0C  & S1C    & 0x1C  \\\hline
                SD     & 0x0D  & S1D    & 0x1D  \\\hline
                SE     & 0x0E  & S1E    & 0x1E  \\\hline
                SF     & 0x0F  & S1F    & 0x1F  \\\hline
            \end{tabular}
        \end{table}

\section{Assembler directives}
    Assembly directives are instructions that are executed by an assembler at assembly time, not by a CPU at run time. They can make the assembly of the program dependent on parameters input by a programmer, so that one program can be assembled different way, perhaps for different applications. They also can be used to manipulate presentation of a program to make it easier to read and maintain.

    \bigskip

    The specified format for most of the directives is:\\
    \verb'<symbol> <directive> <expression>'

    \bigskip

    This syntax is valid for directives EQU, SET, REG, DATA, CODE, PORT, and DEFINE. MDS also supports some other directives, with different syntax format, which is:\\
    \verb'<directive> <symbol>, <expression>'

    \bigskip

    Those directives are CONSTANT, VARIABLE, ADRESS, and NAMEREG. There are some other useful directives like REPT or WHILE. See description below.

    \clearpage
    \subsection{INCLUDE}
        \subsubsection{Syntax}
            \verb'INCLUDE "<file_name>"'

        \subsubsection{Description}
            Compiler copies content of the specified file to line where this directive is used. Included files can include other files.

        \subsubsection{Examples}
            \verb'INCLUDE "some_file.asm"'\\
            \verb'INCLUDE "sub_dir/another_file.asm"'\\
            \verb'INCLUDE "C:/my_dir/my_file.asm"'\\
            \verb'INCLUDE "C:\\my_dir\\my_file.asm"'\\
            \verb'INCLUDE "/home/AlanTuring/my_project/file.asm"'

    \subsection{EQU}
        \subsubsection{Syntax}
            \verb'<symbol> EQU <expression>'

        \subsubsection{Description}
            The directive EQU stands for EQUals. It allows you to give a numerical value to a symbol. Such symbol is considered constant and therefore cannot be redefined.

        \subsubsection{Examples}
            \verb'First_symb    EQU     0b10011100              ;Number in binary'\\
            \verb'Second_symb   EQU     47                      ;Number in decimal'\\
            \verb'Third_symb    EQU     0x39                    ;Number in hexadecimal'\\
            \verb'Fourth_symb   EQU     (A - 4) + 18 / B)       ;Number with expression'\\
            \verb'Fifth_symb    EQU     0x09 << 2               ;'

    \subsection{CONSTANT}
        \subsubsection{Syntax}
            \verb'CONSTANT <symbol>, <expression>'

        \subsubsection{Description}
            The directive CONSTANT. It allows you to give a numerical value to a symbol. This symbol cannot be redefined.

        \subsubsection{Examples}
            \verb'CONSTANT     First_symb,0b10011100               ;Number in binary'\\
            \verb'CONSTANT     Second_symb,47                      ;Number in decimal'\\
            \verb'CONSTANT     Third_symb,0x39                     ;Number in hexadecimal'\\
            \verb'CONSTANT     Fourth_symb,(A -4)+ 18 / B)         ;Number with expression'\\
            \verb'CONSTANT     Fifth_symb,0x09 << 2                ;'

    \subsection{SET}
        \subsubsection{Syntax}
            \verb'<symbol> SET <expression>'

        \subsubsection{Description}
            The directive SET allows you to give a numerical value to a symbol like EQU but with this symbol can be redefined.

        \subsubsection{Examples}
            \verb'First_symb    SET     0b10011100              ;Number in binary'\\
            \verb'Second_symb   SET     47                      ;Number in decimal'\\
            \verb'Third_symb    SET     0x39                    ;Number in hexadecimal'\\
            \verb'Fourth_symb   SET     (A - 4) + 18 / B)       ;Number with expression'\\
            \verb'Fifth_symb    SET     0x09 << 2               ;'

    \subsection{VARIABLE}
        \subsubsection{Syntax}
            \verb'VARIABLE <symbol>, <expression>'

        \subsubsection{Description}
            Directive VARIABLE is similar to SET but with different syntax. Symbols defined with VARIABLE can be redefined with another value in your source code but those defined with EQU cannot.

        \subsubsection{Examples}
            \verb'VARIABLE     First_symb,0b10011100               ; Number in binary'\\
            \verb'VARIABLE     Second_symb,47                      ; Number in decimal'\\
            \verb'VARIABLE     Third_symb,0x39                     ; Number in hexadecimal'\\
            \verb'VARIABLE     Fourth_symb,(A -4)+ 18 / B)         ; Number with expression'\\
            \verb'VARIABLE     Fifth_symb,0x09 << 2                ;'

    \subsection{REG}
        \subsubsection{Syntax}
            \verb'<symbol> REG <address>'

        \subsubsection{Description}
            Symbols defined with the REG directive are by compiler considered as work registers.

        \subsubsection{Examples}
            \verb'First_symb        REG     s1'\\
            \verb'Second_symb       REG     s2'\\
            \verb'Third_symb        REG     s3'\\
            \verb'Fourth_symb       REG     0x4'\\
            \verb'Fifth_symb        REG     0x5'

        \subsection{NAMEREG}
            \verb'NAMEREG <symbol>, <address> '

        \subsubsection{Description}
            Directive NAMEREG is similar to REG but with different syntax. Symbols defined with NAMEREG can be redefined with another value in your source code.

        \subsubsection{Examples}
            \verb'NAMEREG     s1'\\
            \verb'NAMEREG     s2'\\
            \verb'NAMEREG     s3'\\
            \verb'NAMEREG     4         ; Address'\\
            \verb'NAMEREG     0xA       ; Address'

    \subsection{DATA}
        \subsubsection{Syntax}
            \verb'<symbol> DATA <expression>'

        \subsubsection{Description}
            Symbols defined with the DATA directive are by compiler considered as memory data. It is supposed to be used only with instructions FETCH and STORE.

        \subsubsection{Examples}
            \verb'First_symb    DATA                0b10011100              ; Number in binary'\\
            \verb'Second_symb   DATA                47                      ; Number in decimal'\\
            \verb'Third_symb    DATA                0x39                    ; Number in hexadecimal'\\
            \verb'Fourth_symb   DATA                (A -4)+ 18 / B)         ; Number with expression'\\
            \verb'Fifth_symb    DATA                0x09 << 2               ; Expression'

    \subsection{CODE}
        \subsubsection{Syntax}
            \verb'<symbol> CODE <expression>'

        \subsubsection{Description}
            Symbols defined with the CODE directive are by compiler considered as program memory.

        \subsubsection{Examples}
            \verb'First_symb    CODE                0b10011100              ; Number in binary'\\
            \verb'Second_symb   CODE                47                      ; Number in decimal'\\
            \verb'Third_symb    CODE                0x39                    ; Number in hexadecimal'\\
            \verb'Fourth_symb   CODE                (A -4)+ 18 / B)         ; Expression'\\
            \verb'Fifth_symb    CODE                0x09 << 2               ; Expression'

    \subsection{PORT}
        \subsubsection{Syntax}
            \verb'<symbol> PORT <expression>'

        \subsubsection{Description}
            Symbol defined with this directive is considered to be PORT\_ID identifier.

        \subsubsection{Examples}
            \verb'First_symb    PORT                0x10    '\\
            \verb'Second_symb   PORT                10      '\\
            \verb'Third_symb    PORT                0x2     '\\
            \verb'Fourth_symb   PORT                0x5     '\\
            \verb'Fifth_symb    PORT                0x09 + 2'

    \subsection{AUTOREG}
        \subsubsection{Syntax}
            \verb'<symbol> AUTOREG [<address>]'

        \subsubsection{Description}
            This directive saves time. You can use it when you don't care which work register will be used. It will automatically assign a register at address 0x00, which is incremented with every other AUTOREG directive. Optionally, you can change starting address counter by adding a parameter after AUTOREG directive. You can check assigned registers in code listing (file .lst) and symbol table (file .sym).

        \subsubsection{Examples}
            \verb'First_symb    AUTOREG             ; Automatically assigned, register at address 0x00'\\
            \verb'Second_symb   AUTOREG'\\
            \verb'Third_symb    AUTOREG'\\
            \verb'Fourth_symb   AUTOREG     0x5     ; Now with optional parameter changing counting address to 0x05'\\
            \verb'Fifth_symb    AUTOREG             ; Fifth_symb is on address 0x06'

    \subsection{AUTOSPR}
        \subsubsection{Syntax}
            \verb'<symbol> AUTOSPR [<address>]'

    \subsubsection{Description}
        Must be used only with instructions FETCH and STORE. It will automatically assign an address 0x00, which is incremented with every other AUTOSPR directive. Optionally, you can change starting address counter by adding a parameter after AUTOSPR directive. You can check assigned memory in code listing file(.lst) and symbol table file(.sym).

    \subsubsection{Examples}
        \verb'First_symb    AUTOSPR             ; Automatically assigned, data at address 0x00'\\
        \verb'Second_symb   AUTOSPR'\\
        \verb'Third_symb    AUTOSPR'\\
        \verb'Fourth_symb   AUTOSPR     0x5     ; Now with optional parameter changing counting address to 0x05'\\
        \verb'Fifth_symb    AUTOSPR             ; Fifth_symb is on address 0x06'

    \subsection{INITSPR}
        \subsubsection{Syntax}
            \verb'<symbol> INITSPR <value>'

        \subsubsection{Description}
            Initializes scratch-pad RAM (SPR) with the given value(s), content of such initilized memory is stored in the Secondary Assembler Output (see the compiler configuration dialog, or command line option --secondary).

        \subsubsection{Examples}
            \verb'my_data       INITSPR         "Hello PicoBlaze!"'\\
            \verb'my_data2      INITSPR         0x2b'\\
            \verb''\\
            \verb'              FETCH           S0, my_data'\\
            \verb'              FETCH           S1, my_data + 1'\\
            \verb'              FETCH           S2, my_data + 2'\\
            \verb'              FETCH           S3, my_data + 3'\\
            \verb''\\
            \verb'              FETCH           S8, my_data2'

    \subsection{ORGSPR}
        \subsubsection{Syntax}
            \verb'ORGSPR <address>'

        \subsubsection{Description}
            Specify address of origin for scratch-pad RAM initialization (directive INITSPR).

        \subsubsection{Examples}
            \verb'              ORGSPR          0x10'\\
            \verb'my_data       INITSPR         "Hello PicoBlaze!" ; <-- address assigned to my_data is 0x10'\\
            \verb''\\
            \verb'              FETCH           S0, my_data'\\
            \verb'              FETCH           S1, my_data + 1'\\
            \verb'              FETCH           S2, my_data + 2'

    \subsection{MERGESPR}
        \subsubsection{Syntax}
            \verb'MERGESPR <address>'

        \subsubsection{Description}
            Merge scratch-pad RAM initialization with program memory initialization at the specified address.

        \subsubsection{Examples}
            \verb'              MERGESPR        0x280'\\
            \verb'my_data       INITSPR         "Hello PicoBlaze!"'\\
            \verb''\\
            \verb'              FETCH           S0, my_data'\\
            \verb'              FETCH           S1, my_data + 1'\\
            \verb'              FETCH           S2, my_data + 2'

    \subsection{STRING}
        \subsubsection{Syntax}
            \verb'<symbol> STRING "<string>"'

        \subsubsection{Description}
            Defines a named character string (sequence of characters) which can later be used with ``LOAD \& RETURN'' and ``OUTPUTK'' instructions, and with ``DB'' directive.

        \subsubsection{Examples}
            \verb'my_string     STRING          "Hello PicoBlaze!"'\\
            \verb''\\
            \verb'              LOAD & RETURN   S0, my_string'\\
            \verb'              OUTPUTK         my_string, 2'\\
            \verb'              DB              my_string'

    \subsection{DEFINE}
        \subsubsection{Syntax}
            \verb'<symbol> DEFINE <expression>'

        \subsubsection{Description}
            You can define expression using previously defined symbols. Value of this expression is calculated every time the symbol is used. You can use symbols in define expressions

        \subsubsection{Examples}
            \verb'A             EQU         10'\\
            \verb'B             SET         5                   ; Second symbol is redefinable'\\
            \verb'C             DEFINE      ( A + B ) * 2       ; Defined expression'\\
            \verb'F = C                                         ; F equals 30'\\
            \verb'B             SET         10'\\
            \verb'F = C                                         ; F equals 40'

    \subsection{ADDRESS, and ORG}
        \subsubsection{Syntax}
            \verb'ADDRESS <expression>'\\
            \verb'ORG     <expression>'

        \subsubsection{Description}
            When the ORG or ADDRESS statement is encountered, the assembler calculates the value of the expression and changes the address counter. The MDS assembler maintains a location counter for each segment. The location counter contains the offset of the instruction or data being assembled and is incremented after each line by the number of bytes of data or code in that line.

        \subsubsection{Examples}
            \verb'ORG           0x3ff'\\
            \verb'ORG           START'\\
            \verb'ORG           INTERRUPT'\\
            \verb'ORG           (\$ + 15) \& 0xFFEE'\\
            \verb'ADDRESS       0x3ff'\\
            \verb'ADDRESS       START'\\
            \verb'ADDRESS       INTERRUPT'\\
            \verb'ADDRESS       (\$ + 15)'

    \subsection{REPT}
        \subsubsection{Syntax}
            \verb'REPT <expression>'\\
            \verb'     <code>'\\
            \verb'ENDR'

        \subsubsection{Description}
            Directive REPT is able to repeatedly execute a block of code.

        \subsubsection{Examples}
            \verb'; With REPT'\\
            \verb'REPT              8'\\
            \verb'SR0               sF'\\
            \verb'ENDR'\\
            \verb'; Without REPT'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'

    \subsection{\#WHILE}
        \subsubsection{Syntax}
            \verb'#WHILE <expression>'\\
            \verb'       <code>'\\
            \verb'#ENDW'

        \subsubsection{Description}
            The while construct consists of a block of code and an expression. Following code is recompiled until expression equals to zero.

        \subsubsection{Examples}
            \verb'B             SET             8'\\
            \verb'#WHILE        B                       ; while B != 0'\\
            \verb'SR0           sF'\\
            \verb'B             SET             B - 1'\\
            \verb'#ENDW'

    \subsection{SKIP}
        \subsubsection{Syntax}
            \verb'SKIP <expression>'

        \subsubsection{Description}
            SKIP directive is basically address counter + number evaluated in expression. See example for more info.

        \subsubsection{Examples}
            \verb'SKIP          3        ; this will skip first three SR0, performing only one SR0'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'

    \subsection{UNDEFINE, UNDEF}
        \subsubsection{Syntax}
            \verb'UNDEFINE <symbol>'\\
            \verb'UNDEF    <symbol>'

        \subsubsection{Description}
            All symbols can be UNDEFINED. Those symbols will be deleted from symbol table (file .sym) and compiler will not recognize them.

        \subsubsection{Examples}
            \verb'My_symbol             SET             15'\\
            \verb'LOAD                  s0, #My_symbol'\\
            \verb'UNDEFINE              My_symbol               ; My_symbol undeclared, cannot be used'\\
            \verb'LOAD                  s0, #My_symbol          ; this will cause an error'

    \subsection{DB}
        \subsubsection{Syntax}
            \verb'; Expresion syntax'\\
            \verb'DB  <expression1>  [, <expression2>, ...]'\\
            \verb''\\
            \verb'; String syntax'\\
            \verb'DB <"string">'\\
            \verb''\\
            \verb'; Combination of string(s) and expression(s)'\\
            \verb'DB <"string"> [, <expression1>, ...]'

            Parameter can be unlimited number of string characters, or expressions divided by comma.

        \subsubsection{Description}
            The DB directive initializes code memory with 18-bit values. The assembler accepts size up to 24-bit but trims 6 MSB bits making it 18-bit value,
            so it can fit into program memory. You can insert infinite number of string characters and MDS assembler separates them into triplets of bytes replaced
            with their ASCII value. The assembler then trims upper 6 bits making it 18-bit value.
            See the examples for better understanding of DB directive.

        \subsubsection{Examples}
            \verb'DB      0x060FC                 ; Hexadecimal 0x060FC'\\
            \verb'DB      "my string"             ; String.'\\
            \verb'DB      "my string",2+1,3...    ; Combination of string and expressions.'\\

    \subsection{LIMIT}
        \subsubsection{Syntax}
            \verb'LIMIT  D, <number> ; Size of scratch-pad RAM(D stands for data).'\\
            \verb'LIMIT  R, <number> ; Number of registers (R stands for registers).'\\
            \verb'LIMIT  C, <number> ; Size of program memory (C stands for code).'\\

        \subsubsection{Description}
            Useful when you want to change max. number of registers or size of  data and program memory. It is information for compiler. In this example when you want to use 17 registers or JUMP to address bigger than 512, compiler gives you an error.

        \subsubsection{Examples}
            \verb'LIMIT          R,16                   ; Number of registers 16'\\
            \verb'LIMIT          D,7                    ; Size of scratch-pad ram   '\\
            \verb'LIMIT          C,0b100000000          ; Size of program memory '\\

    \subsection{DEVICE}
        \subsubsection{Syntax}
            \verb'DEVICE <device_name>'

        \subsubsection{Description}
            Normally, you choose the target architecture when you are creating a project. But you can also specific architecture with directive DEVICE. This will affect predefined symbols.

        \subsubsection{Examples}
            \verb'DEVICE kcpsm6'\\
            \verb'DEVICE kcpsm3'\\
            \verb'DEVICE kcpsm2'\\
            \verb'DEVICE kcpsm1'\\
            \verb'DEVICE kcpsm1cpld'

    \subsection{LIST, NOLIST}
        \subsubsection{Syntax}
            \verb'LIST'\\
            \verb'NOLIST'

        \subsubsection{Description}
            You can turn on/off printing to code listing in some parts of your code.

    \subsection{TITLE}
        \subsubsection{Syntax}
            \verb'TITLE "<title text>"'

        \subsubsection{Description}
            This will put a title into corresponding line in code listing.

        \subsubsection{Examples}
            \verb'TITLE         "Text, that will show up in the code listing"'

    \subsection{MESSAGE}
        \subsubsection{Syntax}
            \verb'MESSAGE "<message text>"'

        \subsubsection{Description}
            You can define message, that will show up after compilation.

        \subsubsection{Examples}
            \verb'MESSAGE         "Text, that will show up in the code listing"'

    \subsection{ERROR}
        \subsubsection{Syntax}
            \verb'ERROR "<error message>"'

        \subsubsection{Description}
            You can define an error report, which aborts compilation when is executed.

        \subsubsection{Examples}
            \verb'ERROR         "Text, that will show up in the code listing"'

    \subsection{WARNING}
            \verb'WARNING "<warning message>"'

        \subsubsection{Description}
            This will put title into corresponding line in code listing.

        \subsubsection{Examples}
            \verb'WARNING         "Text, that will show up in the code listing"'

    \subsection{LOCAL}
        \subsubsection{Syntax}
            \verb'LOCAL <name>'

        \subsubsection{Description}
            This directive is used to define local variables in macros, so when you expand macro multiple times, there will be no redefinition of labels or symbols.

        \subsubsection{Examples}
            \verb'MACRO         name_of_macro'\\
            \verb'LOCAL         wait'\\
            \verb'wait:'\\
            \verb'SUBCY         s0,#10h'\\
            \verb'SUB           s0,#1h' \\
            \verb'LOAD          s0,#F0h'\\
            \verb'JUMP          C,wait'\\
            \verb'ENDM'

    \subsection{END}
        \subsubsection{Syntax}
            \verb'END'

        \subsubsection{Description}
            The END directive informs the assembler, that it has reached the end of a source file. Compiler ignores following code, so it doesn't have to be syntactically correct.

        \subsubsection{Examples}
                \verb'END'

    \subsection{FAILJMP,DEFAULT\_JUMP}
        \subsubsection{Syntax}
            \verb'FAILJMP     <expression>'\\
            \verb'DEFAULT_JMP <expression>'

        \subsubsection{Description}
            Fills program memory with jump to the specified address. Simple protection against errors.

        \subsubsection{Examples}
            \verb'FAILJMP                   Start'\\
            \verb'DEFAULT\_JUMP             0x000'

\section{Pseudo Instructions}
    MDS assembler supports some useful pseudo instructions, which can improve understandability of your source code. Compiler will replace those instructions with one or more PicoBlaze instructions, to achieve desired purpose of that instruction.

    \subsection{INC}
        \subsubsection{Syntax}
            \verb'INC <expression>'

        \subsubsection{Equal to:}
            \verb'ADD       sX, #1'

        \subsubsection{Description}
            This instruction increments given register value by one.

        \subsubsection{Examples}
            \verb'INC              s0'

    \subsection{DEC}
        \subsubsection{Syntax}
            \verb'DEC <expression>'

        \subsubsection{Equal to:}
            \verb'SUB       sX, #1'

        \subsubsection{Description}
            This instruction decrements given register value by one.

        \subsubsection{Examples}
            \verb'DEC s0'

    \subsection{SETR}
        \subsubsection{Syntax}
            \verb'SETR <expression>'

        \subsubsection{Equal to:}
            \verb'OR       sX, #0xFF'

        \subsubsection{Description}
            This instruction sets given register.

        \subsubsection{Examples}
            \verb'SETR              s0'

    \subsection{CLRR}
        \subsubsection{Syntax}
            \verb'CLRR <expression>'

        \subsubsection{Equal to:}
            \verb'AND       sX, #0x00'

        \subsubsection{Description}
            This instruction clears given register.

        \subsubsection{Examples}
            \verb'CLRR              s0'

    \subsection{CPL}
        \subsubsection{Syntax}
            \verb'CPL <expression>'

        \subsubsection{Equal to:}
            \verb'XOR       sX, #0xFF'

        \subsubsection{Description}
            This instruction execute 1\'s complement with given register.

        \subsubsection{Examples}
            \verb'CPL              s0'

    \subsection{CPL2}
        \subsubsection{Syntax}
            \verb'CPL2 <expression>'

        \subsubsection{Equal to:}
            \verb'XOR              s0,#0xFF'\\
            \verb'ADD              s0,#1'

        \subsubsection{Description}
            This instruction executes 1\'s complement with given register.

        \subsubsection{Examples}
            \verb'CPL2              s0'

    \subsection{SETB}
        \subsubsection{Syntax}
            \verb'SETB <register>, <bit> ; bit belongs to interval [0,7]'

        \subsubsection{Equal to:}
            \verb'OR       sX, #1 << bit'

        \subsubsection{Description}
            Sets bit in given register.

        \subsubsection{Examples}
            \verb'SETB              s0,3'

    \subsection{CLRB}
        \subsubsection{Syntax}
            \verb'CLRB <register>, <bit> ; bit belongs to interval [0,7]'

        \subsubsection{Equal to:}
            \verb'AND       sX,#(0xFF ^ (1 << bit))'

        \subsubsection{Description}
            Clears bit in given register.

        \subsubsection{Examples}
            \verb'CLRB              s0,7'

    \subsection{NOTB}
        \subsubsection{Syntax}
            \verb'NOTB <register>, <bit> ; bit belongs to interval [0,7]'

        \subsubsection{Equal to:}
            \verb'XOR       sX,#(~(1 << bit))'

        \subsubsection{Description}
            Negates bit in given register.

        \subsubsection{Examples}
            \verb'NOTB              s0,7'

    \subsection{DJNZ}
        \subsubsection{Syntax}
            \verb'DJNZ <register>, <label>'

        \subsubsection{Equal to:}
            \verb'SUB               s0,#1'\\
            \verb'JUMP              NZ,loop'

        \subsubsection{Description}
            Given register is decremented until it is zero.

        \subsubsection{Examples}
            \verb'loop:             '\\
            \verb'DJNZ              s0, loop'

    \subsection{IJNZ}
        \subsubsection{Syntax}
            \verb'IJNZ <register>, <label>'

        \subsubsection{Equal to:}
            \verb'ADD               s0,#1'\\
            \verb'JUMP              NZ,loop'

        \subsubsection{Description}
            Given register is incremented until overflow.

        \subsubsection{Examples}
            \verb'loop:             '\\
            \verb'IJNZ              s0, loop'

\section{Code generation directives}
    MDS assembler contains some special directives, which are evaluated during run time sequence. You can use them to evaluate simple conditions in your program. Those directives are IF, ELSEIF, WHILE, FOR.\\ Not all conditions allowed by assembler can be used. Table of allowed instructions is displayed below.

    \begin{table}[h!]
        \mysmallfont{}
        \centering{}
        \begin{tabular}{|l|l}
            \hline
            Condition operator       &          Example  \\
            ==                       &          A ==  B  \\
            !=                       &          A !=  B  \\
            >                        &          A >   B  \\
            <                        &          A <   B  \\
            >=                       &          A >=  B  \\
            <=                       &          A <=  B  \\
            \&                       &          A \&  B  \\
            !\&                      &          A !\& B
        \end{tabular}
        \caption{Allowed conditions with IF, WHILE}
    \end{table}

    \subsection{IF}
        \subsubsection{Syntax}
            \verb'IF      <condition>'\\
            \verb'        <code>'\\
            \verb'ELSEIF  <condition>'\\
            \verb'        <code>'\\
            \verb'ELSE'\\
            \verb'        <code>'\\
            \verb'ENDIF'

        \subsubsection{Description}
            You can use RT\_IF for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and evaluates result. You can use registers, immediate constants (symbols) or register address. Immediate constants are specified as number with \# prefix. Number without \# is considered as register address. See example for conditions syntax. In example below, first condition is comparing register with constant 10. Second condition compares symbol with constant and third condition compares symbol with register address. So 5 would have been replaced with value stored in register with address 5.

        \subsubsection{Examples}
            \verb'IF      s0 == #10'\\
            \verb'        LOAD  s0, #10h'\\
            \verb'ELSEIF  B >= #100'\\
            \verb'        SR0   s0'\\
            \verb'ELSE    A >= 5'\\
            \verb'        INPUT   s0,RX_data'\\
            \verb'ENDIF'

    \subsection{WHILE}
        \subsubsection{Syntax}
            \verb'WHILE <condition>'\\
            \verb'      <code>'\\
            \verb'ENDW'

        \subsubsection{Description}
            You can use WHILE for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and evaluates result. You can use registers, immediate constants (symbols) or register address. Immediate constants are specified as number with \# prefix. Number without \# is considered as register address. See example for conditions syntax.

        \subsubsection{Examples}
            \verb'WHILE s0 == #10'\\
            \verb'      ADDCY S1,#1'\\
            \verb'ENDW'
            \verb''\\
            \verb'WHILE s0 > #10'\\
            \verb'      ADDCY S1,#1'\\
            \verb'ENDW'
            \verb''\\
            \verb'WHILE s0  != #10'\\
            \verb'      ADDCY S1,#1'\\
            \verb'ENDW'

    \subsection{FOR}
        \subsubsection{Syntax}
            \verb'FOR   <condition>'\\
            \verb'      <code>'\\
            \verb'ENDW'

        \subsubsection{Description}
            You can use FOR for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and evaluates result. There are three types of FOR conditions. In first, you have to write the name of used register and number of repetitions. In this case, counting starts at number 0 and incrementing to number of repetitions. In second type, you write used register and range of repetitions ( for example 5..10). In third type, you can even define size of one step, so incremented number can be for some reason bigger. See examples for better understanding.\\ WARNING: Using FOR directive will override used register( s0 in example)

        \subsubsection{Examples}
            \verb'; In this case, incrementing is from 0 to 10. Incrementing step is 1.'
            \verb'FOR   s0, 10'\\
            \verb'      NOP'\\
            \verb'ENDF'
            \verb''\\
            \verb'; In this case, incrementing is in the range 10 to 20. Incrementing step is 1.'
            \verb'FOR   s0, 10..20'\\
            \verb'      NOP'\\
            \verb'ENDF'
            \verb''\\
            \verb'; In this case, incrementing is from 10 to 50. Last number defines'\\
            \verb'; incrementing step. (In this case 10).'\\
            \verb'FOR   s0, 10..50, 10'\\
            \verb'      NOP'\\
            \verb'ENDF'

\section{Macro instructions}
    Macro is a sequence of instructions which can be expanded anywhere in the code and for any number of times. That may reduce necessity of repeating code fragments as well as source code size and make the solved task easier to comprehend and solve. Unlike subprograms macros do not add extra run-time overhead and repeating usage of macros may significantly increase size of the resulting machine code. Macros supported by this assembler are.

    \subsection{Syntax}
        \verb'MACRO     [<parameter1>]  [,<parameter2>..]'\\
        \verb'          <macro source code>'\\
        \verb'ENDM      ; end of macro definition'
        \verb''~\\
        \verb'EXPAND    ; Expanding of macros enabled'\\
        \verb'NOEXPAND  ; Expanding of macros disabled'

        \begin{table}[h!]
            \begin{tabular}{|ll|}
                \hline
                MACRO      & Define a new macro \\
                EXITM      & Exit macro  \\
                ENDM       & End of macro definition \\
                EXPAND     & After usage of this directive, expanding of macros is allowed.(turned on by default)\\
                NOEXPAND   & After usage of this directive, no expanding of macros is allowed.\\
                \hline
            \end{tabular}
            \caption{Macro commands}
        \end{table}

    \subsection{Description}
        Standard macro, consisting of name, code and optional exit command. Macro can be expanded only after his declaration. You can use macro with no parameters  or unlimited number of parameters.

    \subsection{Examples}
        This can be well demonstrated on examples:\\
        {
            \usecodefont
            \verb'abc           macro           ; Define named macro '\\
            \verb'      load    s2,s0'\\
            \verb'      add     s2,#1'\\
            \verb'      load    s1,s2'\\
            \verb'endm'\\\\
            \verb'abc           ; Expand macro "abc"  here'\\
            \verb'abc           ; Expand macro "abc"  here'\\\\
            \verb'; This is the same as if you wrote this:'\\
            \verb'      load    s2,s0'\\
            \verb'      add     s2,#1'\\
            \verb'      load    s1,s2'\\
            \verb'      load    s2,s0'\\
            \verb'      add     s2,#1'\\
            \verb'      load    s1,s2'\\
        }

        Macro without parameters.\\
        {
            \usecodefont
            \verb'; Define macro named as "xyz" with two mandatory parameters'\\
            \verb'xyz       macro   foo, bar'\\
            \verb'          load    foo, #10h'\\
            \verb'          add     bar, #1'\\
            \verb'endm'\\\\
            \verb'          xyz     s2,s3           ; Expand macro "xyz"  here'\\
            \verb'          xyz     s5,s5           ; Expand macro "xyz"  here'\\\\
            \verb'; This is the same as if you wrote this:'\\
            \verb'; xyz     s2,s3'\\
            \verb'          load    s2, #10h'\\
            \verb'          add     s3, #1'\\
            \verb'; xyz     s5,s5'\\
            \verb'          load    s5, #10h'\\
            \verb'          add     s5, #1'\\
        }

        An example of named macro with two parameters.\\
        {
            \usecodefont
            \verb'ijk           macro   foo'\\
            \verb'          add     s1,s0'\\
            \verb''\\
            \verb'          if    foo = 4d'\\
            \verb'              nop'\\
            \verb'          endif'\\
            \verb'          sub     s1, #foo'\\
            \verb'endm'\\\\
            \verb'ijk   5'\\
            \verb'ijk   4'\\\\
            \verb'; This is the same as if you wrote this:'\\
            \verb'      ; ijk   5'\\\\
            \verb'          add     s1,s0'\\
            \verb'          if    5 = 4d'\\
            \verb'              nop'\\
            \verb'          endif'\\
            \verb'          subb    s1,#5'\\
            \verb'      ; ijk   4'\\\\
            \verb'          add     s1,s0'\\
            \verb'          if    4 = 4d'\\
            \verb'              nop'\\
            \verb'          endif'\\
            \verb'          sub     s1,#4'\\
        }

        An example of named macro used with if statement.

\section{Conditional Assembly}
    The aim of conditional assembly to to assemble certain parts of the code if and only if certain arithmetically expressed condition is met. This feature can prove useful particularly when the user want to make the code somehow ``configurable''. This assembler provides these instructions to work with conditional assembly:

    \begin{itemize}
        \item IF <condition>
        \item IFN <condition>
        \item IFDEF <symbol>
        \item IFNDEF <symbol>
        \item ELSE
        \item ELSEIF <condition>
        \item ELSEIFN <condition>
        \item ELSEIFDEF <symbol>
        \item ELSEIFNDEF <symbol>
        \item ENDIF
    \end{itemize}

    This can be best demonstrated on an example:
    \begin{code}[h!]
        \mysmallfont{}
        \verb'abc     equ     14              ; Assign number 14 to symbol abc'\\
        \verb'xyz     equ     10              ; Assign number 10 to symbol abc'\\
        \verb''\\
        \verb'ifdef abc                       ;<--+ Assemble only if symbol abc has been defined'\\
        \verb'  if ( abc = 13 )               ;   | <--+ Assemble if 13 has been assigned to symbol abc'\\
        \verb'        load     a, #01010101b  ;   |    |'\\
        \verb'  elseif ( abc = 14 )           ;   | <--+ Assemble if 14 has been assigned to symbol abc'\\
        \verb'        load     a, #0aah       ;   |    |'\\
        \verb'  elseifn ( abc % 2 )           ;   | <--+ Assemble if the value assigned to symbol abc is even'\\
        \verb'        load     a, #abc        ;   |    |'\\
        \verb'  else                          ;   | <--+ Else ..'\\
        \verb'        load     a, #377q       ;   |    |'\\
        \verb'  endif                         ;   | <--+'\\
        \verb'elseifndef xyz                  ;<--+ Assemble if symbol xyz has NOT been defined'\\
        \verb'        clrr     s1             ;   |'\\
        \verb'else                            ;<--+ Else ...'\\
        \verb'  ifn ( xyz mod 2 )               ;   | <--+ Assemble if ( yxz modulo 2 ) is 0'\\
        \verb'        load     a, #128d       ;   |    |'\\
        \verb'  endif                         ;   | <--+'\\
        \verb'endif                           ;<--+'\\
        \verb''\\
        \verb'jmp    $                       ; Infinite loop'\\
        \verb'end                            ; End of assembly'\\
        \caption{An example of conditional assembly usage}
    \end{code}

    \clearpage

\section{Error and warning messages}
    This chapter lists the error messages generated by MDS. The following sections include a brief description of the possible error messages along with a description of the error and any corrective actions you can take to avoid or eliminate the error. Errors terminate the assembly and generate a message that is displayed on the console. Warnings generate a message in the assembly listing file but do not terminate the assembly.

    \subsection{Errors}
        \begin{description}
            \item[Unable to open file]
                The given file cannot be opened for some reason.
            \item[Unable to write to file]
                It is not possible to write into given file.
            \item[Unable to save file]
                The given file cannot be saved. Check if you have enough space on your disk.
            \item[The resulting machine code is too big to be stored in a file]
                Size of the resulting machine code is bigger, than free disk space.
            \item[Some of the source code files were aparently changed during compilation]
                Do not change source files during the compilation. Wait for compilation to be finished.
            \item[User defined memory limit for program memory exceeded]
                You have exceeded maximum program memory defined with directive LIMIT or project configuration.
            \item[User defined memory limit for register file exceeded]
                You have exceeded maximum number of working registers defined with directive LIMITor project configuration.
            \item[User defined memory limit for Scratch Pad RAM exceeded]
                You have exceeded maximum scratch pad RAM defined with directive LIMIT or project configuration.
            \item[Instruction X requires operand \#Y to be of type(s) Z; while the given operand is of type: W]
                Wrong type of operand.
            \item[Macro not defined ]
                The given macro has not been defined. You must define macro before you can use it. See chapter MACROS for more info.
            \item[Too many arguments given, expecting at most X arguments]
                Too many arguments. Reduce number of given arguments.
            \item[Attempting to use unavailable space in X memory at address: Y ]
                Desired memory space is not available.
            \item[The last error was critical, compilation aborted]
                Critical error has occured. Compilation cannot continue.
            \item[Device not supported]
                The given device is not supported. Please choose different device in project configuration.
            \item[Device specification code is already loaded ]
                You have already specified architecture in project configuration.
            \item[Limit value X is not valid]
                Invalid limit value. Viz. LIMIT directive chapter for valid values.
            \item[Directive `LOCAL' cannot appear outside of macro definition ]
                Directive LOCAL must be only used inside of macro. Use different directive for symbol definition( EQU,SET etc.), or put it inside of macro.
            \item[Directive EXITM' cannot apper outside macro definition]
                The given directive is used to immediately exit macro. It does not make sense to use it differently.
            \item[Maximum macro expansion level X reached  ]
                Maximum macro expansion level reached. You can change your compiler settings and set bigger expansion level. By default, macro expansion level is unlimited.
            \item[Maximum number of WHILE directive iterations reached ]
                Maximum WHILE directive iterations reached. You can change your compiler settings and allow more iterations. By default, number of iterations is unlimited.
            \item[Maximum number of REPEAT directive iterations reached ]
                Maximum REPEAT directive iterations reached. You can change your compiler settings and allow more iterations. By default, number of iterations is unlimited.
            \item[Instruction word is only 18 bits wide, value X trimmed to Y ]
                You have exceeded instruction word length. Value has been trimmed to  appropriate length.
            \item[Symbol already defined]
                The given symbol has been already defined. Symbol cannot be defined more than one time.
            \item[Symbol not defined: X ]
                The given symbol has not been defined. Symbol has to be defined before usage.
            \item[Symbol X already defined with type Y]
                The given symbol has been already defined with type Y. Symbol cannot be defined more than one time.
            \item[Undefined value ]
                Undefined value. You need to specify the value.
            \item[Real numbers are not supported in assembler ]
                Real numbers cannot be used on 8-bit processor.
            \item[Undefined symbol: X ]
                Symbol has not been defined. Define symbol before usage.
            \item[This value is not valid inside of expression ]
                The given expression contains forbidden value.
            \item[Division by zero ]
                Division by zero has been detected. It is not possible to divide with zero, therefore compilation is aborted.
            \item[Unable to resolve this expression ]
                The given expression cannot be resolved. Check if expression is syntactically right.
            \item[Syntax not understood ]
                There is syntax error in your source code.
            \item[Character constant is too long ]
                Character constant is too long. Check ASCII table for appropriate values.
            \item[Unterminated string or character constant ]
                Unterminated string or character constant. You probably forgot to end with ''.
            \item[Unrecognized escape sequence: ]
                Unrecognized escape sequence. Check ASCII table for appropriate values.
            \item[No file name specified ]
                File name has to be specified.
            \item[Unable to open the specified file: X]
                The given file cannot be opened for some reason.
            \item[Unrecognized token:  ]
                Source code contains invalid characters.
        \end{description}

    \subsection{Warnings}
        \begin{description}
            \item[Maximum number of messages reached, suppressing compiler message generation]
                Source code contains a big number of errors. Those errors were suppressed to prevent enormous size of code listing file.
            \item[Redefinition of macro ]
                The given macro has already been defined.
            \item[Macro X will not be expanded because macro expansion has been disabled]
                The given macro cannot be expanded because macro expansion has been disabled by NOEXPAND directive. You can use EXPAND directive to allow expansion again.
            \item[Parameter X substituted for blank value ]
                Macro expected input parameter. Compiler replaced it with blank parameter.
            \item[Symbol X already declared as local ]
                Symbol is already used as local inside of macro.
            \item[Reusing already reserved space in X memory at address: Y]
                Memory space is already defined. Make sure the collision will not occur.
            \item[Limit value -1 means unlimited]
                You can define limit values with LIMIT directive. Using -1 as directive argument, means unlimited.
            \item[Symbol X declared as local but never used, declaration ignored]
                The given local symbol has been declared but never used. Declaration will be ignored.
            \item[Comparing two immediate constants, result is always positive]
                Comparing two immediate constants, result will be always same.
            \item[Comparing two immediate constants, result is always negative]
                Comparing two immediate constants, result will be always same.
            \item[Sign overflow. Result is negative number lower than the lowest negative number representable in two's         complement arithmetic by the given number of bits ]
                Two's complement sign overflow.
            \item[Result is negative number X, this will be represented as X-bit number in two's complement arithmetic]
                Result is negative number. This will be represented as number in two's complement arithmetic.
            \item[Value out of range, allowed range is [0,2] (trimmed to 3 bits) which makes it 4 ]
                Value out of range. Adjust input value.
            \item[Maximum number of messages reached, suppressing compiler message generation ]
                Compiler is suppressing error messages generation to avoid massive code listing file size.
            \item[File name contains a null character ]
                Null character in file name is forbidden. Please change the name of the given file.
        \end{description}

\section{Symbol table}
    Symbol table contains list of macros in your source code with additional informations.\\
    {
        \usecodefont
        \verb'  +-------------------//------------------//-----------------------+'\\
        \verb'  |  name  |  group  |  value   |  usage  |  type  |  declaration  |'\\
        \verb'  +-------------------//------------------//-----------------------+'\\
    }

    \begin{description}
        \item[NAME]
            Describes the name of symbol.

        \item[GROUP]
            Defines what given symbol is and how will compiler handle it. Compiler will warn you, if you for example want to load symbol defined as group "PORT" into register. Symbols can be one of the following types.
            \begin{itemize}
                \item REGISTER: Symbol represents one of the internal registers.
                \item PORT: Symbol should be used as PORT\_id indicator.
                \item DATA: Symbol should be handled only as a scatch\-pad ram data.
                \item EXPRESION: Symbol is defined as an expression, which is evaluated later.
                \item LABEL: Symbol is label defining address in program memory.
                \item NUMBER: Symbol does not have specified type.
            \end{itemize}

        \item[VALUE]
            Value which is represented by the symbol.

        \item[USAGE]
            If it was USED or NOT USED in your source code.

        \item[TYPE]
            Tells you some additional info.
            \begin{itemize}
                \item IMPLICIT: Symbol is defined by default.
                \item LOCAL: Local symbol can be only used in macro body.
                \item REDEFINABLE: Symbol can be redefined everywhere in the source code.
                \item CONSTANT: Symbol cannot be redefined.
            \end{itemize}

        \item[DECLARATION]
            Information where is the symbol defined. Two scenarios. First can be location in your source code It consist of name of the file and line + column number with format: <nameoffile>:<firstlinenumber>.<columns>.<lastlinenumber>. Second is IMPLICIT, which means symbol is defined by default, not in your code.
    \end{description}

\section{Macro table}
    Macro table contains list of macros in your source code with additional informations.\\
    {
        \usecodefont
        \verb'  +-------------------//----------------------+'\\
        \verb'  |  name  |  usage  |  type  |  declaration  |'\\
        \verb'  +-------------------//----------------------+'\\
    }

    \begin{description}
        \item[NAME]
            Describes the name of Macro.
        \item[USAGE]
            It tells you how many times Macro was USED or NOT USED in your source code. Compiler will add number of macro expansions.
        \item[TYPE]
            Tells you some additional info.
        \item[DECLARATION]
            Information where is the macro defined. Two scenarios. First can be location in your source code It consist of name of the file and line + column number with format: <nameoffile>:<firstlinenumber>.<columns>.<lastlinenumber>. Second is IMPLICIT, which means symbol is defined by default, not in your code.
    \end{description}

\section{Mem File}
    Mem file contains program memory in special format. There is seventeen 4byte wide columns, first is starting with \@ and represents starting address. Every other position increments address by one. Unused memory is filled with zeroes.

    Example:\\
    {
        \usecodefont
        \verb'; Starting address 0x0000, sixteen OPcodes'\\
        \verb'@0000 000011F7 00001299 0000132E ... ... ... ... ... ... 00004577 00007789 000015A4'\\
        \verb'; Starting address 0x0040'\\
        \verb'@0040 000004DF 000047F4 00000000 ... ... ... ... ... ... 00000000 00000000 00000000'\\
        \verb'@0080 00000000 00000000 00000000 ... ... ... ... ... ... 00000000 00000000 00000000'\\
        \verb'@00C0 00000000 00000000 00000000 ... ... ... ... ... ... 00000000 00000000 00000000'\\
        \verb'@0100 00000000 00000000 00000000 ... ... ... ... ... ... 00000000 00000000 00000000'\\
        \verb'...'\\
        \verb'...'\\
        \verb'...'\\
        \verb'@3F80 000011F7 00001299 0000132E ... ... ... ... ... ... 00000000 00000000 00000000'\\
        \verb'@3FC0 000011F7 00001299 0000132E ... ... ... ... ... ... 00000000 00000000 00000000'\\
        \verb'; end of program memory'\\
    }

\section{Raw Hex Dump file}
    Raw Hex Dump is very simple. File starts with OP Code of your first instruction at address 0x0, then it is followed by OPcode on address 0x1, 0x2, and so on. If there is no instruction on a certain address, it is filled with zeros.

    Example:\\
    {
        \usecodefont
        \verb'; Starting at address 0x0'\\
        \verb'011F7'\\
        \verb'01299'\\
        \verb'0132E'\\
        \verb'19101'\\
        \verb'00000'\\
        \verb'19201'\\
        \verb'00000'\\
        \verb'19301'\\
        \verb'00000'\\
        \verb'00000'\\
        \verb'00...'\\
        \verb'.....'\\
        \verb'...00'\\
        \verb'; end of program memory'\\
    }

\section{Bin file}
    Bin file gives you raw data from program memory. It contains OP Codes of instructions in 3 bytes (18 bit instructions) or 2 bytes (16 bit instructions) sorted in a line. It does not contain unused memory.

    Example:\\
    {
        \usecodefont
        \verb'; Starting at address 0x0'\\
        \verb'; Displayed OPcodes 22045, 3EF45, 08FF0 (18bit instr.) would be:'\\
        \verb'  02204503EF45008FF0 '\\\\
        \verb'; Displayed OPcodes 2045, 3EF4, 08F0 (16bit instr.) would be:'\\
        \verb'  20453EF408F0 '\\
    }

\section{Motorola S-Rec format}
    Motorola S-records are a form of simple ASCII encoding for binary data. This format is commonly used for firmware uploads to GPSes, industrial robots, and other kinds of microcontroller-driven hardware. It has several convenient properties, including inspectability, easy editing with any text editor, and checksumming for verification of transmission across noisy serial lines. An S-record file consists of a sequence of specially formatted ASCII character strings. An S-record will be less than or equal to 78 bytes in length. The order of S-records within a file is of no significance and no particular order may be assumed.

    The general format of an S-record follows:\\
    {
        \usecodefont
        \verb'  +-------------------//------------------//-----------------------+'\\
        \verb'  | type | count | address  |            data           | checksum |'\\
        \verb'  +-------------------//------------------//-----------------------+'\\
    }

    \begin{description}
        \item[Type]
            A char[2] field. These characters describe the type of record (S0,S1, S2, S3, S5, S7, S8, or S9).

        \item[Count]
            A char[2] field. These characters when paired and interpreted as a hexadecimal value, display the count of remaining character pairs in the record.

        \item[Address]
            A char[4,6, or 8] field. These characters grouped and interpreted as a hexadecimal value, display the address at which the data field is to be loaded into memory. The length of the field depends on the number of bytes necessary to hold the address. A 2-byte address uses 4 characters, a 3-byte address uses 6 characters, and a 4-byte address uses 8 characters.

        \item[Data]
            A char [0-64] field. These characters when paired and interpreted as hexadecimal values represent the memory loadable data or descriptive information.

        \item[Checksum]
            A char[2] field. These characters when paired and interpreted as a hexadecimal value display the least significant byte of the ones complement of the sum of the byte values represented by the pairs of characters making up the count, the address, and the data fields.
    \end{description}

    Each record is terminated with a line feed. If any additional or different record terminator(s) or delay characters are needed during transmission to the target system it is the responsibility of the transmitting program to provide them.

    \subsection{Record types}
        \begin{description}
            \item[S0]
                The type of record is S0 (0x5330). The address field is unused and will be filled with zeros (0x0000). The header information within the data field is divided into the following subfields.

                \begin{itemize}
                    \item mname is char[20] and is the module name.
                    \item ver is char[2] and is the version number.
                    \item rev is char[2] and is the revision number.
                    \item description is char[0-36] and is a text comment.
                \end{itemize}

                Each of the subfields is composed of ASCII bytes whose associated characters when paired, represent one byte hexadecimal values in the case of the version and revision numbers, or represent the hexadecimal values of the ASCII characters comprising the module name and description.

            \item[S1]
                The type of record field is S1 (0x5331). The address field is interpreted as a 2-byte address. The data field is composed of memory loadable data.

            \item[S2]
                The type of record field is S2 (0x5332). The address field is interpreted as a 3-byte address. The data field is composed of memory loadable data.

            \item[S3]
                The type of record field is S3 (0x5333). The address field is interpreted as a 4-byte address. The data field is composed of memory loadable data.

            \item[S5]
                The type of record field is S5 (0x5335). The address field is interpreted as a 2-byte value and contains the count of S1, S2, and S3 records previously transmitted. There is no data field.

            \item[S7]
                The type of record field is S7 (0x5337). The address field contains the starting execution address and is interpreted as a 4-byte address. There is no data field.

            \item[S8]
                The type of record field is S8 (0x5338). The address field contains the starting execution address and is interpreted as a 3-byte address. There is no data field.

            \item[S9]
                The type of record field is S9 (0x5339). The address field contains the starting execution address and is interpreted as a 2-byte address. There is no data field.
        \end{description}

    \subsection{EXAMPLE}
        Shown below is a typical S-record format file.

        {
            \usecodefont
            \verb''\\
            \verb'S00600004844521B'\\
            \verb'S1130000285F245F2212226A000424290008237C2A'\\
            \verb'S11300100002000800082629001853812341001813'\\
            \verb'S113002041E900084E42234300182342000824A952'\\
            \verb'S107003000144ED492'\\
            \verb'S5030004F8'\\
            \verb'S9030000FC'\\
        }

        The file consists of one S0 record, four S1 records, one S5 record and an S9 record.

    \subsubsection{The S0 record is comprised as follows:}
        \begin{itemize}
            \item S0 S-record type S0, indicating it is a header record.
            \item 06 Hexadecimal 06 (decimal 6), indicating that six character pairs (or ASCII bytes) follow.
            \item 00 00 Four character 2-byte address field, zeros in this example.
            \item 48 44 52 ASCII H, D, and R - "HDR".
            \item 1B The checksum.
        \end{itemize}

    \subsubsection{The first S1 record is comprised as follows:}
        \begin{itemize}
            \item S1 S-record type S1, indicating it is a data record to be loaded at a 2-byte address.
            \item 13 Hexadecimal 13 (decimal 19), indicating that nineteen character pairs, representing a 2 byte address, 16 bytes of binary data, and a 1 byte checksum, follow.
            \item 00 00 Four character 2-byte address field; hexadecimal address 0x0000 where the data which follows is to be loaded.
            \item 28 5F 24 5F 22 12 22 6A 00 04 24 29 00 08 23 7C Sixteen character pairs representing the actual binary data.
            \item 2A The checksum.
        \end{itemize}

    \subsubsection{The second and third S1 records are comprised as follows:}
        The second and third S1 records each contain 0x13 (19) character pairs and are ended with checksums of 13 and 52, respectively. The fourth S1 record contains 07 character pairs and has a checksum of 92.

    \subsubsection{The S5 record is comprised as follows:}
        \begin{itemize}
            \item S5 S-record type S5, indicating it is a count record indicating the number of S1 records
            \item 03 Hexadecimal 03 (decimal 3), indicating that three character pairs follow.
            \item 00 04 Hexadecimal 0004 (decimal 4), indicating that there are four data records previous to this record.
            \item F8 The checksum.
        \end{itemize}

    \subsubsection{The S9 record is comprised as follows:}
        \begin{itemize}
            \item S9 S-record type S9, indicating it is a termination record.
            \item 03 Hexadecimal 03 (decimal 3), indicating that three character pairs follow.
            \item 00 00 The address field, hexadecimal 0 (decimal 0) indicating the starting execution address.
            \item FC The checksum.
        \end{itemize}

\section{Generated VHDL and Verilog files}
    As you know, the PicoBlaze microcontroller is primarily designed for use in a VHDL design flow. MDS will generate all necessary files, that are needed for implementation in FPGA. The compiler will read the template and insert the information required to complete the definition of program ROM and write it out to new '.vhd' or '.v' file that is ready for synthesis and simulation.

    Template can be modified to define alternative memory definitions. However, you are responsible for ensuring the template is correct as the compiler does not perform any checking of the VHDL.

    The compiler identifies all text enclosed by {} characters, and replaces these character strings. All templates should include these {} character strings for the compiler to work correctly. Basically the MDS replaces instances on {INIT\_XX}, {INITP\_XX} and {INIT64\_X}, {INIT128\_X}, {INIT256\_X} by constant strings with the appropriate values, similar to the kcpsmX tools of Xilinx.

\section{List File Format}
    Code listing serves as an additional information about the assembled code and the progress of the assembly process. It contains information about all symbols defined in the code. Where and how were they were defined, what are their values and whether they were used in the code. Also detailed information about all macros defined in the code and/or expanded in the code. Conditional compilation configuration, instruction OP codes, address space reservations, inclusion of code from another files. And all warnings, errors and notes generated during the assembly by the assembler.

    There are assembler control sequences which alters formatting of the code listing file. These control sequences will be discussed here. Format of code listing generated by this assembler is very similar to the one generated Metalink(R) ASM51.

    \begin{code}[h]
        \mysmallfont{}
        \verb'demo0                                         PAGE 1'\\
        \verb'                         1     ; Demostration code'\\
        \verb'                         2             org     0'\\
        \verb'                         3'\\
        \verb'0000 01001               4     main:   load    s0, #1'\\
        \verb'0001 01102               5             load    s1, #2'\\
        \verb'0005 01203               6             load    s2, #3'\\
        \verb'0007 3E000               7             jump    main'\\
        \verb'                         8'\\
        \verb'                         9             end'\\
        \caption{A simple code listing}
    \end{code}

    Code listing contains entire source code which was assembled but with each line prefixed with line number and some additional information which will be explained later. Besides the original code there is also table of symbols defined during the assembly unless it was turned off. Code listing is divided into pages separated by form feed character, this behavior may be altered by certain assembler control sequences as well as page height and width.

    Each line of code listing which contains original source code line may contain beside line number also some additional information regarding the compilation of the given line of code. Such a additional information might look like this and is composed of these parts:

    \begin{code}[h]
        {
            \usecodefont
            \verb'  '{\color{Lavender}{0055}}\verb'                  '{\color{Goldenrod}{18}}\verb'      '{\color{Gray}{X      data     55h}}\\
            {\color{Apricot}{0014}}\verb' '{\color{GreenYellow}{1122}}\verb'       '{\color{LimeGreen}{=1}}\verb'      '{\color{Goldenrod}{33}}\verb'      '{\color{Gray}{l:     inc      s0}}\\
            \verb'                        '{\color{Goldenrod}{35}}\verb' '{\color{ProcessBlue}{+1}}\verb'   '{\color{Gray}{abc     ; Expand macro ``abc'' here}}\\
            {\color{Apricot}{001E}}\verb' '{\color{GreenYellow}{E580}}\verb'               '{\color{Goldenrod}{36}}\verb' '{\color{ProcessBlue}{+1}}\verb'  '{\color{Gray}{                LOAD     s1, s0}}\\
            {\color{Apricot}{0020}}\verb' '{\color{GreenYellow}{F410}}\verb'               '{\color{Goldenrod}{37}}\verb' '{\color{ProcessBlue}{+1}}\verb'  '{\color{Gray}{                SR0     s1}}\\
            {\color{Apricot}{0021}}\verb' '{\color{GreenYellow}{F590}}\verb'               '{\color{Goldenrod}{38}}\verb' '{\color{ProcessBlue}{+1}}\verb'  '{\color{Gray}{                LOAD     s2, s1}}\\

            \colorbox{Goldenrod}{\color{Goldenrod}X} Line number\\
            \colorbox{LimeGreen}{\color{LimeGreen}X} Level of file inclusion\\
            \colorbox{ProcessBlue}{\color{ProcessBlue}X} Level of macro expansion\\
            \colorbox{Apricot}{\color{Apricot}X} Address in code memory\\
            \colorbox{GreenYellow}{\color{GreenYellow}X} Machine code or another value to be stored in the code memory\\
            \colorbox{Lavender}{\color{Lavender}X} Value of a symbol\\
            \colorbox{Gray}{\color{Gray}X} Original line\\
        }
        \caption{Format of code listing}
    \end{code}

    \begin{code}[h]
        \mysmallfont{}
        \verb'complicated_lst                                                                                                         '{\color{highlight_macro}\verb'PAGE'}\verb' '{\color{highlight_unknown_base}\verb'1'}\\
        {\color{highlight_lst_number}\verb'  001C'}{\color{highlight_lst_line}\verb'               1'}\verb'     '{\color{highlight_constant}\verb'abc'}\verb'     '{\color{highlight_directive}\verb'equ'}\verb'     '{\color{highlight_symbol}\verb'('}\verb' '{\color{highlight_unknown_base}\verb'14'}\verb' '{\color{highlight_symbol}\verb'*'}\verb' '{\color{highlight_unknown_base}\verb'2'}\verb' '{\color{highlight_symbol}\verb')'}\verb'      '{\color{highlight_comment}\verb'; Define symbol abc'}\\
        {\color{highlight_lst_line}\verb'                     2'}\verb'             '{\color{highlight_directive}\verb'org'}\verb'     '{\color{highlight_unknown_base}\verb'0'}\verb'               '{\color{highlight_comment}\verb'; Code at address 0'}\\
        {\color{highlight_lst_line}\verb'                     3'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      4'}\verb'             '{\color{highlight_directive}\verb'include'}\verb' '{\color{highlight_string}\verb''\verb"'"\verb'my_macros.asm'\verb"'"\verb' '{\color{highlight_comment}\verb'; Include my_macros.asm'}}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      5'}\verb'     '{\color{highlight_comment}\verb'; This is the beginning of file my_macros.asm'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      6'}\verb'     '{\color{highlight_macro}\verb'my_cpl'}\verb'  '{\color{highlight_directive}\verb'macro'}\verb'   '{\color{highlight_constant}\verb'foo'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      7'}\verb'             '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's3'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_constant}\verb'foo'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      8'}\verb'             '{\color{highlight_instruction}\verb'add'}\verb'      '{\color{highlight_sfr}\verb's3'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      9'}\verb'             '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_constant}\verb'foo'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's3'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'     10'}\verb'     '{\color{highlight_directive}\verb'endm'}\\
        {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'     11'}\verb'     '{\color{highlight_comment}\verb'; This is the end of file my_macros.asm'}\\
        {\color{highlight_lst_line}\verb'                    12'}\\
        {\color{highlight_lst_line}\verb'                    13'}{\color{highlight_lst_macro}\verb' +1'}\verb'  '{\color{highlight_label}\verb'main:'}\verb'   '{\color{highlight_macro}\verb'my_cpl'}\verb'  '{\color{highlight_sfr}\verb's0'}\verb'          '{\color{highlight_comment}\verb'; Expand macro my_cpl here'}\\
        {\color{highlight_lst_address}\verb'0000'}{\color{highlight_lst_code}\verb' E580'}{\color{highlight_lst_line}\verb'           14'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's1'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's0'}\\
        {\color{highlight_lst_address}\verb'0002'}{\color{highlight_lst_code}\verb' F4'}{\color{highlight_lst_line}\verb'             15'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'add'}\verb'      '{\color{highlight_sfr}\verb's1'}\\
        {\color{highlight_lst_address}\verb'0003'}{\color{highlight_lst_code}\verb' F580'}{\color{highlight_lst_line}\verb'           16'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's0'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's1'}\\
        {\color{highlight_lst_address}\verb'0005'}{\color{highlight_lst_code}\verb' 80F9'}{\color{highlight_lst_line}\verb'           17'}\verb'             '{\color{highlight_instruction}\verb'jmp'}\verb'    '{\color{highlight_constant}\verb'main'}\verb'        '{\color{highlight_comment}\verb'; Jump back to label main'}\\
        {\color{highlight_lst_line}\verb'                    18'}\verb'             '{\color{highlight_directive}\verb'end'}\verb'                 '{\color{highlight_comment}\verb'; End of assembly'}\\
        {\color{highlight_lst_msg}\verb'ASSEMBLY COMPLETE,'}\verb' NO ERRORS FOUND, NO WARNINGS'\\
        \caption{A more complicated example of code listing}
    \end{code}

    \clearpage

\section{Specification of Intel(R) 8 HEX Format}
    Intel(R) 8 HEX is a popular object file format capable of containing up to 64kB of data. Hex files have usually extension .hex or .ihx. These files are text files consisting of a sequence of records, each line line can contain at most one record. Records starts with ``:'' (colon) character at the beginning of the line and ends by end of the line. Everything else besides records should be ignored. Records consist of a sequence of 8-bit hexadecimal numbers (e.g. ``a2'' or ``8c''). These numbers are divided into ``fields'' with different meaning, see the example below.

    \begin{code}[h]
        \caption{An example of an Intel(R) 8 hex code}
        \mysmallfont{}
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{0000}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{57}}\\
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{000F}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{48}}\\
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{001E}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{39}}\\
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{002D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F5907410B3758010B2907410B3}\colorbox{Lavender}{30}}\\
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{003D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{758010B2902694052600940426940526}\colorbox{Lavender}{0A}}\\
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{004D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{00940426009404269405E580F4F59026}\colorbox{Lavender}{8A}}\\
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0B}\colorbox{blue}{005D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{009404269405E580F4F590}\colorbox{Lavender}{63}}\\
        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{00}\colorbox{blue}{0000}\colorbox{Apricot}{01}\colorbox{Lavender}{FF}}\\\\
        \colorbox{Goldenrod}{\color{Goldenrod}X} Start code\\
        \colorbox{green}{\color{green}X} Byte count\\
        \colorbox{blue}{\color{blue}X} Address\\
        \colorbox{Apricot}{\color{Apricot}X} Record type\\
        \colorbox{GreenYellow}{\color{GreenYellow}X} Data\\
        \colorbox{Lavender}{\color{Lavender}X} Checksum (two's complement of 8-bit sum of entire record, except for the start code and the checksum itself)
    \end{code}

\section{Instructions}
    \paragraph{Legend}
        ~\\
        "sX" and "sY" are direct addresses in register file, e.g. S0, S1, S2, ...\\
        "@sX" and "@sY" are indirect addresses, e.g. @S0, @S1, @S2, ...\\
        "\#kk" is immediate value (constant), e.g. \#0x21 (hex.), \#26 (dec.), \#'A' (ascii).\\
        "aaa" is address in program memory.\\
        "pp" is port address in the range from 0x00 to 0xFF.\\
        "p" is port address in the range from 0x0 to 0xF.\\
        "ss" is address in scratch-pad RAM.

    \subsection{Program Control Group}
        \subsubsection{JUMP}
            Instruction JUMP loads program counter with the address specified by aaa operand. This instruction has no effect on the status flags.

            \paragraph{Syntax}
                ~\\
                \verb'JUMP aaa          '; Unconditional jump.\\
                \verb'JUMP Z, aaa       '; Jump only if the Zero flag is set.\\
                \verb'JUMP NZ, aaa      '; Jump only if the Zero flag is NOT set.\\
                \verb'JUMP C, aaa       '; Jump only if the Carry flag is set.\\
                \verb'JUMP NC, aaa      '; Jump only if the Carry flag is NOT set.

            \paragraph{Examples}
                ~\\
                \verb'my_label:'\\
                \verb'          ; ... code ...'\\
                \verb'          JUMP    my_label        ; Jump to label "my_label".'\\
                \verb''\\
                \verb'          JUMP    0x300 + 0xff    ; Jump to address 3FF hexadecimal.'

        \subsubsection{CALL}
            Call subroutine at the address specified by aaa operand.

            \paragraph{Syntax}
                ~\\
                \verb'CALL aaa          '; Unconditional call.\\
                \verb'CALL Z, aaa       '; Call only if the Zero flag is set.\\
                \verb'CALL NZ, aaa      '; Call only if the Zero flag is NOT set.\\
                \verb'CALL C, aaa       '; Call only if the Carry flag is set.\\
                \verb'CALL NC, aaa      '; Call only if the Carry flag is NOT set.

            \paragraph{Examples}
                ~\\
                \verb'subprog:  ADD     S0, S1          ; S0 := S0 + S1'\\
                \verb'          SUB     S1, # 5 * 2     ; S1 := S1 + 7'\\
                \verb'          RETURN'\\
                \verb''\\
                \verb'          CALL    my_subprog'\\
                \verb''\\
                \verb'          CALL    40            ; Call subroutine at address 40 decimal.'

        \subsubsection{RETURN, RET}
            Return from subroutine. RET and RETURN are completely interchangeable, they are the same instruction, RET is only shorthand for RETURN.

            \paragraph{Syntax}
                ~\\
                \verb'RETURN    '; Unconditional return.\\
                \verb'RETURN Z  '; Return only if the Zero flag is set.\\
                \verb'RETURN NZ '; Return only if the Zero flag is NOT set.\\
                \verb'RETURN C  '; Return only if the Carry flag is set.\\
                \verb'RETURN NC '; Return only if the Carry flag is NOT set.

            \paragraph{Examples}
                ~\\
                \verb'subr:     ADD     S0, S1          ; S0 := S0 + S1'\\
                \verb'          RETURN  Z               ; Return if S0 contains zero value.'\\
                \verb'          LOAD    S0, #1          ; Load S1 with value 1.'\\
                \verb'          RET                     ; Return unconditionally.'\\
                \verb''\\
                \verb'          CALL    subr'\\

    \subsection{Arithmetic Group}
        \subsubsection{ADD, ADDCY}
            The ADD instruction performs an 8-bit addition of two values.

            \paragraph{Syntax}
                ~\\
                \verb'ADD sX, #kk    '; Add immediate value \#kk to sX register (without carry).\\
                \verb'ADD sX, sY     '; Add content of sY register to sX register (without carry).\\
                \verb'ADDCY sX, #kk  '; Add immediate value \#kk to sX register (with carry).\\
                \verb'ADDCY sX, sY   '; Add content of sY register to sX register (with carry).

            \paragraph{Examples}
                ~\\
                \verb'          LOAD    S0, #1          ; S0 := 1'\\
                \verb'          LOAD    S1, #2          ; S0 := 2'\\
                \verb''\\
                \verb'          ADD     S0, S1          ; S0 := S0 + S1'\\
                \verb'          ADD     S0, #5          ; S0 := S0 + 5'\\
                \verb'          ADDCY   S0, S1          ; S0 := S0 + S1 + Carry'\\
                \verb'          ADDCY   S0, #5          ; S0 := S0 + 5 + Carry'

        \subsubsection{SUB, SUBCY}
            The SUB instruction performs an 8-bit subtraction of two values.

            \paragraph{Syntax}
                ~\\
                \verb'SUB sX, #kk       '; Subtract immediate value \#kk from sX register (without carry).\\
                \verb'SUB sX, sY        '; Subtract content of sY register from sX register (without carry).\\
                \verb'SUBCY sX, #kk     '; Subtract immediate value \#kk from sX register (with carry).\\
                \verb'SUBCY sX, sY      '; Subtract content of sY register from sX register (with carry).

            \paragraph{Examples}
                ~\\
                \verb'          LOAD    S0, #10         ; S0 := 1'\\
                \verb'          LOAD    S1, #2          ; S0 := 2'\\
                \verb''\\
                \verb'          SUB     S0, S1          ; S0 := S0 - S1'\\
                \verb'          SUB     S0, #5          ; S0 := S0 - 5'\\
                \verb'          SUBCY   S0, S1          ; S0 := S0 - S1 - Carry'\\
                \verb'          SUBCY   S0, #5          ; S0 := S0 - 5 - Carry'

        \subsubsection{COMPARE, CMP}
            The COMPARE instruction performs an 8-bit subtraction of two values. Unlike the SUB instruction, result of this operation is discarded, and only status flags are affected. CMP is only shorthand for COMPARE.

            \paragraph{Syntax}
                ~\\
                \verb'COMPARE sX, #kk   '; Compare immediate value \#kk to content of register sX.\\
                \verb'COMPARE sX, sY    '; Compare content of register sY to content of register sX.\\\
                \verb'CMP     sX, #kk   '; Same as ``COMPARE sX, \#kk''.\\
                \verb'CMP     sX, sY    '; Same as ``COMPARE sX, sY''.

            \paragraph{Examples}
                ~\\
                \verb'          COMPARE    S0, #1          ; Set Z flag, if S0 == 1.'\\
                \verb'          JUMP       Z, somewhere    ; Jump to label "somewhere", if Z flag is set.'

    \subsection{Interrupt group}
        \subsubsection{RETURNI, RETIE, RETID}
            Return from Interrupt Service Routine (ISR) while enabling or disabling further interrupts. RETIE stands for \textbf{RET}urn from \textbf{I}nterrupt and \textbf{E}nable, RETID stands for \textbf{RET}urn from \textbf{I}nterrupt and \textbf{D}isable

            \paragraph{Syntax}
                ~\\
                \verb'RETURNI ENABLE    '; Return from ISR and enable interrupts.\\
                \verb'RETURNI DISABLE   '; Return from ISR and disable interrupts.\\
                \verb'RETIE             '; Same as ``RETURNI ENABLE''\\
                \verb'RETID             '; Same as ``RETURNI DISABLE''

            \paragraph{Examples}
                ~\\
                \verb'          ORG        0x3ff          ; Interrupt vector.'\\
                \verb'          LOAD       S0, #0x55      ; Load register S0 with immediate value 0x55.'\\
                \verb'          RETURNI    DISABLE        ; Return from ISR and disable further interrupts.'

        \subsubsection{ENABLE INTERRUPT, DISABLE INTERRUPT, ENA, DIS}
            Enable or disable interrupts.

            \paragraph{Syntax}
                ~\\
                \verb'ENABLE INTERRUPT  '; Enable interrupts.\\
                \verb'DISABLE INTERRUPT '; Disable interrupts.\\
                \verb'ENA               '; Same as ``ENABLE INTERRUPT''.\\
                \verb'DIS               '; Same as ``DISABLE INTERRUPT''.

            \paragraph{Examples}
                ~\\
                \verb'          DIS                       ; Timing critical code begins here, disable interrupts.'\\
                \verb'          LOAD       S0, #0x55      ; Do something...'\\
                \verb'          ENA                       ; Timing critical code ends here, re-enable interrupts.'

    \subsection{Logical Group}
        \subsubsection{LOAD, LD}
            The LOAD instruction provides a method for specifying the contents of any register. The new value can be a constant, or the contents of any other register. The LOAD instruction has no effect on the status flags.

            \paragraph{Syntax}
                ~\\
                \verb'LOAD sX, #kk ';\\
                \verb'LOAD sX, sY  ';\\
                \verb'LD   sX, #kk ';\\
                \verb'LD   sX, sY  ';

        \subsubsection{STAR}
            Apart from bank "A" being the default on power up or following a reset you are completely free to select back "A" or bank "B" as an when you wish using the REGBANK instruction. All instructions only operate on the registers in the actively selected bank which preserves the values in the inactive bank.

            \paragraph{Syntax}
                ~\\
                \verb'STAR sX, sY'\\
                \verb'STAR sX, #kk'

        \subsubsection{OR}
            The "OR" instructions perform the bit-wise logical OR operation. The zero flag (Z) will be set if all 8-bits of the result returned to "sX" are zero. The carry flag (C) will be cleared (C=0) in all cases.

            \paragraph{Syntax}
                ~\\
                \verb'OR sX, sY'\\
                \verb'OR sX, #kk'

        \subsubsection{XOR}
            The "XOR" instructions perform the bit\-wise logical exclusive-OR operation. The zero flag (Z) will be set if all 8-bits of the result returned to "sX" are zero. The carry flag (C) will be cleared (C=0) in all cases.

            \paragraph{Syntax}
                ~\\
                \verb'XOR sX, #kk'\\
                \verb'XOR sX, sY'

        \subsubsection{AND}
            The first operand must specify a register "sX" whose value provides one input to the AND operation and in to which the result is returned. The second operand defines the second input to the AND operation and can either be an 8-bit constant \#kk or a register sY. The zero flag (Z) will be set if all 8-bits of the result returned to sX are zero. The carry flag (C) will be cleared (C=0) in all cases.

            \paragraph{Syntax}
                ~\\
                \verb'AND sX, #kk'\\
                \verb'AND sX, sY'

        \subsubsection{TEST}
            The "TEST" instructions are similar to the "AND" instructions in that a bit-wise logical AND operation is performed. However, the actual result is discarded and only the flags are updates to reflect the temporary 8-bit. The zero flag (Z) will be set if all 8-bits of the temporary result are zero. The carry flag (C) will be set if the temporary result contains an odd number of bits set to "1" (the exclusive-OR of the 8-bit temporary result).

            \paragraph{Syntax}
                ~\\
                \verb'TEST sX, sY'\\
                \verb'TEST sX, #kk'

        \subsubsection{TESTCY}
            The "TESTCY" instructions are primarily intended as an extension to the basic "TEST" instructions in order to support testing and odd parity calculation of values more than 8-bits.

            \paragraph{Syntax}
                ~\\
                \verb'TESTCY} sX, sY'
                \verb'TESTCY} sX, #kk'

    \subsection{Shift and Rotate Group}
        \subsubsection{SR}
            \paragraph{Syntax}
                ~\\
                \verb'SR0 sX'\\
                \verb'SR1 sX'\\
                \verb'SRX sX'\\
                \verb'SRA sX'

        \subsubsection{RR, RL}
            \paragraph{Syntax}
                ~\\
                \verb'RR sX'\\
                \verb'RL sX'

        \subsubsection{SL}
            \paragraph{Syntax}
                ~\\
                \verb'SL0 sX'\\
                \verb'SL1 sX'\\
                \verb'SLX sX'\\
                \verb'SLA sX'

    \subsection{Storage group}
        \subsubsection{STORE}
            The store instructions write the contents of a register "sX" into the scratch pad memory (SPM).

            \paragraph{Syntax}
                ~\\
                \verb'STORE sX, ss'\\
                \verb'STORE sX, @sY'

        \subsubsection{FETCH}
            The fetch instructions read the contents of a location of scratch pad memory (SPM) into a register "sX".

            \paragraph{Syntax}
                ~\\
                \verb'FETCH sX, ss'\\
                \verb'FETCH sX, @sY'

    \subsection{Input output group}
        \subsubsection{INPUT, IN}
            An "INPUT" instruction enables to read information from the from your hardware design into a register "sX" using a general purpose input port.

            \paragraph{Syntax}
                ~\\
                \verb'INPUT sX, pp'\\
                \verb'INPUT sX, @sY'\\
                \verb'IN    sX, pp'\\
                \verb'IN    sX, @sY'

        \subsubsection{OUTPUT, OUT}
            An "OUTPUT" instruction is used to transfer information from a register "sX" to a general purpose output port specified by an 8-bit constant value "pp" or the
            contents of another register "@sY".

            \paragraph{Syntax}
                ~\\
                \verb'OUTPUT sX, pp'\\
                \verb'OUTPUT sX, @sY'\\
                \verb'OUT    sX, pp'\\
                \verb'OUT    sX, @sY'

        \subsubsection{OUTPUTK, OUTK}
            The first operand is the 8-bit constant value "\#kk". "p" is port\_id[0:3].

            \paragraph{Syntax}
                ~\\
                \verb'OUTPUTK #kk, p'\\
                \verb'OUTPUTK #kk, @sY'\\
                \verb'OUTK    #kk, p'\\
                \verb'OUTK    #kk, @sY'
