In this chapter, we will be concerned with build-in macro assembler. With syntax of its statements, directives and PicoBlaze assembler instructions. It is assumed, that the reader is familiar with general concepts of assembly language programming and PicoBlaze architecture.

MDS has the most advanced macro assembler on the market. Its suports a lot of various types of macros and advanced directives, like for example REPT and WHILE, which can create for and while loops or  macros with unlimited number of input parameters.

Then each list element is beeing parsed and splitted into an address reference, a command and an argument list. After them all directives are beeing filtered out and all commands and their arguments are beeing checked for validity.

\paragraph{Important changes}
    You need to tell compiler, that you are using constants by adding \# before second operand.

    {
        ~\\
        \usecodefont
        \verb'; Example of instructions operating with constants'\\
        \verb'LOAD    s0, #0b000111   ; compiler now know, that this number is constant'\\
        \verb'LOAD    s0,  0b000111   ; and this compiler takes as an adrress'\\
    }

\section{Statements}
    Source code files for this assembler must be text files where lines are formed like these:

    {
        ~\\
        \usecodefont
        \verb'[ label: ]  [ instruction  [ operand [ , operand [ , operand ] ] ]  [ ;comment ]'\\
        \verb'[ label: ]  directive      [ argument ]                             [ ;comment ]'\\
        \verb'            symbol         directive argument                       [ ;comment ]'\\
        \verb'            directive      symbol, argument                         [ ;comment ]'\\
    }

    Everything in square brackets is optional. Compilation does not go beyond line containing "end" directive, so after that directive the code do not have to be syntactically valid. Empty lines are allowed as well as line containing only comment or label. Statements can be separated by spaces, NBSP characters and tabs. Statements are case insensitive and their length is not limited, overall line length is also not limited.

\section{Symbols}
    Symbol names for numbers, macros or addresses defined by user in the code using appropriate directive. Like with ``\texttt{equ}'' directive you can define a new symbol and assign a value to it right away. Symbols may consist of upper and lower case letter, digits and underscore character (``\_''), their length is not limited, they are case insensitive and they can be the same as language keywords. Be aware of that there cannot coexists two or more symbols in the same memory segment which differs only by letter casing, in other words symbols ``\texttt{abc}'' and ``\texttt{ABC}'' are completely the same thing.

    {
        \usecodefont
        \verb'First_symb      EQU     0b100111 ; Number in binary'\\
        \verb'Second_symb     SET     47q      ; Octal'\\
        \verb'Third_symb      REG     39d      ; Decimal'\\
        \verb'Fourth_symb     DATA    27h      ; Hexadecimal'\\
        \verb'Fifth_symb      CODE    27h      ; Hexadecimal'

    }

    As you can see in Code \ref{code:esd} example, some unknown directives are used for symbol definition. Next chapter describes all directives, as well as constants syntax and expresions priority.

\section{Constants}
    MDS supports both prefix and sufix definition.

    \begin{code}[h!]
    {
        \usecodefont

        \verb'x       equ     10         ; Decimal'\\
        \verb'x       equ     10D        ; Decimal'\\
        \verb'x       equ     0xFE       ; Hexadecimal'\\
        \verb'x       equ     FEh        ; Hexadecimal'\\
        \verb'x       equ     O52        ; Octal'\\
        \verb'x       equ     52q        ; Octal'\\
        \verb'x       equ     01011110b  ; Binary'\\
        \verb'x       equ     0b00100001 ; Binary'\\
        \verb'x       equ     0b01       ; Binary, considers left side of byte zeroes'\\
        \verb'x       equ     01b        ; Binary, considers right side of byte zeroes'

        \caption{Syntax of various constant bases.}
        \label{code:svcb}
    }
    \end{code}

    When you want to say to compiler, that you are using constant, you must add "\#" before.

\clearpage
\section{Expressions}
    Arithmetical expressions are evaluated at compilation time and replaced by assembler with constant corresponding the their resulting value. Expressions comprises of arithmetical operators, constants, symbols and another expressions. An example of such expression might be:

    \begin{itemize}
        \item \texttt{2+1}
        \item \texttt{(2 + 4) - ABC}
        \item \texttt{A \&\& B)} (
        \item \texttt{X XOR 0FF00H}
        \item \texttt{X * Y + X \% Y}
    \end{itemize}

    When multiple operators occur in an expression, the expression is evaluated in a specific order depending upon the operators in the expression. All logical operators have priorities lower than arithmetic and relational operators. Therefore, if an expression involving arithmetic, relational and logical operators, the arithmetic operators are evaluated first, followed by the relational operators, followed by the logical operators.

    The following table shows the priority of all the operators used in expressions.

    \begin{table}[h!]
        \centering{}
        \mysmallfont{}

        \begin{tabular}{|l|l|l|l|}
            \hline
            Priority & Operator & Description             & Example         \\\hline
            1        & +        & unary plus sign         & +12             \\\hline
            1        & -        & unary minus sign        & -5              \\\hline
            2        & \~{}     & bitwise NOT             & \~{}0a55ah      \\\hline
            2        & !        & logical NOT             & !0a55ah         \\\hline
            3        & *        & unsigned multiplication & 11 * 12         \\\hline
            3        & /        & unsigned divisiono      & 11 / 12         \\\hline
            3        & \%       & unsigned remainder      & 13 \% 11        \\\hline
            4        & +        & unsigned addition       & 3 + 5           \\\hline
            4        & -        & unsigned substraction   & 20 - 4          \\\hline
            5        & <{}<     & binary shift left       & 21 << 4         \\\hline
            5        & >{}>     & binary shift right      & 32 >> 2         \\\hline
            6        & <        & less than               & 11 < 12         \\\hline
            6        & <=       & less or equal than      & 11 <= 11        \\\hline
            6        &  >       & greater than            & 12 > 11         \\\hline
            6        & >=       & greater or equal than   & 12 >= 11        \\\hline
            7        & ==       & equal to                & 11 == 11        \\\hline
            7        & !=       & not equal to            &  A != B         \\\hline
            8        & \&       & bitwise and             & 48 \& 16        \\\hline
            8        & |        & bitwise or              & 370q | 7        \\\hline
            9        & \&\&     & logical and             & 48 \&\& 16      \\\hline
            9        & ||       & logical or              & 370q || 7       \\\hline
            9        & \^{}     & exclusive or            & 00fh \^{} 005h  \\\hline
        \end{tabular}

        \caption{Expression operators priority}
    \end{table}

    A priority of 1 is the highest priority a priority of 9 is the lowest priority. When operators with different priority levels appear in an expression, operations are performed according to priorities. When operators of the same priority appear in an expression, operations are performed from left to right within the expression.

\section{Predefined Symbols}
    There are symbols which are defined by default by assembler. The aim is to make it a little easier to write code in assembly language for Picoblaze, because user do not have to define all these symbols in his or her code.

    \begin{table}[h!]
        \centering{}
        \mysmallfont{}

        \begin{tabular}{|cc|}
            \hline
            Symbol & Value \\\hline
            s0     & 000h  \\\hline
            s1     & 001h  \\\hline
            s2     & 002h  \\\hline
            s3     & 003h  \\\hline
            s4     & 004h  \\\hline
            s5     & 005h  \\\hline
            s6     & 006h  \\\hline
            s7     & 007h  \\\hline
            s8     & 008h  \\\hline
            s9     & 009h  \\\hline
            sA     & 00Ah  \\\hline
            sB     & 00Bh  \\\hline
            sC     & 00Ch  \\\hline
            sD     & 00Dh  \\\hline
            sE     & 00Eh  \\\hline
            sF     & 00Fh  \\\hline
        \end{tabular}

        \caption{Code addresses}
    \end{table}

\section{Assembler directives}
    Assembly directives are instructions that are executed by an assembler at assembly time, not by a CPU at run time. They can make the assembly of the program dependent on parameters input by a programmer, so that one program can be assembled different way, perhaps for different applications. They also can be used to manipulate presentation of a program to make it easier to read and maintain.

    The specified format for most of the directives is:
    {
        ~\\
        \usecodefont
        \verb'<symbol> <directive> <expresion>'
    }

    \bigskip

    This syntax is valid for directives EQU, SET, REG, DATA, CODE, PORT, and DEFINE. MDS also supports some other directives, with diferent syntax format, which is:
    {
        ~\\
        \usecodefont
        \verb'<directive> <symbol>, <expresion>'
    }

    \bigskip

    Those directives are CONSTANT, VARIABLE, ADRESS, and NAMEREG. There are some other usefull directives like REPT or WHILE. See description below.

    \clearpage
    \subsection{INCLUDE}
        \subsubsection{Syntax}
            \verb'INCLUDE "file_name.asm"'

        \subsubsection{Description}
            Compiler basicaly copies content of included file to line, where the directive is used. Include files can include other files.

        \subsubsection{Examples}
        {
            ~\\
            \usecodefont
            \verb'INCLUDE "some_file.asm"'\\
            \verb'INCLUDE "sub_dir/another_file.asm"'\\
            \verb'INCLUDE "C:/my_dir/my_file.asm"'\\
            \verb'INCLUDE "C:\\my_dir\\my_file.asm"'\\
            \verb'INCLUDE "/home/AlanTuring/my_project/cool_file.asm"'\\
        }

    \subsection{EQU}
        \subsubsection{Syntax}
            \verb'<symbol>      EQU             <expresion> '
            
        \subsubsection{Description:}
                The directive EQU stands for "equals". It allows you to give a numerical value to a symbol. This symbol cannot be redefined.
                
        \subsubsection{Examples:}
       {
            ~\\
            \usecodefont
            \verb'First_symb    EQU     0b10011100              ;Number in binary'\\
            \verb'Second_symb   EQU     47                      ;Number in decimal'\\
            \verb'Third_symb    EQU     0x39                    ;Number in hexadecimal'\\
            \verb'Fourth_symb   EQU     (A -4)+ 18 / B)         ;Number with expresion'\\
            \verb'Fifth_symb    EQU     0x09 << 2               ;'\\
        }

    \subsection{CONSTANT}
        \subsubsection{Syntax}
            \verb'CONSTANT             <symbol>,<expresion> '

        \subsubsection{Description:}
                The directive CONSTANT. It allows you to give a numerical value to a symbol. This symbol cannot be redefined.

        \subsubsection{Examples:}
      {
            ~\\
            \usecodefont
            \verb'CONSTANT     First_symb,0b10011100               ;Number in binary'\\
            \verb'CONSTANT     Second_symb,47                      ;Number in decimal'\\
            \verb'CONSTANT     Third_symb,0x39                     ;Number in hexadecimal'\\
            \verb'CONSTANT     Fourth_symb,(A -4)+ 18 / B)         ;Number with expresion'\\
            \verb'CONSTANT     Fifth_symb,0x09 << 2                ;'\\
        }

    \subsection{SET}
        \subsubsection{Syntax}
            \verb'<symbol>      SET             <expresion>'

        \subsubsection{Description:}
            The directive SET allows you to give a numerical value to a symbol like EQU, but with this symbol can be redefined.

        \subsubsection{Examples:
        {
            ~\\
            \usecodefont
            \verb'First_symb    SET     0b10011100              ;Number in binary'\\
            \verb'Second_symb   SET     47                      ;Number in decimal'\\
            \verb'Third_symb    SET     0x39                    ;Number in hexadecimal'\\
            \verb'Fourth_symb   SET     (A -4)+ 18 / B)         ;Number with expresion'\\
            \verb'Fifth_symb    SET     0x09 << 2               ;'\\
        }
        
    \subsection{VARIABLE}
        \subsubsection{Syntax:}
            \verb'VARIABLE            <symbol>,<expresion>'

        \subsubsection{Description:}
            Directive VARIABLE is similar to SET, but with diferent syntax. Symbols defined with VARIABLE can be redefined with another value in your source
            code, but those defined with EQU cannot.

        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont
            \verb'VARIABLE     First_symb,0b10011100               ;Number in binary'\\
            \verb'VARIABLE     Second_symb,47                      ;Number in decimal'\\
            \verb'VARIABLE     Third_symb,0x39                     ;Number in hexadecimal'\\
            \verb'VARIABLE     Fourth_symb,(A -4)+ 18 / B)         ;Number with expresion'\\
            \verb'VARIABLE     Fifth_symb,0x09 << 2                ;'\\
        }
            
    \subsection{REG}
        \subsubsection{Syntax:}
            \verb'<symbol>      REG             <reg name/address>'
            
        \subsubsection{Description:}
        Symbols defined with the REG directive are by compiler considered as work registers.

        \subsubsection{Examples:}
            {
            ~\\
            \usecodefont
            \verb'First_symb        REG     s1'\\
            \verb'Second_symb       REG     s2'\\
            \verb'Third_symb        REG     s3'\\
            \verb'Fourth_symb       REG     s4'\\
            \verb'Fifth_symb        REG     s5'\\
            }
            
        \subsection{NAMEREG}
            \verb'NAMEREG            <symbol>,<reg name or address> '
            
        \subsubsection{Description:}
        Directive NAMEREG is similar to REG, but with diferent syntax. Symbols defined with NAMEREG can be redefined with another value in your source
        code.

        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont
            \verb'NAMEREG     s1'\\
            \verb'NAMEREG     s2'\\
            \verb'NAMEREG     s3'\\
            \verb'NAMEREG     4         ; Address'\\
            \verb'NAMEREG     0xA       ; Address'\\
        }


    \subsection{DATA}
        \subsubsection{Syntax:}
            \verb'<symbol>      DATA             <expresion>'
            
        \subsubsection{Description:}
            Symbols defined with the DATA directive are by compiler considered as memory data . It must be used only with instructions FETCH and STORE.

        \subsubsection{Examples:}
            {
                ~\\
                \usecodefont
                \verb'First_symb    DATA                0b10011100              ;Number in binary'\\
                \verb'Second_symb   DATA                47                      ;Number in decimal'\\
                \verb'Third_symb    DATA                0x39                    ;Number in hexadecimal'\\
                \verb'Fourth_symb   DATA                (A -4)+ 18 / B)         ;Number with expresion'\\
                \verb'Fifth_symb    DATA                0x09 << 2               ;'\\
            }
            
    \subsection{CODE}
        \subsubsection{Syntax:}
            \verb'<symbol>      CODE             <expresion>'
        \subsubsection{Description:}
        Symbols defined with the CODE directive are by compiler considered as program memory.

        \subsubsection{Examples:}
            {
                ~\\
                \usecodefont
                \verb'First_symb    CODE                0b10011100              ;Number in binary'\\
                \verb'Second_symb   CODE                47                      ;Number in decimal'\\
                \verb'Third_symb    CODE                0x39                    ;Number in hexadecimal'\\
                \verb'Fourth_symb   CODE                (A -4)+ 18 / B)         ;Number with expresion'\\
                \verb'Fifth_symb    CODE                0x09 << 2               ;'\\
            }
            
    \subsection{PORT}
        \subsubsection{Syntax:}
            \verb'<symbol>      PORT             <expresion>'

        \subsubsection{Description:}
        Symbol defined with this directive is considered to be PORT\_ID identificator.

        \subsubsection{Examples:}
            {
                ~\\
                \usecodefont
                \verb'First_symb    PORT                0x10    '\\
                \verb'Second_symb   PORT                10      '\\
                \verb'Third_symb    PORT                0x2     '\\
                \verb'Fourth_symb   PORT                0x5     '\\
                \verb'Fifth_symb    PORT                0x09 + 2'\\
            }
    \subsection{AUTOREG}
        \subsubsection{Syntax:}
            \verb'<symbol>      AUTOREG         [<cnt address>]'
            
        \subsubsection{Description:}
        This directive saves time. You can use it, when you dont care which work register will be used. It will automatically assign a register
        at adress 0x00, which is incremented with every other AUTOREG directive. Optionaly, you can change starting address counter by adding a parameter
        after AUTOREG directive. You can check assigned registers in codelisting (file .lst) and symbol table (file .sym).

        \subsubsection{Examples:}
            {
                ~\\
                \usecodefont
                \verb'First_symb    AUTOREG             ; Automaticaly assigned, register at adress 0x00'\\
                \verb'Second_symb   AUTOREG'\\
                \verb'Third_symb    AUTOREG'\\
                \verb'Fourth_symb   AUTOREG     0x5     ; Now with optional parameter changing counting adress to 0x05'\\
                \verb'Fifth_symb    AUTOREG             ; Fifth_symb is on address 0x06'\\
            }
            
    \subsection{AUTOSPR}
        \subsubsection{Syntax:}
            \verb'<symbol>      AUTOREG         [<cnt address>]'
           
    \subsubsection{Description:}
    Must be used only with instructions FETCH and STORE. It will automatically assign an
    adress 0x00, which is incremented with every other AUTOSPR directive. Optionaly, you can change starting address counter by adding a parameter
    after AUTOSPR directive. You can check assigned memory in codelisting file(.lst) and symbol table file(.sym).

    \subsubsection{Examples:}
        {
            ~\\
            \usecodefont
            \verb'First_symb    AUTOSPR             ; Automaticaly assigned, data at adress 0x00'\\
            \verb'Second_symb   AUTOSPR'\\
            \verb'Third_symb    AUTOSPR'\\
            \verb'Fourth_symb   AUTOSPR     0x5     ; Now with optional parameter changing counting adress to 0x05'\\
            \verb'Fifth_symb    AUTOSPR             ; Fifth_symb is on address 0x06'\\
        }
            
    \subsection{INITSPR}
        \subsubsection{Syntax:}

        \subsubsection{Description:}
 
        \subsubsection{Examples:}


    \subsection{ORGSPR, MERGESPR}
        \subsubsection{Syntax:}

        \subsubsection{Description:}

    \subsection{DEFINE}
        \subsubsection{Syntax:}
            \verb'<symbol>      DEFINE             <expresion>'

        \subsubsection{Description:}
        You can define expresion using previously defined symbols. Value of this expresion is calculated every time the symbol is used. You can use symbols in define expresions

        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont
            \verb'A             EQU         10'\\
            \verb'B             SET         5                   ; Second symbol is redefinable'\\
            \verb'C             DEFINE      ( A + B ) * 2       ; Defined expresion'\\
            \verb'F = C                                         ; F equals 30'
            \verb'B             SET         10'\\
            \verb'F = C                                         ; F equals 40'
        }

    \subsection{ADDRESS,ORG}
        \subsubsection{Syntax:}
            \verb'ADDRESS             <expresion>'
            \verb'ORG                 <expresion>'

        \subsubsection{Description:}
        When the ORG or ADDRESS statement is encountered, the assembler calculates the value of the expression and changes the address counter. The MDS assembler maintains a location counter for each segment. The location counter contains the offset of the instruction or data being assembled and is incremented after each line by the number of bytes of data or code in that line.

        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont
            \verb'ORG           0x3ff'\\
            \verb'ORG           START'\\
            \verb'ORG           INTERRUPT'\\
            \verb'ORG           (\$ + 15) \& 0xFFEE'\\

            \verb'ADDRESS       0x3ff'\\
            \verb'ADDRESS       START'\\
            \verb'ADDRESS       INTERRUPT'\\
            \verb'ADDRESS       (\$ + 15)'\\
        }
    \subsection{REPT}
        \subsubsection{Syntax:}
            \verb'REPT  <NumberOfRepetions>'\\
            \verb'<repeated code>'\\
            \verb'ENDR'

        \subsubsection{Description:}
            Directive REPT is able to repeatedly execute a block of code.

        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont
                \verb'; With REPT'\\
                \verb'REPT              8'\\
                \verb'SR0               sF'\\
                \verb'ENDR'\\
                \verb'; Without REPT'\\
                \verb'SR0           sF'\\
                \verb'SR0           sF'\\
                \verb'SR0           sF'\\
                \verb'SR0           sF'\\
                \verb'SR0           sF'\\
                \verb'SR0           sF'\\
                \verb'SR0           sF'\\
                \verb'SR0           sF'\\
        }        
    \subsection{\#WHILE}
        \subsubsection{Syntax:}
            \verb'#WHILE  <symbol>'\\
            \verb'<code>'\\
            \verb'#ENDW'
            
        \subsubsection{Description:}
        The while construct consists of a block of code and an expresion. Following code is recompiled until expresion equals to zero.

        \subsubsection{Examples:}
            {
                ~\\
                \usecodefont
                \verb'B             SET             8'\\
                \verb'#WHILE        B                       ; while B != 0'\\
                \verb'SR0           sF'\\
                \verb'B             SET             B - 1'\\
                \verb'#ENDW'
    }
    \subsection{SKIP}

        \subsubsection{Syntax:}
            \verb'SKIP  <NumberOfInstructions>'
            
        \subsubsection{Description:}
        SKIP directive is basicaly address counter + number evaluated in expression. See example for more info.
        
        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont
            \verb'SKIP          3        ; this will skip first three SR0, performing only one SR0'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
        }

    \subsection{UNDEFINE, UNDEF}

        \subsubsection{Syntax:}
        \verb'UNDEFINE          <symbol>'\\
        \verb'UNDEF             <symbol>'
        \subsubsection{Description:}
        All symbols can be UNDEFINED. Those symbols will be deleted from symbol table (file .sym) and compiler will not recognize them.

        \subsubsection{Examples:}\\
        {
            ~\\
            \usecodefont
            \verb'My_symbol             SET             15'\\
            \verb'LOAD                  s0, #My_symbol'\\
            \verb'UNDEFINE              My_symbol               ; My_symbol undeclared, cannot be use'\\
            \verb'LOAD                  s0, #My_symbol          ; this will cause an error'\\
        }

    \subsection{DB}
        \subsubsection{Syntax:}
            \verb '; Expresion syntax'\\
            \verb'DB                 <expresion1>  [,<expresion2>,..]'\\
            \verb' ; String syntax'\\
            \verb'DB                <"string">'\\
            \verb'; Combination of string and expresions'\\
            \verb'DB                <"string"> [,<expresion1>,..]'\\
            \verb' ; parameter can be unlimited number of string characters, or expresions divided by comma'\\

        \subsubsection{Description:}\\
            The DB directive initializes code memory with 18-bit values. The assembler accepts size up to 24-bit, but trimes 6 MSB bits making it 18-bit value,
            so it can fit into program memory. You can insert infinite number of string characters and MDS assembler seperates them into triplets of bytes replaced
            with their ASCII value. The assembler then trimes upper 6 bits making it 18-bit value.
            See the examples for better understanding of DB directive.

        \subsubsection{Examples:}\\
        {
            ~\\
            \usecodefont
            \verb'DB      24828                   ; hexadecimal 0x0060FC'\\
            \verb'DB      "my string"             ; String syntax'\\
            \verb'DB      "my string",2+1,3...    ; Combination of string and expresions'\\
            \verb' ; parameter can be unlimited number of string characters, or expresions divided by comma'\\
        }
    \subsection{LIMIT}
    
        \subsubsection{Syntax:}
        \verb'LIMIT          D,<number>                  ; Number of registers '\\
        \verb'LIMIT          R,<number>                  ; Size of scratchpad ram '\\
        \verb'LIMIT          C,<number>                  ; Size of program memory '\\
        
        \subsubsection{Description:}
        Usefull when you want to change max. number of registers or size of  data and program memory. It is information for compiler.\\
        In this example, when you want to use 17 registers or JUMP to address bigger than 512, compiler gives you an error.

        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont            
            \verb'LIMIT          R,16                   ; Number of registers 16'\\
            \verb'LIMIT          D,7                    ; Size of scratchpad ram   '\\
            \verb'LIMIT          C,0b100000000          ; Size of program memory '\\
        }
        
    \subsection{DEVICE}
        \subsubsection{Syntax:}
        \verb'DEVICE            <device name>'

        \subsubsection{Description:}
        Normaly, you choose the target architecture, when you are creating a project. But you can also specific architecture with directive DEVICE.
        This will affect predefined symbols.

        \subsubsection{Examples:}
        {
            ~\\
            \usecodefont       
            \verb'DEVICE                KCPSM3'\\
            \verb'DEVICE                KCPSM2'\\
            \verb'DEVICE                KCPSM1'\\
            \verb'DEVICE                KCPSM1cpld'\\
            \verb'DEVICE                KCPSM6'\\
        }

        \subsection{LIST, NOLIST}
        \subsubsection{Syntax:}\\
        \\ {
            \texttt{}
            \begin{tabular}[h!]{llll}
                    { \color{highlight_directive} LIST }
                    { \color{highlight_comment} ; Printing to code listing turned on (turned on by default)  }\\
            \end{tabular}
            }\\

        {
            \texttt{}
            \begin{tabular}[h!]{llll}
                    { \color{highlight_directive} NOLIST }
                    { \color{highlight_comment} ; Printing to code listing turned off  }\\
            \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        You can turn on/off printing to code listing in some parts of your code.\\

        \subsection{TITLE}
        \subsubsection{Syntax:}\\
            {
            \texttt{}
            \begin{tabular}[h!]{llll}
                { \color{highlight_directive} TITLE }\verb`       `{ \color{highlight_string} <"title text"> }
            \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        This will put a title into coresponding line in codelisting.  \\
        \subsubsection{Examples:}\\
                \begin{code}[h!]
                    directive}\verb'TITLE'}\verb'    '
                    constant}\verb'"Text, that will show up in the codelisting"'}
                \end{code}

        \subsection{MESSAGE}
            {
            \texttt{}
            \begin{tabular}[h!]{llll}
                { \color{highlight_directive} MESSAGE }\verb`       `{ \color{highlight_string} <"message text"> }
            \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        You can define message, that will show up after compilation.  \\
        \subsubsection{Examples:}\\
                \begin{code}[h!]
                    directive}\verb'MESSAGE'}\verb'    '
                    constant}\verb'"Text, that will show up in the codelisting"'}
                \end{code}

        \subsection{ERROR}
        \subsubsection{Syntax:}\\
        \\ {
            \texttt{}
            \begin{tabular}[h!]{llll}
                { \color{highlight_directive} ERROR }\verb`       `{ \color{highlight_string} <"error text"> }
            \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        You can define an error report, which aborts compilation, when is executed.  \\
        \subsubsection{Examples:}\\
                \begin{code}[h!]
                    directive}\verb'ERROR'}\verb'    '
                    constant}\verb'"Text, that will show up in the codelisting"'}
                \end{code}

        \subsection{LOCAL}
        \subsubsection{Syntax:}\\
        \\ {
            \texttt{}
            \begin{tabular}[h!]{llll}
                    { \color{highlight_directive} LOCAL } { \color{highlight_symbol} <name> }
                    { \color{highlight_comment}  }\\
            \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        This directive is used to define local variables in macros, so when you expand macro multiple times, there will be no redefinition of labels
        or symbols.
        \subsubsection{Examples:}\\
                \begin{code}[h!]
                    directive}\verb'MACRO'}\verb'     '\verb'name_of_macro'\\
                    directive}\verb'LOCAL'}\verb`    `symbol}\verb'wait'}\\
                    directive}\verb'wait:'}\\
                    symbol}\verb'SUBCY        s0,#10h'}\\
                    symbol}\verb'SUB          s0,#1h' }\\
                    symbol}\verb'LOAD         s0,#F0h'}\\
                    symbol}\verb'JUMP         C,wait'}\\
                    directive}\verb'ENDM'}\\
                \end{code}

        \subsection{WARNING}
            {
            \texttt{}
            \begin{tabular}[h!]{llll}
                { \color{highlight_directive} WARNING }\verb`       `{ \color{highlight_string} <"warning text"> }
            \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        This will put title into coresponding line in codelisting.  \\
        \subsubsection{Examples:}\\
                \begin{code}[h!]
                    directive}\verb'WARNING'}\verb'    '
                    constant}\verb'"Text, that will show up in the codelisting"'}
                \end{code}

        \subsection{END}
        \subsubsection{Syntax:}\\
        \\ {
                \texttt{}
                \begin{tabular}[h!]{llll}
                        { \color{highlight_directive} END } &
                        { \color{highlight_comment} ; Just END, no parameters }\\
                \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        The END directive informs the assembler, that it has reached the end of a source file. Compiler ignores following code, so it doesnt have to be
        syntactically right.

        \subsubsection{Examples:}\\
            \begin{code}[h!]
                \verb'    'directive}\verb'END'}
                \caption{END directive}
            \end{code}

        \subsection{FAILJMP,DEFAULT\_JUMP}
        \subsubsection{Syntax:}\\
        \\ {
                \texttt{}
                \begin{tabular}[h!]{llll}
                        { \color{highlight_directive} FAILJMP }\verb`       `{ \color{highlight_string} <"label"> }\\
                        { \color{highlight_directive} DEFAULT\_JUMP }\verb`       `{ \color{highlight_string} <"label"> }\\
                \end{tabular}
            }\\
            \\
        \subsubsection{Description:}\\
        Fills program memory with jump to the specified address. Simple protection against errors.

        \subsubsection{Examples:}\\
            \begin{code}[h!]
                \verb'    'directive}\verb'FAILJMP'}\verb`       `{ \color{highlight_string} start }
                \verb'    'directive}\verb'DEFAULT\_JUMP'}\verb`       `{ \color{highlight_string} 0x000> }
                \caption{END directive}
            \end{code}

        \section{Pseudo Instructions}
        MDS assembler supports some usefull pseudo instructions, which can improve understandabillity of your source code.
        Compiler will replace those instructions with one or more PicoBlaze instructions, to achieve desired purpose of that instruction.

                \subsection{INC}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} INC    } { \color{highlight_symbol} <register> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_instruction} ADD    } { \color{highlight_symbol}      sX,\#1 }
                    \\
                \textbf{Description:}\\
                This instruction increments given register value by one.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'INC          s0' }\\
                        \end{code}
                \subsection{DEC}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} DEC    } { \color{highlight_symbol} <register> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_instruction} SUB    } { \color{highlight_symbol}      sX,\#1 }
                    \\
                \textbf{Description:}\\
                This instruction decrements given register value by one.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'DEC          s0' }\\
                        \end{code}


                \subsection{SETR}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} SET    } { \color{highlight_symbol} <register> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_instruction} OR    } { \color{highlight_symbol}      sX,\#0xFF }
                    \\
                \textbf{Description:}\\
                This instruction sets given register.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'SET          s0' }\\
                        \end{code}
                \subsection{CLRR}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} CLR    } { \color{highlight_symbol} <register> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_instruction} AND    } { \color{highlight_symbol}      sX,\#0x00 }
                    \\
                \textbf{Description:}\\
                This instruction clears given register.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'CLR          s0' }\\
                        \end{code}
                \subsection{CPL}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} CPL    } { \color{highlight_symbol} <register> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_instruction} XOR    } { \color{highlight_symbol}      sX,\#0xFF }
                    \\
                \textbf{Description:}\\
                This instruction execute 1\'s complement with given register.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'CPL          s0' }\\
                        \end{code}
                \subsection{CPL2}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} CPL2    } { \color{highlight_symbol} <register> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_instruction} XOR    } { \color{highlight_symbol}      sX,\#0xFF }\\
                    { \color{highlight_instruction} ADD    } { \color{highlight_symbol}      sX,\#0x1 }\\
                \textbf{Description:}\\
                This execute 2\'s complement with given register.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'CPL2          s0' }\\
                        \end{code}

                \subsection{SETB}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} SETB    } { \color{highlight_symbol} <register>,<bit> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    Example for bit number 3 >\\
                    { \color{highlight_instruction} OR    } { \color{highlight_symbol}      sX,\#1<<3 }
                \textbf{Description:}\\
                Sets bit in given register.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'SETB          s0,#3' }\\
                        \end{code}

                \subsection{CLRB}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} CLRB    } { \color{highlight_symbol} <register>,<bit> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    Example for bit number 3 >\\
                    { \color{highlight_instruction} AND    } { \color{highlight_symbol}    sX,\#(0xFF \^ (1 << 3)) }
                \textbf{Description:}\\
                Clears bit in given register.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'CLRB          s0,#3' }\\
                        \end{code}

                \subsection{NOTB}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} NOTB    } { \color{highlight_symbol} <register>,<bit> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    Example for bit number 3 >\\
                    { \color{highlight_instruction} XOR    } { \color{highlight_symbol}      sX,\#~0b00000100 }
                \textbf{Description:}\\
                Negates bit in given register.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                            symbol}\verb'NOTB          s0,#3' }\\
                        \end{code}

                \subsection{DJNZ}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} DJNZ    } { \color{highlight_symbol} <register>,<label> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_label} loop:    } { \color{highlight_symbol}       }\\
                    { \color{highlight_instruction} SUB    } { \color{highlight_symbol}      sX,\#1 }\\
                    { \color{highlight_instruction} JUMP    } { \color{highlight_symbol}     NZ,\#loop }\\
                \textbf{Description:}\\
                Given register is decremented until it is zero.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                        symbol}\verb'loop:          ' }\\
                        symbol}\verb'DJNZ          s0,loop' }\\
                        \end{code}

                \subsection{IJNZ}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                    \begin{tabular}[h!]{llll}
                            { \color{highlight_instruction} IJNZ   } { \color{highlight_symbol} <register>,<bit> }
                            { \color{highlight_comment}  }\\
                    \end{tabular}
                    }\\
                    \textbf{EQUAL TO:}\\
                    { \color{highlight_label} loop:    } { \color{highlight_symbol}       }\\
                    { \color{highlight_instruction} ADD    } { \color{highlight_symbol}      sX,\#1 }\\
                    { \color{highlight_instruction} JUMP    } { \color{highlight_symbol}     NZ,\#loop }\\
                \textbf{Description:}\\
                Given register is incremented until overflow.\\
                \textbf{Examples:}\\
                        \begin{code}[h!]
                        symbol}\verb'loop:          ' }\\
                        symbol}\verb'IJNZ          s0,loop' }\\
                        \end{code}
        \section{Run time directives}
        MDS assembler contains some special directives, which are evaluated during run time sequence. You can use them to evaluate simple conditions in your program.
        Those directives are IF, ELSEIF, WHILE, FOR.\\ Not all conditions allowed by assembler can be used.
        Table of allowed instructions is displayed below.
            \begin{table}[h!]
                    \mysmallfont{}
                    \centering{}
                    \begin{tabular}{|l|l}
                    \hline
                    Condition operator       &          Example  \\
                    ==                       &          A ==  B  \\
                    !=                       &          A !=  B  \\
                    >                        &          A >   B  \\
                    <                        &          A <   B  \\
                    >=                       &          A >=  B  \\
                    <=                       &          A <=  B  \\
                    \&                       &          A \&  B  \\
                    !\&                      &          A !\& B
                    \end{tabular}
                    \caption{Allowed conditions with IF, WHILE}
            \end{table}

                \subsection{IF}
                    \textbf{Syntax:}\\
                    \\ {
                        \texttt{}
                            \begin{tabular}[h!]{llll}
                                { \color{highlight_directive} IF } & \verb'     ' &
                                { \color{highlight_constant} <condition> }\\
                                { \color{highlight_symbol} <code> }\\
                                { \color{highlight_directive} ELSEIF } & \verb'     ' &
                                { \color{highlight_constant} <condition> }\\
                                { \color{highlight_symbol} <code> }\\
                                { \color{highlight_directive} ELSE } & \verb'     ' &
                                { \color{highlight_symbol} <code> }\\
                                { \color{highlight_directive} ENDIF }
                            \end{tabular}
                        }\\
                    \textbf{Description:}\\
                    You can use RT\_IF for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and
                    evaluates result. You can use registers, immediate constants (symbols) or register adress. Immediate constants are specified as number with \# prefix.
                    Number without \# is considered as register adress. See example for conditions syntax.
                    \textbf{Examples:}\\
                            \begin{code}[h!]
                                    { \color{highlight_directive} IF }
                                    { \color{highlight_constant}   s0 == \#10 }\\
                                    { \color{highlight_instruction}   LOAD  s0, \#10h }\\
                                    { \color{highlight_comment}  ELSEIF} { \color{highlight_constant}   B >= \#100 }\\
                                    { \color{highlight_instruction}   SR0   s0 }\\
                                    { \color{highlight_comment}  ELSE} { \color{highlight_constant}   A >= 5 }\\
                                    { \color{highlight_instruction}   INPUT   s0,RX\_data }\\
                                \caption{Run time if example}
                        \end{code}
                In this example, first condition is comparing register with constant 10. Second condition compares symbol with constant and third condition compares
                symbol with register adress. So 5 would have been replaced with value storen in register with adress 5.
                \subsection{WHILE}
                    \textbf{Syntax:}\\
                    \\ {
                        \texttt{}
                            \begin{tabular}[h!]{llll}
                                { \color{highlight_directive} WHILE } & \verb'     ' &
                                { \color{highlight_constant} <condition> }\\
                                { \color{highlight_symbol} <code> }\\
                                { \color{highlight_directive} ENDW }
                            \end{tabular}
                        }\\
                    \textbf{Description:}\\
                    You can use WHILE for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and
                    evaluates result. You can use registers, immediate constants (symbols) or register adress. Immediate constants are specified as number with \# prefix.
                    Number without \# is considered as register adrress. See example for conditions syntax.
                    \textbf{Examples:}\\
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0 == \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0  != \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0 >    \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0 < \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0 <= \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0 >= \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0 \& \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}
                            \begin{code}[h!]
                                    { \color{highlight_directive} WHILE  }
                                    { \color{highlight_constant}   s0 !\& \#10 }\\
                                    { \color{highlight_instruction} ADDCY    S1,\#1 }\\
                                    { \color{highlight_directive}  ENDW}\\
                                \caption{Run time while example}
                            \end{code}

                \subsection{FOR}
                    \textbf{Syntax:}\\
                    \\ {
                        \texttt{}
                            \begin{tabular}[h!]{llll}
                                { \color{highlight_directive} FOR } & \verb'     ' &
                                { \color{highlight_constant} <condition> }\\
                                { \color{highlight_symbol} <code> }\\
                                { \color{highlight_directive} ENDF }
                            \end{tabular}
                        }\\
                    \textbf{Description:}\\
                    You can use FOR for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and
                    evaluates result. There are three types of FOR conditions. In first, you have to write the name of used register and number of repetions. In this case,
                    counting starts at number 0 and incrementing to number of repetions. In second type, you write used register and range of
                    repetions ( for examle 5..10). In third type, you can even define size of one step, so incremented number can be for some reason bigger.
                    See examples for better understanding. WARNING: Using FOR directive will overide used register( s0 in example)
                    \textbf{Examples:}\\
                            \begin{code}[h!]
                                    { \color{highlight_directive} FOR  }
                                    { \color{highlight_constant}   s0,10 }\\
                                    { \color{highlight_directive}  ENDF}\\
                                \caption{Run time while example}
                            \end{code}
                    In this case, incrementing is from 0 to 10. Incrementing step is 1.
                            \begin{code}[h!]
                                    { \color{highlight_directive} FOR  }
                                    { \color{highlight_constant}   s0,10..20 }\\
                                    { \color{highlight_directive}  ENDF}\\
                                \caption{Run time while example}
                            \end{code}
                    In this case, incrementing is in the range 10 to 20. Incrementing step is 1.
                            \begin{code}[h!]
                                    { \color{highlight_directive} FOR  }
                                    { \color{highlight_constant}   s0,10..50,10 }\\
                                    { \color{highlight_directive}  ENDF}\\
                                \caption{Run time while example}
                            \end{code}
                    In this case, incrementing is from 10 to 50. Last number defines incrementing step. (In this case 10).

        \section{Macro Processing}
                Macro is a sequence of instructions which can be expanded anywhere in the code and for any number of times. That may reduce necessity of
                repeating code fragments as well as source code size and make the solved task easier to comprehend and solve. Unlike subprograms macros do
                not add extra run-time overhead and repeating usage of macros may significantly increase size of the resulting machine code. Macros supported
                by this assembler are.

                \subsection{MACROS}
                \textbf{Syntax:}\\
                \\ {
                    \texttt{}
                        \begin{tabular}[h!]{llll}
                            { \color{highlight_directive} MACRO } & \verb'     ' &
                            { \color{highlight_constant} [<parameter1>]  [,<parameter2>..] }\\
                            { \color{highlight_symbol} <macro source code> }\\
                            { \color{highlight_directive} ENDM } &  \verb'     ' { \color{highlight_comment} ; end of macro declaration  }
                        \end{tabular}
                    }\\
                \\ {
                    \texttt{}
                        \begin{tabular}[h!]{llll}
                            { \color{highlight_directive} EXPAND } &  \verb'     ' { \color{highlight_comment} ; Expanding of macros allowed  }\\
                            { \color{highlight_directive} NOEXPAND } &  \verb'     ' { \color{highlight_comment} ; Expanding of macros forbidden  }
                        \end{tabular}
                    }\\
                \begin{table}[h!]
                    \begin{tabular}{|ll|}
                            \hline
                            MACRO      & Define a new macro \\
                            EXITM      & Exit macro  \\
                            ENDM       & End of macro definition \\
                            EXPAND     & After usage of this directive, expanding of macros is allowed.(turned on by default)\\
                            NOEXPAND   & After usage of this directive, no expanding of macros is allowed.\\
                            \hline
                    \end{tabular}
                    \caption{Macro comands}
                \end{table}
                \textbf{Description:}\\
                Standard macro, consiting of name, code and optional exit command. Macro can be expanded only after his declaration. You can use macro
                with no parameters  or unlimited number of parameters.\\
                \textbf{Examples:}\\
                This can be well demonstrated on examples:

                \begin{code}[h!]
                        macro}\verb'abc'}\verb'     'directive}\verb'macro'}\verb'   \verb'; Define named macro ``abc'\verb"'"\verb''\verb"'"\verb''}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'sfr}\verb's0'}\\
                        \verb'        'instruction}\verb'SR0'}\verb'      'sfr}\verb'a'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb's1'}oper_sep}\verb','}\verb' 'sfr}\verb'a'}\\
                        directive}\verb'endm'}\\
                        \verb''\\
                        macro}\verb'abc'}\verb'     \verb'; Expand macro ``abc'\verb"'"\verb''\verb"'"\verb' here'}\\
                        macro}\verb'abc'}\verb'     \verb'; Expand macro ``abc'\verb"'"\verb''\verb"'"\verb' here'}\\
                        \verb''\\
                        comment}\verb'; This is the same as if you wrote this:'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'sfr}\verb's0'}\\
                        \verb'        'instruction}\verb'SR0'}\verb'      'sfr}\verb'a'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb's1'}oper_sep}\verb','}\verb' 'sfr}\verb'a'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'sfr}\verb's0'}\\
                        \verb'        'instruction}\verb'SR0'}\verb'      'sfr}\verb'a'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb's1'}oper_sep}\verb','}\verb' 'sfr}\verb'a'}\\
                        \caption{An exaple of simple macro without parameters}
                \end{code}
                \begin{code}[h!]

                        comment}\verb'; Define macro named as ``xyz'\verb"'"\verb''\verb"'"\verb' with 2 mandatory parameters'}\\
                        macro}\verb'xyz'}\verb'     'directive}\verb'macro'}\verb'   'constant}\verb'foo'}oper_sep}\verb','}\verb' 'constant}\verb'bar'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'constant}\verb'foo'}oper_sep}\verb','}\verb' 'imm_hex}\verb'#10h'}\\
                        \verb'        'instruction}\verb'SR0'}\verb'      'constant}\verb'bar'}\\
                        directive}\verb'endm'}\\
                        \verb''\\
                        macro}\verb'xyz'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'sfr}\verb'c'}\verb'            \verb'; Expand macro ``xyz'\verb"'"\verb''\verb"'"\verb' here'}\\
                        macro}\verb'xyz'}\verb'     'sfr}\verb's0'}oper_sep}\verb','}\verb' 'sfr}\verb's1'}\verb'        \verb'; Expand macro ``xyz'\verb"'"\verb''\verb"'"\verb' here'}\\
                        \verb''\\
                        comment}\verb'; This is the same as if you wrote this:'\\
                        }\verb'        \verb'; xyz   a, c'\\
                        }\verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'imm_hex}\verb'#10h'}\\
                        \verb'        'instruction}\verb'SR0'}\verb'      'sfr}\verb'c'}\\
                        \verb'        \verb'; xyz   s0, s0'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb's0'}oper_sep}\verb','}\verb' 'imm_hex}\verb'#10h'}\\
                        \verb'        'instruction}\verb'SR0'}\verb'      'sfr}\verb's1'}\\
                        \caption{An exaple of macro with two parameters}
                \end{code}
                \begin{code}[h!]
                       macro}\verb'ijk'}\verb'     'directive}\verb'macro'}\verb'   'constant}\verb'foo'}\\
                        \verb'        'instruction}\verb'ADD'}\verb'     'sfr}\verb's0'}oper_sep}\verb','}\verb' 'indirect}\verb's1'}\\
                        \verb''\\
                        \verb'        'directive}\verb'if'}\verb' 'constant}\verb'foo'}\verb' 'symbol}\verb'='}\verb' 'dec}\verb'4d'}\\
                        \verb'                'instruction}\verb'SKIP 1'}\\
                        \verb'        'directive}\verb'endif'}\\
                        \verb''\\
                        \verb'        'instruction}\verb'SUB'}\verb'    'sfr}\verb's0'}oper_sep}\verb','}\verb' 'imm_constant}\verb'#foo'}\\
                        directive}\verb'endm'}\\
                        \verb''\\
                        macro}\verb'ijk'}\verb'     'unknown_base}\verb'5'}\\
                        macro}\verb'ijk'}\verb'     'unknown_base}\verb'4'}\\
                        \verb''\\
                        comment}\verb'; This is the same as if you wrote this:'}\\
                        \verb'        \verb'; ijk   5'}\\
                        \verb'        'instruction}\verb'ADD'}\verb'     'sfr}\verb's0'}oper_sep}\verb','}\verb' 'indirect}\verb's1'}\\
                        \verb'        'directive}\verb'if'}\verb' 'unknown_base}\verb'5'}\verb' 'symbol}\verb'='}\verb' 'dec}\verb'4d'}\\
                        \verb'        'instruction}\verb'SKIP 1'}\\
                        \verb'        'directive}\verb'endif'}\\
                        \verb'        'instruction}\verb'SUB'}\verb'    'sfr}\verb's0'}oper_sep}\verb','}\verb' 'imm_unknown}\verb'#5'}\\
                        \verb'        \verb'; ijk   4'}\\
                        \verb'        'instruction}\verb'ADD'}\verb'     'sfr}\verb's0'}oper_sep}\verb','}\verb' 'indirect}\verb's1'}\\
                        \verb'        'directive}\verb'if'}\verb' 'unknown_base}\verb'4'}\verb' 'symbol}\verb'='}\verb' 'dec}\verb'4d'}\\
                        \verb'        'instruction}\verb'SKIP 1'}\\
                        \verb'        'directive}\verb'endif'}\\
                        \verb'        'instruction}\verb'SUB'}\verb'    'sfr}\verb's0'}oper_sep}\verb','}\verb' 'imm_unknown}\verb'#4'}\\
                        \caption{An exaple of named macro used with if statement}
                \end{code}

        \section{Conditional Assembly}
                The aim of conditional assembly to to assemble certain parts of the code if and only if certain arithmetically expressed condition is met.
                This feature can prove useful particularly when the user want to make the code somehow ``configurable''. This assembler provides these instructions
                to work with conditional assembly:
                \begin{itemize}
                        \setlength{\itemsep}{-3pt}
                        \item IF <condition>
                        \item IFN <condition>
                        \item IFDEF <symbol>
                        \item IFNDEF <symbol>
                        \item ELSE
                        \item ELSEIF <condition>
                        \item ELSEIFN <condition>
                        \item ELSEIFDEF <symbol>
                        \item ELSEIFNDEF <symbol>
                        \item ENDIF
                \end{itemize}

                This can be best demonstrated on an example:
                \begin{code}[h!]
                        \mysmallfont{}
                        constant}\verb'abc'}\verb'     'directive}\verb'equ'}\verb'     'unknown_base}\verb'16'}\verb'              \verb'; Assign number 14 to symbol abc'}\\
                        constant}\verb'xyz'}\verb'     'directive}\verb'equ'}\verb'     'unknown_base}\verb'10'}\verb'              \verb'; Assign number 10 to symbol abc'}\\
                        \verb''\\
                        directive}\verb'ifdef'}\verb' 'constant}\verb'abc'}\verb'                       \verb';<--+ Assemble only if symbol abc has been defined'}\\
                        \verb'  'directive}\verb'if'}\verb' 'symbol}\verb'('}\verb' 'constant}\verb'abc'}\verb' 'symbol}\verb'='}\verb' 'unknown_base}\verb'13'}\verb' 'symbol}\verb')'}\verb'               \verb';   | <--+ Assemble if 13 has been assigned to symbol abc'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'imm_bin}\verb'#01010101b'}\verb'   \verb';   |    |'}\\
                        \verb'  'directive}\verb'elseif'}\verb' 'symbol}\verb'('}\verb' 'constant}\verb'abc'}\verb' 'symbol}\verb'='}\verb' 'unknown_base}\verb'14'}\verb' 'symbol}\verb')'}\verb'           \verb';   | <--+ Assemble if 14 has been assigned to symbol abc'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'imm_hex}\verb'#0aah'}\verb'        \verb';   |    |'}\\
                        \verb'  'directive}\verb'elseifn'}\verb' 'symbol}\verb'('}\verb' 'constant}\verb'abc'}\verb' 'symbol}\verb'%'}\verb' 'unknown_base}\verb'2'}\verb' 'symbol}\verb')'}\verb'           \verb';   | <--+ Assemble if the value assigned to symbol abc is even'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'imm_constant}\verb'#abc'}\verb'         \verb';   |    |'}\\
                        \verb'  'directive}\verb'else'}\verb'                          \verb';   | <--+ Else ..'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'imm_\verb'#377q'}\verb'        \verb';   |    |'}\\
                        \verb'  'directive}\verb'endif'}\verb'                         \verb';   | <--+'}\\
                        directive}\verb'elseifndef'}\verb' 'constant}\verb'xyz'}\verb'                  \verb';<--+ Assemble if symbol xyz has NOT been defined'}\\
                        \verb'        'instruction}\verb'clr'}\verb'     'sfr}\verb'A'}\verb'               \verb';   |'}\\
                        directive}\verb'else'}\verb'                            \verb';<--+ Else ...'}\\
                        \verb'  'directive}\verb'ifn'}\verb' 'symbol}\verb'('}constant}\verb'xyz'}symbol}\verb' mod'}\verb' 'unknown_base}\verb'2'}symbol}\verb')'}\verb'               \verb';   | <--+ Assemble if ( yxz modulo 2 ) is 0'}\\
                        \verb'        'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'imm_dec}\verb'#128d'}\verb'        \verb';   |    |'}\\
                        \verb'  'directive}\verb'endif'}\verb'                         \verb';   | <--+'}\\
                        directive}\verb'endif'}\verb'                           \verb';<--+'}\\
                        \verb''\\
                        instruction}\verb'sjmp'}\verb'    'constant}\verb'$'}\verb'                       \verb'; Infinite loop'}\\
                        directive}\verb'end'}\verb'                             \verb'; End of assembly'}\\
                        \caption{An example of conditional assembly usage}
                \end{code}

                \clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \section{ERROR and WARNING messages}
        This chapter lists the error messages generated by MDS. The following sections
        include a brief description of the possible error messages along with a
        description of the error and any corrective actions you can take to avoid or
        eliminate the error. Errors terminate the assembly and generate a message that is displayed on
        the console. Warnings generate a message in the assembly listing file but do not terminate the assembly.
                \subsection{ERROR list}
                    \begin{description}
                    \item[Unable to open file] \hfill \\
                    The given file cannot be opened for some reason.
                    \item[Unable to write to file] \hfill \\
                    It is not possible to write into given file.
                    \item[Unable to save file] \hfill \\
                    The given file cannot be saved. Check if you have enough space on your disk.
                    \item[The resulting machine code is too big to be stored in a file]\hfill \\
                    Size of the resulting machine code is bigger, than free disk space.
                    \item[Some of the source code files were aparently changed during compilation]\hfill \\
                    Do not change source files during the compilation. Wait for compilation to be finished.
                    \item[User defined memory limit for program memory exceeded]\hfill \\
                    You have exceeded maximum program memory defined with directive LIMIT.
                    \item[User defined memory limit for register file exceeded]\hfill \\
                    You have exceeded maximum number of working registers defined with directive LIMIT.
                    \item[User defined memory limit for Scratch Pad RAM exceeded]\hfill \\
                    You have exceeded maximum scratch pad RAM defined with directive LIMIT.
                    \item[Instruction X requires operand \#Y to be of type(s) Z; while the given operand is of type: W] \hfill \\   %lllll
                    Wrong type of operand. See manual for more informations.
                    \item[Macro not defined ] \hfill \\
                    The given macro has not been defined. You must define macro before you can use it. See chapter MACROS for more info.
                    \item[Too many arguments given, expecting at most X arguments] \hfill \\             % lll
                    Too many arguments, compiler tells you how many he is expecting.
                    \item[Attempting to use unavailable space in X memory at address: Y ] \hfill \\  %llll
                    bl
                    \item[The last error was critical, compilation aborted] \hfill \\                   %llll
                    bl
                    \item[Device not supported] \hfill \\
                    The given device is not supported. Please choose different device.
                    \item[Device specification code is already loaded ] \hfill \\                       %llll
                    bl
                    \item[Limit value X is not valid] \hfill \\
                    Invalid limit value. Viz. LIMIT directive chapter for valid values.
                    \item[Directive `LOCAL' cannot appear outside macro definition ] \hfill \\   % chyba, apear
                    Directive LOCAL must be only used inside macro. Use different directive for symbol definition, or put it inside of macro.
                    \item[Directive EXITM' cannot apper outside macro definition] \hfill \\
                    The given directive is used to immediately exit macro. It does not make sense to use it differently.
                    \item[Maximum macro expansion level X reached  ] \hfill \\
                    Maximum macro expansion level reached. You can change your compiler settings and set bigger expansion level.
                    By default, macro expansion level is unlimited.
                    \item[Maximum number of WHILE directive iterations reached ] \hfill \\    %\#kk\#kk
                    Maximum WHILE directive iterations reached. You can change your compiler settings and allow more iterations.
                    By default, number of iterations is unlimited.
                    \item[Maximum number of REPEAT directive iterations reached ] \hfill \\                     % nema byt rept?
                    Maximum REPEAT directive iterations reached. You can change your compiler settings and allow more iterations.
                    By default, number of iterations is unlimited.
                    \item[Instruction word is only 18 bits wide, value X trimmed to Y ] \hfill \\
                    You have exceeded instruction word length. Value has been trimmed to  appropriate length.
                    \item[Symbol already defined] \hfill \\
                    The given symbol has been already defined. Symbol cannot be defined more than one time.
                    \item[Symbol not defined: X ] \hfill \\
                    The given symbol has not been defined. Symbol has to be defined before usage.
                    \item[Symbol X already defined with type Y] \hfill \\
                    The given symbol has been already defined with type Y. Symbol cannot be defined more than one time.
                    \item[Undefined value ] \hfill \\
                    Undefined value. Compiler does not know this value.                       %mmmm
                    \item[Real numbers are not supported in assembler ] \hfill \\
                    Real numbers cannot be used on 8-bit processor.
                    \item[Undefined symbol: X ] \hfill \\
                    Symbol has not been defined. Define symbol before usage.
                    \item[This value is not valid inside an expression ] \hfill \\         %mmmmm
                    The given expresion contains forbidden value.
                    \item[Division by zero ] \hfill \\
                    Division by zero has been detected. It is not possible to divide with zero, therefore compilation is aborted.
                    \item[Unable to resolve this expression ] \hfill \\
                    The given expresion cannot be resolved. Check if expresion is syntactically right.
                    \item[Syntax not understood ] \hfill \\
                    There is syntax error in your source code. Check manual for right syntax.
                    \item[Character constant is too long ] \hfill \\
                    Character constant is too long
                    \item[Unterminated string or character constant ] \hfill \\
                    Unterminated string or character constant
                    \item[Unrecognized escape sequence: ] \hfill \\
                    Unrecognized escape sequence
                    \item[no file name specified ] \hfill \\                                                                            %llll
                    File name has to be specified.
                    \item[Unable to open the specified file: X] \hfill \\
                    The given file cannot be opened for some reason.
                    \item[Unrecognized token:  ] \hfill \\                    % mas to tam dvakrat
                    bl
                    \ldots
                    \end{description}

                 \subsection{WARNING list}
                    \begin{description}
                    \item[Maximum number of messages reached, suppressing compiler message generation] \hfill \\
                    Source code contains big number of errors. Those errors were suppressed to prevent enormous size of code listing file.
                    \item[Redefinition of macro ] \hfill \\
                    The given macro has been already defined.
                    \item[Macro X will not be expanded because macro expansion has been disabled] \hfill \\
                    The given macro cannot be expanded, because macro expansion has been disabled by NOEXPAND directive.
                    You can use EXPAND directive to allow expansion again.
                    \item[Parameter X substituted for blank value ] \hfill \\     %llll
                    Macro expected
                    \item[Symbol X already declared as local ] \hfill \\
                    Symbol is already used as local inside macro.   %llll
                    \item[Reusing already reserved space in X memory at address: Y] \hfill \\  %llll
                    bl
                    \item[Limit value -1 means unlimited] \hfill \\
                    You can define limit values with LIMIT directive. Using -1 as directive argument, means unlimited.
                    \item[Symbol X declared as local but never used, declaration ignored] \hfill \\
                    The given local symbol has been declared, but never used. Declaration will be ignored.
                    \item[Comparing two immediate constants, result is always positive] \hfill \\

                    \item[Comparing two immediate constants, result is always negative] \hfill \\

                    \item[Sign overflow. Result is negative number lower than the lowest negative number representable in two's complement arithmetic by the given number of bits ] \hfill \\

                    \item[Result is negative number X, this will be represented as 2-bit number in two's complement arithmetic] \hfill \\

                    \item[Value out of range, allowed range is [0,2] (trimmed to 3 bits) which makes it 4 ] \hfill \\
                    Value out of range. Adjust input value.                                                     %,,,,
                    \item[Maximum number of messages reached, suppressing compiler message generation ] \hfill \\
                    Compiler is suppressing error messages generation to avoid massive code listing file size.
                    \item[File name contains a null character ] \hfill \\
                    Null character in file name is forbidden. Please change name of the given file.
                    \ldots
                    \end{description}

        \section{List File Format}
                Code listing serves as an additional information about the assembled code and the progress of the assembly process. It contains information about all symbols defined in the code. Where and how were they were defined, what are their values and whether they were used in the code. Also detailed information about all macros defined in the code and/or expanded in the code. Conditional compilation configuration, instruction OP codes, address space reservations, inclusion of code from another files. And all warnings, errors and notes generated during the assembly by the assembler. There are assembler control sequences which alters formatting of the code listing file. These control sequences will be discussed here. Format of code listing generated by this assembler is very similar to the one generated Metalink(R) ASM51.
                \begin{code}[h]

                        \verb'demo0                                                                                                                   'macro}\verb'PAGE'}\verb' 'unknown_base}\verb'1'}\\
                        lst_line}\verb'                         1'}\verb'     \verb'; MDS Picoblaze - Demostration code'}\\
                        lst_line}\verb'                         2'}\verb'     \verb'; Very simple code'}\\
                        lst_line}\verb'                         3'}\\
                        lst_line}\verb'                         4'}\verb'     \verb'; Press F2 and F6 to run the program (start simulator and animate)'}\\
                        lst_line}\verb'                         5'}\\
                        lst_line}\verb'                         6'}\verb'             'directive}\verb'org'}\verb'     'hex}\verb'0h'}\\
                        lst_line}\verb'                         7'}\\
                        lst_address}\verb'0000'}lst_code}\verb' 08'}lst_line}\verb'                  8'}\verb'     'label}\verb'main:'}\verb'   'instruction}\verb'inc'}\verb'     'sfr}\verb'R0'}\\
                        lst_address}\verb'0001'}lst_code}\verb' 06'}lst_line}\verb'                  9'}\verb'             'instruction}\verb'inc'}\verb'     'indirect}\verb'@R0'}\\
                        lst_address}\verb'0002'}lst_code}\verb' B87FFB'}lst_line}\verb'             10'}\verb'             'instruction}\verb'cjne'}\verb'    'sfr}\verb'R0'}oper_sep}\verb','}\verb' 'imm_hex}\verb'#07Fh'}oper_sep}\verb','}\verb' 'constant}\verb'main'}\\
                        lst_address}\verb'0005'}lst_code}\verb' 7800'}lst_line}\verb'               11'}\verb'             'instruction}\verb'LOAD'}\verb'     'sfr}\verb'R0'}oper_sep}\verb','}\verb' 'imm_dec}\verb'#0d'}\\
                        lst_address}\verb'0007'}lst_code}\verb' 80F7'}lst_line}\verb'               12'}\verb'             'instruction}\verb'sjmp'}\verb'    'constant}\verb'main'}\\
                        lst_line}\verb'                        13'}\\
                        lst_line}\verb'                        14'}\verb'             'directive}\verb'end'}\\
                        lst_msg}\verb'ASSEMBLY COMPLETE,'}\verb' NO ERRORS FOUND, NO WARNINGS'\\
                        \caption{A simple code listing}
                \end{code}
                Code listing contains entire source code which was assembled but with each line prefixed with line number and some additional information which will be explained later. Besides the original code there is also table of symbols defined during the assembly unless it was turned off. Code listing is divided into pages separated by form feed character, this behavior may be altered by certain assembler control sequences as well as page height and width.

                Each line of code listing which contains original source code line may contain beside line number also some additional information regarding the compilation of the given line of code. Such a additional information might look like this and is composed of these parts:

                \begin{code}[h]
                        \verb'  '\texttt{\colorbox{Lavender}{0055}}\verb'                   '\texttt{\colorbox{Goldenrod}{18}}\verb'      '\texttt{\colorbox{Gray}{X      data     55h}} \\
                        \texttt{\colorbox{Apricot}{0014}}\verb' '\texttt{\colorbox{GreenYellow}{1122}}\verb'       '\texttt{\colorbox{LimeGreen}{=1}}\verb'     '\texttt{\colorbox{Goldenrod}{33}}\verb'      '\texttt{\colorbox{Gray}{l:     inc      A}} \\
                        \verb'                          '\texttt{\colorbox{Goldenrod}{35}}\verb' '\texttt{\colorbox{ProcessBlue}{+1}}\verb'  '\texttt{\colorbox{Gray}{abc     ; Expand macro ``abc'' here}} \\
                        \texttt{\colorbox{Apricot}{001E}}\verb' '\texttt{\colorbox{GreenYellow}{E580}}\verb'               '\texttt{\colorbox{Goldenrod}{36}}\verb' '\texttt{\colorbox{ProcessBlue}{+1}}\verb'  '\texttt{\colorbox{Gray}{                LOAD     a, p0}} \\
                        \texttt{\colorbox{Apricot}{0020}}\verb' '\texttt{\colorbox{GreenYellow}{F4}}\verb'                 '\texttt{\colorbox{Goldenrod}{37}}\verb' '\texttt{\colorbox{ProcessBlue}{+1}}\verb'  '\texttt{\colorbox{Gray}{                SR0     a}} \\
                        \texttt{\colorbox{Apricot}{0021}}\verb' '\texttt{\colorbox{GreenYellow}{F590}}\verb'               '\texttt{\colorbox{Goldenrod}{38}}\verb' '\texttt{\colorbox{ProcessBlue}{+1}}\verb'  '\texttt{\colorbox{Gray}{                LOAD     p1, a}} \\\\
                        \colorbox{Goldenrod}{\color{Goldenrod}X} Line number \\
                        \colorbox{LimeGreen}{\color{LimeGreen}X} Level of file inclusion \\
                        \colorbox{ProcessBlue}{\color{ProcessBlue}X} Level of macro expansion \\
                        \colorbox{Apricot}{\color{Apricot}X} Address in code memory \\
                        \colorbox{GreenYellow}{\color{GreenYellow}X} Machine code or another value to be stored in the code memory \\
                        \colorbox{Lavender}{\color{Lavender}X} Value of a symbol \\
                        \colorbox{Gray}{\color{Gray}X} Original line \\

                        \caption{Explanation code listing format}
                \end{code}

                \begin{code}[h]

                        \verb'complicated_lst                                                                                                         'macro}\verb'PAGE'}\verb' 'unknown_base}\verb'1'}\\
                        lst_number}\verb'  001C'}lst_line}\verb'                   1'}\verb'     'constant}\verb'abc'}\verb'     'directive}\verb'equ'}\verb'     'symbol}\verb'('}\verb' 'unknown_base}\verb'14'}\verb' 'symbol}\verb'*'}\verb' 'unknown_base}\verb'2'}\verb' 'symbol}\verb')'}\verb'      \verb'; Define symbol abc'}\\
                        lst_line}\verb'                         2'}\verb'             'directive}\verb'org'}\verb'     'unknown_base}\verb'0'}\verb'               \verb'; Start writing code at address 0'}\\
                        lst_line}\verb'                         3'}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'      4'}\verb'             'directive}\verb'include'}\verb' 'string}\verb''\verb"'"\verb'my_macros.asm'\verb"'"\verb' \verb'; Include file my_macros.asm'}}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'      5'}\verb'     \verb'; This is the beginning of file my_macros.asm'}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'      6'}\verb'     'macro}\verb'my_SR0'}\verb'  'directive}\verb'macro'}\verb'   'constant}\verb'foo'}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'      7'}\verb'             'instruction}\verb'LOAD'}\verb'     'sfr}\verb'A'}oper_sep}\verb','}\verb' 'constant}\verb'foo'}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'      8'}\verb'             'instruction}\verb'SR0'}\verb'     'sfr}\verb'A'}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'      9'}\verb'             'instruction}\verb'LOAD'}\verb'     'constant}\verb'foo'}oper_sep}\verb','}\verb' 'sfr}\verb'A'}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'     10'}\verb'     'directive}\verb'endm'}\\
                        lst_include}\verb'                 =1'}lst_line}\verb'     11'}\verb'     \verb'; This is the end of file my_macros.asm'}\\
                        lst_line}\verb'                        12'}\\
                        lst_line}\verb'                        13'}lst_macro}\verb' +1'}\verb'  'label}\verb'main:'}\verb'   'macro}\verb'my_SR0'}\verb'  'sfr}\verb'P0'}\verb'              \verb'; Expand macro my_SR0 here'}\\
                        lst_address}\verb'0000'}lst_code}\verb' E580'}lst_line}\verb'               14'}lst_macro}\verb' +1'}\verb'                  'instruction}\verb'LOAD'}\verb'     'sfr}\verb'a'}oper_sep}\verb','}\verb' 'sfr}\verb'p0'}\\
                        lst_address}\verb'0002'}lst_code}\verb' F4'}lst_line}\verb'                 15'}lst_macro}\verb' +1'}\verb'                  'instruction}\verb'SR0'}\verb'     'sfr}\verb'a'}\\
                        lst_address}\verb'0003'}lst_code}\verb' F580'}lst_line}\verb'               16'}lst_macro}\verb' +1'}\verb'                  'instruction}\verb'LOAD'}\verb'     'sfr}\verb'p0'}oper_sep}\verb','}\verb' 'sfr}\verb'a'}\\
                        lst_address}\verb'0005'}lst_code}\verb' 80F9'}lst_line}\verb'               17'}\verb'             'instruction}\verb'sjmp'}\verb'    'constant}\verb'main'}\verb'            \verb'; Jump back to label main'}\\
                        lst_line}\verb'                        18'}\verb'             'directive}\verb'end'}\verb'                     \verb'; End of assembly'}\\
                        lst_msg}\verb'ASSEMBLY COMPLETE,'}\verb' NO ERRORS FOUND, NO WARNINGS'\\
                        \caption{A more complicated example of code listing}
                \end{code}

        \section{Specification of Intel(R) 8 HEX Format}
                Intel(R) 8 HEX is a popular object file format capable of containing up to
       64kB of data. Hex files have usually extension .hex or .ihx. These files are text files
       consisting of a sequence of records, each line line can contain at most one record.
       Records starts with ``:'' (colon) character at the beginning of the line and ends by
       end of the line. Everything else besides records should be ignored. Records consist
       of a sequence of 8-bit hexadecimal numbers (e.g. ``a2'' or ``8c''). These numbers are
       divided into ``fields'' with different meaning, see the example below.

                \begin{code}[h]
                        \caption{An example of an Intel(R) 8 hex code}
                \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{0000}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{57}}\\
                        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{000F}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{48}}\\
                        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{001E}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{39}}\\
                        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{002D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F5907410B3758010B2907410B3}\colorbox{Lavender}{30}}\\
                        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{003D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{758010B2902694052600940426940526}\colorbox{Lavender}{0A}}\\
                        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{004D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{00940426009404269405E580F4F59026}\colorbox{Lavender}{8A}}\\
                        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0B}\colorbox{blue}{005D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{009404269405E580F4F590}\colorbox{Lavender}{63}}\\
                        \texttt{\colorbox{Goldenrod}{:}\colorbox{green}{00}\colorbox{blue}{0000}\colorbox{Apricot}{01}\colorbox{Lavender}{FF}}\\\\
                        \colorbox{Goldenrod}{\color{Goldenrod}X} Start code\\
                        \colorbox{green}{\color{green}X} Byte count\\
                        \colorbox{blue}{\color{blue}X} Address\\
                        \colorbox{Apricot}{\color{Apricot}X} Record type\\
                        \colorbox{GreenYellow}{\color{GreenYellow}X} Data\\
                \colorbox{Lavender}{\color{Lavender}X} Checksum (two's complement of 8-bit sum of entire record, except for the start code and the checksum itself)
        \end{code}

        \section{Suported instructions}
        MDS macro assembler supports multiple instruction syntax. You can use, for example, LOAD as well as LD. This section contains
        list of all supported instructions. For more informations about those instructions, see official PicoBlaze manual.\\

                \subsection{Program Control Group}
                "X" and "Y" refer to the definition of the storage registers "s" in the range 0 to F.\\
                "\#kk" represents a constant value in the range 00 to FF.\\
                "aaa" represents an address in the range 000 to 3FF.\\
                "pp" represents a port address in the range 00 to FF.\\
                "ss" represents an internal storage address in the range 00 to 3F.\\
                        \subsubsection{JUMP}
                        Instruction JUMP will load PC with "aaa" address. The JUMP instruction has no effect on the status of the flags.\\
                            \textbf{JUMP} aaa\\
                            \textbf{JUMP} Z,aaa\\
                            \textbf{JUMP} NZ,aaa\\
                            \textbf{JUMP} C,aaa\\
                            \textbf{JUMP} NC,aaa\\

                        \subsubsection{CALL}
                        T"aaa" - call address. Instruction can be conditional.\\
                            \textbf{CALL} aaa\\
                            \textbf{CALL} Z,aaa\\
                            \textbf{CALL} NZ,aaa\\
                            \textbf{CALL} C,aaa\\
                            \textbf{CALL} NC,aaa\\

                        \subsubsection{RETURN, RET}
                        Return from subroutine. Can be conditional.\\
                            \textbf{RETURN}\\
                            \textbf{RET}\\
                            \textbf{RETURN} Z\\
                            \textbf{RET} Z\\
                            \textbf{RETURN} NZ\\
                            \textbf{RET} NZ\\
                            \textbf{RETURN} C\\
                            \textbf{RET} C\\
                            \textbf{RETURN} NC\\
                            \textbf{RET} NC\\
                            \textbf{RETURNI ENABLE}\\
                            \textbf{RETURNI DISABLE}\\

                \subsection{Arithmetic Group}
                "X" and "Y" refer to the definition of the storage registers "s" in the range 0 to F.\\
                "\#kk" represents a constant value in the range 00 to FF.\\
                "aaa" represents an address in the range 000 to 3FF.\\
                "pp" represents a port address in the range 00 to FF.\\
                "ss" represents an internal storage address in the range 00 to 3F.\\
                        \subsubsection{ADD, ADDCY}
                        The ADD instruction performs an 8-bit addition of two operands. Can use constants or registers.\\
                            \textbf{ADD} sX,\#kk\\
                            \textbf{ADDCY} sX,\#kk\\
                            \textbf{ADD} sX,sY\\
                            \textbf{ADDCY} sX,sY\\

                        \subsubsection{COMPARE, CMP}
                        The COMPARE instruction performs an 8-bit subtraction of two operands Unlike the "SUB" instruction, the result of the operation is
                        discarded and only the flags are affected. This instruction updates flags\\
                            \textbf{COMPARE} sX,\#kk\\
                            \textbf{COMPARE} sX,sY\\
                            \textbf{CMP}     sX,\#kk\\
                            \textbf{CMP}     sX,sY\\

                        \subsubsection{SUB}
                        The SUB instruction performs an 8-bit subtraction of two operands. This instruction updates flags\\
                            \textbf{SUB} sX,\#kk\\
                            \textbf{SUB} sX,sY\\
                        \subsubsection{SUBCY}
                            \textbf{SUBCY} sX,\#kk\\
                            \textbf{SUBCY} sX,sY\\

                \subsection{Interrupt group}
                "X" and "Y" refer to the definition of the storage registers "s" in the range 0 to F.\\
                "\#kk" represents a constant value in the range 00 to FF.\\
                "aaa" represents an address in the range 000 to 3FF.\\
                "pp" represents a port address in the range 00 to FF.\\
                "ss" represents an internal storage address in the range 00 to 3F.\\
                        \subsubsection{RETURNI, RETIE, RETID}
                            \textbf{RETURNI ENABLE}\\
                            \textbf{RETIE}\\
                            \textbf{RETID}\\
                        \subsubsection{ENABLE INTERRUPT, ENA, DIS}
                            \textbf{ENABLE INTERRUPT}\\
                            \textbf{DISABLE INTERRUPT}\\
                            \textbf{ENA}\\
                            \textbf{DIS}\\
                \subsection{Logical Group}
                "X" and "Y" refer to the definition of the storage registers "s" in the range 0 to F.\\
                "\#kk" represents a constant value in the range 00 to FF.\\
                "aaa" represents an address in the range 000 to 3FF.\\
                "pp" represents a port address in the range 00 to FF.\\
                "ss" represents an internal storage address in the range 00 to 3F.\\
                        \subsubsection{LOAD, LD}
                        The LOAD instruction provides a method for specifying the contents of any register. The new value can be a constant, or the
                        contents of any other register. The LOAD instruction has no effect on the status of the flags.\\
                            \textbf{LOAD} sX,\#kk\\
                            \textbf{LOAD} sX,sY\\
                            \textbf{LD} sX,\#kk\\
                            \textbf{LD} sX,sY\\
                        \subsubsection{STAR}
                        Apart from bank "A" being the default on power up or following a reset you are completely free to select back "A" or bank "B" as an when you wish using the
                        REGBANK instruction. All instructions only operate on the registers in the actively selected bank which preserves the values in the inactive bank.\\
                        \textbf{STAR} sX,sY\\
                        \subsubsection{OR}
                        The "OR" instructions perform the bit-wise logical OR operation.
                        The zero flag (Z) will be set if all 8-bits of the result returned to "sX" are zero.
                        The carry flag (C) will be cleared (C=0) in all cases.\\
                            \textbf{OR} sX,sY\\
                            \textbf{OR} sX,\#kk\\

                        \subsubsection{XOR}
                                The "XOR" instructions perform the bit\-wise logical exclusive-OR operation.
                                 The zero flag (Z) will be set if all 8-bits of the result returned to "sX" are zero.
                                The carry flag (C) will be cleared (C=0) in all cases.\\
                            \textbf{XOR} sX,\#kk\\
                            \textbf{XOR} sX,sY\\

                        \subsubsection{AND}
                        The first operand must specify a register "sX" whose value provides one input to the AND operation and in to which the result is returned.
                        The second operand defines the second input to the AND operation and can either be an 8-bit constant \#kk\ or a register sY.
                        The zero flag (Z) will be set if all 8-bits of the result returned to sX are zero.
                        The carry flag (C) will be cleared (C=0) in all cases.\\
                            \textbf{AND} sX,\#kk\\
                            \textbf{AND} sX,sY\\

                        \subsubsection{TEST}
                        The "TEST" instructions are similar to the "AND" instructions in that a bit-wise logical AND operation is performed. However, the actual result is discarded and
                        only the flags are updates to reflect the temporary 8-bit. The zero flag (Z) will be set if all 8-bits of the temporary result are zero.
                        The carry flag (C) will be set if the temporary result contains an odd number of bits set to "1" (the exclusive-OR of the 8-bit temporary result).
                            \textbf{TEST} sX,sY\\
                            \textbf{TEST} sX,\#kk\\
                        \subsubsection{TESTCY}
                        The "TESTCY" instructions are primarily intended as an extension to the basic "TEST" instructions in order to support testing and odd parity calculation of
                        values more than 8-bits.
                            \textbf{TESTCY} sX,sY\\
                            \textbf{TESTCY} sX,\#kk\\
                \subsection{Shift and Rotate Group}
                "X" and "Y" refer to the definition of the storage registers "s" in the range 0 to F.\\
                "\#kk" represents a constant value in the range 00 to FF.\\
                "aaa" represents an address in the range 000 to 3FF.\\
                "pp" represents a port address in the range 00 to FF.\\
                "ss" represents an internal storage address in the range 00 to 3F.\\
                        \subsubsection{SR}
                            \textbf{SR0} sX\\
                            \textbf{SR1} sX\\
                            \textbf{SRX} sX\\
                            \textbf{SRA} sX\\
                        \subsubsection{RR, RL}
                            \textbf{RR}  sX\\
                            \textbf{RL}  sX\\
                        \subsubsection{SL}
                            \textbf{SL0} sX\\
                            \textbf{SL1} sX\\
                            \textbf{SLX} sX\\
                            \textbf{SLA} sX\\
                \subsection{Storage group}
                "X" and "Y" refer to the definition of the storage registers "s" in the range 0 to F.\\
                "\#kk" represents a constant value in the range 00 to FF.\\
                "aaa" represents an address in the range 000 to 3FF.\\
                "pp" represents a port address in the range 00 to FF.\\
                "ss" represents an internal storage address in the range 00 to 3F.\\
                        \subsubsection{STORE}
                        The store instructions write the contents of a register "sX" into the scratch pad memory (SPM).
                            \textbf{STORE} sX,ss\\
                            \textbf{STORE} sX,@sY\\

                        \subsubsection{FETCH}
                        The fetch instructions read the contents of a location of scratch pad memory (SPM) into a register "sX"
                            \textbf{FETCH} sX,ss\\
                            \textbf{FETCH} sX,@sY\\

                \subsection{Input output group}
                "X" and "Y" refer to the definition of the storage registers "s" in the range 0 to F.\\
                "\#kk" represents a constant value in the range 00 to FF.\\
                "aaa" represents an address in the range 000 to 3FF.\\
                "pp" represents a port address in the range 00 to FF.\\
                "ss" represents an internal storage address in the range 00 to 3F.\\
                        \subsubsection{INPUT, IN}
                        An "INPUT" instruction enables to read information from the from your hardware design into a register "sX" using a general purpose input port.\\
                            \textbf{INPUT}      sX,pp\\
                            \textbf{INPUT}      sX,@sY\\
                            \textbf{IN}         sX,pp\\
                            \textbf{IN}         sX,@sY\\
                        \subsubsection{OUTPUT, OUT}
                        An "OUTPUT" instruction is used to transfer information from a register "sX" to a general purpose output port specified by an 8-bit constant value "pp" or the
                        contents of another register "@sY".\\
                            \textbf{OUTPUT}     sX,pp\\
                            \textbf{OUTPUT}     sX,@sY\\
                            \textbf{OUT}        sX,pp\\
                            \textbf{OUT}        sX,@sY\\
                        \subsubsection{OUTPUTK, OUTK}
                        The first operand is the 8-bit constant value "\#kk". "p" is port\_id[0:3].\\
                            \textbf{OUTPUTK}     \#kk,p\\
                            \textbf{OUTPUTK}     \#kk,@sY\\
                            \textbf{OUTK}        \#kk,p\\
                            \textbf{OUTK}        \#kk,@sY\\

        \section{Generated VHDL and Verilog files}
        As you know, the PicoBlaze microcontroller is primarily designed for use in a VHDL design flow.
        MDS will generate all necessary files, that are needed for
        implementation in FPGA. Basically the MDS replaces instances on
        {INIT\_XX}, {INITP\_XX} and {INIT64\_X}, {INIT128\_X}, {INIT256\_X} by constant strings with the appropriate values, similar to the kcpsmX tools of Xilinx.

                \subsection{Connecting the Program ROM}
                The PicoBlaze program ROM is used within a VHDL design flow. The PicoBlaze assembler
                generates a VHDL and VERILOG file in which a block RAM and its initial contents are defined. This
                file can be used for both logic synthesis and simulation of the processor.
                You need to declare component in your VHDL or VERILOG design and instantiate.\\
