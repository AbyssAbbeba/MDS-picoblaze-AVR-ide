\newcommand{\no}{\color{red}{\textbf{no}}}
\newcommand{\yes}{\color{black}{\textbf{yes}}}

In this chapter, we will be concerned with the build-in macro assembler. With syntax of its statements, directives, and PicoBlaze instructions. We assume that the reader is familiar with general concepts of the assembly language programming and with PicoBlaze architecture.

MDS macro-assembler for PicoBlaze is a two stage fast macro-assembler inspired by Intel assemblers and the C language. It supports wide range of output data formats and a number of advanced features like macro processing, conditions, loops, etc. it is meant to give you means to write code with run-time efficiency typical for the assembly language while giving you some of the comfort of a more high-level language like C. For instance you may use ``\verb'if ( S0 == S1 )''' to easy write conditions instead of compares and conditional jumps, ``\verb'for ( S0, 0 .. 9 )''' for loops, ``\verb'#if my_constant > 20''' for conditional compilation, ``\verb'abc macro x, y, z''' for defining your own macros, and more. MDS assembler is enhanced with these features in hope it will help you save your time and make your work a little bit easier. MDS assembler also has a number of features for smooth and transparent debugging and it is regularly subjected to extensive automated testing to ensure its very functionality and to provide high reliability. Also this assembler supports all PicoBlaze versions publicly available at the time of its release. For these reasons we are convinced that this is the most advanced assembler for PicoBlaze currently available on the market.

\paragraph{Supported processors}
    \begin{itemize}
        \item PicoBlaze 6
        \item PicoBlaze 3
        \item PicoBlaze II
        \item PicoBlaze CPLD
        \item PicoBlaze
    \end{itemize}

\paragraph{Note about this documentation:}
    to write a document properly describing any programming language, including the assembly language, is always a challenging task. If you find a mistake or improperly covered area in this documentation, please let us know, we will fix that and provide you with the fixed version as soon as possible.

\clearpage
\section{Basics}
    \subsection{Main differences from the Xilinx assembler}
        \begin{description}
            \item[Default radix is decimal, not hexadecimal.]~\\
                You can use different radix for each numerical literal, if you do not specify radix, it is decimal by default. For hexadecimal radix use the `0x' prefix: 0x1a, 0xbc, 0x23, ...; for octal radix use the `0' (zero) prefix: 076, 011, 027, ...; for binary radix use the `0b' prefix: 0b11001100, 0b10101010, 0b11111111, ...; for ASCII value put the character in single quotes: 'a', 'A', '3', ... Suffix notation is also supported: 80h (hex.), 128d (dec.), 200q (oct.), 10000000b (bin.), for ASCII characters, you can also use C language escape sequences: \verb"'\0'"~(NUL), \verb"'\n'"~(LF), \verb"'\r"~(CR), \verb"'\t"~(TAB), ...
            \item[Addressing mode specification is mandatory.]~\\
                For immediate addressing use the `\#' prefix: \texttt{LOAD~S0,~\#0xAB}; for indirect addressing use the ``@'' prefix: ``\texttt{STORE~S0,~@S1}''; and for direct addressing do not use any prefix: ``\texttt{LOAD~S0,~S1~+~3}'' (this loads S0 with S4).
            \item[This assembler is case insensitive.]~\\
                ``\texttt{load~S0,~S1}'' is the same as ``\texttt{LOAD~s0,~s1}'', or ``\texttt{Load~S0,~s1}''.
            \item[This assembler supports user defined macro instructions, and expressions.]~\\
                ``\texttt{LOAD~S0,~\#(2~+~3~*~8)}'', etc. please refer to the Tutorial Project, and the Quick User Guide for brief introduction, or to later pages in this manual for detailed description.
        \end{description}

    \clearpage
    \subsection{Statements}
        Source code files for this assembler have to be text files in the following format:
        ~\\\\
        \verb'[ label: ]  [ instruction  [ operand  [ , operand  ] ]    [ ;comment ]'\\
        \verb'[ label: ]  directive      [ argument [ , argument ] ]    [ ;comment ]'\\
        \verb'[ symbol ]  directive      [ argument [ , argument ... ]  [ ;comment ]'\\
        \verb'            directive      symbol, argument               [ ;comment ]'\\

        Tokens in square brackets are optional. Compilation does not continue beyond line containing the \texttt{END} directive, after that directive the code does not have to be syntactically correct. Empty lines are valid, as well as lines containing only comment or label. Statements are separated by white space (spaces or tabs). Statements are case insensitive and their length is not limited, overall line length is also not limited. Allowed line delimiters are: LF, CR, and sequence CRLF. Expected encoding is UTF-8 but it is not necessarily required.

    \subsection{Comments}
        Comments in source code are ignored by the assembler (they are supposed to serve only as notes to the developer). MDS assembler uses two types of comments: single-line comment starting with ``\texttt{;}'' (semicolon) character and ending with the end of line, and multi-line comments starting with ``\texttt{/*}'' sequence (slash followed by asterisk) and ending with ``\texttt{*/}'' sequence (asterisk followed by slash), like in the C language.

        \paragraph{Example}
            ~\\
            \verb'    ; Single-line comment'\\
            \verb'    '\\
            \verb'    /*'\\
            \verb'     * Multi-line comment ...'\\
            \verb'     */'\\
            \verb'    '\\
            \verb'    LOAD /* Comment, */ S0, /* another comment, */ S1 ; more comment.'

    \clearpage
    \subsection{Numbers}
        MDS assembler supports multiple radixes for numeric constants, radix is specified using prefix or suffix notation. Default radix is decimal (like in the C language).

        ~\\
        \verb"    ; Hexadecimal."\\
        \verb"    ld          S0, #0xAB       ; prefix notation (`0x...')"\\
        \verb"    ld          S0, #0ABh       ; suffix notation (`...h')"\\
        \verb""\\
        \verb"    ; Decimal."\\
        \verb"    ld          S0, #123        ; no prefix - default radix - decimal"\\
        \verb"    ld          S0, #123d       ; suffix notation (`d')"\\
        \verb""\\
        \verb"    ; Octal."\\
        \verb"    ld          S0, #076        ; prefix notation (`0...')"\\
        \verb"    ld          S0, #76q        ; suffix notation (`...q')"\\
        \verb"    ld          S0, #76o        ; suffix notation (`...o')"\\
        \verb""\\
        \verb"    ; Binary."\\
        \verb"    ld          S0, #0b1100     ; prefix notation (`0b...')"\\
        \verb"    ld          S0, #1100b      ; suffix notation (`...b')"\\
        \verb""\\
        \verb"    ; ASCII."\\
        \verb"    ld          S0, #'A'        ; ASCII value of capital A."\\
        \verb"    ld          S0, #'\t'       ; ASCII value of the tab character (escape sequence)."

        \subsubsection{Escape sequences}
            \index{Escape sequences} \label{Escape sequences}
            In place of ASCII value you can also use a single escape sequence, escape sequences can also be used in strings (\verb'"abc\r\n"'). Escape sequences in MDS assembler are exactly the same as in the C language.

            \begin{table}[h!]
                \centering
                \begin{tabular}{|c|l|c|}
                    \hline
                    \textbf{Sequence} & \textbf{Description} & \textbf{Value} \\\hline
                    \verb'\a'         & alarm (bell)         & 0x07 \\\hline
                    \verb'\b'         & backspace            & 0x08 \\\hline
                    \verb"\'"         & single quote         & 0x27 \\\hline
                    \verb'\"'         & double quote         & 0x22 \\\hline
                    \verb'\?'         & question mark        & 0x3F \\\hline
                    \verb'\\'         & backslash            & 0x5C \\\hline
                    \verb'\f'         & form feed            & 0x0C \\\hline
                    \verb'\n'         & line feed            & 0x0A \\\hline
                    \verb'\r'         & carriage return      & 0x0D \\\hline
                    \verb'\t'         & horizontal tab       & 0x09 \\\hline
                    \verb'\v'         & vertical tab         & 0x0B \\\hline
                    \verb'\e'         & escape               & 0x1B \\\hline
                \end{tabular}
                \caption{Escape sequences.}
            \end{table}

            In addition to the escape sequences sequences described in the table above, MDS assembler also supports these escape sequences:
            \begin{description}
                \item[$\backslash$NNN]~\\
                    To write a character whose numerical value is given by \texttt{NNN} interpreted as an octal number (e.g. \verb'\0', \verb'\22', \verb'\377', etc.).
                \item[$\backslash$xHH]~\\
                    To write a character whose numerical value is given by \texttt{HH} interpreted as an hexadecimal number (e.g. \verb'\x0F', \verb'\x2A', \verb'\xC7', etc.).
                \item[$\backslash$uXX]~\\
                    To write a unicode character specified by max. 4 hexadecimal digits.
                \item[$\backslash$uXXXX]~\\
                    To write a unicode character specified by max. 8 hexadecimal digits.
            \end{description}

    \subsection{Symbols}
        \index{Symbols}
        Symbols are user defined symbolic names for numbers and addresses used in the program. Symbol names consist of upper and lower case letters, digits, and underscore character (``\_''), their length is not limited, they are case insensitive and they have to be different from language keywords. Symbol names cannot start with digit. Be aware of that there cannot coexists two or more symbols which differs only by letter casing, for instance ``\texttt{abc}'' and ``\texttt{ABC}'' are considered by this assembler to be the same symbol. Symbols have to be defined before they are used.

        \paragraph{Example}
        ~\\
        \verb'    first_symbol      EQU     0b100111 ; Binary radix, number.'\\
        \verb'    second_symbol     SET     047      ; Octal radix, number.'\\
        \verb'    third_symbol      REG     39       ; Decimal radix, register address.'\\
        \verb'    fourth_symbol     DATA    0x27     ; Hexadecimal radix, scratch-pad ram address.'\\
        \verb'    fifth_symbol      CODE    0x27     ; Hexadecimal radix, program memory address.'\\
        \verb'    my_label:                          ; Program memory address, defined using label.'

        \subsubsection{Special Symbols}
            MDS assembler supports only one special symbol, this symbol is always automatically defined on every line containing an instruction (or the \texttt{DB} directive), it is symbol ``\texttt{\$}''. ``\texttt{\$}'' contains address in the program memory where ``this instruction'' is going to be placed by the assembler.

            \paragraph{Example}
                ~\\
                \verb'    ; Since $ conatins the address of the JUMP instruction,'\\
                \verb'    ; this jump results in infinite loop.'\\
                \verb'    JUMP    $'\\
                \verb''\\
                \verb'    ; Skip the next instruction ($+1 would "skip" only the jump itself).'\\
                \verb'    JUMP    $+2'\\
                \verb'    LOAD    S0, S1   ; <-- This instruction is goigh to be skipped.'\\
                \verb'    LOAD    S2, S3'

        \clearpage
        \subsubsection{Predefined Symbols}
            These symbols are defined by default when you specify the target device (using the ``\texttt{DEVICE}'' directive). Symbols \texttt{S10}..\texttt{S1F} are defined for KCPSM2 only, symbols \texttt{S8}..\texttt{S1F} are not defined for KCPSM1-CPLD but defined for every other PicoBlaze. All these symbols are defined as register addresses.

            \begin{table}[h!]
                \centering
                \begin{tabular}{|cc|cc|}
                    \hline
                    \textbf{Symbol} & \textbf{Value} & \textbf{Symbol} & \textbf{Value} \\\hline
                    \texttt{S0}     & 0x00           & \texttt{S10}    & 0x10           \\\hline
                    \texttt{S1}     & 0x01           & \texttt{S11}    & 0x11           \\\hline
                    \texttt{S2}     & 0x02           & \texttt{S12}    & 0x12           \\\hline
                    \texttt{S3}     & 0x03           & \texttt{S13}    & 0x13           \\\hline
                    \texttt{S4}     & 0x04           & \texttt{S14}    & 0x14           \\\hline
                    \texttt{S5}     & 0x05           & \texttt{S15}    & 0x15           \\\hline
                    \texttt{S6}     & 0x06           & \texttt{S16}    & 0x16           \\\hline
                    \texttt{S7}     & 0x07           & \texttt{S17}    & 0x17           \\\hline
                    \texttt{S8}     & 0x08           & \texttt{S18}    & 0x18           \\\hline
                    \texttt{S9}     & 0x09           & \texttt{S19}    & 0x19           \\\hline
                    \texttt{SA}     & 0x0A           & \texttt{S1A}    & 0x1A           \\\hline
                    \texttt{SB}     & 0x0B           & \texttt{S1B}    & 0x1B           \\\hline
                    \texttt{SC}     & 0x0C           & \texttt{S1C}    & 0x1C           \\\hline
                    \texttt{SD}     & 0x0D           & \texttt{S1D}    & 0x1D           \\\hline
                    \texttt{SE}     & 0x0E           & \texttt{S1E}    & 0x1E           \\\hline
                    \texttt{SF}     & 0x0F           & \texttt{S1F}    & 0x1F           \\\hline
                \end{tabular}
                \caption{Predefined symbols}
            \end{table}

    \subsection{Expressions}
        \index{Expressions}
        Mathematical expressions are evaluated at compilation time and replaced with constants corresponding to their resulting values. Expression calculation is performed on 32-bit unsigned integers, the resulting values then are trimmed from left to 16-bits at most (with exception for the \texttt{DB} directive where values might be trimmed to 18 bits). Expression comprises of arithmetical operators, numeric literals, and symbols. Examples of such expressions include:

        \begin{itemize}
            \item \texttt{2+1}
            \item \texttt{(2 + 4) - ABC}
            \item \texttt{A \& B}
            \item \texttt{X / 0FF00h}
            \item \texttt{X * Y + X \% Y}
        \end{itemize}

        When operators with different priority levels appear in the expression, operations are evaluated according to priorities. When operators of the same priority appear in the expression, operations are evaluated from left to right. Parenthesis may be used to force a different order of evaluation, for example \texttt{2 + 2 * 2} is evaluated as 6 because multiplication has higher priority than addition, but \texttt{( 2 + 2 ) * 2} results in 8 because addition is enclosed by parenthesis and therefore it is evaluated prior to the multiplication.

        The table below shows priorities for all supported operators, priority 1 is the highest priority, priority 9 is the lowest priority. Arithmetic operators have higher priority than relational operators, and relational operators have higher priority than logical operators.

        \begin{table}[h!]
            \centering
            \begin{tabular}{|c|c|l|l|}
                \hline
                \textbf{Priority} & \textbf{Operator} & \textbf{Description} & \textbf{Example} \\\hline
                1        & \texttt{+}    & unary plus sign         & \texttt{+12}               \\\hline
                1        & \texttt{-}    & unary minus sign        & \texttt{-5}                \\\hline
                2        & \texttt{\~{}} & bitwise NOT             & \texttt{\~{}0a55ah}        \\\hline
                2        & \texttt{!}    & logical NOT             & \texttt{!0a55ah}           \\\hline
                3        & \texttt{*}    & unsigned multiplication & \texttt{11 * 12}           \\\hline
                3        & \texttt{/}    & unsigned division       & \texttt{11 / 12}           \\\hline
                3        & \texttt{\%}   & unsigned modulo         & \texttt{13 \% 11}          \\\hline
                4        & \texttt{+}    & unsigned addition       & \texttt{3 + 5}             \\\hline
                4        & \texttt{-}    & unsigned subtraction    & \texttt{20 - 4}            \\\hline
                5        & \texttt{<{}<} & binary shift left       & \texttt{21 <{}< 4}         \\\hline
                5        & \texttt{>{}>} & binary shift right      & \texttt{32 >{}> 2}         \\\hline
                6        & \texttt{<}    & less than               & \texttt{11 < 12}           \\\hline
                6        & \texttt{<=}   & less or equal than      & \texttt{11 <= 11}          \\\hline
                6        & \texttt{>}    & greater than            & \texttt{12 > 11}           \\\hline
                6        & \texttt{>=}   & greater or equal than   & \texttt{12 >= 11}          \\\hline
                7        & \texttt{==}   & equal to                & \texttt{11 == 11}          \\\hline
                7        & \texttt{!=}   & not equal to            & \texttt{A != B}           \\\hline
                7        & \texttt{<>}   & not equal to            & \texttt{A <> B}           \\\hline
                8        & \texttt{\&}   & bitwise AND             & \texttt{48 \& 16}          \\\hline
                8        & \texttt{|}    & bitwise OR              & \texttt{370q | 7}          \\\hline
                9        & \texttt{\&\&} & logical AND             & \texttt{48 \&\& 16}        \\\hline
                9        & \texttt{||}   & logical OR              & \texttt{370q || 7}         \\\hline
                9        & \texttt{\^{}} & bitwise XOR             & \texttt{00fh \^{} 005h}    \\\hline
            \end{tabular}
            \caption{Operators priorities.}
        \end{table}

        \subsubsection{Special operators}
            Special operators can appear only at certain places and serve special purposes.
            \begin{description}
                \item[high(...)]~\\
                    Operator \texttt{HIGH(...)} extracts the high order byte from 16 bit value. For example \texttt{LOAD  S0, \#high(0x2233)} would load S0 with immediate value of 0x22.
                \item[low(...)]~\\
                    Operator \texttt{LOW(...)} extracts the low order byte from 16 bit value. For example \texttt{LOAD  S0, \#low(0x2233)} would load S0 with immediate value of 0x33.
                \item[at]~\\
                    Operator \texttt{AT} is used only in conjunction with \texttt{AUTOREG} and \texttt{AUTOSPR} directives to set address counter to the specified value.
                \item[..]~\\
                    Operator \texttt{..} is used only with the \texttt{FOR} directive to specify the loop iteration interval.
            \end{description}

    \subsection{Reserved keywords}
        Please remember that the assembler is case \textbf{in-}sensitive.
        \subsubsection{Instruction mnemonics}
            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|}
                        \hline
                        cpl2 & cpl  & inc  & dec  & setr & clrr \\\hline
                        setb & clrb & notb & djnz & ijnz & nop  \\\hline
                    \end{tabular}
                }
                \caption{Pseudo-instructions}
            \end{table}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|l|}
                        \hline
                        ldret & ena  & dis & retie & retid & cmp & in  \\\hline
                        out   & outk & ld  & cmpcy & st    & ft  & ret \\\hline
                    \end{tabular}
                }
                \caption{Instruction shortcuts}
            \end{table}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|l|}
                        \hline
                        add     & addcy & sub    & subcy   & compare & load      & return \\\hline
                        and     & or    & xor    & test    & store   & fetch     & jump   \\\hline
                        sr0     & sr1   & srx    & sra     & rr      & sl0       & call   \\\hline
                        sl1     & slx   & sla    & rl      & input   & output    &        \\\hline
                        hwbuild & star  & testcy & outputk & jump    & comparecy &        \\\hline
                    \end{tabular}
                }
                \caption{Regular instructions}
            \end{table}

        \subsubsection{Directives}
            Regular directives and special macros directives can be prefixed with ``\texttt{.}'' (period) character without any effect on their meaning and function.

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|}
                        \hline
                        if       & elseif & else & endif & while  \\\hline
                        endwhile & endw   & for  & endf  & endfor \\\hline
                    \end{tabular}
                }
                \caption{Special macros}
            \end{table}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|}
                        \hline
                        \#if         & \#ifn   & \#ifdef  & \#ifndef  & \#elseifb   & \#endwhile \\\hline
                        \#elseifnb   & \#else  & \#elseif & \#elseifn & \#elseifdef & \#endw     \\\hline
                        \#elseifndef & \#endif & \#ifnb   & \#ifb     & \#while     &            \\\hline
                    \end{tabular}
                }
                \caption{Conditional compilation \& the \texttt{\#WHILE}}
            \end{table}

            \enlargethispage{6\baselineskip}

            \begin{table}[h!]
                \centering
                \texttt{
                    \begin{tabular}{|l|l|l|l|l|l|}
                        \hline
                        failjmp & device   & limit    & reg       & string   & default\_jump \\\hline
                        namereg & address  & org      & define    & undefine & undef         \\\hline
                        equ     & constant & set      & variable  & port     & portin        \\\hline
                        portout & data     & code     & string    & db       & error         \\\hline
                        warning & list     & message  & messg     & nolist   & skip          \\\hline
                        title   & expand   & noexpand & local     & endmacro & endm          \\\hline
                        exitm   & repeat   & rept     & endrepeat & endr     & autoreg       \\\hline
                        autospr & orgspr   & initspr  & mergespr  & macro    & end           \\\hline
                    \end{tabular}
                }
                \caption{Regular directives}
            \end{table}

\clearpage
\section{Instructions}
    \input{chapter_Built-in_Macro_assembler_instructions.tex}

\clearpage
\section{Pseudo Instructions}
    \input{chapter_Built-in_Macro_assembler_pseudo-instructions.tex}

\clearpage
\input{chapter_Built-in_Macro_assembler_directives.tex}

\clearpage
\section{Output files}
    \subsection{Generated VHDL and Verilog files}
        As you know, the PicoBlaze microprocessor is primarily designed for use in a VHDL design. MDS will generate all the necessary files that are needed for implementation in FPGA. The compiler will read a VHDL template and insert the generated machine code for PicoBlaze processor to complete the definition of program ROM and write the result into a new VHDL file that is ready for synthesis and simulation.

        Template can be modified to define alternative memory definitions. However, you are responsible for ensuring that the template is correct, the compiler does not perform any validity checks on the VHDL template.

        The compiler identifies certain strings enclosed by ``\texttt{\{\}}'' characters (marks), and substitutes these character strings with corresponding values. The MDS assembler replaces instances of \verb'{timestamp}', \verb'{name}', \verb'{INIT_X}', \verb'{INITP_X}', \verb'{INIT64_X}', \verb'{INIT128_X}', \verb'{INIT256_X}', \verb'{[8:0]_INIT_X}', \verb'{[8:0]_INITP_X}', \verb'{[17:9]_INIT_X}', \verb'{[17:9]_INITP_X}', and \verb'{begin template}'. Templates have to contain these marks for the compiler to work correctly.

    \subsection{MEM File}
        MEM file contains machine code generated by the assembler. There are 17 columns 4 bytes wide, the first column starts with ``\verb'@''' and represents address, other columns contain instruction opcodes. Unused locations are filled with zeros.

        \subsubsection{Example}
            \verb'@0000 000011F7 00001299 0000132E ... ... ... 00004577 00007789 000015A4'\\
            \verb'...'\\
            \verb'...'\\
            \verb'...'\\
            \verb'@0040 000004DF 000047F4 00000000 ... ... ... 00000000 00000000 00000000'\\
            \verb'@0080 00000000 00000000 00000000 ... ... ... 00000000 00000000 00000000'\\
            \verb'@00C0 00000000 00000000 00000000 ... ... ... 00000000 00000000 00000000'\\
            \verb'@0100 00000000 00000000 00000000 ... ... ... 00000000 00000000 00000000'\\
            \verb'...'\\
            \verb'...'\\
            \verb'...'\\
            \verb'@3F80 000011F7 00001299 0000132E ... ... ... 00000000 00000000 00000000'\\
            \verb'@3FC0 000011F7 00001299 0000132E ... ... ... 00000000 00000000 00000000'\\

    \clearpage
    \subsection{Raw Hex Dump file}
        Raw Hex Dump is very simple, file starts with hexadecimal representation of opcode of the first instruction in your program at address 0x0 then it is followed by opcode at address 0x1, 0x2, and so on. Unused locations are filled with zeros.

        \subsubsection{Example}
            ~\\
            \verb'011F7'\\
            \verb'01299'\\
            \verb'0132E'\\
            \verb'19101'\\
            \verb'00000'\\
            \verb'19201'\\
            \verb'00000'\\
            \verb'19301'\\
            \verb'00000'\\
            \verb'00000'\\
            \verb'00...'\\
            \verb'.....'\\
            \verb'...00'

    \subsection{Raw binary file}
        Raw binary file contains machine code generated by the assembler in raw form. It contains instruction opodes formatted either as a sequence of byte triplets (in case of 18-bit instruction opcodes), or sequence of byte pairs (in case of 16-bit instructions opcodes), byte order for these sequences is big-endian. Unused memory locations and higher bits of bytes which are not used in their entire width are filled with binary zeros, start address for the entire file is 0.

    \subsection{String table}
        String table is a human readable text file containing table of strings defined in your source code using the \texttt{STRING} directive.

        \subsubsection{File format}
            The table of strings consists of a number of lines with following format:

            \begin{tabular}{|ccc|}
                \hline
                <Name> & <Location> & <"Value"> \\\hline
            \end{tabular}

            \begin{description}
                \item[Name]~\\
                    Name of the string.
                \item[Location]~\\
                    Location of the string definition, formatted as:\\
                    \texttt{<file-name>:<line-number>.<column>.<line-number>.<column>}
                \item[Value]~\\
                    The assigned character string.
            \end{description}

    \subsection{Symbol table}
        Symbol table is a human readable text file containing table of symbols defined in your source code using labels, symbol definition directives (\texttt{EQU}, \texttt{SET}, \texttt{REG}, \texttt{DATA}, \texttt{CODE}, \texttt{AUTOREG}, \texttt{AUTOSPR}), and implicitly defined symbols for your processor.

        \subsubsection{File format}
            The table of symbols consists of a number of lines with following format:

            \begin{tabular}{|cccccc|}
                \hline
                <Name> & <Type> & <Value> & <Usage> & <Attribute> & <Location> \\\hline
            \end{tabular}

            \begin{description}
                \item[Name]~\\
                    Symbol name.
                \item[Type]~\\
                    Symbol type.
                    \begin{itemize}
                        \item PORT: PORT\_ID indicator.
                        \item DATA: Scratch-pad memory address.
                        \item LABEL: Address in program memory.
                        \item REGISTER: Address of an internal register.
                        \item EXPRESION: An expression.
                        \item NUMBER: Symbol is a general number.
                    \end{itemize}
                \item[Value]~\\
                    Value assigned to the symbol.
                \item[Usage]~\\
                    ``USED'' or ``NOT USED''.
                \item[Attribute]~\\
                    \begin{itemize}
                        \item IMPLICIT: Symbol is defined implicitly for your processor.
                        \item LOCAL: Local symbol in macro.
                        \item REDEFINABLE: Symbol is re-definable, i.e. is not constant.
                        \item CONSTANT: Symbol cannot be redefined, i.e. is constant.
                    \end{itemize}
                \item[Location]~\\
                    Location of symbol definition formatted as:\\
                    \texttt{<file-name>:<line-number>.<column>.<line-number>.<column>}
            \end{description}

    \clearpage
    \subsection{Macro table}
        Macro table is a human readable text file containing table of macros defined in your source code using the \texttt{MACRO} directive.

        \subsubsection{File format}
            The table of macros consists of a number of lines with following format:

            \begin{tabular}{|cccc|}
                \hline
                <Name> & ( <Parameters> ) & <Usage> & <Location> \\\hline
            \end{tabular}

            \begin{description}
                \item[Name]~\\
                    Name of macro.
                \item[Parameters]~\\
                    Macro parameters.
                \item[Usage]~\\
                    Information about how many times the macro was used.
                \item[Location]~\\
                    Location of the macro definition formatted as:\\
                    \texttt{<file-name>:<line-number>.<column>.<line-number>.<column>}
            \end{description}

    \enlargethispage{3\baselineskip}
    \subsection{Intel 8 HEX}
        Intel 8 HEX is a popular object file format capable of containing up to 64kB of data. Hex files have usually extension .hex or .ihx. These files are text files consisting of a sequence of records, each line line can contain at most one record. Records starts with ``\texttt{:}'' (colon) character at the beginning of the line and ends by end of the line. Everything else besides records should be ignored. Records consist of a sequence of 8-bit hexadecimal numbers (e.g. ``a2'' or ``8c''). These numbers are divided into ``fields'' with different meaning, see the example below.

        For PicoBlaze, opcodes are divided into either 3 bytes (in case of 18-bit opcode, unused high order bits are filled with zeros) or 2 bytes (in case of 16-bit opcode), these bytes are placed in the file in big-endian byte order.

        ~\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{0000}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{57}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{000F}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{48}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0F}\colorbox{blue}{001E}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F590E580F4F590E580F4F590}\colorbox{Lavender}{39}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{002D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{E580F4F5907410B3758010B2907410B3}\colorbox{Lavender}{30}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{003D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{758010B2902694052600940426940526}\colorbox{Lavender}{0A}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{10}\colorbox{blue}{004D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{00940426009404269405E580F4F59026}\colorbox{Lavender}{8A}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{0B}\colorbox{blue}{005D}\colorbox{Apricot}{00}\colorbox{GreenYellow}{009404269405E580F4F590}\colorbox{Lavender}{63}}\\
        \indent\texttt{\colorbox{Goldenrod}{:}\colorbox{green}{00}\colorbox{blue}{0000}\colorbox{Apricot}{01}\colorbox{Lavender}{FF}}\\\\
        \indent\colorbox{Goldenrod}{\color{Goldenrod}X} Start code\\
        \indent\colorbox{green}{\color{green}X} Byte count\\
        \indent\colorbox{blue}{\color{blue}X} Address\\
        \indent\colorbox{Apricot}{\color{Apricot}X} Record type\\
        \indent\colorbox{GreenYellow}{\color{GreenYellow}X} Data\\
        \indent\colorbox{Lavender}{\color{Lavender}X} Checksum\footnote{Checksum is two's complement of 8-bit sum of entire record, except for the start code and the checksum itself.}

    \clearpage
    \subsection{S-Rec format}
        S-records are a form of simple ASCII encoding for binary data. An S-record file consists of a sequence of specially formatted ASCII character strings. An S-record will be less than or equal to 78 bytes in length. The order of S-records within a file is of no significance and no particular order may be assumed.

        For PicoBlaze, opcodes are divided into either 3 bytes (in case of 18-bit opcode, unused high order bits are filled with zeros) or 2 bytes (in case of 16-bit opcode), these bytes are placed in the file in big-endian byte order.

        \subsubsection{File format}
            The Motorola S-Rec file consists of a number of lines with following format:

            \begin{tabular}{|ccccc|}
                \hline
                <Type> & <Count> & <Address> & <Data> & <Checksum> \\\hline
            \end{tabular}

            \begin{description}
                \item[Type]~\\
                    A char[2] field. These characters describe the type of record (S0, S1, S2, S3, S5, S7, S8, or S9).

                \item[Count]~\\
                    A char[2] field. These characters when paired and interpreted as a hexadecimal value, display the count of remaining character pairs in the record.

                \item[Address]~\\
                    A char[4,6, or 8] field. These characters grouped and interpreted as a hexadecimal value, display the address at which the data field is to be loaded into memory. The length of the field depends on the number of bytes necessary to hold the address. A 2-byte address uses 4 characters, a 3-byte address uses 6 characters, and a 4-byte address uses 8 characters.

                \item[Data]~\\
                    A char [0-64] field. These characters when paired and interpreted as hexadecimal values represent the memory loadable data or descriptive information.

                \item[Checksum]~\\
                    A char[2] field. These characters when paired and interpreted as a hexadecimal value display the least significant byte of the ones complement of the sum of the byte values represented by the pairs of characters making up the count, the address, and the data fields.
            \end{description}

            Each record is terminated with a line feed. If any additional or different record terminator(s) or delay characters are needed during transmission to the target system it is the responsibility of the transmitting program to provide them.

        \subsubsection{Record types}
            \begin{description}
                \item[S0]~\\
                    The type of record is S0 (0x5330). The address field is unused and will be filled with zeros (0x0000). The header information within the data field is divided into the following subfields.

                    \begin{itemize}
                        \item mname is char[20] and is the module name.
                        \item ver is char[2] and is the version number.
                        \item rev is char[2] and is the revision number.
                        \item description is char[0-36] and is a text comment.
                    \end{itemize}

                    Each of the subfields is composed of ASCII bytes whose associated characters when paired, represent one byte hexadecimal values in the case of the version and revision numbers, or represent the hexadecimal values of the ASCII characters comprising the module name and description.

                \item[S1]~\\
                    The type of record field is S1 (0x5331). The address field is interpreted as a 2-byte address. The data field is composed of memory loadable data.

                \item[S2]~\\
                    The type of record field is S2 (0x5332). The address field is interpreted as a 3-byte address. The data field is composed of memory loadable data.

                \item[S3]~\\
                    The type of record field is S3 (0x5333). The address field is interpreted as a 4-byte address. The data field is composed of memory loadable data.

                \item[S5]~\\
                    The type of record field is S5 (0x5335). The address field is interpreted as a 2-byte value and contains the count of S1, S2, and S3 records previously transmitted. There is no data field.

                \item[S7]~\\
                    The type of record field is S7 (0x5337). The address field contains the starting execution address and is interpreted as a 4-byte address. There is no data field.

                \item[S8]~\\
                    The type of record field is S8 (0x5338). The address field contains the starting execution address and is interpreted as a 3-byte address. There is no data field.

                \item[S9]~\\
                    The type of record field is S9 (0x5339). The address field contains the starting execution address and is interpreted as a 2-byte address. There is no data field.
            \end{description}

            \paragraph{Example}
                ~\\
                \verb'S00600004844521B'\\
                \verb'S1130000285F245F2212226A000424290008237C2A'\\
                \verb'S11300100002000800082629001853812341001813'\\
                \verb'S113002041E900084E42234300182342000824A952'\\
                \verb'S107003000144ED492'\\
                \verb'S5030004F8'\\
                \verb'S9030000FC'

                ~\\This file consists of one S0 record, four S1 records, one S5 record and an S9 record.

            \paragraph{The S0 record is comprised as follows:}
                ~\\
                \begin{itemize}
                    \item S0 S-record type S0, indicating it is a header record.
                    \item 06 Hexadecimal 06 (decimal 6), indicating that six character pairs (or ASCII bytes) follow.
                    \item 00 00 Four character 2-byte address field, zeros in this example.
                    \item 48 44 52 ASCII H, D, and R - "HDR".
                    \item 1B The checksum.
                \end{itemize}

            \paragraph{The first S1 record is comprised as follows:}
                ~\\
                \begin{itemize}
                    \item S1 S-record type S1, indicating it is a data record to be loaded at a 2-byte address.
                    \item 13 Hexadecimal 13 (decimal 19), indicating that nineteen character pairs, representing a 2 byte address, 16 bytes of binary data, and a 1 byte checksum, follow.
                    \item 00 00 Four character 2-byte address field; hexadecimal address 0x0000 where the data which follows is to be loaded.
                    \item 28 5F 24 5F 22 12 22 6A 00 04 24 29 00 08 23 7C Sixteen character pairs representing the actual binary data.
                    \item 2A The checksum.
                \end{itemize}

            \paragraph{The second and third S1 records are comprised as follows:}
                ~\\
                The second and third S1 records each contain 0x13 (19) character pairs and are ended with checksums of 13 and 52, respectively. The fourth S1 record contains 07 character pairs and has a checksum of 92.

            \paragraph{The S5 record is comprised as follows:}
                ~\\
                \begin{itemize}
                    \item S5 S-record type S5, indicating it is a count record indicating the number of S1 records
                    \item 03 Hexadecimal 03 (decimal 3), indicating that three character pairs follow.
                    \item 00 04 Hexadecimal 0004 (decimal 4), indicating that there are four data records previous to this record.
                    \item F8 The checksum.
                \end{itemize}

            \paragraph{The S9 record is comprised as follows:}
                ~\\
                \begin{itemize}
                    \item S9 S-record type S9, indicating it is a termination record.
                    \item 03 Hexadecimal 03 (decimal 3), indicating that three character pairs follow.
                    \item 00 00 The address field, hexadecimal 0 (decimal 0) indicating the starting execution address.
                    \item FC The checksum.
                \end{itemize}

    \subsection{Code Listing}
        Code listing serves as an additional information about the assembled code and the progress of the assembly process. It contains information about all symbols defined in the code. Where and how they have been defined, what are their values and whether they are used in the code. Also detailed information about all macros defined in the code and/or expanded in the code. Conditional compilation configuration, instruction opcodes, address space reservations, inclusion of code from other files. And all warnings, errors, and notes generated during the assembly by the assembler. There are assembler directives which alters formatting of the code listing file.

        \subsubsection{A simple code listing.}
            ~\\
            \verb'                         1     ; Comment.'\\
            \verb'                         2             org     0'\\
            \verb'                         3'\\
            \verb'0000 01001               4     main:   load    s0, #1'\\
            \verb'0001 01102               5             load    s1, #2'\\
            \verb'0005 01203               6             load    s2, #3'\\
            \verb'0007 3E000               7             jump    main'\\
            \verb'                         8'\\
            \verb'                         9             end'\\

        Code listing contains entire source code which has been assembled but with each line prefixed with line number and some additional information which will be explained later. Each line of the code listing which contains an original source code line may contain besides line number also some additional information regarding the compilation of the given line of code. Such a additional information might look like this and is composed of these parts:

        \subsubsection{Format of code listing}
            ~\\
            \verb'  '{\color{highlight_lst_number}\verb'00055'}\verb'                  '{\color{highlight_lst_line}\verb'1'}\verb'      '{\color{highlight_comment}\verb'X           EQU         0x55'}\\
            \verb'                         '{\color{highlight_lst_line}\verb'2'}\verb'      '{\color{highlight_comment}\verb'            INCLUDE     "file.asm"'}\\
            {\color{highlight_lst_address}\verb'0007'}\verb' '{\color{highlight_lst_code}\verb'00100'}\verb'      '{\color{highlight_label}\verb'=1'}\verb'       '{\color{highlight_lst_line}\verb'3'}\verb' '{\color{highlight_constant}\verb'+1'}\verb'   '{\color{highlight_comment}\verb'label:      LOAD        S1, S0'}\\
            ~\\
            \colorbox{highlight_lst_number}{\color{highlight_lst_number}X} Expression value\\
            \colorbox{highlight_lst_address}{\color{highlight_lst_address}X} Address in program memory\\
            \colorbox{highlight_lst_code}{\color{highlight_lst_code}X} Machine code\\
            \colorbox{highlight_label}{\color{highlight_label}X} Level of file inclusion\\
            \colorbox{highlight_lst_line}{\color{highlight_lst_line}X} Line number\\
            \colorbox{highlight_constant}{\color{highlight_constant}X} Level of macro expansion\\
            \colorbox{highlight_comment}{\color{highlight_comment}X} Original line

        \clearpage
        \subsubsection{A more complex example of code listing}
            ~\\
            {\color{highlight_lst_number}\verb' 0001C'}{\color{highlight_lst_line}\verb'               1'}\verb'     '{\color{highlight_constant}\verb'abc'}\verb'     '{\color{highlight_directive}\verb'equ'}\verb'     '{\color{highlight_symbol}\verb'('}\verb' '{\color{highlight_unknown_base}\verb'14'}\verb' '{\color{highlight_symbol}\verb'*'}\verb' '{\color{highlight_unknown_base}\verb'2'}\verb' '{\color{highlight_symbol}\verb')'}\verb'      '{\color{highlight_comment}\verb'; Define symbol abc.'}\\
            {\color{highlight_lst_line}\verb'                     2'}\verb'             '{\color{highlight_directive}\verb'org'}\verb'     '{\color{highlight_unknown_base}\verb'0'}\verb'               '{\color{highlight_comment}\verb'; Code at address 0.'}\\
            {\color{highlight_lst_line}\verb'                     3'}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      4'}\verb'             '{\color{highlight_directive}\verb'include'}\verb' '{\color{highlight_string}\verb''\verb"'"\verb'macros.asm'\verb"'"\verb' '{\color{highlight_comment}\verb'; Include macros.asm'}}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      5'}\verb'     '{\color{highlight_comment}\verb'; This is the beginning of file macros.asm.'}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      6'}\verb'     '{\color{highlight_macro}\verb'xyz'}\verb'     '{\color{highlight_directive}\verb'macro'}\verb'    '{\color{highlight_constant}\verb'arg'}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      7'}\verb'             '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's1'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_constant}\verb'arg'}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      8'}\verb'             '{\color{highlight_instruction}\verb'nop'}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'      9'}\verb'             '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_constant}\verb'arg'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's1'}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'     10'}\verb'     '{\color{highlight_directive}\verb'endm'}\\
            {\color{highlight_lst_include}\verb'             =1'}{\color{highlight_lst_line}\verb'     11'}\verb'     '{\color{highlight_comment}\verb'; This is the end of file macros.asm.'}\\
            {\color{highlight_lst_line}\verb'                    12'}\\
            {\color{highlight_lst_line}\verb'                    13'}\verb'     '{\color{highlight_label}\verb'main:'}\verb'   '{\color{highlight_macro}\verb'xyz'}\verb'     '{\color{highlight_sfr}\verb's0'}\verb'          '{\color{highlight_comment}\verb'; Expand macro xyz here.'}\\
            {\color{highlight_lst_address}\verb'0000'}{\color{highlight_lst_code}\verb' 00100'}{\color{highlight_lst_line}\verb'          14'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's1'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's0'}\\
            {\color{highlight_lst_address}\verb'0002'}{\color{highlight_lst_code}\verb' 00000'}{\color{highlight_lst_line}\verb'          15'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'nop'}\\
            {\color{highlight_lst_address}\verb'0003'}{\color{highlight_lst_code}\verb' 00010'}{\color{highlight_lst_line}\verb'          16'}{\color{highlight_lst_macro}\verb' +1'}\verb'                  '{\color{highlight_instruction}\verb'load'}\verb'     '{\color{highlight_sfr}\verb's0'}{\color{highlight_oper_sep}\verb','}\verb' '{\color{highlight_sfr}\verb's1'}\\
            {\color{highlight_lst_address}\verb'0005'}{\color{highlight_lst_code}\verb' 22000'}{\color{highlight_lst_line}\verb'          17'}\verb'             '{\color{highlight_instruction}\verb'jump'}\verb'    '{\color{highlight_constant}\verb'main'}\verb'        '{\color{highlight_comment}\verb'; Jump back to main:.'}\\
            {\color{highlight_lst_line}\verb'                    18'}\verb'             '{\color{highlight_directive}\verb'end'}\verb'                 '{\color{highlight_comment}\verb'; End of assembly.'}

\clearpage
\section{Assembler messages}
    This chapter lists the messages generated by the MDS assembler. The following sections include a brief description of the possible error and warning messages along with a description of the error or warning and any corrective actions you can take to avoid or eliminate the error or warning. Errors terminate the assembly and generate a message that is displayed on the console. Warnings generate a message that is displayed on the console but do not terminate the assembly. All messages are recorded in the code listing file.

    \begin{description}
        \item[Unable to open file: X]~\\
            The given file (X) cannot be opened, probably does not exist or your operating system refuses to grad the access to it. Check whether the file exists, and check your permissions.
        \item[Unable to write to file: X]~\\
            It is not possible to write into the given file (X). This is in most cases caused by wrong permissions set on the file or directory, or nonexistent directory in the file path.
        \item[Unable to save file: X]~\\
            The given file (X) cannot be saved. This might indicate that there is something badly wrong, like not enough space left on your storage device (HDD, etc.).
        \item[The resulting machine code is too big to be stored in a file]~\\
            Size of the resulting machine code is bigger than your processor could handle in its current configuration.
        \item[Some of the source code files were apparently changed during compilation]~\\
            Please do not change source files during the compilation, wait for the compilation finish first.
        \item[User defined memory limit for X memory exceeded]~\\
            You have exceeded boundary of some memory space (X) defined by the \texttt{LIMIT} directive.
        \item[Instruction X requires operand \#Y to be of type(s) Z ...]~\\
            This means for example that you are trying to use a symbol defined as port address in place of register address. ``\#Y'' stands for operand number, starting from 1.
        \item[Macro not defined: X]~\\
            The macro you are attempting to use (X) has not (yet) been defined, possibly you are trying to expand a macro before its definition.
        \item[Too many arguments given, expecting at most X arguments]~\\
            Directives require certain number of arguments, when you provide a different number of arguments, the directive makes no sense to the assembler.
        \item[Attempting to use unavailable space in X memory at address: Y]~\\
            Suppose you have 8 registers and you try for example to write to register at address 10, then the assembler will give you this error. The same, of course, apply also to program memory, or any other memory space.
        \item[The last error was critical, compilation aborted]~\\
            Normally the assembler tries to carry on compiling for as long as possible despite errors, it is implemented that way to provide you with as many error message at the time as possible. But in certain cases compilation has to aborted instantaneously.
        \item[Device not supported: X]~\\
            The given processor (X) is not supported, this usually happens due to some typo.
        \item[Device specification code is already loaded ]~\\
            The processor architecture has to be specified only once, multiple specifications for one source code would not make sense, they could "collide" with each other.
        \item[Limit value X is not valid]~\\
            Invalid memory size limit for the \texttt{LIMIT} directive, only -1, 0, and positive integers are valid.
        \item[Directive `LOCAL' cannot appear outside of macro definition ]~\\
            Directive \texttt{LOCAL} can be only used inside macro definition, outside macro definition it has no meaning and therefore cannot be used.
        \item[Directive `EXITM' cannot appear outside macro definition]~\\
            Directive \texttt{EXITM} can be only used inside macro definition, outside macro definition it has no meaning and therefore cannot be used.
        \item[Maximum macro expansion depth (X) reached]~\\
            Macros can be expanded in other macros, and they can be expanded in other macros, and so on. To avoid infinite loops or other kinds of undesirable behavior related to macro expansion occurring in another macro expansion, the assembler limits maximum depth of macro expansion. You can change your compiler settings and allow higher expansion depth. By default, maximum macro expansion depth is set to 1024.
        \item[Maximum file inclusion depth (X) reached]~\\
            A source file may include another source file(s) using the \texttt{INCLUDE} directive, and these files can in the same way include other source files, and so on. Although cycles in the inclusion tree (infinite loop of inclusion) are checked for by the assembler, and theoretically cannot possibly happen, the assembler limits maximum inclusion depth by default to 1024 for stability reasons. You can change your compiler settings and allow higher inclusion depth.
        \item[Maximum number of \#WHILE directive iterations (X) reached]~\\
            When using the \texttt{\#WHILE} directive, it is easy, by mistake, to make it an enormously long loop, or even an infinite loop; in order to prevent that from happening, the assembler limits maximum number of the \#while loop iterations to 1024.
        \item[Maximum number of REPEAT directive iterations (X) reached]~\\
            When using the \texttt{REPEAT} directive, it is easy, by mistake, to make it an enormously long loop, or even an infinite loop; in order to prevent that from happening, the assembler limits maximum number of the repeat loop iterations to 1024.
        \item[Instruction word is only X bits wide, value Y trimmed to Z]~\\
            You have exceeded instruction word length, opcode value has been trimmed from left to X bits which reduces value Y to value Z.
        \item[Symbol already defined: X]~\\
            The given symbol (X) has already been defined, there cannot coexist two or more symbols with the same name in one compilation unit.
        \item[Symbol not defined: X]~\\
            The given symbol has not been defined, maybe you are trying to use it prior to its definition.
        \item[Symbol X already defined with type Y]~\\
            The given symbol has been already defined with type Y, you are trying to define two or more symbols with the same name but with different types. This is not allowed in this assembler, such practice often tends to lower software quality.
        \item[Undefined value]~\\
            You are attempting to use some value whose numerical representation is unknown to the assembler.
        \item[Real numbers are not supported in this assembler]~\\
            Real numbers (1.8, 22.65, etc.) are not supported by this assembler.
        \item[Undefined symbol: X]~\\
            Symbol X has been undefined, i.e. deleted from the symbol table using the \texttt{UNDEFINE} directive and therefore can be no longer used.
        \item[This value is not valid inside of expression ]~\\
            Expressions in this assembler can be calculated only from integer values; other values like strings, etc. are not allowed.
        \item[Division by zero]~\\
            During evaluation of an expression, the assembler encountered division by zero. Division by zero results in value not representable by this assembler therefore is reported as error. Examples of such case might be: ``\texttt{LOAD S0, \#10 / 0}'', or ``\texttt{A  EQU  ( 2 * A / B ) ; where B = 0}''.
        \item[Unable to resolve this expression]~\\
            The given expression cannot be resolved, please check if the expression is syntactically correct.
        \item[Syntax not understood]~\\
            There is a syntax error in your source code; in this case, the error is completely ununderstandable for the assembler.
        \item[Character constant has to have 8 bits]~\\
            Character constants are supposed to be only one letter long.
        \item[Unterminated string or character constant]~\\
            Strings and character constants start with ``\texttt{"}'' respectively ``\texttt{'}'', and has to end with the same character, i.e. ``\texttt{"}'' respectively ``\texttt{'}''. In this case you have apparently left a string or character constant unterminated by the appropriate character.
        \item[Unrecognized escape sequence: X]~\\
            Escape sequence X was not understood by the assembler, please check the table of escape sequences for reference (section \ref{Escape sequences}).
        \item[No file name specified]~\\
            You probably forgot to specify name of file for the \texttt{INCLUDE} directive.
        \item[Unable to open the specified file: X]~\\
            The specified file (X) cannot be opened, probably does not exists or your operating system refuses to grad you access to it. Please check whether the file exists, and check your permissions.
        \item[Unrecognized token: X]~\\
            Lexical analyzer was unable to recognize this token (X). Normally this does not happen; but if your code contains some binary values with no printable representation or something like that, this may happen.
        \item[Maximum number of messages reached, suppressing compiler message...]~\\
            Source code contains a huge number of errors, further error messages are from now on suppressed in order to prevent enormous size of code listing file, and enormous and impractical assembler console output.
        \item[Macro expansion has been disabled, macro X will not be expanded]~\\
            The given macro (X) cannot be expanded because macro expansion has been temporarily disabled by \texttt{NOEXPAND} directive. You can use \texttt{EXPAND} directive to re-enable the macro expansion.
        \item[Parameter X substituted for blank value]~\\
            Macro parameters are optional, those parameters which has not been substituted with arguments are filled with blank values. Parameters can be checked if they are ``blanks'' using the \texttt{\#IFB} and \texttt{\#IFNB} directives.
        \item[Symbol X already declared as local]~\\
            You are trying to declare a symbol as local macro symbol, which itself is perfectly valid operation unless you do it multiple times for the same symbol.
        \item[Reusing already reserved space in X memory at address: Y]~\\
            There is a collision in two different attempts to utilize certain location in memory space. For instance with the \texttt{ORG} directive you can easily, by mistake, attempt to put two instruction at the same location in the program memory. Or using the \texttt{REG} directive you can also, by mistake, use the same register for two completely different things which could result in "mysterious" behavior of your program.
        \item[Limit value -1 means unlimited]~\\
            Using -1 as size argument for the \texttt{LIMIT} directive removes the limit set by that directive, there is nothing bad about that but the assembler notifies you about it just to make sure you know what you are doing.
        \item[Symbol X declared as local but never used, declaration ignored]~\\
            What is the point of having a local symbol inside a macro and do not use it? This is not an error but its possible side effect from some error or mistake, that is why the compiler warns you about it.
        \item[Comparing two immediate constants, result is always X]~\\
            When using autogenerated run-time conditions, it does not make sense to write a condition which result is always known in advance, that is why you get this warning message. Please check if you are using correct addressing modes.
        \item[Sign overflow. Result is negative number lower than the lowest negative...]~\\
            Two's complement signed arithmetic overflow occurred during expression evaluation.
        \item[File name contains a null character]~\\
            This is a very unlikely error message, it means that the provided file name contains an invalid character, in this case it is the NULL character.
        \item[Result is negative number X, this will be represented as X-bit number...]~\\
            Result is negative number, in two's complement signed arithmetic that means that the number contains binary ones in high order bits; after the value is trimmed to fit binary width required for the specific purpose, it might result in a different value (even a positive number).
        \item[Value out of range, allowed range is {[X,Y]} (trimmed to Z bits) which makes it N]~\\
            Value exceeds the required range for the specific purpose.
        \item[Architecture not supported for the selected language]~\\
            The specified processor architecture is not supported by this compiler for the selected programming language, this cannot normally happen.
        \item[Programming language not supported]~\\
            The specified programming language is not supported by this compiler, this does not normally happen.
        \item[Failure: X]~\\
            This message indicates some kind of low-level failure, something wrong with your operating system, etc. This does not normally happen.
        \item[Programming language not specified]~\\
            Since this compiler is implemented in a way that it can be extended with support for additional programming languages via compiler modules, programming language has to be specified as a compilation option.
        \item[Target architecture not specified]~\\
            Since this compiler is implemented in a way that it can be extended with support for additional target processor architectures via compiler modules, target architecture has to be specified as a compilation option.
        \item[Source code file not specified]~\\
            You are trying to compile something but you did not provide any input file name.
        \item[Empty string used as source code file name]~\\
            If you are running the compiler from a script, this probably indicates an error in that script; otherwise, it should not normally happen.
        \item[File not found: X]~\\
            Some of the specified source files does not exist.
        \item[Invalid unicode character: X]~\\
            Invalid value used for Unicode escape sequence, please check the Unicode table for reference.
        \item[Too big number: X]~\\
            Some numeric literal in your source code represents a value too high to be usable in the compiler's internal logic.
        \item[Invalid token: X]~\\
            Compiler's lexical analyzer encountered a token which it cannot use.
        \item[Identifier cannot start with a digit: X]~\\
            Assembler encountered a token which it cannot recognize; in this case it might be a numeric literal, or an identifier. For example: ``0abc'' might be meant as hexadecimal number but correct syntax is with radix specifier, i.e.: 0x0abc or 0abcH; or it may be identifier (like a label or so) but in that case it cannot start with a digit.
        \item[Too many arguments given to macro X, expecting at most Y argument(s)]~\\
            You have defined some macro with parameters (X), this macro is defined with certain number (Y) of parameters. When you expand this macro with lower number of arguments than is the number of parameters, the remaining parameters will be filled with ``blank'' values; but when you provide higher number of arguments, the compiler will not know what to do with them.
        \item[String already defined: X]~\\
            You are attempting to override, already defined character string (X). Character strings are defined with the \texttt{STRING} directive.
        \item[Blank value]~\\
            Blank value used in expression; since blank values are not numbers, they cannot be use for calculations. Blank values are automatically generated by the assembler when some of macro parameters was not substituted with the corresponding argument.
        \item[This value is not valid inside an expression]~\\
            This indicates an attempt to use nonnumerical value (like a string) in an expression. Since such value is not a number, it cannot be use for calculation.
        \item[Invalid number of operands, instruction X takes Y operand(s)]~\\
            Each instruction takes an exact number of operands; for example \texttt{LOAD} always takes two operands, it cannot be used with only one operand, or with three, four, etc. operands.
        \item[Invalid number of operands, instruction X takes Y or Z operand(s)]~\\
            Each instruction takes an exact number of operands; for example \texttt{LOAD} always takes two operands, it cannot be used with only one operand, or with three, four, etc. operands.
        \item[Cannot declare a label before X directive]~\\
            For various reasons with certain directives it is not allowed to define a label at the same line.
        \item[Directive X requires a single argument]~\\
            This means that directive X cannot be used with different number of arguments than one.
        \item[Directive X takes no arguments]~\\
            This means that directive X cannot be used with different number of arguments than zero.
        \item[Directive X requires an identifier for the symbol (or macro) which it defines]~\\
            Symbol, string, and macro definition directives always require name of the symbol, string, or macro which they are suppose to define.
        \item[Directive X requires `AT' operator before the start address]~\\
            Missing ``\texttt{AT}'' operator, please refer to the directive syntax for details.
        \item[Comma (`,') expected between operands]~\\
            There is a syntax error in your code, and the assembler guesses that it might be caused by missing comma between instruction operands.
        \item[Instruction not supported on the this device: X]~\\
            Various processors have various instruction sets, this error message indicates that you are trying to use some instruction (X) which is not supported by the processor you are compiling your code for.
        \item[No user defined limit for the program memory size, fail jump cannot be used]~\\
            When using the \texttt{FAILJMP} directive (or similar directive), there has to be defined exact size of the program memory. Otherwise, the assembler cannot know up to which address it is supposed to fill the program memory with \texttt{JUMP}s.
        \item[Invalid size: X]~\\
            Size cannot be zero or negative number.
        \item[Cannot merge DATA memory (SPR) with the CODE memory at address: X]~\\
            When using the \texttt{MERGESPR} directive, the merge address has to be valid. Zero and negative numbers are not valid: zero would collide with the reset address, and negative number does not make sense at all.
        \item[Address is crossing CODE memory size boundary: Y]~\\
            When using the \texttt{MERGESPR} directive, the merge address has to be within boundaries of the progra memory space.
        \item[Directive `EXITM' cannot appear inside special macro...]~\\
            Directive \texttt{EXITM} cannot appear inside special macro because it would break its pairing rules. Special macros include directives: \texttt{IF}, \texttt{ELSEIF}, \texttt{ELSE}, \texttt{FOR}, and \texttt{WHILE}. Term pairing rules refers to pairing of \texttt{IF--ENDIF}, \texttt{FOR--ENDFOR}, and \texttt{WHILE--ENDWHILE}.
        \item[Only one fail jump may be specified in the code]~\\
            When using the \texttt{FAILJMP} directive (or similar directive), it may be used only once in the compilation unit. Multiple usage of such directive would result either in mutual overrides or in collisions, for that reason it is not allowed.
        \item[String X not defined]~\\
            You are attempting to use a string (X) which has not been defined in the table strings using the \texttt{STRING} directive. Probably this is just a typo, please check if you are using the correct syntax for the \texttt{OUTPUTK} or \texttt{LOAD \& RETURN} instruction.
        \item[Assembler feature X is supported only on X and higher]~\\
            Certain special assembler features like autogenerated run-time conditions, etc. are supported only on certain processors because they dependent on specific instructions.
        \item[Attempting to override string: X]~\\
            A string defined using the \texttt{STRING} directive, would be overridden by symbol. This action is not allowed.
        \item[Attempting to override symbol: X]~\\
            A symbol defined using the \texttt{EQU}, \texttt{SET}, etc. directive, would be overridden by string (\texttt{STRING} directive). This action is not allowed.
        \item[Redefinition of macro X, original definition is at: Y]~\\
            This indicates that the macro X originally defined at location Y, will be overridden by this definition, expansions of this macro from this line on will use the new definition, while the preceding expansions will not be affected.
        \item[Macro parameter X eclipses global symbol Y, defined at: Z]~\\
            This message means that your macro uses a parameter with the same name as some of the already defined symbols. There is nothing wrong with that but it is generally better to avoid it.
        \item[Macro parameter X eclipses global symbol Y]~\\
            This message means that your macro uses a parameter with the same name as some of the already defined symbols. There is nothing wrong with that but it is generally better to avoid it.
        \item[Argument \#X not used]~\\
            Expression defined using the \texttt{DEFINE} directive contains parameter which is not used during the expression evaluation.
        \item[Exact device not specified, using X by default]~\\
            If you do not use the \texttt{DEVICE} directive to specify the exact processor, assembler will use something (X) by default.
        \item[Processor type (X) should be specified without double quotes...]~\\
            The \texttt{DEVICE} takes processor name as it argument, the processor name should not be enclosed by ``\texttt{"}'' (double quote) characters.
        \item[Reuse of iterator register in nested for loop]~\\
            The two loops will affect each other via their iterator registers.
        \item[Comparing a register with itself, result is always X]~\\
            Result your autogenerated run-time condition is always known in advance because it compares the given register with the same register.
        \item[Register is expected here but given type is: X]~\\
            Only register addresses are recommended for the \texttt{FOR} loops iterators.
        \item[Generic number is expected here but given type is: X]~\\
            Only generic numbers are recommended for specifying the \texttt{FOR} loops intervals.
        \item[No target file for SPR initialization specified]~\\
            When you wish the compiler to perform scratch-pad memory initialization, you either need to specify target file for the initialization, or specify merge address in the program memory.
        \item[Jump address is not specified by a label]~\\
            When using the \texttt{FAILJMP} directive, argument for this directive is recommended to be a ``label''.
        \item[Instruction word is only X bits wide, value Y trimmed to Z]~\\
            When using the \texttt{DB} directive to directly initialize the program memory, values exceeding bit width of the instruction opcode on your processor are automatically trimmed from left to fit the opcode width.
        \item[Unable to locate file X in base path Y, or include path(s): Z]~\\
        \item[File X is already opened, you might have an "include" loop in your code]~\\
        \item[I/O error, cannot read the source file properly]~\\
    \end{description}
