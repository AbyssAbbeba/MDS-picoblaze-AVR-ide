\definecolor{asmdirective_bg}{rgb}{0.7, 1.0, 0.7}
\newcommand{\asmdirective}[1]{~\\[7pt]\addcontentsline{toc}{subsection}{#1}\colorbox{asmdirective_bg}{\parbox{\dimexpr\textwidth-2\fboxsep}{\color{black}\textbf{#1}}}\bigskip}

Assembler directives are commands for the assembler executed at compilation time, their purpose is to instruct the assembler how to compile your code, to define constants, implement conditional compilation, and evaluate various things at compilation time.

\asmdirective{INCLUDE}
    Compiler copies content of the specified file to line where this directive is used. Included files can include other files. Path of the included file might be specified as either absolute or relative; in case of relative path, the path is always relative to location of file in which the INCLUDE directive appears and optionally to any of the include path list specified as assembler option.

    \subsubsection{Syntax}
        \verb'    INCLUDE "file_name"'

    \subsubsection{Examples}
        \verb'    INCLUDE "some_file.asm"'\\
        \verb'    INCLUDE "sub_dir/another_file.asm"'\\
        \verb'    INCLUDE "C:/my_dir/my_file.asm"'\\
        \verb'    INCLUDE "C:\\my_dir\\my_file.asm"'\\
        \verb'    INCLUDE "/home/user/project/file.asm"'

\asmdirective{EQU}
    EQU stands for EQUals, it defines a symbol and assigns it a numerical value. Such symbol is considered constant and therefore cannot be redefined. Constant symbols defined with directive EQU can be used as register addresses, port addresses, and many others.

    \subsubsection{Syntax}
        \verb'    <symbol> EQU <expression>'

    \subsubsection{Examples}
        \verb'    First_symb   EQU   0b10011100        ; Binary.'\\
        \verb'    Second_symb  EQU   47                ; Decimal.'\\
        \verb'    Third_symb   EQU   0x39              ; Hexadecimal.'\\
        \verb'    Fourth_symb  EQU   (A - 4) + 18 / B) ; An expression.'\\
        \verb'    Fifth_symb   EQU   0x09 << 2         ; Another expression.'\\
        \verb''\\
        \verb'                 LOAD  S0, #First_symb   ; Loads S0 register with 0b10011100.'

\asmdirective{CONSTANT}
    This directive is nothing more or less than the EQU directive with another syntax.

    \subsubsection{Syntax}
        \verb'    CONSTANT <symbol>, <expression>'

\asmdirective{SET}
    The SET directive does the same thing as the EQU directive, the only difference is that symbols defined with SET are re-definable while symbols defined with EQU are constant.

    \subsubsection{Syntax}
        \verb'    <symbol> SET <expression>'

    \subsubsection{Examples}
        \verb'    my_symbol SET   0x10           ; my_symbol = 0x10'\\
        \verb'              LOAD  S0, #my_symbol ; Loads S0 register with immediate value 0x10.'\\
        \verb''\\
        \verb'    my_symbol SET   0x20           ; re-defining my_symbol to new value: 0x20'\\
        \verb'              LOAD  S0, #my_symbol ; Loads S0 register with immediate value 0x20.'

\asmdirective{VARIABLE}
    This directive is nothing more or less than the SET directive with another syntax.

    \subsubsection{Syntax}
        \verb'    VARIABLE <symbol>, <expression>'

    \subsubsection{Examples}
        \verb'    VARIABLE  First_symb, 0b10011100        ; Binary.'\\
        \verb'    VARIABLE  Second_symb, 47               ; Decimal.'\\
        \verb'    VARIABLE  Third_symb, 0x39              ; Hexadecimal.'\\
        \verb'    VARIABLE  Fourth_symb, (A -4)+ 18 / B)  ; An expression.'\\
        \verb'    VARIABLE  Fifth_symb, 0x09 << 2         ; Another expression.'\\
        \verb''\\
        \verb'    LOAD      S0, #First_symb               ; Loads S0 with 0b10011100.'

\asmdirective{REG}
    Symbols defined with the REG directive are considered to be register addresses only and cannot be used for anything else, except for that REG is just another EQU.

    \subsubsection{Syntax}
        \verb'    <symbol> REG <address>'

    \subsubsection{Examples}
        \verb'    A_reg  REG    s1'\\
        \verb'    B_reg  REG    s2'\\
        \verb'    C_reg  REG    s3'\\
        \verb'    D_reg  REG    0x4'\\
        \verb'    E_reg  REG    0x5'\\
        \verb''\\
        \verb'           LOAD   A_reg, D_reg  ; S0 = S5'\\
        \verb'           LOAD   B_reg, #0x55  ; S2 = 0x55'

\asmdirective{NAMEREG}
    This directive is nothing more the REG directive with another syntax.

    \subsubsection{Syntax}
        \verb'    NAMEREG <symbol>, <address> '

    \subsubsection{Examples}
        \verb'    NAMEREG     a, s1'\\
        \verb'    NAMEREG     b, s2'\\
        \verb'    NAMEREG     x, s3'\\
        \verb'    NAMEREG     y, 4'\\
        \verb'    NAMEREG     z, 0xA'
        \verb''\\
        \verb'    LOAD        a, b         ; S1 = S2'\\
        \verb'    LOAD        x, #0x55     ; S3 = 0x55'

\asmdirective{DATA}
    Symbols defined with the DATA directive are considered to be scratch-pad ram addresses only and cannot be used for anything else, except for that DATA is just another EQU.

    \subsubsection{Syntax}
        \verb'    <symbol> DATA <expression>'

    \subsubsection{Examples}
        \verb'    my_location   PORT    0x12'\\
        \verb''\\
        \verb'                  STORE   S0, my_location'

\asmdirective{CODE}
    Symbols defined with the CODE directive are considered to be program memory addresses only and cannot be used for anything else, except for that CODE is just another EQU.

    \subsubsection{Syntax}
        \verb'    <symbol> CODE <expression>'

    \subsubsection{Examples}
        \verb'    somewhere     CODE    0x3ff'\\
        \verb'                  ; ...'\\
        \verb'                  ORG     somewhere'\\
        \verb'                  ; ...'\\
        \verb'                  CALL    somewhere'

\asmdirective{PORT}
    Symbols defined with the PORT directive are considered to be port addresses only and cannot be used for anything else, except for that PORT is just another EQU.

    \subsubsection{Syntax}
        \verb'    <symbol> PORT <expression>'

    \subsubsection{Examples}
        \verb'    my_port       PORT    0x22'\\
        \verb''\\
        \verb'                  OUTPUT  S0, my_port'

\asmdirective{AUTOREG}
    It will automatically assign a register at some address starting from 0x00 which is incremented with every other AUTOREG directive. Optionally, you can change starting address counter by adding a parameter after AUTOREG directive. Symbols defined with this directive have the same purpose and limitations as if they were defined with the REG directive. You can check assigned registers in code listing (file .lst) and symbol table (file .sym). This directive may save you some time, you can use it when you don't care which exact register will be used.

    \subsubsection{Syntax}
        \verb'    <symbol> AUTOREG [<address>]'

    \subsubsection{Examples}
        \verb'    reg_1  AUTOREG                ; reg_1 = 0'\\
        \verb'    reg_2  AUTOREG                ; reg_2 = 1'\\
        \verb'    reg_3  AUTOREG                ; reg_3 = 2'\\
        \verb'    reg_4  AUTOREG  10            ; Start counting from 10 so reg_4 =10'\\
        \verb'    reg_5  AUTOREG                ; my_reg_5 = 11'
        \verb''\\
        \verb'           LOAD     reg_3, reg_4  ; S2 = SA'\\
        \verb'           LOAD     reg_1, #0x22  ; S0 = 0x22'

\asmdirective{AUTOSPR}
    This directive provides exactly the same functionality as the AUTOREG directive but for addresses in scratch-pad ram. Symbols defined with this directive have the same purpose and limitations as if they were defined with the DATA directive.

    \subsubsection{Syntax}
        \verb'    <symbol> AUTOSPR [<address>]'

    \subsubsection{Examples}
        \verb'    my_data  AUTOSPR'\\
        \verb''\\
        \verb'             STORE    S0, my_data'

\asmdirective{INITSPR}
    Initializes scratch-pad RAM (SPR) with the given value(s), content of such initialized memory is stored in the Secondary Assembler Output (see the compiler configuration dialog, or command line option --secondary).

    \subsubsection{Syntax}
        \verb'    <symbol> INITSPR <value>'

    \subsubsection{Examples}
        \verb'my_data       INITSPR         "Hello PicoBlaze!"'\\
        \verb'my_data2      INITSPR         0x2b'\\
        \verb''\\
        \verb'              FETCH           S0, my_data'\\
        \verb'              FETCH           S1, my_data + 1'\\
        \verb'              FETCH           S2, my_data + 2'\\
        \verb'              FETCH           S3, my_data + 3'\\
        \verb''\\
        \verb'              FETCH           S8, my_data2'

\asmdirective{ORGSPR}
    Specify address of origin for scratch-pad RAM initialization (directive INITSPR).

    \subsubsection{Syntax}
        \verb'    ORGSPR <address>'

    \subsubsection{Examples}
        \verb'              ORGSPR          0x10'\\
        \verb'my_data       INITSPR         "Hello PicoBlaze!" ; <-- address assigned to my_data is 0x10'\\
        \verb''\\
        \verb'              FETCH           S0, my_data'\\
        \verb'              FETCH           S1, my_data + 1'\\
        \verb'              FETCH           S2, my_data + 2'

\asmdirective{MERGESPR}
    Merge scratch-pad RAM initialization with program memory initialization at the specified address.

    \subsubsection{Syntax}
        \verb'    MERGESPR <address>'

    \subsubsection{Examples}
        \verb'              MERGESPR        0x280'\\
        \verb'my_data       INITSPR         "Hello PicoBlaze!"'\\
        \verb''\\
        \verb'              FETCH           S0, my_data'\\
        \verb'              FETCH           S1, my_data + 1'\\
        \verb'              FETCH           S2, my_data + 2'

\asmdirective{STRING}
    Defines a named character string (sequence of characters) which can later be used with ``LOAD \& RETURN'' and ``OUTPUTK'' instructions, and with ``DB'' directive.

    \subsubsection{Syntax}
        \verb'    <symbol> STRING "<string>"'

    \subsubsection{Examples}
        \verb'my_string     STRING          "Hello PicoBlaze!"'\\
        \verb''\\
        \verb'              LOAD & RETURN   S0, my_string'\\
        \verb'              OUTPUTK         my_string, 2'\\
        \verb'              DB              my_string'

\asmdirective{DEFINE}
    Define and expression which is evaluated every time separately when used in the code. These expressions can handle unlimited number of parameters, parameters are defined in curly brackets and are numbered from 0 to infinity (in decimal radix), using expressions with parameters resembles calling a function in C language, please see the example below.

    \subsubsection{Syntax}
        \verb'    <symbol> DEFINE <expression>'

    \subsubsection{Examples}
        \verb'    A     EQU     10              ; A = 10 (decimal)'\\
        \verb'    B     SET     25              ; B = 25 (decimal)'\\
        \verb'    C     DEFINE  ( A + B ) * 2   ; Value of C is unknown for now.'\\
        \verb''\\
        \verb'          LOAD    S0, #C          ; Load S0 with ( ( 10 + 25 ) * 2 ) = 70.'\\
        \verb''\\
        \verb'    B     SET     11              ; B = 11 (decimal)'\\
        \verb'          LOAD    S0, #C          ; Now load S0 with ( ( 10 + 11 ) * 2 ) = 42.'\\
        \verb''\\
        \verb''\\
        \verb'    X     DEFINE  ( {0} + {1} )   ; Value of C is unknown for now.'\\
        \verb'          LOAD    S0, #X(4, 5)    ; Now load S0 with ( 4 + 5 ) = 9.'

\asmdirective{ORG, ADDRESS}
    The assembler maintains a location counter for program memory, this location counter is incremented with each assembled instruction. With ORG or ADDRESS directive this location counter can be changed to instruct the assembler to start writing the code following the ORG directive at the new location counter position.

    \subsubsection{Syntax}
        \verb'    ORG     <expression>'\\
        \verb'    ADDRESS <expression>'


    \subsubsection{Examples}
        \verb'    ORG   0x3ff             ; Suppose that 0x3ff is the address for ISR.'\\
        \verb'    JUMP  handle_interrupt'

\asmdirective{SKIP}
    Do not initialize the given number of program memory words and skip to the next nearest location.

    \subsubsection{Syntax}
        \verb'    SKIP <expression>'

    \subsubsection{Examples}
        \verb'    ORG   0'\\
        \verb'    LOAD  S0, #0x22  ; Put opcode at address 0x0.'\\
        \verb'    LOAD  S0, #0x22  ; Put opcode at address 0x1.'\\
        \verb'    LOAD  S0, #0x22  ; Put opcode at address 0x2.'\\
        \verb'    LOAD  S0, #0x22  ; Put opcode at address 0x3.'\\
        \verb'    SKIP  5          ; Skip next 5 program memory locations.'\\
        \verb'    LOAD  S0, #0x22  ; Put opcode at address 0x8.'\\
        \verb'    LOAD  S0, #0x22  ; Put opcode at address 0x9.'

\asmdirective{UNDEFINE, UNDEF}
    All symbols can be undefined, undefined symbols are be deleted from the symbol table and compiler will not recognize them.

    \subsubsection{Syntax}
        \verb'    UNDEFINE <symbol>'\\
        \verb'    UNDEF    <symbol>'

    \subsubsection{Examples}
        \verb'    symbol  SET     15'\\
        \verb'            LOAD    S0, #symbol'\\
        \verb'            UNDEF   symbol'\\
        \verb'            LOAD    s0, #symbol  ; This will cause compilation error.'

\asmdirective{DB}
    This directive initializes the program memory directly, it can be used for direct writing of instruction opcodes. Memory is initialized in two different ways: in case of string given as argument to the directive, program memory will be initialized byte by byte; in case of constants and expressions, each constant or expression initializes one instruction word. If instruction word is 18 bits wide, the MSB of the byte triplet will be trimmed to 2 bits, making entire triplet only 18 bits wide instead of 24.

    \subsubsection{Syntax}
        \verb'    ; Expresion syntax'\\
        \verb'    DB  <expression1>  [, <expression2>, ...]'\\
        \verb''\\
        \verb'    ; String syntax'\\
        \verb'    DB <"string">'\\
        \verb''\\
        \verb'    ; Combination of string(s) and expression(s)'\\
        \verb'    DB <"string"> [, <expression1>, ...]'

        Parameter can be unlimited number of string characters, or expressions divided by comma.


    \subsubsection{Examples}
        \verb'    DB  0x060FC                 ; Constant.'\\
        \verb'    DB  "my string"             ; String.'\\
        \verb'    DB  "my string", 2+1, 3     ; Combination of string, expression, and constant.'

\asmdirective{LIMIT}
    Imposes user defined limit on size of register file, scratch-pad ram, or program memory. In the example below if you use 8 registers or JUMP to address higher than 512, compiler reports such attempt as error.

    \subsubsection{Syntax}
        \verb'    LIMIT  D, <number> ; Size of scratch-pad RAM (D stands for data).'\\
        \verb'    LIMIT  R, <number> ; Number of registers (R stands for registers).'\\
        \verb'    LIMIT  C, <number> ; Size of program memory (C stands for code).'

    \subsubsection{Examples}
        \verb'    LIMIT  R, 8   ; Limit maximum register address to 7.'\\
        \verb'    LIMIT  D, 32  ; Limit maximum address in scratch-pad ram to 31. '\\
        \verb'    LIMIT  C, 512 ; Limit maximum address in program memory to 511.'

\asmdirective{DEVICE}
    Normally, you choose the target architecture when you are creating a project. But you can also specify target architecture with DEVICE directive. This will affect predefined symbols.

    \subsubsection{Syntax}
        \verb'    DEVICE <device_name>'

    \subsubsection{Examples}
        \verb'    DEVICE kcpsm6'\\
        \verb'    DEVICE kcpsm3'\\
        \verb'    DEVICE kcpsm2'\\
        \verb'    DEVICE kcpsm1'\\
        \verb'    DEVICE kcpsm1cpld'

\asmdirective{LIST, NOLIST}
    Temporarily turns on and off output to the code listing.

    \subsubsection{Syntax}
        \verb'    LIST    ; Turn code listing ON.'\\
        \verb'    NOLIST  ; Turn code listing OFF.'

    \subsubsection{Examples}
        \verb'    NOLIST'\\
        \verb'    INCLUDE "some_file.asm" ; The included file will not appear in the code listing.'\\
        \verb'    LIST'

\asmdirective{TITLE}
    Set title for code listing.

    \subsubsection{Syntax}
        \verb'    TITLE  "<title text>"'

    \subsubsection{Examples}
        \verb'    TITLE  "My program for something, etc."'

\asmdirective{MESSAGE}
    Print compiler message, the message will be printed by the compiler in the same was as errors and warnings are. Such message, however, is not considered to be neither error nor warning.

    \subsubsection{Syntax}
        \verb'    MESSAGE "some message..."'

    \subsubsection{Examples}
        \verb'    MESSAGE "text text text..."'

\asmdirective{ERROR}
    This directive does the same things as the MESSAGE directive but in this case the printed message is considered as an error and causes the assembler to consider the entire compilation unsuccessful.

    \subsubsection{Syntax}
        \verb'    ERROR "error message"'

    \subsubsection{Examples}
        \verb'    ERROR "my error message"'

\asmdirective{WARNING}
    This directive does the same things as the MESSAGE directive but in this case the printed message is considered as a warning.

    \subsubsection{Syntax}
        \verb'WARNING "warning message"'

    \subsubsection{Examples}
        \verb'WARNING "my warning message"'

\asmdirective{REPT}
    Repeats the specified block of code for the specified number of times.

    \subsubsection{Syntax}
        \verb'    REPT <number-of-repeats>'\\
        \verb'        <code>'\\
        \verb'    ENDR'

    \subsubsection{Examples}
        \verb'    REPT          5'\\
        \verb'        SR0       sF'\\
        \verb'    ENDR'\\
        \verb''\\
        \verb'    ; Equivalent to.'\\
        \verb'    SR0           sF'\\
        \verb'    SR0           sF'\\
        \verb'    SR0           sF'\\
        \verb'    SR0           sF'\\
        \verb'    SR0           sF'

\asmdirective{\#WHILE}
    Repeats the specified block of code until expression equals to zero.

    \subsubsection{Syntax}
        \verb'    #WHILE <expression>'\\
        \verb'        <code>'\\
        \verb'    #ENDW'

    \subsubsection{Examples}
        \verb'    ld          S0, #0xAA       ; (value to output)'\\
        \verb'    ld          S1, #0          ; (starting address)'\\
        \verb''\\
        \verb'    while       S1 < #5         ; C: while ( S1 < 5 ) {'\\
        \verb'        out     S0, @S1         ; C:     S0 = *S1;'\\
        \verb'        inc     S1              ; C:     S1++;'\\
        \verb'    endw                        ; C: }'

\asmdirective{END}
    The END directive informs the assembler that it has reached the end of all source code. Assembler then ignores any code following this directive so everything after this directive is threated as comment.

    \subsubsection{Syntax}
        \verb'    END'

    \subsubsection{Examples}
        \verb'    LOAD  S0, S1'\\
        \verb'    END'\\
        \verb'    LOAD  S0, S1, S2, S3 ; This will not be processed by the assembler.'

\asmdirective{FAILJMP, DEFAULT\_JUMP}
    Fills program memory with jumps to the specified address. Purpose of this directive is to provide a simple means of protection against random errors.

    \subsubsection{Syntax}
        \verb'    FAILJMP     <expression>'\\
        \verb'    DEFAULT_JMP <expression>'

    \subsubsection{Examples}
        \verb'    something_is_wrong:'\\
        \verb'          ; ... do something ...'\\
        \verb''\\
        \verb'    FAILJMP  something_is_wrong'

\clearpage
\section{Code generation directives}
    MDS assembler supports several special directives for automated generation of run-time loops and conditions.

    \paragraph{Loops:} Instead of writing loops with loads, compares, and jumps, you might find it to be more straightforward to use the assembler to generate them for you. You can use three types of FOR loop and one type of WHILE loop.

    \paragraph{Conditions:} Instead of writing conditional branching using compares and jumps, you can let the assembler do at least some this work for you with IF, ELSEIF, ELSE, and ENDIF directives. This feature resembles C language but don't forget that you are still working with assembler, these branching directives are merely a "syntax sugar", they are translated as compare and conditional jump, nothing more.

    \paragraph{Condition syntax}
        ~\\
        \begin{table}[h!]
            \mysmallfont{}
            \centering{}
            \begin{tabular}{|c|c|}
                \hline
                Condition & Example  \\
                \verb'A == B' & \verb'S0 == S1' \\
                \verb'A != B' & \verb'S0 != #0xA5' \\
                \verb'A >  B' & \verb'#(0x5A + 2) > S0' \\
                \verb'A <  B' & \verb'#A < my_reg' \\
                \verb'A >= B' & \verb'A >= #B' \\
                \verb'A <= B' & \verb'S4 <= #B' \\
                \verb'A &  B' & \verb'#A & S0' \\
                \verb'A !& B' & \verb'S0 !& S0' \\\hline
            \end{tabular}
            \caption{Condition syntax used for all code generation directives.}
        \end{table}

        ~\\``A'' and ``B'' can be either register address or immediate value, in case of immediate value it has to be prefixed with ``\#''. So immediate constants are specified with ``\#'' prefix. A value without ``\#'' is considered to be a register address.

    \asmdirective{IF, ELSEIF, ELSE, ENDIF}
        You can use IF, ELSEIF, ELSE, and ENDIF directives for better readability of you code. Assembler translates these directives as predefined macros containing COMPARE, TEST, and JUMP instructions. You can use registers and immediate constants in conditions.

        \subsubsection{Syntax}
            \verb'    IF      <condition>'\\
            \verb'        <code>'\\
            \verb'    ELSEIF  <condition>'\\
            \verb'        <code>'\\
            \verb'    ELSE'\\
            \verb'        <code>'\\
            \verb'    ENDIF'

        \subsubsection{Example}
            \verb'    IF          s0 == #10         ; Register to immediate value.'\\
            \verb'        LOAD    s0, #10h'\\
            \verb'    ELSEIF      B >= S1           ; Register to register.'\\
            \verb'        SR0     s0'\\
            \verb'    ELSE        #0x5 >= #0x6      ; Immediate value to immediate value.'\\
            \verb'        INPUT   s0,RX_data'\\
            \verb'    ENDIF'

            ~\\In this example, the first condition compares register S0 to immediate value of 10 (decimal). The second condition compares register at address given by ``B'' symbol to register S1, and the third condition compares two immediate values (in this case the result of comparison is known in advance and the assembler with exploit that fact and print warning).

    \asmdirective{WHILE}
        Assembler translates the WHILE directive to COMPARE, TEST, and JUMP instructions to implement the loop.

        \subsubsection{Syntax}
            \verb'    WHILE <condition>'\\
            \verb'          <code>'\\
            \verb'    ENDW'

        \subsubsection{Example}
            \verb'    LOAD        S0, #0xAA       ; (value to output)'\\
            \verb'    LOAD        S1, #0          ; (starting address)'\\
            \verb''\\
            \verb'    WHILE       S1 < #5         ; C: while ( S1 < 5 ) {'\\
            \verb'        OUTPUT  S0, @S1         ; C:     S0 = *S1;'\\
            \verb'        INC     S1              ; C:     S1++;'\\
            \verb'    ENDW                        ; C: }'

    \asmdirective{FOR}
        The FOR directive provides another way how to relatively easily write a program loop, it's best demonstrated on examples (see below).

        \subsubsection{Syntax}
            \verb'    FOR   <iterator-register>, <number-of-iterations>'\\
            \verb'          <code>'\\
            \verb'    ENDW'
            \verb''\\
            \verb'    FOR   <iterator-register>, <start> .. <end>'\\
            \verb'          <code>'\\
            \verb'    ENDW'
            \verb''\\
            \verb'    FOR   <iterator-register>, <start> .. <end>, <step>'\\
            \verb'          <code>'\\
            \verb'    ENDW'

        \subsubsection{Examples}
            \verb'    ; In this case, S0 starts from 0 and goes up to 9 (S0 is incremented after each iteration).'
            \verb'    FOR s0, 10'\\
            \verb'        NOP'\\
            \verb'    ENDF'
            \verb''\\
            \verb'    ; In this case, S0 goes from 10 to 15 (6 iterations: 10, 11, 12, 13, 14, 15).'
            \verb'    FOR s0, 10..15'\\
            \verb'        NOP'\\
            \verb'    ENDF'
            \verb''\\
            \verb'    ; In this case, S0 goes from 10 to 50 by steps of 10 (5 iterations: 10, 20, 30, 40, 50).'\\
            \verb'    FOR s0, 10..50, 10'\\
            \verb'        NOP'\\
            \verb'    ENDF'

\clearpage
\section{Macro processing}
    Macro is a sequence of instructions which can be expanded anywhere in the code and for any number of times. That may reduce necessity of repeating code fragments as well as source code size and make the solved task easier to comprehend and solve. Unlike subprograms macros do not add extra run-time overhead, repeating usage of macros may significantly increase size of the resulting machine code. Macros can have no parameters or any number of parameters (number of parameters is unlimited).

    \subsection{Syntax}
        \verb'    MACRO     [<parameter1>]  [,<parameter2>..]'\\
        \verb'        <code>'\\
        \verb'    ENDM'

        \begin{table}[h!]
            \begin{tabular}{|ll|}
                \hline
                MACRO      & Define a new macro. \\
                ENDM       & End of macro definition. \\
                EXITM      & Exit macro expansion. \\
                EXPAND     & Disable macro expansions.\\
                NOEXPAND   & (Re-)enable macro expansions.\\
                \hline
            \end{tabular}
            \caption{Macro processing directives.}
        \end{table}

    \subsection{Examples}
        \paragraph{Macro without parameters}
        ~\\
        \verb'    abc     macro'\\
        \verb'            load    s2, s0'\\
        \verb'            add     s2, #1'\\
        \verb'            load    s1, s2'\\
        \verb'    endm'\\
        \verb''\\
        \verb'            abc           ; Expand macro "abc" here'\\
        \verb'            abc           ; And here...'\\
        \verb'            abc           ; And here...'\\
        \verb''\\
        \verb'    ; This produces the same result as if you wrote this:'\\
        \verb'    ;       load    s2, s0'\\
        \verb'    ;       add     s2, #1'\\
        \verb'    ;       load    s1, s2'\\
        \verb'    ;'\\
        \verb'    ;       load    s2, s0'\\
        \verb'    ;       add     s2, #1'\\
        \verb'    ;       load    s1, s2'\\
        \verb'    ;'\\
        \verb'    ;       load    s2, s0'\\
        \verb'    ;       add     s2, #1'\\
        \verb'    ;       load    s1, s2'\\

        \paragraph{Macro with parameters}
        ~\\
        \verb'abc         macro   x, y'\\
        \verb'            load    x, #y'\\
        \verb'            load    x, y'\\
        \verb'endm'\\
        \verb''\\
        \verb'            abc     s2, 3'\\
        \verb'    ; This produces the same result as if you wrote this:'\\
        \verb'    ;       load    s2, #3'\\
        \verb'    ;       load    s2, 3'

        \paragraph{Premature end of macro expansion}
        ~\\
        \verb'abc         macro   x, y'\\
        \verb'            load    x, #y'\\
        \verb'        #if y > 2'\\
        \verb'            exitm'\\
        \verb'        #endif'\\
        \verb'            load    x, y'\\
        \verb'endm'\\
        \verb''\\
        \verb'            abc     s0, 1'\\
        \verb'    ; This produces the same result as if you wrote this:'\\
        \verb'    ;       load    s0, #1'\\
        \verb'    ;       load    s0, 1'\\
        \verb''\\
        \verb'            abc     s0, 3'\\
        \verb'    ; But this produces different result because of the exitm directive:'\\
        \verb'    ;       load    s0, #1'\\

    \subsection{Local symbols}
        \asmdirective{LOCAL}
            Declares a symbol as local for the macro in which it appears.

            \subsubsection{Syntax}
                \verb'    LOCAL <symbols>'

            \subsubsection{Example}
                \verb'    MACRO            my_macro'\\
                \verb'            LOCAL    wait'\\
                \verb''\\
                \verb'        wait:'\\
                \verb'            SUBCY    S0, #0x10'\\
                \verb'            SUB      S0, #0x01' \\
                \verb'            LOAD     S0, #0xF0'\\
                \verb'            JUMP     C,  wait'\\
                \verb'    ENDM'

\clearpage
\section{Conditional Assembly}
    The aim of conditional assembly to to assemble certain parts of the code if and only if certain arithmetically expressed condition is met. This feature can prove useful particularly when the user want to make the code somehow ``configurable''. This assembler provides these directives to cope with conditional assembly:

    \begin{itemize}
        \item \#IF     <condition>
        \item \#IFN    <condition>
        \item \#IFDEF  <symbol>
        \item \#IFNDEF <symbol>
        \item \#ELSE
        \item \#ELSEIF     <condition>
        \item \#ELSEIFN    <condition>
        \item \#ELSEIFDEF  <symbol>
        \item \#ELSEIFNDEF <symbol>
        \item \#ENDIF
    \end{itemize}

    \subsection{Example}
        ~\\
        {
            \mysmallfont
            \verb'    abc     equ     14           ; Assign number 14 to symbol abc.'\\
            \verb'    xyz     equ     10           ; Assign number 10 to symbol abc.'\\
            \verb''\\
            \verb'    ifdef abc                    ; <--+ Assemble only if symbol abc has been defined.'\\
            \verb'      if ( abc = 13 )            ;    | <--+ Assemble if 13 has been assigned to symbol abc.'\\
            \verb'            load     S0, #0b1101 ;    |    |'\\
            \verb'      elseif ( abc = 14 )        ;    | <--+ Assemble if 14 has been assigned to symbol abc.'\\
            \verb'            load     S0, #0x21   ;    |    |'\\
            \verb'      elseifn ( abc % 2 )        ;    | <--+ Assemble if the value assigned to symbol abc is even.'\\
            \verb'            load     S0, #abc    ;    |    |'\\
            \verb'      else                       ;    | <--+ Else ..'\\
            \verb'            load     S0, #077    ;    |    |'\\
            \verb'      endif                      ;    | <--+'\\
            \verb'    elseifndef xyz               ; <--+ Assemble if symbol xyz has NOT been defined.'\\
            \verb'            clrr     S0          ;    |'\\
            \verb'    else                         ; <--+ Else ...'\\
            \verb'      ifn ( xyz mod 2 )          ;    | <--+ Assemble if ( yxz modulo 2 ) is 0.'\\
            \verb'            load     S0, #128    ;    |    |'\\
            \verb'      endif                      ;    | <--+'\\
            \verb'    endif                        ; <--+'
        }
