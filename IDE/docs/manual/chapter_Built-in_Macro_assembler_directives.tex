

    Assembly directives are instructions that are executed by an assembler at assembly time, not by a CPU at run time. They can make the assembly of the program dependent on parameters input by a programmer, so that one program can be assembled different way, perhaps for different applications. They also can be used to manipulate presentation of a program to make it easier to read and maintain.

    \bigskip

    The specified format for most of the directives is:\\
    \verb'<symbol> <directive> <expression>'

    \bigskip

    This syntax is valid for directives EQU, SET, REG, DATA, CODE, PORT, and DEFINE. MDS also supports some other directives, with different syntax format, which is:\\
    \verb'<directive> <symbol>, <expression>'

    \bigskip

    Those directives are CONSTANT, VARIABLE, ADRESS, and NAMEREG. There are some other useful directives like REPT or WHILE. See description below.

    \clearpage
    \subsection{INCLUDE}
        \subsubsection{Syntax}
            \verb'INCLUDE "<file_name>"'

        \subsubsection{Description}
            Compiler copies content of the specified file to line where this directive is used. Included files can include other files.

        \subsubsection{Examples}
            \verb'INCLUDE "some_file.asm"'\\
            \verb'INCLUDE "sub_dir/another_file.asm"'\\
            \verb'INCLUDE "C:/my_dir/my_file.asm"'\\
            \verb'INCLUDE "C:\\my_dir\\my_file.asm"'\\
            \verb'INCLUDE "/home/AlanTuring/my_project/file.asm"'

    \subsection{EQU}
        \subsubsection{Syntax}
            \verb'<symbol> EQU <expression>'

        \subsubsection{Description}
            The directive EQU stands for EQUals. It allows you to give a numerical value to a symbol. Such symbol is considered constant and therefore cannot be redefined.

        \subsubsection{Examples}
            \verb'First_symb    EQU     0b10011100              ;Number in binary'\\
            \verb'Second_symb   EQU     47                      ;Number in decimal'\\
            \verb'Third_symb    EQU     0x39                    ;Number in hexadecimal'\\
            \verb'Fourth_symb   EQU     (A - 4) + 18 / B)       ;Number with expression'\\
            \verb'Fifth_symb    EQU     0x09 << 2               ;'

    \subsection{CONSTANT}
        \subsubsection{Syntax}
            \verb'CONSTANT <symbol>, <expression>'

        \subsubsection{Description}
            The directive CONSTANT. It allows you to give a numerical value to a symbol. This symbol cannot be redefined.

        \subsubsection{Examples}
            \verb'CONSTANT     First_symb,0b10011100               ;Number in binary'\\
            \verb'CONSTANT     Second_symb,47                      ;Number in decimal'\\
            \verb'CONSTANT     Third_symb,0x39                     ;Number in hexadecimal'\\
            \verb'CONSTANT     Fourth_symb,(A -4)+ 18 / B)         ;Number with expression'\\
            \verb'CONSTANT     Fifth_symb,0x09 << 2                ;'

    \subsection{SET}
        \subsubsection{Syntax}
            \verb'<symbol> SET <expression>'

        \subsubsection{Description}
            The directive SET allows you to give a numerical value to a symbol like EQU but with this symbol can be redefined.

        \subsubsection{Examples}
            \verb'First_symb    SET     0b10011100              ;Number in binary'\\
            \verb'Second_symb   SET     47                      ;Number in decimal'\\
            \verb'Third_symb    SET     0x39                    ;Number in hexadecimal'\\
            \verb'Fourth_symb   SET     (A - 4) + 18 / B)       ;Number with expression'\\
            \verb'Fifth_symb    SET     0x09 << 2               ;'

    \subsection{VARIABLE}
        \subsubsection{Syntax}
            \verb'VARIABLE <symbol>, <expression>'

        \subsubsection{Description}
            Directive VARIABLE is similar to SET but with different syntax. Symbols defined with VARIABLE can be redefined with another value in your source code but those defined with EQU cannot.

        \subsubsection{Examples}
            \verb'VARIABLE     First_symb,0b10011100               ; Number in binary'\\
            \verb'VARIABLE     Second_symb,47                      ; Number in decimal'\\
            \verb'VARIABLE     Third_symb,0x39                     ; Number in hexadecimal'\\
            \verb'VARIABLE     Fourth_symb,(A -4)+ 18 / B)         ; Number with expression'\\
            \verb'VARIABLE     Fifth_symb,0x09 << 2                ;'

    \subsection{REG}
        \subsubsection{Syntax}
            \verb'<symbol> REG <address>'

        \subsubsection{Description}
            Symbols defined with the REG directive are by compiler considered as work registers.

        \subsubsection{Examples}
            \verb'First_symb        REG     s1'\\
            \verb'Second_symb       REG     s2'\\
            \verb'Third_symb        REG     s3'\\
            \verb'Fourth_symb       REG     0x4'\\
            \verb'Fifth_symb        REG     0x5'

        \subsection{NAMEREG}
            \verb'NAMEREG <symbol>, <address> '

        \subsubsection{Description}
            Directive NAMEREG is similar to REG but with different syntax. Symbols defined with NAMEREG can be redefined with another value in your source code.

        \subsubsection{Examples}
            \verb'NAMEREG     s1'\\
            \verb'NAMEREG     s2'\\
            \verb'NAMEREG     s3'\\
            \verb'NAMEREG     4         ; Address'\\
            \verb'NAMEREG     0xA       ; Address'

    \subsection{DATA}
        \subsubsection{Syntax}
            \verb'<symbol> DATA <expression>'

        \subsubsection{Description}
            Symbols defined with the DATA directive are by compiler considered as memory data. It is supposed to be used only with instructions FETCH and STORE.

        \subsubsection{Examples}
            \verb'First_symb    DATA                0b10011100              ; Number in binary'\\
            \verb'Second_symb   DATA                47                      ; Number in decimal'\\
            \verb'Third_symb    DATA                0x39                    ; Number in hexadecimal'\\
            \verb'Fourth_symb   DATA                (A -4)+ 18 / B)         ; Number with expression'\\
            \verb'Fifth_symb    DATA                0x09 << 2               ; Expression'

    \subsection{CODE}
        \subsubsection{Syntax}
            \verb'<symbol> CODE <expression>'

        \subsubsection{Description}
            Symbols defined with the CODE directive are by compiler considered as program memory.

        \subsubsection{Examples}
            \verb'First_symb    CODE                0b10011100              ; Number in binary'\\
            \verb'Second_symb   CODE                47                      ; Number in decimal'\\
            \verb'Third_symb    CODE                0x39                    ; Number in hexadecimal'\\
            \verb'Fourth_symb   CODE                (A -4)+ 18 / B)         ; Expression'\\
            \verb'Fifth_symb    CODE                0x09 << 2               ; Expression'

    \subsection{PORT}
        \subsubsection{Syntax}
            \verb'<symbol> PORT <expression>'

        \subsubsection{Description}
            Symbol defined with this directive is considered to be PORT\_ID identifier.

        \subsubsection{Examples}
            \verb'First_symb    PORT                0x10    '\\
            \verb'Second_symb   PORT                10      '\\
            \verb'Third_symb    PORT                0x2     '\\
            \verb'Fourth_symb   PORT                0x5     '\\
            \verb'Fifth_symb    PORT                0x09 + 2'

    \subsection{AUTOREG}
        \subsubsection{Syntax}
            \verb'<symbol> AUTOREG [<address>]'

        \subsubsection{Description}
            This directive saves time. You can use it when you don't care which work register will be used. It will automatically assign a register at address 0x00, which is incremented with every other AUTOREG directive. Optionally, you can change starting address counter by adding a parameter after AUTOREG directive. You can check assigned registers in code listing (file .lst) and symbol table (file .sym).

        \subsubsection{Examples}
            \verb'First_symb    AUTOREG             ; Automatically assigned, register at address 0x00'\\
            \verb'Second_symb   AUTOREG'\\
            \verb'Third_symb    AUTOREG'\\
            \verb'Fourth_symb   AUTOREG     0x5     ; Now with optional parameter changing counting address to 0x05'\\
            \verb'Fifth_symb    AUTOREG             ; Fifth_symb is on address 0x06'

    \subsection{AUTOSPR}
        \subsubsection{Syntax}
            \verb'<symbol> AUTOSPR [<address>]'

    \subsubsection{Description}
        Must be used only with instructions FETCH and STORE. It will automatically assign an address 0x00, which is incremented with every other AUTOSPR directive. Optionally, you can change starting address counter by adding a parameter after AUTOSPR directive. You can check assigned memory in code listing file(.lst) and symbol table file(.sym).

    \subsubsection{Examples}
        \verb'First_symb    AUTOSPR             ; Automatically assigned, data at address 0x00'\\
        \verb'Second_symb   AUTOSPR'\\
        \verb'Third_symb    AUTOSPR'\\
        \verb'Fourth_symb   AUTOSPR     0x5     ; Now with optional parameter changing counting address to 0x05'\\
        \verb'Fifth_symb    AUTOSPR             ; Fifth_symb is on address 0x06'

    \subsection{INITSPR}
        \subsubsection{Syntax}
            \verb'<symbol> INITSPR <value>'

        \subsubsection{Description}
            Initializes scratch-pad RAM (SPR) with the given value(s), content of such initilized memory is stored in the Secondary Assembler Output (see the compiler configuration dialog, or command line option --secondary).

        \subsubsection{Examples}
            \verb'my_data       INITSPR         "Hello PicoBlaze!"'\\
            \verb'my_data2      INITSPR         0x2b'\\
            \verb''\\
            \verb'              FETCH           S0, my_data'\\
            \verb'              FETCH           S1, my_data + 1'\\
            \verb'              FETCH           S2, my_data + 2'\\
            \verb'              FETCH           S3, my_data + 3'\\
            \verb''\\
            \verb'              FETCH           S8, my_data2'

    \subsection{ORGSPR}
        \subsubsection{Syntax}
            \verb'ORGSPR <address>'

        \subsubsection{Description}
            Specify address of origin for scratch-pad RAM initialization (directive INITSPR).

        \subsubsection{Examples}
            \verb'              ORGSPR          0x10'\\
            \verb'my_data       INITSPR         "Hello PicoBlaze!" ; <-- address assigned to my_data is 0x10'\\
            \verb''\\
            \verb'              FETCH           S0, my_data'\\
            \verb'              FETCH           S1, my_data + 1'\\
            \verb'              FETCH           S2, my_data + 2'

    \subsection{MERGESPR}
        \subsubsection{Syntax}
            \verb'MERGESPR <address>'

        \subsubsection{Description}
            Merge scratch-pad RAM initialization with program memory initialization at the specified address.

        \subsubsection{Examples}
            \verb'              MERGESPR        0x280'\\
            \verb'my_data       INITSPR         "Hello PicoBlaze!"'\\
            \verb''\\
            \verb'              FETCH           S0, my_data'\\
            \verb'              FETCH           S1, my_data + 1'\\
            \verb'              FETCH           S2, my_data + 2'

    \subsection{STRING}
        \subsubsection{Syntax}
            \verb'<symbol> STRING "<string>"'

        \subsubsection{Description}
            Defines a named character string (sequence of characters) which can later be used with ``LOAD \& RETURN'' and ``OUTPUTK'' instructions, and with ``DB'' directive.

        \subsubsection{Examples}
            \verb'my_string     STRING          "Hello PicoBlaze!"'\\
            \verb''\\
            \verb'              LOAD & RETURN   S0, my_string'\\
            \verb'              OUTPUTK         my_string, 2'\\
            \verb'              DB              my_string'

    \subsection{DEFINE}
        \subsubsection{Syntax}
            \verb'<symbol> DEFINE <expression>'

        \subsubsection{Description}
            You can define expression using previously defined symbols. Value of this expression is calculated every time the symbol is used. You can use symbols in define expressions

        \subsubsection{Examples}
            \verb'A             EQU         10'\\
            \verb'B             SET         5                   ; Second symbol is redefinable'\\
            \verb'C             DEFINE      ( A + B ) * 2       ; Defined expression'\\
            \verb'F = C                                         ; F equals 30'\\
            \verb'B             SET         10'\\
            \verb'F = C                                         ; F equals 40'

    \subsection{ADDRESS, and ORG}
        \subsubsection{Syntax}
            \verb'ADDRESS <expression>'\\
            \verb'ORG     <expression>'

        \subsubsection{Description}
            When the ORG or ADDRESS statement is encountered, the assembler calculates the value of the expression and changes the address counter. The MDS assembler maintains a location counter for each segment. The location counter contains the offset of the instruction or data being assembled and is incremented after each line by the number of bytes of data or code in that line.

        \subsubsection{Examples}
            \verb'ORG           0x3ff'\\
            \verb'ORG           START'\\
            \verb'ORG           INTERRUPT'\\
            \verb'ORG           (\$ + 15) \& 0xFFEE'\\
            \verb'ADDRESS       0x3ff'\\
            \verb'ADDRESS       START'\\
            \verb'ADDRESS       INTERRUPT'\\
            \verb'ADDRESS       (\$ + 15)'

    \subsection{REPT}
        \subsubsection{Syntax}
            \verb'REPT <expression>'\\
            \verb'     <code>'\\
            \verb'ENDR'

        \subsubsection{Description}
            Directive REPT is able to repeatedly execute a block of code.

        \subsubsection{Examples}
            \verb'; With REPT'\\
            \verb'REPT              8'\\
            \verb'SR0               sF'\\
            \verb'ENDR'\\
            \verb'; Without REPT'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'

    \subsection{\#WHILE}
        \subsubsection{Syntax}
            \verb'#WHILE <expression>'\\
            \verb'       <code>'\\
            \verb'#ENDW'

        \subsubsection{Description}
            The while construct consists of a block of code and an expression. Following code is recompiled until expression equals to zero.

        \subsubsection{Examples}
            \verb'B             SET             8'\\
            \verb'#WHILE        B                       ; while B != 0'\\
            \verb'SR0           sF'\\
            \verb'B             SET             B - 1'\\
            \verb'#ENDW'

    \subsection{SKIP}
        \subsubsection{Syntax}
            \verb'SKIP <expression>'

        \subsubsection{Description}
            SKIP directive is basically address counter + number evaluated in expression. See example for more info.

        \subsubsection{Examples}
            \verb'SKIP          3        ; this will skip first three SR0, performing only one SR0'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'\\
            \verb'SR0           sF'

    \subsection{UNDEFINE, UNDEF}
        \subsubsection{Syntax}
            \verb'UNDEFINE <symbol>'\\
            \verb'UNDEF    <symbol>'

        \subsubsection{Description}
            All symbols can be UNDEFINED. Those symbols will be deleted from symbol table (file .sym) and compiler will not recognize them.

        \subsubsection{Examples}
            \verb'My_symbol             SET             15'\\
            \verb'LOAD                  s0, #My_symbol'\\
            \verb'UNDEFINE              My_symbol               ; My_symbol undeclared, cannot be used'\\
            \verb'LOAD                  s0, #My_symbol          ; this will cause an error'

    \subsection{DB}
        \subsubsection{Syntax}
            \verb'; Expresion syntax'\\
            \verb'DB  <expression1>  [, <expression2>, ...]'\\
            \verb''\\
            \verb'; String syntax'\\
            \verb'DB <"string">'\\
            \verb''\\
            \verb'; Combination of string(s) and expression(s)'\\
            \verb'DB <"string"> [, <expression1>, ...]'

            Parameter can be unlimited number of string characters, or expressions divided by comma.

        \subsubsection{Description}
            The DB directive initializes code memory with 18-bit values. The assembler accepts size up to 24-bit but trims 6 MSB bits making it 18-bit value,
            so it can fit into program memory. You can insert infinite number of string characters and MDS assembler separates them into triplets of bytes replaced
            with their ASCII value. The assembler then trims upper 6 bits making it 18-bit value.
            See the examples for better understanding of DB directive.

        \subsubsection{Examples}
            \verb'DB      0x060FC                 ; Hexadecimal 0x060FC'\\
            \verb'DB      "my string"             ; String.'\\
            \verb'DB      "my string",2+1,3...    ; Combination of string and expressions.'\\

    \subsection{LIMIT}
        \subsubsection{Syntax}
            \verb'LIMIT  D, <number> ; Size of scratch-pad RAM(D stands for data).'\\
            \verb'LIMIT  R, <number> ; Number of registers (R stands for registers).'\\
            \verb'LIMIT  C, <number> ; Size of program memory (C stands for code).'\\

        \subsubsection{Description}
            Useful when you want to change max. number of registers or size of  data and program memory. It is information for compiler. In this example when you want to use 17 registers or JUMP to address bigger than 512, compiler gives you an error.

        \subsubsection{Examples}
            \verb'LIMIT          R,16                   ; Number of registers 16'\\
            \verb'LIMIT          D,7                    ; Size of scratch-pad ram   '\\
            \verb'LIMIT          C,0b100000000          ; Size of program memory '\\

    \subsection{DEVICE}
        \subsubsection{Syntax}
            \verb'DEVICE <device_name>'

        \subsubsection{Description}
            Normally, you choose the target architecture when you are creating a project. But you can also specific architecture with directive DEVICE. This will affect predefined symbols.

        \subsubsection{Examples}
            \verb'DEVICE kcpsm6'\\
            \verb'DEVICE kcpsm3'\\
            \verb'DEVICE kcpsm2'\\
            \verb'DEVICE kcpsm1'\\
            \verb'DEVICE kcpsm1cpld'

    \subsection{LIST, NOLIST}
        \subsubsection{Syntax}
            \verb'LIST'\\
            \verb'NOLIST'

        \subsubsection{Description}
            You can turn on/off printing to code listing in some parts of your code.

    \subsection{TITLE}
        \subsubsection{Syntax}
            \verb'TITLE "<title text>"'

        \subsubsection{Description}
            This will put a title into corresponding line in code listing.

        \subsubsection{Examples}
            \verb'TITLE         "Text, that will show up in the code listing"'

    \subsection{MESSAGE}
        \subsubsection{Syntax}
            \verb'MESSAGE "<message text>"'

        \subsubsection{Description}
            You can define message, that will show up after compilation.

        \subsubsection{Examples}
            \verb'MESSAGE         "Text, that will show up in the code listing"'

    \subsection{ERROR}
        \subsubsection{Syntax}
            \verb'ERROR "<error message>"'

        \subsubsection{Description}
            You can define an error report, which aborts compilation when is executed.

        \subsubsection{Examples}
            \verb'ERROR         "Text, that will show up in the code listing"'

    \subsection{WARNING}
            \verb'WARNING "<warning message>"'

        \subsubsection{Description}
            This will put title into corresponding line in code listing.

        \subsubsection{Examples}
            \verb'WARNING         "Text, that will show up in the code listing"'

    \subsection{LOCAL}
        \subsubsection{Syntax}
            \verb'LOCAL <name>'

        \subsubsection{Description}
            This directive is used to define local variables in macros, so when you expand macro multiple times, there will be no redefinition of labels or symbols.

        \subsubsection{Examples}
            \verb'MACRO         name_of_macro'\\
            \verb'LOCAL         wait'\\
            \verb'wait:'\\
            \verb'SUBCY         s0,#10h'\\
            \verb'SUB           s0,#1h' \\
            \verb'LOAD          s0,#F0h'\\
            \verb'JUMP          C,wait'\\
            \verb'ENDM'

    \subsection{END}
        \subsubsection{Syntax}
            \verb'END'

        \subsubsection{Description}
            The END directive informs the assembler, that it has reached the end of a source file. Compiler ignores following code, so it doesn't have to be syntactically correct.

        \subsubsection{Examples}
                \verb'END'

    \subsection{FAILJMP,DEFAULT\_JUMP}
        \subsubsection{Syntax}
            \verb'FAILJMP     <expression>'\\
            \verb'DEFAULT_JMP <expression>'

        \subsubsection{Description}
            Fills program memory with jump to the specified address. Simple protection against errors.

        \subsubsection{Examples}
            \verb'FAILJMP                   Start'\\
            \verb'DEFAULT\_JUMP             0x000'

\section{Code generation directives}
    MDS assembler contains some special directives, which are evaluated during run time sequence. You can use them to evaluate simple conditions in your program. Those directives are IF, ELSEIF, WHILE, FOR.\\ Not all conditions allowed by assembler can be used. Table of allowed instructions is displayed below.

    \begin{table}[h!]
        \mysmallfont{}
        \centering{}
        \begin{tabular}{|l|l}
            \hline
            Condition operator       &          Example  \\
            ==                       &          A ==  B  \\
            !=                       &          A !=  B  \\
            >                        &          A >   B  \\
            <                        &          A <   B  \\
            >=                       &          A >=  B  \\
            <=                       &          A <=  B  \\
            \&                       &          A \&  B  \\
            !\&                      &          A !\& B
        \end{tabular}
        \caption{Allowed conditions with IF, WHILE}
    \end{table}

    \subsection{IF}
        \subsubsection{Syntax}
            \verb'IF      <condition>'\\
            \verb'        <code>'\\
            \verb'ELSEIF  <condition>'\\
            \verb'        <code>'\\
            \verb'ELSE'\\
            \verb'        <code>'\\
            \verb'ENDIF'

        \subsubsection{Description}
            You can use RT\_IF for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and evaluates result. You can use registers, immediate constants (symbols) or register address. Immediate constants are specified as number with \# prefix. Number without \# is considered as register address. See example for conditions syntax. In example below, first condition is comparing register with constant 10. Second condition compares symbol with constant and third condition compares symbol with register address. So 5 would have been replaced with value stored in register with address 5.

        \subsubsection{Examples}
            \verb'IF      s0 == #10'\\
            \verb'        LOAD  s0, #10h'\\
            \verb'ELSEIF  B >= #100'\\
            \verb'        SR0   s0'\\
            \verb'ELSE    A >= 5'\\
            \verb'        INPUT   s0,RX_data'\\
            \verb'ENDIF'

    \subsection{WHILE}
        \subsubsection{Syntax}
            \verb'WHILE <condition>'\\
            \verb'      <code>'\\
            \verb'ENDW'

        \subsubsection{Description}
            You can use WHILE for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and evaluates result. You can use registers, immediate constants (symbols) or register address. Immediate constants are specified as number with \# prefix. Number without \# is considered as register address. See example for conditions syntax.

        \subsubsection{Examples}
            \verb'WHILE s0 == #10'\\
            \verb'      ADDCY S1,#1'\\
            \verb'ENDW'
            \verb''\\
            \verb'WHILE s0 > #10'\\
            \verb'      ADDCY S1,#1'\\
            \verb'ENDW'
            \verb''\\
            \verb'WHILE s0  != #10'\\
            \verb'      ADDCY S1,#1'\\
            \verb'ENDW'

    \subsection{FOR}
        \subsubsection{Syntax}
            \verb'FOR   <condition>'\\
            \verb'      <code>'\\
            \verb'ENDW'

        \subsubsection{Description}
            You can use FOR for better readability of you code. Compiler translates this directive as predefined MACRO with instructions COMPARE and TEST and evaluates result. There are three types of FOR conditions. In first, you have to write the name of used register and number of repetitions. In this case, counting starts at number 0 and incrementing to number of repetitions. In second type, you write used register and range of repetitions ( for example 5..10). In third type, you can even define size of one step, so incremented number can be for some reason bigger. See examples for better understanding.\\ WARNING: Using FOR directive will override used register( s0 in example)

        \subsubsection{Examples}
            \verb'; In this case, incrementing is from 0 to 10. Incrementing step is 1.'
            \verb'FOR   s0, 10'\\
            \verb'      NOP'\\
            \verb'ENDF'
            \verb''\\
            \verb'; In this case, incrementing is in the range 10 to 20. Incrementing step is 1.'
            \verb'FOR   s0, 10..20'\\
            \verb'      NOP'\\
            \verb'ENDF'
            \verb''\\
            \verb'; In this case, incrementing is from 10 to 50. Last number defines'\\
            \verb'; incrementing step. (In this case 10).'\\
            \verb'FOR   s0, 10..50, 10'\\
            \verb'      NOP'\\
            \verb'ENDF'

\section{Macro instructions}
    Macro is a sequence of instructions which can be expanded anywhere in the code and for any number of times. That may reduce necessity of repeating code fragments as well as source code size and make the solved task easier to comprehend and solve. Unlike subprograms macros do not add extra run-time overhead and repeating usage of macros may significantly increase size of the resulting machine code. Macros supported by this assembler are.

    \subsection{Syntax}
        \verb'MACRO     [<parameter1>]  [,<parameter2>..]'\\
        \verb'          <macro source code>'\\
        \verb'ENDM      ; end of macro definition'
        \verb''~\\
        \verb'EXPAND    ; Expanding of macros enabled'\\
        \verb'NOEXPAND  ; Expanding of macros disabled'

        \begin{table}[h!]
            \begin{tabular}{|ll|}
                \hline
                MACRO      & Define a new macro \\
                EXITM      & Exit macro  \\
                ENDM       & End of macro definition \\
                EXPAND     & After usage of this directive, expanding of macros is allowed.(turned on by default)\\
                NOEXPAND   & After usage of this directive, no expanding of macros is allowed.\\
                \hline
            \end{tabular}
            \caption{Macro commands}
        \end{table}

    \subsection{Description}
        Standard macro, consisting of name, code and optional exit command. Macro can be expanded only after his declaration. You can use macro with no parameters  or unlimited number of parameters.

    \subsection{Examples}
        This can be well demonstrated on examples:\\
        {
            \usecodefont
            \verb'abc           macro           ; Define named macro '\\
            \verb'      load    s2,s0'\\
            \verb'      add     s2,#1'\\
            \verb'      load    s1,s2'\\
            \verb'endm'\\\\
            \verb'abc           ; Expand macro "abc"  here'\\
            \verb'abc           ; Expand macro "abc"  here'\\\\
            \verb'; This is the same as if you wrote this:'\\
            \verb'      load    s2,s0'\\
            \verb'      add     s2,#1'\\
            \verb'      load    s1,s2'\\
            \verb'      load    s2,s0'\\
            \verb'      add     s2,#1'\\
            \verb'      load    s1,s2'\\
        }

        Macro without parameters.\\
        {
            \usecodefont
            \verb'; Define macro named as "xyz" with two mandatory parameters'\\
            \verb'xyz       macro   foo, bar'\\
            \verb'          load    foo, #10h'\\
            \verb'          add     bar, #1'\\
            \verb'endm'\\\\
            \verb'          xyz     s2,s3           ; Expand macro "xyz"  here'\\
            \verb'          xyz     s5,s5           ; Expand macro "xyz"  here'\\\\
            \verb'; This is the same as if you wrote this:'\\
            \verb'; xyz     s2,s3'\\
            \verb'          load    s2, #10h'\\
            \verb'          add     s3, #1'\\
            \verb'; xyz     s5,s5'\\
            \verb'          load    s5, #10h'\\
            \verb'          add     s5, #1'\\
        }

        An example of named macro with two parameters.\\
        {
            \usecodefont
            \verb'ijk           macro   foo'\\
            \verb'          add     s1,s0'\\
            \verb''\\
            \verb'          if    foo = 4d'\\
            \verb'              nop'\\
            \verb'          endif'\\
            \verb'          sub     s1, #foo'\\
            \verb'endm'\\\\
            \verb'ijk   5'\\
            \verb'ijk   4'\\\\
            \verb'; This is the same as if you wrote this:'\\
            \verb'      ; ijk   5'\\\\
            \verb'          add     s1,s0'\\
            \verb'          if    5 = 4d'\\
            \verb'              nop'\\
            \verb'          endif'\\
            \verb'          subb    s1,#5'\\
            \verb'      ; ijk   4'\\\\
            \verb'          add     s1,s0'\\
            \verb'          if    4 = 4d'\\
            \verb'              nop'\\
            \verb'          endif'\\
            \verb'          sub     s1,#4'\\
        }

        An example of named macro used with if statement.

\section{Conditional Assembly}
    The aim of conditional assembly to to assemble certain parts of the code if and only if certain arithmetically expressed condition is met. This feature can prove useful particularly when the user want to make the code somehow ``configurable''. This assembler provides these instructions to work with conditional assembly:

    \begin{itemize}
        \item IF <condition>
        \item IFN <condition>
        \item IFDEF <symbol>
        \item IFNDEF <symbol>
        \item ELSE
        \item ELSEIF <condition>
        \item ELSEIFN <condition>
        \item ELSEIFDEF <symbol>
        \item ELSEIFNDEF <symbol>
        \item ENDIF
    \end{itemize}

    This can be best demonstrated on an example:
    \begin{code}[h!]
        \mysmallfont{}
        \verb'abc     equ     14              ; Assign number 14 to symbol abc'\\
        \verb'xyz     equ     10              ; Assign number 10 to symbol abc'\\
        \verb''\\
        \verb'ifdef abc                       ;<--+ Assemble only if symbol abc has been defined'\\
        \verb'  if ( abc = 13 )               ;   | <--+ Assemble if 13 has been assigned to symbol abc'\\
        \verb'        load     a, #01010101b  ;   |    |'\\
        \verb'  elseif ( abc = 14 )           ;   | <--+ Assemble if 14 has been assigned to symbol abc'\\
        \verb'        load     a, #0aah       ;   |    |'\\
        \verb'  elseifn ( abc % 2 )           ;   | <--+ Assemble if the value assigned to symbol abc is even'\\
        \verb'        load     a, #abc        ;   |    |'\\
        \verb'  else                          ;   | <--+ Else ..'\\
        \verb'        load     a, #377q       ;   |    |'\\
        \verb'  endif                         ;   | <--+'\\
        \verb'elseifndef xyz                  ;<--+ Assemble if symbol xyz has NOT been defined'\\
        \verb'        clrr     s1             ;   |'\\
        \verb'else                            ;<--+ Else ...'\\
        \verb'  ifn ( xyz mod 2 )               ;   | <--+ Assemble if ( yxz modulo 2 ) is 0'\\
        \verb'        load     a, #128d       ;   |    |'\\
        \verb'  endif                         ;   | <--+'\\
        \verb'endif                           ;<--+'\\
        \verb''\\
        \verb'jmp    $                       ; Infinite loop'\\
        \verb'end                            ; End of assembly'\\
        \caption{An example of conditional assembly usage}
    \end{code}
