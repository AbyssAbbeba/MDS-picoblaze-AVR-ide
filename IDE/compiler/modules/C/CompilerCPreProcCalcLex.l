/* ========================================================================== */
/**
 * @brief
 *
 * ...
 *
 * (C) copyright 2014 Moravia Microsystems, s.r.o.
 */
/* ========================================================================== */


/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
    // Standard header files.
    #include <cmath> */
    #include <cctype>
    #include <cstdio>
    #include <cstdint>
    #include <cstdlib>
    #include <iostream>

    // Compiler preprocessor interface.
    #include "CompilerCPreProcInterface.h"

    // Functions for handling escape sequences in strings, etc.
    #include "CompilerLexerUtils.h"
    using namespace CompilerLexerUtils;

    // Header file for the parser generated by Bison.
    #include "CompilerCPreProcCalcPar.h"

    // Each time lexer matches a string, move the end cursor to its end.
    #define YY_USER_ACTION \
        yylloc->last_column += yyleng;

    #define compilerCore yyextra->m_compilerCore
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="CompilerCPreProcInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="CompilerCPreProcCalcLex.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="CompilerCPreProcCalcLex_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-sensitive scanner */
%option case-sensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* get rid of the warning message: 'int yy_top_state(yyscan_t)â€™ defined but not used */
%option noyy_top_state


/*
 * Named regular expressions used in the lexer
 */
/* White space. */
WSPACE  ([ \t]|\u00A0)+
/* C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'. */
XESC    (\\[0-7]{1,3})|(\\x[0-9A-F]{1,2})|(\\[uU][0-9A-F]{1,8})|(\\[abfnrtve\\"'?])
/* Floating point number. */
FLOAT   [0-9]+\.[0-9]+(e[+-][0-9]+)?

/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
    // At each yylex invocation, mark the current position as the start of the next token.
    yylloc_param->first_column = yylloc_param->last_column;
%}

 /* White space: */
{WSPACE}        { /* eat up white space */ }

 /* Parenthesis */
"("             { return P_LEFT;  }
")"             { return P_RIGHT; }


 /* Expression operators */
":"             { return O_COLON;    }
"?"             { return O_QMARK;    }
","             { return O_COMMA;    }
"/"             { return O_SLASH;    }
"+"             { return O_PLUS;     }
"-"             { return O_MINUS;    }
"*"             { return O_ASTERISK; }
"!"             { return O_NOT;      }
"%"             { return O_MOD;      }
"<<"            { return O_SHL;      }
">>"            { return O_SHR;      }
"&&"            { return O_AND;      }
"||"            { return O_OR;       }
"&"             { return O_BITAND;   }
"|"             { return O_BITOR;    }
"^"             { return O_BITXOR;   }
"=="            { return O_EQ;       }
"!="            { return O_NE;       }
"<"             { return O_LT;       }
"<="            { return O_LE;       }
">"             { return O_GT;       }
">="            { return O_GE;       }
"~"             { return O_BITNOT;   }
"sizeof"        { return O_SIZEOF;   }

 /* Data types */
"const"         { return D_CONST;    }
"signed"        { return D_SIGNED;   }
"unsigned"      { return D_UNSIGNED; }
"void"          { return D_VOID;     }
"char"          { return D_CHAR;     }
"int"           { return D_INT;      }
"long"          { return D_LONG;     }
"short"         { return D_SHORT;    }
"float"         { return D_FLOAT;    }
"double"        { return D_DOUBLE;   }

 /* Integers */
0b[01]+         {
                    // Binary integer.
                    yylval->number = convertStrToNumber(compilerCore, yylloc, (yytext + 2), 64, 2);
                    return NUMBER;
                }
0x[0-9A-F]+     {
                    // Hexadecimal integer.
                    yylval->number = convertStrToNumber(compilerCore, yylloc, (yytext + 2), 16, 16);
                    return NUMBER;
                }
0[0-7]+         {
                    // Octal integer.
                    yylval->number = convertStrToNumber(compilerCore, yylloc, (yytext + 1), 22, 8);
                    return NUMBER;
                }
[0-9]+          {
                    // Decimal integer.
                    yylval->number = convertStrToNumber(compilerCore, yylloc, yytext, 20, 10);
                    return NUMBER;
                }

 /* Single character literals */
'.'             {
                    yylval->number = (int64_t) (yytext[1]);
                    return NUMBER;
                }
'{XESC}'        {
                    // Handle C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

                    yytext[strlen(yytext) - 1] = '\0';

                    int size; // Size of the binary value in bytes
                    yylval->number = (long long) escapeSequence(compilerCore, yylloc, yytext+1, &size);

                    // Check whether the conversion was successful
                    if ( 0 == size )
                    {
                        compilerCore->lexerMessage ( yylloc,
                                                     CompilerBase::MT_ERROR,
                                                     QObject::tr ( "unrecognized escape sequence: " ).toStdString()
                                                                 + "`" + yytext + "'" );
                        yyterminate();
                    }

                    return NUMBER;
                }

 /* Real numbers */
{FLOAT}         {
                    // Floating point number.
                    compilerCore->lexerMessage ( yylloc,
                                                 CompilerBase::MT_ERROR,
                                                 QObject::tr ( "floating point number in preprocessor expression: " )
                                                             . toStdString()
                                                             + "`" + yytext + "'" );
                }

%%
