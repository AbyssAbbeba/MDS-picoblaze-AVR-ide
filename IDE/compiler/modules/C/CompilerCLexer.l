/* ========================================================================== */
/**
 * @brief
 *
 * ...
 *
 * (C) copyright 2014 Moravia Microsystems, s.r.o.
 */
/* ========================================================================== */


/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
    // Standard header files.
    #include <cmath>
    #include <cctype>
    #include <cstdio>
    #include <cstdint>
    #include <cstdlib>
    #include <iostream>

    // Compiler core interface to the syntax analyzer (parser) and the lexical analyzer (lexer/scaner).
    #include "CompilerParserInterface.h"

    // Functions for handling escape sequences in strings, etc.
    #include "CompilerLexerUtils.h"
    using namespace CompilerLexerUtils;

    // Header file for the parser generated by Bison.
    #include "CompilerCParser.h"

    // Each time lexer matches a string, move the end cursor to its end.
    #define YY_USER_ACTION \
        yylloc->last_column += yyleng;

    // At each yylex invocation, mark the current position as the start of the next token.
    #define advanceLocation()                                   \
        yylloc_param->first_line   = yylloc_param->last_line;   \
        yylloc_param->first_column = yylloc_param->last_column;

    /**
     * @brief
     * @param[in,out] yylval
     */
    inline void enlargeStringBuffer ( YYSTYPE * yylval,
                                      CompilerParserInterface * compiler,
                                      int byMin = 1 );
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="CompilerParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="CompilerCLexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="CompilerCLexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-sensitive scanner */
%option case-sensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* enable use of start condition stacks */
%option stack
/* get rid of the warning message: 'int yy_top_state(yyscan_t)â€™ defined but not used */
%option noyy_top_state


/*
 * Named regular expressions used in the lexer
 */
/* White space. */
WSPACE  ([ \t]|\u00A0)+
/* New line */
NLINE   (\r?\n)|(\n?\r)
/* C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'. */
XESC    (\\[0-7]{1,3})|(\\x[0-9A-F]{1,2})|(\\[uU][0-9A-F]{1,8})|(\\[abfnrtve\\"'?])
/* Floating point numbers. */
DFLOAT  ([0-9]+[eE][+-]?[0-9]+)|((([0-9]+\.[0-9]*)|(\.[0-9]+))([eE][+-]?[0-9]+)?)
XFLOAT  (0x(([0-9a-fA-F]+\.[0-9a-fA-F]*)|(\.[0-9a-fA-F]+))[pP][0-9]+)
FLOAT   {DFLOAT}|{XFLOAT}
/* Identifier. */
ID      [_a-zA-Z][_a-zA-Z0-9]*
/* Integer suffixes. */
U       [uU]
L       [lL]
LL      {L}{L}
UL      ({U}{L})|({L}{U})
ULL     ({U}{L}{L})|({L}{L}{U})
/* Float suffix. */
F_SFX   [Ff]?[Ll]?
/* Hexadecimal integer. */
HEX     0x[0-9a-fA-F]+


/*
 * Exclusive start conditions
 */
/* Inside a string, e.g. "my string" */
%x STR
%x LSTR


/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
    advanceLocation();
%}

 /* White space: */
{WSPACE}        { advanceLocation(); }
{NLINE}         {
                    yylloc->last_line++;
                    yylloc->last_column = 1;
                    advanceLocation();
                }

 /* Special tokens */
";"             { return EOS;               }
"__at__"        { return LOCATION_SPEC;     }
"__asm__"       { return INLINE_ASSEMBLY;   }
"__critical__"  { return CRITICAL_BLOCK;    }
"..."           { return ELIPSIS;           }

 /* Keywords */
"break"         { return KW_BREAK;          }
"case"          { return KW_CASE;           }
"continue"      { return KW_CONTINUE;       }
"default"       { return KW_DEFAULT;        }
"do"            { return KW_DO;             }
"else"          { return KW_ELSE;           }
"for"           { return KW_FOR;            }
"goto"          { return KW_GOTO;           }
"if"            { return KW_IF;             }
"inline"        { return KW_INLINE;         }
"return"        { return KW_RETURN;         }
"restrict"      { return KW_RESTRICT;       }
"sizeof"        { return KW_SIZEOF;         }
"switch"        { return KW_SWITCH;         }
"while"         { return KW_WHILE;          }

 /* Data types, etc. */
"auto"          { return DATA_AUTO;         }
"char"          { return DATA_CHAR;         }
"const"         { return DATA_CONST;        }
"double"        { return DATA_DOUBLE;       }
"extern"        { return DATA_EXTERN;       }
"float"         { return DATA_FLOAT;        }
"enum"          { return DATA_ENUM;         }
"int"           { return DATA_INT;          }
"long"          { return DATA_LONG;         }
"register"      { return DATA_REGISTER;     }
"short"         { return DATA_SHORT;        }
"signed"        { return DATA_SIGNED;       }
"static"        { return DATA_STATIC;       }
"struct"        { return DATA_STRUCT;       }
"typedef"       { return DATA_TYPEDEF;      }
"union"         { return DATA_UNION;        }
"unsigned"      { return DATA_UNSIGNED;     }
"void"          { return DATA_VOID;         }
"volatile"      { return DATA_VOLATILE;     }
"_Complex"      { return DATA_COMPLEX;      }
"_Bool"         { return DATA_BOOL;         }
"_Imaginary"    { return DATA_IMAGINARY;    }

 /* Brackets */
"("             { return B_RND_LEFT;        }
")"             { return B_RND_RIGHT;       }
"["             { return B_SQR_LEFT;        }
"]"             { return B_SQR_RIGHT;       }
"{"             { return B_CRL_LEFT;        }
"}"             { return B_CRL_RIGHT;       }

 /* Expression operators */
":"             { return O_COLON;           }
"?"             { return O_QUESTION_MARK;   }
","             { return O_COMMA;           }
"."             { return O_DOT;             }
"->"            { return O_ARROW;           }
"/"             { return O_SLASH;           }
"+"             { return O_PLUS;            }
"-"             { return O_MINUS;           }
"*"             { return O_ASTERISK;        }
"!"             { return O_NOT;             }
"%"             { return O_MOD;             }
"<<"            { return O_SHL;             }
">>"            { return O_SHR;             }
"&&"            { return O_AND;             }
"||"            { return O_OR;              }
"&"             { return O_BITAND;          }
"|"             { return O_BITOR;           }
"^"             { return O_BITXOR;          }
"=="            { return O_EQ;              }
"!="            { return O_NE;              }
"<"             { return O_LT;              }
"<="            { return O_LE;              }
">"             { return O_GT;              }
">="            { return O_GE;              }
"="             { return O_ASSIGN;          }
"~"             { return O_BITNOT;          }
"+="            { return O_ADD_ASSIGN;      }
"-="            { return O_SUB_ASSIGN;      }
"*="            { return O_MUL_ASSIGN;      }
"/="            { return O_DIV_ASSIGN;      }
"%="            { return O_MOD_ASSIGN;      }
"<<="           { return O_SHL_ASSIGN;      }
">>="           { return O_SHR_ASSIGN;      }
"&="            { return O_BAND_ASSIGN;     }
"|="            { return O_BOR_ASSIGN;      }
"^="            { return O_XOR_ASSIGN;      }
"--"            { return O_DECREMENT;       }
"++"            { return O_INCREMENT;       }

 /*
  *  Constants
  */

 /* Binary integers */
0b[01]+         {
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
                    return INTEGER;
                }
0b[01]+{U}      {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
                    return U_INTEGER;
                }
0b[01]+{L}      {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
                    return L_INTEGER;
                }
0b[01]+{LL}     {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
                    return LL_INTEGER;
                }
0b[01]+{UL}     {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
                    return UL_INTEGER;
                }
0b[01]+{ULL}    {
                    yytext[yyleng-3] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
                    return ULL_INTEGER;
                }

 /* Octal integers */
0[0-7]+         {
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 1), 22, 8);
                    return INTEGER;
                }
0[0-7]+{U}      {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 1), 22, 8);
                    return U_INTEGER;
                }
0[0-7]+{L}      {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 1), 22, 8);
                    return L_INTEGER;
                }
0[0-7]+{LL}     {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 1), 22, 8);
                    return LL_INTEGER;
                }
0[0-7]+{UL}     {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 1), 22, 8);
                    return UL_INTEGER;
                }
0[0-7]+{ULL}    {
                    yytext[yyleng-3] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 1), 22, 8);
                    return ULL_INTEGER;
                }

 /* Decimal integers */
[0-9]+          {
                    yylval->integer = convertStrToNumber(yyextra, yylloc, yytext, 20, 10);
                    return INTEGER;
                }
[0-9]+{U}       {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, yytext, 20, 10);
                    return U_INTEGER;
                }
[0-9]+{L}       {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, yytext, 20, 10);
                    return L_INTEGER;
                }
[0-9]+{LL}      {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, yytext, 20, 10);
                    return LL_INTEGER;
                }
[0-9]+{UL}      {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, yytext, 20, 10);
                    return UL_INTEGER;
                }
[0-9]+{ULL}     {
                    yytext[yyleng-3] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, yytext, 20, 10);
                    return ULL_INTEGER;
                }

 /* Hexadecimal integers */
{HEX}           {
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
                    return INTEGER;
                }
{HEX}{U}        {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
                    return U_INTEGER;
                }
{HEX}{L}        {
                    yytext[yyleng-1] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
                    return L_INTEGER;
                }
{HEX}{LL}       {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
                    return LL_INTEGER;
                }
{HEX}{UL}       {
                    yytext[yyleng-2] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
                    return UL_INTEGER;
                }
{HEX}{ULL}      {
                    yytext[yyleng-3] = '\0';
                    yylval->integer = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
                    return ULL_INTEGER;
                }

 /* Floating constants. */
{FLOAT}{F_SFX}  {
                    // Floating point number.
                    int symbol;

                    switch ( yytext[yyleng-1] )
                    {
                        case 'f':
                        case 'F':
                            yytext[yyleng-1] = '\0';
                            symbol = FLOAT;
                            break;
                        case 'l':
                        case 'L':
                            yytext[yyleng-1] = '\0';
                            symbol = LONG_DOUBLE;
                            break;
                        default:
                            symbol = DOUBLE;
                    }

                    yylval->real = str2float ( yyextra, yylloc, yytext );
                    return symbol;
                }

 /* Character constants. */
L?'{XESC}'       {
                    // Handle C escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

                    int isL = ( 'L' == yytext[0] ) ? 1 : 0;

                    yytext[yyleng - 1] = '\0';

                    int size; // Size of the binary value in bytes
                    yylval->integer = (long long) escapeSequence(yyextra, yylloc, ( yytext + 1 + isL ), &size);


                    // Check whether the conversion was successful
                    if ( 0 == size )
                    {
                        yyextra->lexerMessage ( yylloc,
                                                CompilerBase::MT_ERROR,
                                                QObject::tr ( "unrecognized escape sequence: " ).toStdString()
                                                            + "`" + yytext + "'" );
                        yyterminate();
                    }

                    if ( 0 == isL )
                    {
                        return CHARACTER;
                    }
                    else
                    {
                        return L_CHARACTER;
                    }
                }
'.'             {
                    yylval->integer = (int64_t) (yytext[1]);
                    return CHARACTER;
                }
L'.'            {
                    yylval->integer = (int64_t) (yytext[2]);
                    return L_CHARACTER;
                }

 /* Identifiers. */
{ID}            {
                    // Arbitrary identifier, e.g. `abc'.
                    yylval->symbol = yytext;

                    switch ( ((CompilerCParserExtension*) (yyextra->m_parserExtension))->findIdentifier(yytext) )
                    {
                        case CompilerCParserExtension::TYPE_UNSPECIFIED:
std::cout << "symbol '"<<yytext<<"' is IDENTIFIER\n";
                            return IDENTIFIER;
                        case CompilerCParserExtension::TYPE_TYPEDEF:
std::cout << "symbol '"<<yytext<<"' is TYPEDEF\n";
                            return TYPEDEF_NAME;
                        case CompilerCParserExtension::TYPE_ENUM_CONST:
std::cout << "symbol '"<<yytext<<"' is ENUM_CONST\n";
                            return ENUM_CONST;
                    }
                }

 /* String literals. */
<INITIAL>L?\"   {
                    // Beginning of a string, i.e. --> "some string"
                    if ( 'L' == yytext[0] )
                    {
                        yy_push_state(LSTR, yyscanner);
                    }
                    else
                    {
                        yy_push_state(STR, yyscanner);
                    }
                    yyextra->m_strMaxSize = 32;
                    yylval->string.size = 0;
                    yylval->string.data = (char*) malloc(yyextra->m_strMaxSize);
                }
<STR,LSTR>
{
    \"                  {
                            // End of the string, i.e. "my string" <--
                            bool isL = ( LSTR == YY_START );
                            yy_pop_state(yyscanner);
                            if ( INITIAL == YY_START )
                            {
                                return ( isL ? L_STRING : STRING );
                            }
                            else
                            {
                                yyextra->lexerMessage ( yylloc,
                                                        CompilerBase::MT_ERROR,
                                                        QObject::tr("syntax not understood").toStdString(),
                                                        true );
                            }
                        }
    [^\\"\r\n]+         {
                            // Any string content except for escape sequences.

                            // Increase the string size
                            yylval->string.size += yyleng;
                            // Enlarge the string buffer, if necessary
                            enlargeStringBuffer(yylval, yyextra);
                            // Copy matched characters into our string buffer
                            memcpy(yylval->string.data + yylval->string.size - yyleng, yytext, yyleng);
                        }
    {NLINE}             {
                            yylloc->last_line++;
                            yylloc->last_column = 1;

                            // A string has to be terminated at the same line which it was started on
                            bool isL = ( LSTR == YY_START );
                            yy_pop_state(yyscanner);
                            yyextra->lexerMessage ( yylloc,
                                                    CompilerBase::MT_ERROR,
                                                    QObject::tr("unterminated string literal")
                                                               .toStdString(),
                                                    true );

                            // Put the EOL character sequence back onto the input stream
                            char * eol = strdup(yytext);
                            for ( int i = yyleng - 1; i >= 0; --i )
                            {
                                unput(eol[i]);
                            }
                            free(eol);

                            if ( INITIAL == YY_START )
                            {
                                return ( isL ? L_STRING : STRING );
                            }
                        }
    {XESC}              {
                            // Handle C escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

                            int size; // Size of the binary value in bytes
                            uint32_t value = escapeSequence(yyextra, yylloc, yytext, &size);

                            // Check whether the conversion was successful
                            if ( 0 == size )
                            {
                                yyextra->lexerMessage ( yylloc,
                                                        CompilerBase::MT_ERROR,
                                                        QObject::tr("unrecognized escape sequence: ").toStdString()
                                                        + "`" + yytext + "'" );
                                yyterminate();
                            }

                            // Copy converted escape sequence to the string buffer
                            enlargeStringBuffer(yylval, yyextra, size);
                            for ( int i = 0; i < size; i++ )
                            {
                                yylval->string.data [ yylval->string.size++ ] = (unsigned char) (value & 0xFF);
                                value >>= 8;
                            }
                        }
    <<EOF>>             {
                            // Handle strings terminated by EOF (End Of File) as ERROR.
                            yy_pop_state(yyscanner);
                            yyextra->lexerMessage ( yylloc,
                                                    CompilerBase::MT_ERROR,
                                                    QObject::tr("unterminated string literal")
                                                               .toStdString(),
                                                    true );

                            // Discard the string buffer and terminate lexical analysis (this is a fatal error)
                            free(yylval->string.data);
                            yylval->string.size = 0;
                            yyterminate();
                        }
}

%%

/* --------------------------------------------------------------------------- */
/* EPILOGUE - USER CODE - FUNCTION DEFINITIONS                                 */
/* --------------------------------------------------------------------------- */

inline void enlargeStringBuffer ( YYSTYPE * semval,
                                  CompilerParserInterface * compiler,
                                  int byMin )
{
    if ( ( byMin + semval->string.size ) >= compiler->m_strMaxSize )
    {
        compiler->m_strMaxSize = 2 * semval->string.size;
        semval->string.data = (char*) realloc(semval->string.data, compiler->m_strMaxSize);
    }
}
