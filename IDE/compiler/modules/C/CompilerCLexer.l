/* ========================================================================== */
/**
 * @brief
 *
 * ...
 *
 * (C) copyright 2013, 2014 Moravia Microsystems, s.r.o.
 */
/* ========================================================================== */


/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
    // Standard header files.
    #include <cmath>
    #include <cctype>
    #include <cstdio>
    #include <cstdint>
    #include <cstdlib>
    #include <iostream>

    // Compiler core interface to the syntax analyzer (parser) and the lexical analyzer (lexer/scaner).
    #include "CompilerParserInterface.h"

    // Functions for handling escape sequences in strings, etc.
    #include "CompilerLexerUtils.h"
    using namespace CompilerLexerUtils;

    // Header file for the parser generated by Bison.
    #include "CompilerCParser.h"

    // Each time lexer matches a string, move the end cursor to its end.
    #define YY_USER_ACTION \
        yylloc->last_column += yyleng;

    /**
     * @brief
     * @param[in,out] yylval
     */
    inline void enlargeStringBuffer ( YYSTYPE * yylval,
                                      CompilerParserInterface * compiler,
                                      int byMin = 1 );
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="CompilerParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="CompilerCLexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="CompilerCLexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-sensitive scanner */
%option case-sensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* enable use of start condition stacks */
%option stack
/* get rid of the warning message: 'int yy_top_state(yyscan_t)â€™ defined but not used */
%option noyy_top_state
/* To suppress the warning message "yyunput defined but not used". */
%option nounput

/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
    // At each yylex invocation, mark the current position as the start of the next token.
    yylloc_param->first_line   = yylloc_param->last_line;
    yylloc_param->first_column = yylloc_param->last_column;
%}

 // -----------------------------------------------------------------------------------------
 // >>>>>>>>>>>>>>>>>>>>>>>>>> TODO: write lexical rules here! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 // -----------------------------------------------------------------------------------------

%%

/* --------------------------------------------------------------------------- */
/* EPILOGUE - USER CODE - FUNCTION DEFINITIONS                                 */
/* --------------------------------------------------------------------------- */

inline void enlargeStringBuffer ( YYSTYPE * semval,
                                  CompilerParserInterface * compiler,
                                  int byMin )
{
    if ( ( byMin + semval->string.size ) >= compiler->m_strMaxSize )
    {
        compiler->m_strMaxSize = 2 * semval->string.size;
        semval->string.data = (char*) realloc(semval->string.data, compiler->m_strMaxSize);
    }
}
