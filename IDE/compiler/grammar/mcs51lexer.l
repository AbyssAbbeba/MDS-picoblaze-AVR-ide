/**
 * @brief
 * ...
 *
 * ...
 *
 * Copyright: See COPYING file that comes with this distribution.
 *
 * @author: Martin Ošmera <martin.osmera@gmail.com>, (C) 2012
 *
 */

/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
	// Standard header files
	#include <iostream>
	#include <cctype>
	#include <cstdlib>
	#include <cstdio>
	#include <cstdint>
	// Assembler interface to the syntax analyzer (parser) and the lexical analyzer (lexer/scaner)
	#include "CompilerParserInterface.h"
	// Header file for the parser generated by Bison
	#include "mcs51parser.h"
	// Functions for handling escape sequences in strings, etc.
	#include "LexerUtils.h"
	using namespace LexerUtils;

	// Each time lexer matches a string, move the end cursor to its end.
	#define YY_USER_ACTION \
		yylloc->last_column += yyleng;

	/**
	 * @brief
	 * @param yylval: [InOut]
	 */
	inline void enlargeStringBuffer(YYSTYPE * yylval, CompilerParserInterface * compiler, int byMin = 1);
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="CompilerParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="mcs51lexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="mcs51lexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-insensitive scanner */
%option case-insensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* enable use of start condition stacks */
%option stack
/* get rid of the warning message: 'int yy_top_state(yyscan_t)’ defined but not used */
%option noyy_top_state

/*
 * Named regular expressions used in the lexer
 */
/* White space */
WSPACE	([ \t]|\u00A0)+
/* New line */
NLINE	(\r?\n)|(\n?\r)
/* An identifier in Assembly language */
ID	[_A-Z][_A-Z0-9]*
/* Comment, in this case it starts with a semicolon (`;') */
COMMENT	(;[^\r\n]*)
/* C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177' */
XESC	(\\[0-7]{1,3})|(\\x[0-9A-F]{1,2})|(\\[uU][0-9A-F]{1,8})

/*
 * Exclusive start conditions
 */
/* Inside a string, e.g. "my string" */
%x STR
/* Inside a string, or a character literal; e.g. 'my string', or 'a' */
%x QUOTE
/* Multi-line comment */
%x MCOMMENT
/* Inside an INCLUDE directive */
%x INC
%x INC_END
%x INC_LP
%x INC_RP


/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
	// Terminate lexical analysis, in case all input files have been closed using the `END' directive.
	if ( NULL == mcs51lexer_get_in(yyscanner) ) {
		yyterminate();
	}

	// At each yylex invocation, mark the current position as the start of the next token.
	yylloc_param->first_line   = yylloc_param->last_line;
	yylloc_param->first_column = yylloc_param->last_column;
%}

{WSPACE}	{ /* eat up white space */ }
{NLINE}		{
			yylloc->last_line++;
			yylloc->last_column = 1;
			return EOL;
		}

;{COMMENT}	{ return COMMENT; }
{COMMENT}	{ /* ignore ordinary comment */ }
<INITIAL,INC,INC_END,INC_LP,INC_RP>{
	"/*"		{ yy_push_state(MCOMMENT, yyscanner); }
}
<MCOMMENT>{
	"*/"		{ yy_pop_state(yyscanner); }
	[^*\n]*		{ /* eat anything that's not a '*' */ }
	"*"+[^*/\n]*	{ /* eat up '*'s not followed by '/'s */ }
	{NLINE}		{
				yylloc->last_line++;
				yylloc->last_column = 1;
				return EOL;
			}
}

\.?"db"		{ return D_DB; }
\.?"macro"	{ return D_MACRO; }
\.?"endm"	{ return D_ENDM; }
\.?"bit"	{ return D_BIT; }
\.?"bseg"	{ return D_BSEG; }
\.?"byte"	{ return D_BYTE; }
\.?"code"	{ return D_CODE; }
\.?"cseg"	{ return D_CSEG; }
\.?"data"	{ return D_DATA; }
\.?"dbit"	{ return D_DBIT; }
\.?"ds"		{ return D_DS; }
\.?"dseg"	{ return D_DSEG; }
\.?"dw"		{ return D_DW; }
\.?"else"	{ return D_ELSE; }
\.?"elseif"	{ return D_ELSEIF; }
\.?"elseifdef"	{ return D_ELSEIFDEF; }
\.?"elseifn"	{ return D_ELSEIFN; }
\.?"elseifndef"	{ return D_ELSEIFNDEF; }
\.?"endif"	{ return D_ENDIF; }
\.?"equ"	{ return D_EQU; }
\.?"flag"	{ return D_FLAG; }
\.?"idata"	{ return D_IDATA; }
\.?"if"		{ return D_IF; }
\.?"ifdef"	{ return D_IFDEF; }
\.?"iseg"	{ return D_ISEG; }
\.?"list"	{ return D_LIST; }
\.?"name"	{ return D_NAME; }
\.?"nolist"	{ return D_NOLIST; }
\.?"org"	{ return D_ORG; }
\.?"rept"	{ return D_REPT; }
\.?"times"	{ return D_REPT; }
\.?"set"	{ return D_SET; }
\.?"skip"	{ return D_SKIP; }
\.?"using"	{ return D_USING; }
\.?"xdata"	{ return D_XDATA; }
\.?"xseg"	{ return D_XSEG; }
\.?"local"	{ return D_LOCAL; }
\.?"elseifnb"	{ return D_ELSEIFNB; }
\.?"exitm"	{ return D_EXITM; }
\.?"ifn"	{ return D_IFN; }
\.?"elseifb"	{ return D_ELSEIFB; }
\.?"ifnb"	{ return D_IFNB; }
\.?"ifb"	{ return D_IFB; }
\.?"ifndef"	{ return D_IFNDEF; }
\.?"end"	{
			// Close the current file
			mcs51lexer_pop_buffer_state(yyscanner);
			if ( YY_CURRENT_BUFFER ) {
				yyextra->popFileName();
				*yylloc = yyextra->m_yyllocStack.back();
				yyextra->m_yyllocStack.pop_back();
			} else {
				mcs51lexer_set_in(NULL, yyscanner);
			}

			return D_END;
		}

\$"cond"	{ return C_COND; }
\$"go"		{ return C_GENONLY; }
\$"nodebug"	{ return C_NODEBUG; }
\$"nosymbols"	{ return C_NOSYMBOLS; }
\$"rs"		{ return C_RESTORE; }
\$"condonly"	{ return C_CONDONLY; }
\$"noge"	{ return C_NOGEN; }
\$"notabs"	{ return C_NOTABS; }
\$"sa"		{ return C_SAVE; }
\$"da"		{ return C_DATE; }
\$"nogen"	{ return C_NOGEN; }
\$"noxr"	{ return C_NOXREF; }
\$"save"	{ return C_SAVE; }
\$"date"	{ return C_DATE; }
\$"li"		{ return C_LIST; }
\$"noli"	{ return C_NOLIST; }
\$"noxref"	{ return C_NOXREF; }
\$"sb"		{ return C_SYMBOLS; }
\$"db"		{ return C_DEBUG; }
\$"list"	{ return C_LIST; }
\$"nolist"	{ return C_NOLIST; }
\$"pagelength"	{ return C_PAGELENGTH; }
\$"symbols"	{ return C_SYMBOLS; }
\$"debug"	{ return C_DEBUG; }
\$"macro"	{ return C_MACRO; }
\$"nomacro"	{ return C_NOMACRO; }
\$"pagewidth"	{ return C_PAGEWIDTH; }
\$"title"	{ return C_TITLE; }
\$"ej"		{ return C_EJECT; }
\$"mo"		{ return C_MOD51; }
\$"nomo"	{ return C_NOMOD51; }
\$"paging"	{ return C_PAGING; }
\$"tt"		{ return C_TITLE; }
\$"eject"	{ return C_EJECT; }
\$"mod51"	{ return C_MOD51; }
\$"nomod51"	{ return C_NOMOD51; }
\$"philips"	{ return C_PHILIPS; }
\$"warning"	{ return C_WARNING; }
\$"error"	{ return C_ERROR; }
\$"mr"		{ return C_MACRO; }
\$"nomr"	{ return C_NOMACRO; }
\$"pi"		{ return C_PAGING; }
\$"xr"		{ return C_XREF; }
\$"ge"		{ return C_GEN; }
\$"nobuiltin"	{ return C_NOBUILTIN; }
\$"nopaging"	{ return C_NOPAGING; }
\$"pl"		{ return C_PAGELENGTH; }
\$"xref"	{ return C_XREF; }
\$"gen	"	{ return C_GEN; }
\$"nocond"	{ return C_NOCOND; }
\$"nopi"	{ return C_NOPAGING; }
\$"pw"		{ return C_PAGEWIDTH; }
\$"genonly"	{ return C_GENONLY; }
\$"nodb"	{ return C_NODEBUG; }
\$"nosb"	{ return C_NOSYMBOLS; }
\$"restore"	{ return C_RESTORE; }

"acall"		{ return I_ACALL; }
"add"		{ return I_ADD; }
"addc"		{ return I_ADDC; }
"ajmp"		{ return I_AJMP; }
"anl"		{ return I_ANL; }
"cjne"		{ return I_CJNE; }
"clr"		{ return I_CLR; }
"cpl"		{ return I_CPL; }
"da"		{ return I_DA; }
"dec"		{ return I_DEC; }
"div"		{ return I_DIV; }
"djnz"		{ return I_DJNZ; }
"inc"		{ return I_INC; }
"jb"		{ return I_JB; }
"jbc"		{ return I_JBC; }
"jc"		{ return I_JC; }
"jmp"		{ return I_JMP; }
"jnb"		{ return I_JNB; }
"jnc"		{ return I_JNC; }
"jnz"		{ return I_JNZ; }
"jz"		{ return I_JZ; }
"lcall"		{ return I_LCALL; }
"ljmp"		{ return I_LJMP; }
"mov"		{ return I_MOV; }
"movc"		{ return I_MOVC; }
"movx"		{ return I_MOVX; }
"mul"		{ return I_MUL; }
"nop"		{ return I_NOP; }
"orl"		{ return I_ORL; }
"pop"		{ return I_POP; }
"push"		{ return I_PUSH; }
"ret"		{ return I_RET; }
"reti"		{ return I_RETI; }
"rl"		{ return I_RL; }
"rlc"		{ return I_RLC; }
"rr"		{ return I_RR; }
"rrc"		{ return I_RRC; }
"setb"		{ return I_SETB; }
"sjmp"		{ return I_SJMP; }
"subb"		{ return I_SUBB; }
"swap"		{ return I_SWAP; }
"xch"		{ return I_XCH; }
"xchd"		{ return I_XCHD; }
"xrl"		{ return I_XRL; }

"a"		{ return REG_A; }
"ab"		{ return REG_AB; }
"c"		{ return BIT_C; }
"dptr"		{ return REG_DPTR; }
"r0"		{ return REG_0; }
"r1"		{ return REG_1; }
"r2"		{ return REG_2; }
"r3"		{ return REG_3; }
"r4"		{ return REG_4; }
"r5"		{ return REG_5; }
"r6"		{ return REG_6; }
"r7"		{ return REG_7; }
"@r0"		{ return IND_R0; }
"@r1"		{ return IND_R1; }
"@a+dptr"	{ return IND_A_DPTR; }
"@a+pc"		{ return IND_A_PC; }
"@dptr"		{ return IND_DPTR; }

"at"		{ return AT; }
"("		{ return LP; }
")"		{ return RP; }
","		{ return COMMA; }
"/"		{ return SLASH; }
"#"		{ return IMMEDIATE; }
"+"		{ return PLUS; }
"-"		{ return MINUS; }
"*"		{ return ASTERISK; }
"."		{ return DOT; }
"!"		{ return NOT; }
"NOT"		{ return NOT; }
"HIGH"		{ return HIGH; }
"LOW"		{ return LOW; }
"%"		{ return MOD; }
"MOD"		{ return MOD; }
"<<"		{ return SHL; }
"SHL"		{ return SHL; }
">>"		{ return SHR; }
"SHR"		{ return SHR; }
"&&"		{ return AND; }
"AND"		{ return AND; }
"||"		{ return OR; }
"OR"		{ return OR; }
"XOR"		{ return XOR; }
"^^"		{ return XOR; }
"&"		{ return BITAND; }
"|"		{ return BITOR; }
"^"		{ return BITXOR; }
"="		{ return EQ; }
"=="		{ return EQ; }
"EQ"		{ return EQ; }
"<>"		{ return NE; }
"!="		{ return NE; }
"NE"		{ return NE; }
"<"		{ return LT; }
"LT"		{ return LT; }
"<="		{ return LE; }
"LE"		{ return LE; }
">"		{ return GT; }
"GT"		{ return GT; }
">="		{ return GE; }
"GE"		{ return GE; }
"~"		{ return COMPLEMET; }

\.?"include"	{
			// Handle `include' directive
			yy_push_state(INC_END, yyscanner);
			yy_push_state(INC, yyscanner);
			yylval->array.size = -1;
		}
\$"include"|\$"ic" {
			// Handle `$include("<filename")' assembler control
			yy_push_state(INC_END, yyscanner);
			yy_push_state(INC_RP, yyscanner);
			yy_push_state(INC, yyscanner);
			yy_push_state(INC_LP, yyscanner);
			yylval->array.size = -1;
		}

<INC_LP>"("		{ yy_pop_state(yyscanner); }
<INC_RP>")"		{ yy_pop_state(yyscanner); }
<INC,INC_END,INC_LP,INC_RP>{
	{WSPACE}	{ /* eat up white space */ }
	{COMMENT}	{ return COMMENT; }
}
<INC_LP,INC_RP>.	{
				yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
					QObject::tr("unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'");
				yyterminate();
			}
<INITIAL,INC>{
	\"		{
				// Beginning of a string, i.e. --> "some string"
				yy_push_state(STR, yyscanner);
				yyextra->m_strMaxSize = 32;
				yylval->array.size = 0;
				yylval->array.data = (unsigned char*) malloc(yyextra->m_strMaxSize);
			}
	'		{
				// Beginning of a string, or a character literal; i.e. --> 'a' (char.), or --> 'some string' (str.)
				yy_push_state(QUOTE, yyscanner);
				yyextra->m_strMaxSize = 8;
				yylval->array.size = 0;
				yylval->array.data = (unsigned char*) malloc(yyextra->m_strMaxSize);
			}
}
<STR>{
	\"		{
				// End of the string, i.e. "my string" <--
				yy_pop_state(yyscanner);
				switch ( YY_START ) {
					case INITIAL:
						return STRING;
					case INC:
						yy_pop_state(yyscanner);
						break;
					default:
						yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
							QObject::tr("syntax not understood").toStdString());
						break;
				}
			}
	[^\\"\r\n]+	{
				// Any string content except for escape sequences, EOL (end of line) is also not allowed

				// Increase the string size
				yylval->array.size += yyleng;
				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval, yyextra);
				// Copy matched characters into our string buffer
				memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
			}
}
<QUOTE>{
	'		{
				// End of the string, or single character literal; i.e. 'a' <--, or 'some string' <--
				yy_pop_state(yyscanner);
				switch ( YY_START ) {
					case INITIAL:
						if ( yylval->array.size == 1 ) {
							yylval->number = int(yylval->array.data[0]);
							return NUMBER;
						} else {
							return STRING;
						}
					case INC:
						yy_pop_state(yyscanner);
						break;
					default:
						yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
							QObject::tr("syntax not understood").toStdString());
						break;
				}
			}
	[^\\'\r\n]+	{
				// Any string, content except for escape sequences, EOL (end of line) is also not allowed

				// Increase the string size
				yylval->array.size += yyleng;
				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval, yyextra);
				// Copy matched characters into our string buffer
				memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
			}
}
<STR,QUOTE>{
	{NLINE}		{
				// A string has to be terminated at the same line which it was started on
				yy_pop_state(yyscanner);
				yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
					QObject::tr("unterminated string").toStdString());

				// Put the EOL character sequence back onto the input stream
				char * eol = strdup(yytext);
				for ( int i = yyleng - 1; i >= 0; --i ) {
					unput(eol[i]);
				}
				free(eol);

				if ( INITIAL == YY_START ) {
					return STRING;
				}
			}
	{XESC}		{
				// Handle C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

				int size; // Size of the binary value in bytes
				uint32_t value = escapeSequence(yyextra, yylloc, yytext, &size);

				// Check whether the conversion was successful
				if ( 0 == size ) {
					yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
						QObject::tr("unrecognized escape sequence: ").toStdString() + "`" + yytext + "'");
					yyterminate();
				}

				// Copy converted escape sequence to the string buffer
				enlargeStringBuffer(yylval, yyextra, size);
				for ( int i = 0; i < size; i++ ) {
					yylval->array.data [ yylval->array.size++ ] = (unsigned char) (value & 0xFF);
					value >>= 8;
				}
			}
	\\.		{
				// Handle escape sequences inside strings and character literals, and convert the to binary values

				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval, yyextra);
				// Copy converted escape sequence to the string buffer
				int size;
				yylval->array.data [ yylval->array.size++ ] = (unsigned char) escapeSequence(yyextra, yylloc, yytext, &size);
			}
	<<EOF>>		{
				// Handle strings terminated by EOF (End Of File) as ERROR, of course.
				yy_pop_state(yyscanner);
				yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
					QObject::tr("unterminated string").toStdString());

				// Discard the string buffer and terminate lexical analysis (this is a fatal error)
				free(yylval->array.data);
				yylval->array.size = 0;
				yyterminate();
			}
}
<INC,INC_END>{
	{NLINE}		{
				// Attempt to open the specified file

				// Put the EOL character sequence back onto the input stream
				char * eol = strdup(yytext);
				for ( int i = yyleng - 1; i >= 0; --i ) {
					unput(eol[i]);
				}
				free(eol);

				yy_pop_state(yyscanner);

				if ( 1 > yylval->array.size ) {
					yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
						QObject::tr("no file name specified").toStdString());
					return INCLUDE;
				}
				enlargeStringBuffer(yylval, yyextra);
				yylval->array.data [ yylval->array.size ] = '\0';

				char * filename = (char*) yylval->array.data;

				if ( strlen(filename) != (size_t) yylval->array.size ) {
					yyextra->lexerMessage(yylloc, CompilerBase::MT_WARNING,
						QObject::tr("file name contains a null character").toStdString() );
				}

				FILE * file = yyextra->fileOpen(filename);
				if ( NULL == file ) {
					yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
						QObject::tr("unable to open the specified file: ").toStdString() + "`" + filename + "'" );
					return INCLUDE;
				} else {
					yylval->string = filename;

					yyextra->m_yyllocStack.push_back(*yylloc);
					mcs51lexer_push_buffer_state(mcs51lexer__create_buffer(file, YY_BUF_SIZE, yyscanner), yyscanner);
					
					yylloc->last_line = 1;
					yylloc->last_column = 1;

					return INCLUDE;
				}
			}
	.		{
				// Anything else results in an error, it wouldn't make sense otherwise
				yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
					QObject::tr("unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'");
				yyterminate();
			}
}
[01]+b		{
			// Binary number (max. 64 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `b'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 64, 2);
			return NUMBER;
		}
[0-9A-F]+h	{
			// Hexadecimal number (max. 16 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `h'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 16, 16);
			return NUMBER;
		}
[0-7]+[oq]	{
			// Octal number (max. 21 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `o' or `q'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 21, 8);
			return NUMBER;
		}
[0-9]+d		{
			// Decimal number (max. 10 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `d'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
			return NUMBER;
		}
0b[01]+		{
			// Binary number (max. 64 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
			return NUMBER;
		}
0x[0-9A-F]+	{
			// Hexadecimal number (max. 16 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
			return NUMBER;
		}
0[0-7]+		{
			// Octal number (max. 21 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 1), 21, 8);
			return NUMBER;
		}
[0-9]+		{
			// Decimal number (max. 10 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
			return NUMBER;
		}
{ID}:		{
			// Label, e.g. `main:'

			// Remove the trailing `:'
			yytext [ yyleng - 1 ] = '\0';

			// Convert the string to upper case characters
			for ( int i = 0; i < yyleng; i++ ) {
				yytext[i] = toupper(yytext[i]);
			}

			// Return as label
			yylval->string = yytext;
			return LABEL;
		}
{ID}|"$"	{
			// Arbitrary identifier, e.g. `MYREG_U1'

			// Convert the string to upper case characters
			for ( int i = 0; i < yyleng; i++ ) {
				yytext[i] = toupper(yytext[i]);
			}

			// Return as general identifier
			yylval->string = yytext;
			return IDENFIFIER;
		}
<<EOF>> 	{
			// Handle end of file; possibly switch back to previous file, in case "include" was used
			mcs51lexer_pop_buffer_state(yyscanner);
			if ( !YY_CURRENT_BUFFER ) {
				yyterminate();
			} else {
				yyextra->popFileName();
				*yylloc = yyextra->m_yyllocStack.back();
				yyextra->m_yyllocStack.pop_back();
			}
		}
.		{
			// Unrecognized token => ERROR
			yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
				QObject::tr("unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'");
		}

%%

/* --------------------------------------------------------------------------- */
/* EPILOGUE - USER CODE - FUNCTION DEFINITIONS                                 */
/* --------------------------------------------------------------------------- */

inline void enlargeStringBuffer(YYSTYPE * semval, CompilerParserInterface * compiler, int byMin) {
	if ( ( byMin + semval->array.size ) >= compiler->m_strMaxSize ) {
		compiler->m_strMaxSize = 2 * semval->array.size;
		semval->array.data = (unsigned char*) realloc(semval->array.data, compiler->m_strMaxSize);
	}
}
