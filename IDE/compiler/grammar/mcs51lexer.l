%{
	// Standard header files
	#include <iostream>
	#include <cctype>
	#include <cstdlib>
	#include <cstdio>
	// Assembler interface to the syntax analyzer (parser) and the lexical analyzer (lexer/scaner)
	#include "CompilerParserInterface.h"
	// Header file for the parser generated by Bison
	#include "mcs51parser.h"

	// Variables with file scope in this lexer
	int strMaxSize; // String buffer size, used for scanning strings and character literals

	/**
	 * @brief Convert a string to an integer and check its size
	 * @param extra: [InOut]
	 * @param loc: [In]
	 * @param str: [In]
	 * @param max: [In]
	 * @param base: [In]
	 * @return
	 */
	inline int convertStrToNumber(CompilerParserInterface * extra, const YYLTYPE * loc, const char * str, uint max, int base) {
		unsigned long number;
		if (
			( strlen(str) > max )
				||
			( ( 0x1ULL << 32 ) <= ( number = strtoul(str, NULL, base) ) ) )
		{
			extra->lexerMessage(
				extra->toSourceLocation(loc),
				CompilerBase::MT_ERROR,
				QObject::tr("Too big number: ").toStdString() + "`" + std::string(str) + "'");
			return 1; // Some "neutral" dummy value
		}
		return int(number);
	}

	/**
	 * @brief Convert a two-character escape sequence to its binary form
	 * @param extra: [InOut]
	 * @param loc: [In]
	 * @param ch: [In] The second character in the sequence, e.g. for `\n' it's `n'
	 * @return The binary value represented by the escape sequence, e.g. for `\n' it's 0x0A
	 */
	inline unsigned char escapeSeqToNum(CompilerParserInterface * extra, const YYLTYPE * loc, char ch) {
		switch ( ch ) {
			case 'a' : return '\a'; // alarm
			case 'b' : return '\b'; // backspace
			case '\'': return '\''; // single quote
			case '"' : return '\"'; // double quote
			case '?' : return '\?'; // question mark
			case '\\': return '\\'; // backslash
			case '0' : return '\0'; // null character
			case 'f' : return '\f'; // form feed
			case 'n' : return '\n'; // line feed
			case 'r' : return '\r'; // carriage return
			case 't' : return '\t'; // horizontal tab
			case 'v' : return '\v'; // vertical tab
			default:
				extra->lexerMessage(
					extra->toSourceLocation(loc),
					CompilerBase::MT_ERROR,
					QObject::tr("Unrecognized escape sequence: ").toStdString() + "`\\" + ch + "'");
				return 0;
		}
	}

	inline void enlargeStringBuffer(YYSTYPE * yylval) {
		if ( ( 1 + yylval->array.size ) >= strMaxSize ) {
			strMaxSize = 2 * yylval->array.size;
			yylval->array.data = (unsigned char*) realloc(yylval->array.data, strMaxSize);
		}
	}
%}

/* data type of the user-specific data to be stored in yyextra */
%option extra-type="CompilerParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="mcs51lexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="mcs51lexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-insensitive scanner */
%option case-insensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn

/*
 * Exclusive start conditions
 */
/* Inside a string, e.g. "my string" */
%x STR
/* Inside a string, or a character literal; e.g. 'my string', or 'a' */
%x QUOTE
/* Inside an INCLUDE directive */
%x INC

/*
 * Named regular expressions used in the lexer
 */
/* White space */
WSPACE	[ \t]+
/* New line */
NLINE	(\r?\n)|(\n?\r)
/* An identifier in Assembly language */
ID	[_A-Z][_A-Z0-9]*
/* Comment, in this case it starts with a semicolon (`;') */
COMMENT	(;[^\r\n]*)
/* File name specifier, used with an "include" directive */
FILE	(\"[^\"]+\")|('[^']+')

%%

{WSPACE}	{ /* eat up white space */ }
{NLINE}		{ return EOL; }

"DB"		{ return DB; }
"MACRO"		{ return MACRO; }
"ENDM"		{ return ENDM; }

"ACALL"		{ return ACALL; }
"ADD"		{ return ADD; }
"ADDC"		{ return ADDC; }
"AJMP"		{ return AJMP; }
"ANL"		{ return ANL; }
"CJNE"		{ return CJNE; }
"CLR"		{ return CLR; }
"CPL"		{ return CPL; }
"DA"		{ return DA; }
"DEC"		{ return DEC; }
"DIV"		{ return DIV; }
"DJNZ"		{ return DJNZ; }
"INC"		{ return INC; }
"JB"		{ return JB; }
"JBC"		{ return JBC; }
"JC"		{ return JC; }
"JMP"		{ return JMP; }
"JNB"		{ return JNB; }
"JNC"		{ return JNC; }
"JNZ"		{ return JNZ; }
"JZ"		{ return JZ; }
"LCALL"		{ return LCALL; }
"LJMP"		{ return LJMP; }
"MOV"		{ return MOV; }
"MOVC"		{ return MOVC; }
"MOVX"		{ return MOVX; }
"MUL"		{ return MUL; }
"NOP"		{ return NOP; }
"ORL"		{ return ORL; }
"POP"		{ return POP; }
"PUSH"		{ return PUSH; }
"RET"		{ return RET; }
"RETI"		{ return RETI; }
"RL"		{ return RL; }
"RLC"		{ return RLC; }
"RR"		{ return RR; }
"RRC"		{ return RRC; }
"SETB"		{ return SETB; }
"SJMP"		{ return SJMP; }
"SUBB"		{ return SUBB; }
"SWAP"		{ return SWAP; }
"XCH"		{ return XCH; }
"XCHD"		{ return XCHD; }
"XRL"		{ return XRL; }

"A"		{ return REG_A; }
"AB"		{ return REG_AB; }
"C"		{ return BIT_C; }
"DPTR"		{ return REG_DPTR; }
"R0"		{ return REG_0; }
"R1"		{ return REG_1; }
"R2"		{ return REG_2; }
"R3"		{ return REG_3; }
"R4"		{ return REG_4; }
"R5"		{ return REG_5; }
"R6"		{ return REG_6; }
"R7"		{ return REG_7; }
"@R0"		{ return IND_R0; }
"@R1"		{ return IND_R1; }
"@A+DPTR"	{ return IND_A_DPTR; }
"@A+PC"		{ return IND_A_PC; }
"@DPTR"		{ return IND_DPTR; }

"AT"		{ return AT; }
"("		{ return LP; }
")"		{ return RP; }
","		{ return COMMA; }
"/"		{ return SLASH; }
"#"		{ return IMMEDIATE; }
"+"		{ return PLUS; }
"-"		{ return MINUS; }
"*"		{ return ASTERISK; }
"."		{ return DOT; }

"INCLUDE"	{
			BEGIN(INC);
		}
<INC>{
	{WSPACE}	{ /* eat up white space */ }
	{FILE}		{
				// Attempt to open the specified file
				BEGIN(INITIAL);

				yytext [ yyleng - 1 ] = '\0';
				const char * filename = ( 1 + yytext );

				FILE * file = fopen(filename, "r");
				if ( NULL == file ) {
					yyextra->lexerMessage (
						yyextra->toSourceLocation(yylloc),
						CompilerBase::MT_ERROR,
						QObject::tr("Unable to open the specified file: ").toStdString() + "`" + filename + "'" );
					yyterminate();
				} else {
					yyextra->pushFileName(filename);
					mcs51lexer_push_buffer_state(mcs51lexer__create_buffer(file, YY_BUF_SIZE, yyscanner), yyscanner);
				}
			}
	.		{
				// Anything else results in an error, it wouldn't make sense otherwise
				yyextra->lexerMessage(
					yyextra->toSourceLocation(yylloc),
					CompilerBase::MT_ERROR,
					QObject::tr("Unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'");
				yyterminate();
			}
}
\"		{
			// Beginning of a string, i.e. --> "some string"
			BEGIN(STR);
			strMaxSize = 32;
			yylval->array.size = 0;
			yylval->array.data = (unsigned char*) malloc(strMaxSize);
		}
'		{
			// Beginning of a string, or a character literal; i.e. --> 'a' (char.), or --> 'some string' (str.)
			BEGIN(QUOTE);
			strMaxSize = 8;
			yylval->array.size = 0;
			yylval->array.data = (unsigned char*) malloc(strMaxSize);
		}
<STR>{
	\"		{
				// End of the string, i.e. "my string" <--
				BEGIN(INITIAL);
				return STRING;
			}
	[^\\"\r\n]+	{
				// Any string content except for escape sequences, EOL (end of line) is also not allowed

				// Increase the string size
				yylval->array.size += yyleng;
				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval);
				// Copy matched characters into our string buffer
				memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
			}
}
<QUOTE>{
	'		{
				// End of the string, or single character literal; i.e. 'a' <--, or 'some string' <--
				BEGIN(INITIAL);
				if ( yylval->array.size == 1 ) {
					yylval->number = int(yylval->array.data[0]);
					return NUMBER;
				} else {
					return STRING;
				}
			}
	[^\\'\r\n]+	{
				// Any string, content except for escape sequences, EOL (end of line) is also not allowed

				// Increase the string size
				yylval->array.size += yyleng;
				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval);
				// Copy matched characters into our string buffer
				memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
			}
}
<STR,QUOTE>{
	{NLINE}		{
				// A string has to be terminated at the same line which it was started on
				BEGIN(INITIAL);
				yyextra->lexerMessage (
					yyextra->toSourceLocation(yylloc),
					CompilerBase::MT_ERROR,
					QObject::tr("Unterminated string").toStdString() );
				return STRING;
			}
	\\[0-7]{3}	{
				// Handle escape sequence like `\048'
				int val;
				sscanf(yytext + 1, "%o", &val);
				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval);
				// Copy converted escape sequence to the string buffer
				yylval->array.data [ yylval->array.size++ ] = (unsigned char) val;
			}
	\\x[0-9A-F]{2}	{
				// Handle escape sequence like `\xA2'
				if ( 'x' != yytext[1] ) {
					yyextra->lexerMessage(
						yyextra->toSourceLocation(yylloc),
						CompilerBase::MT_ERROR,
						QObject::tr("Unrecognized escape sequence: ").toStdString() + "`" + yytext + "'");
					yyterminate();
				}
				// Convert the escape sequence to binary form
				int val;
				sscanf(yytext + 2, "%x", &val);
				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval);
				// Copy converted escape sequence to the string buffer
				yylval->array.data [ yylval->array.size++ ] = (unsigned char) val;
			}
	\\.		{
				// Handle escape sequences inside strings and character literals, and convert the to binary values

				// Enlarge the string buffer, if necessary
				enlargeStringBuffer(yylval);
				// Copy converted escape sequence to the string buffer
				yylval->array.data [ yylval->array.size++ ] = escapeSeqToNum(yyextra, yylloc, yytext[1]);
			}
	<<EOF>>		{
				// Handle strings terminated by EOF (End Of File) as ERROR, of course.
				BEGIN(INITIAL);

				// Report error
				yyextra->lexerMessage (
					yyextra->toSourceLocation(yylloc),
					CompilerBase::MT_ERROR,
					QObject::tr("Unterminated string").toStdString() );

				// Discard the string buffer and terminate lexical analysis (this is a fatal error)
				free(yylval->array.data);
				yylval->array.size = 0;
				yyterminate();
			}
}
[01]+b		{
			// Binary number (max. 64 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `b'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 64, 2);
			return NUMBER;
		}
[0-9A-F]+h	{
			// Hexadecimal number (max. 16 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `h'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 16, 16);
			return NUMBER;
		}
[0-7]+[oq]	{
			// Octal number (max. 21 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `o' or `q'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 21, 8);
			return NUMBER;
		}
[0-9]+d		{
			// Decimal number (max. 10 digits, max. 32 bits)
			yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `d'
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
			return NUMBER;
		}
0b[01]+		{
			// Binary number (max. 64 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
			return NUMBER;
		}
0x[0-9A-F]+	{
			// Hexadecimal number (max. 16 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
			return NUMBER;
		}
0[0-7]+		{
			// Octal number (max. 21 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 1), 21, 8);
			return NUMBER;
		}
[0-9]+		{
			// Decimal number (max. 10 digits, max. 32 bits)
			yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
			return NUMBER;
		}
{ID}:		{
			// Label, e.g. `main:'

			// Remove the trailing `:'
			yytext [ yyleng - 1 ] = '\0';

			// Convert the string to upper case characters
			for ( int i = 0; i < yyleng; i++ ) {
				yytext[i] = toupper(yytext[i]);
			}

			// Return as label
			yylval->string = yytext;
			return LABEL;
		}
{ID}		{
			// Arbitrary identifier, e.g. `MYREG_U1'

			// Convert the string to upper case characters
			for ( int i = 0; i < yyleng; i++ ) {
				yytext[i] = toupper(yytext[i]);
			}

			// Return as general identifier
			yylval->string = yytext;
			return IDENFIFIER;
		}

{COMMENT}	{ return COMMENT; }
<<EOF>> 	{
			// Handle end of file; possibly switch back to previous file, in case "include" was used
			mcs51lexer_pop_buffer_state(yyscanner);
			if ( !YY_CURRENT_BUFFER ) {
				yyterminate();
			} else {
				yyextra->popFileName();
			}
		}
.		{
			// Unrecognized token => ERROR
			yyextra->lexerMessage(
				yyextra->toSourceLocation(yylloc),
				CompilerBase::MT_ERROR,
				QObject::tr("Unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'");
		}

%%
