%{
	// Standard header files
	#include <iostream>
	// Assembler interface to the syntax analyzer (parser) and the lexical analyzer (lexer/scaner)
	#include "CompilerParserInterface.h"
	// Header file for the parser generated by Bison
	#include "mcs51parser.h"
%}

/* data type of the user-specific data to be stored in yyextra */
%option extra-type="CompilerParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="mcs51lexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="mcs51lexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-insensitive scanner */
%option case-insensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner call yywrap() upon an end-of-file */
%option yywrap
/* generate warning messages */
%option warn


ID	[_a-zA-Z][_a-zA-Z0-9]*
NUM	[0-9]+
STR	'abc'

/*
yylval->character
yylval->number
*/
%%

[ \t]+		{ /* eat up white space */ }
\r?\n		{ return END_OF_LINE; }

"A"		{ return REG_A; }
"AB"		{ return REG_AB; }
"C"		{ return BIT_C; }
"DPTR"		{ return REG_DPTR; }
"R0"		{ return REG_0; }
"R1"		{ return REG_1; }
"R2"		{ return REG_2; }
"R3"		{ return REG_3; }
"R4"		{ return REG_4; }
"R5"		{ return REG_5; }
"R6"		{ return REG_6; }
"R7"		{ return REG_7; }
"@R0"		{ return INDIRECT_R0; }
"@R1"		{ return INDIRECT_R1; }
"@A+DPTR"	{ return INDIRECT_A_DPTR; }
"@A+PC"		{ return INDIRECT_A_PC; }
"@DPTR"		{ return INDIRECT_DPTR; }


"CSEG"		{ return CSEG; }


"ACALL"		{ return ACALL; }
"ADD"		{ return ADD; }
"ADDC"		{ return ADDC; }
"AJMP"		{ return AJMP; }
"ANL"		{ return ANL; }
"CJNE"		{ return CJNE; }
"CLR"		{ return CLR; }
"CPL"		{ return CPL; }
"DA"		{ return DA; }
"DEC"		{ return DEC; }
"DIV"		{ return DIV; }
"DJNZ"		{ return DJNZ; }
"INC"		{ return INC; }
"JB"		{ return JB; }
"JBC"		{ return JBC; }
"JC"		{ return JC; }
"JMP"		{ return JMP; }
"JNB"		{ return JNB; }
"JNC"		{ return JNC; }
"JNZ"		{ return JNZ; }
"JZ"		{ return JZ; }
"LCALL"		{ return LCALL; }
"LJMP"		{ return LJMP; }
"MOV"		{ return MOV; }
"MOVC"		{ return MOVC; }
"MOVX"		{ return MOVX; }
"MUL"		{ return MUL; }
"NOP"		{ return NOP; }
"ORL"		{ return ORL; }
"POP"		{ return POP; }
"PUSH"		{ return PUSH; }
"RET"		{ return RET; }
"RETI"		{ return RETI; }
"RL"		{ return RL; }
"RLC"		{ return RLC; }
"RR"		{ return RR; }
"RRC"		{ return RRC; }
"SETB"		{ return SETB; }
"SJMP"		{ return SJMP; }
"SUBB"		{ return SUBB; }
"SWAP"		{ return SWAP; }
"XCH"		{ return XCH; }
"XCHD"		{ return XCHD; }
"XRL"		{ return XRL; }

"AT"		{ return AT; }
"("		{ return LP; }
")"		{ return RP; }
","		{ return COMMA; }
"/"		{ return SLASH; }
"#"		{ return IMMEDIATE; }
"+"		{ return PLUS; }
"-"		{ return MINUS; }
"*"		{ return ASTERISK; }

{STR}		{ return STRING; /* TODO: Use start conditions here! */ }
";"[^\r\n]*	{ return COMMENT; }
{NUM}		{ yylval->number = atoi(yytext); return NUMBER; }
{ID}:		{ yylval->string = strdup(yytext); return LABEL; }
{ID}		{ yylval->string = strdup(yytext); return IDENFIFIER; }

<<EOF>> 	{ return 0; }

.		{ yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR, "Unrecognized token"); }

%%

int mcs51lexer_wrap (yyscan_t /*yyscanner*/ ) {
	return 0;
}
