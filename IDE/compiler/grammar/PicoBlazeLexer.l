/* ========================================================================== */
/**
 * @brief
 *
 * ...
 *
 * (C) copyright 2013 Moravia Microsystems, s.r.o.
 *
 * @author Martin Ošmera <martin.osmera@moravia-microsystems.com>
 */
/* ========================================================================== */


/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
    // Standard header files
    #include <iostream>
    #include <cctype>
    #include <cstdlib>
    #include <cstdio>
    #include <cstdint>
    // Assembler interface to the syntax analyzer (parser) and the lexical analyzer (lexer/scaner)
    #include "CompilerParserInterface.h"
    // Header file for the parser generated by Bison
    #include "PicoBlazeParser.h"
    // Functions for handling escape sequences in strings, etc.
    #include "LexerUtils.h"
    using namespace LexerUtils;

    // Each time lexer matches a string, move the end cursor to its end.
    #define YY_USER_ACTION \
        yylloc->last_column += yyleng;

    /**
     * @brief
     * @param[in,out] yylval
     */
    inline void enlargeStringBuffer ( YYSTYPE * yylval,
                                      CompilerParserInterface * compiler,
                                      int byMin = 1 );
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="CompilerParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="PicoBlazeLexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="PicoBlazeLexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-insensitive scanner */
%option case-insensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* enable use of start condition stacks */
%option stack
/* get rid of the warning message: 'int yy_top_state(yyscan_t)’ defined but not used */
%option noyy_top_state

/*
 * Named regular expressions used in the lexer
 */
/* White space character */
WSCHAR  ([ \t]|\u00A0)*
/* White space */
WSPACE  {WSCHAR}+
/* Empty or white space */
EWSPACE {WSCHAR}*
/* New line */
NLINE   (\r?\n)|(\n?\r)
/* An identifier in Assembly language */
ID      [_A-Z][_A-Z0-9]*
/* Comment, in this case it starts with a semicolon (`;') */
COMMENT (;[^\r\n]*)
/* C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177' */
XESC    (\\[0-7]{1,3})|(\\x[0-9A-F]{1,2})|(\\[uU][0-9A-F]{1,8})
/* Instruction "RETURNI ENABLE" */
RETURNI_ENABLE_INST    "returni"{WSPACE}"enable"
/* Instruction "RETURNI DISABLE" */
RETURNI_DISABLE_INST    "returni"{WSPACE}"disable"
/* Instruction "ENABLE INTERRUPT" */
ENA_INT_INST            "enable"{WSPACE}"interrupt"
/* Instruction "DISABLE INTERRUPT" */
DIS_INT_INST            "disable"{WSPACE}"interrupt"

/*
 * Exclusive start conditions
 */
/* Inside a string, e.g. "my string" */
%x STR
/* Inside a string, or a character literal; e.g. 'my string', or 'a' */
%x QUOTE
/* Multi-line comment */
%x MCOMMENT
/* Inside an INCLUDE directive */
%x INC
%x INC_END


/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
    if ( true == yyextra->getInsertEOL() )
    {
        return EOL;
    }

    // Terminate lexical analysis, in case all input files have been closed using the EXIT' directive.
    if ( NULL == PicoBlazeLexer_get_in(yyscanner) )
    {
        yyterminate();
    }

    // At each yylex invocation, mark the current position as the start of the next token.
    yylloc_param->first_line   = yylloc_param->last_line;
    yylloc_param->first_column = yylloc_param->last_column;
%}

{WSPACE}                { /* eat up white space */ }
{NLINE}                 {
                            yylloc->last_line++;
                            yylloc->last_column = 1;
                            return EOL;
                        }

;{COMMENT}              { return COMMENT; }
{COMMENT}               { /* ignore ordinary comment */ }
<INITIAL,INC,INC_END>
{
    "/*"                { yy_push_state(MCOMMENT, yyscanner); }
}
<MCOMMENT>
{
    "*/"                { yy_pop_state(yyscanner); }
    [^*\n]*             { /* eat anything that's not a '*' */ }
    "*"+[^*/\n]*        { /* eat up '*'s not followed by '/'s */ }
    {NLINE}             {
                            yylloc->last_line++;
                            yylloc->last_column = 1;
                            return EOL;
                        }
}

\.?"device"             { return D_DEVICE;     }
\.?"limit"              { return D_LIMIT;      }
\.?"reg"                { return D_REG;        }
\.?"namereg"            { return D_NAMEREG;    }
\.?"address"            { return D_ADDRESS;    }
\.?"org"                { return D_ORG;        }
\.?"define"             { return D_DEFINE;     }
\.?"undefine"           { return D_UNDEFINE;   }
\.?"undef"              { return D_UNDEFINE;   }
\.?"equ"                { return D_EQU;        }
\.?"constant"           { return D_CONSTANT;   }
\.?"set"                { return D_SET;        }
\.?"variable"           { return D_VARIABLE;   }
\.?"while"              { return D_WHILE;      }
\.?"endwhile"           { return D_ENDW;       }
\.?"endw"               { return D_ENDW;       }
\.?"port"               { return D_PORT;       }
\.?"data"               { return D_DATA;       }
\.?"code"               { return D_CODE;       }
\.?"db"                 { return D_DB;         }
\.?"error"              { return D_ERROR;      }
\.?"warning"            { return D_WARNING;    }
\.?"list"               { return D_LIST;       }
\.?"messg"              { return D_MESSG;      }
\.?"nolist"             { return D_NOLIST;     }
\.?"skip"               { return D_SKIP;       }
\.?"title"              { return D_TITLE;      }
\.?"expand"             { return D_EXPAND;     }
\.?"noexpand"           { return D_NOEXPAND;   }
\.?"if"                 { return D_IF;         }
\.?"ifn"                { return D_IFN;        }
\.?"ifdef"              { return D_IFDEF;      }
\.?"ifndef"             { return D_IFNDEF;     }
\.?"elseifb"            { return D_ELSEIFB;    }
\.?"elseifnb"           { return D_ELSEIFNB;   }
\.?"else"               { return D_ELSE;       }
\.?"elseif"             { return D_ELSEIF;     }
\.?"elseifn"            { return D_ELSEIFN;    }
\.?"elseifdef"          { return D_ELSEIFDEF;  }
\.?"elseifndef"         { return D_ELSEIFNDEF; }
\.?"endif"              { return D_ENDIF;      }
\.?"local"              { return D_LOCAL;      }
\.?"ifnb"               { return D_IFNB;       }
\.?"ifb"                { return D_IFB;        }
\.?"endmacro"           { return D_ENDM;       }
\.?"endm"               { return D_ENDM;       }
\.?"exitm"              { return D_EXITM;      }
\.?"repeat"             { return D_REPT;       }
\.?"rept"               { return D_REPT;       }
\.?"endrepeat"          { return D_ENDR;       }
\.?"endr"               { return D_ENDR;       }
\.?"autoreg"            { return D_AUTOREG;    }
\.?"autospr"            { return D_AUTOSPR;    }
\.?"macro"              { return D_MACRO;      }
\.?"end"                {
                            // Close the current file
                            PicoBlazeLexer_pop_buffer_state(yyscanner);
                            if ( YY_CURRENT_BUFFER )
                            {
                                yyextra->popFileName();
                                *yylloc = yyextra->m_yyllocStack.back();
                                yyextra->m_yyllocStack.pop_back();
                            }
                            else
                            {
                                PicoBlazeLexer_set_in(NULL, yyscanner);
                            }

                            return D_END;
                        }

 /* Instructions. */
"add"                   { return I_ADD;         }
"addcy"                 { return I_ADDCY;       }
"sub"                   { return I_SUB;         }
"subcy"                 { return I_SUBCY;       }
"compare"               { return I_COMPARE;     }
"load"                  { return I_LOAD;        }
"and"                   { return I_AND;         }
"or"                    { return I_OR;          }
"xor"                   { return I_XOR;         }
"test"                  { return I_TEST;        }
"store"                 { return I_STORE;       }
"fetch"                 { return I_FETCH;       }
"st"                    { return I_STORE;       }
"ft"                    { return I_FETCH;       }
"sr0"                   { return I_SR0;         }
"sr1"                   { return I_SR1;         }
"srx"                   { return I_SRX;         }
"sra"                   { return I_SRA;         }
"rr"                    { return I_RR;          }
"sl0"                   { return I_SL0;         }
"sl1"                   { return I_SL1;         }
"slx"                   { return I_SLX;         }
"sla"                   { return I_SLA;         }
"rl"                    { return I_RL;          }
"input"                 { return I_INPUT;       }
"output"                { return I_OUTPUT;      }
"hwbuild"               { return I_HWBUILD;     }
"star"                  { return I_STAR;        }
"testcy"                { return I_TESTCY;      }
"comparecy"             { return I_COMPARECY;   }
"outputk"               { return I_OUTPUTK;     }
"jump"{WSPACE}"z"{EWSPACE}","       { return I_JUMP_Z;      }
"jump"{WSPACE}"nz"{EWSPACE}","      { return I_JUMP_NZ;     }
"jump"{WSPACE}"c"{EWSPACE}","       { return I_JUMP_C;      }
"jump"{WSPACE}"nc"{EWSPACE}","      { return I_JUMP_NC;     }
"call"{WSPACE}"z"{EWSPACE}","       { return I_CALL_Z;      }
"call"{WSPACE}"nz"{EWSPACE}","      { return I_CALL_NZ;     }
"call"{WSPACE}"c"{EWSPACE}","       { return I_CALL_C;      }
"call"{WSPACE}"nc"{EWSPACE}","      { return I_CALL_NC;     }
"return"{WSPACE}"z"{EWSPACE}","     { return I_RETURN_Z;    }
"return"{WSPACE}"nz"{EWSPACE}","    { return I_RETURN_NZ;   }
"return"{WSPACE}"c"{EWSPACE}","     { return I_RETURN_C;    }
"return"{WSPACE}"nc"{EWSPACE}","    { return I_RETURN_NC;   }
"return"                { return I_RETURN;      }
"jump"                  { return I_JUMP;        }
"call"                  { return I_CALL;        }
"regbank"{WSPACE}"A"    { return I_REGBANK_A;   }
"regbank"{WSPACE}"B"    { return I_REGBANK_B;   }
{RETURNI_ENABLE_INST}   { return I_RETURNI_ENA; }
{RETURNI_DISABLE_INST}  { return I_RETURNI_DIS; }
{ENA_INT_INST}          { return I_ENABLE_INT;  }
{DIS_INT_INST}          { return I_DISABLE_INT; }

 /* Instruction shortcuts. */
"ena"                   { return I_ENABLE_INT;  }
"dis"                   { return I_DISABLE_INT; }
"retie"                 { return I_RETURNI_ENA; }
"retid"                 { return I_RETURNI_DIS; }
"ret"                   { return I_RETURN;      }
"cmp"                   { return I_COMPARE;     }
"in"                    { return I_INPUT;       }
"out"                   { return I_OUTPUT;      }
"outk"                  { return I_OUTPUTK;     }
"ld"                    { return I_LOAD;        }
"cmpcy"                 { return I_COMPARECY;   }
"rb"{WSPACE}"A"         { return I_REGBANK_A;   }
"rb"{WSPACE}"B"         { return I_REGBANK_B;   }

 /* Special macros. */
"rt_if"                 { return M_RTIF;     }
"rt_elseif"             { return M_RTELSEIF; }
"rt_else"               { return M_RTELSE;   }
"rt_endif"              { return M_RTENDIF;  }
"rt_while"              { return M_RTWHILE;  }
"rt_endw"               { return M_RTENDW;   }
"rt_for"                { return M_RTFOR;    }
"rt_endf"               { return M_RTENDF;   }

 /* Special "operators". */
"high"                  { return F_HIGH;    }
"low"                   { return F_LOW;     }
"at"                    { return AT;        }
"@"                     { return AT_MARK;   }
"("                     { return LP;        }
")"                     { return RP;        }
"#"                     { return IMMEDIATE; }
","                     { return COMMA;     }
".."                    { return INTERVAL;  }

 /* Operators. */
"/"                     { return SLASH;      }
"+"                     { return PLUS;       }
"-"                     { return MINUS;      }
"*"                     { return ASTERISK;   }
"!"                     { return NOT;        }
"%"                     { return MOD;        }
"<<"                    { return SHL;        }
">>"                    { return SHR;        }
"&&"                    { return AND;        }
"||"                    { return OR;         }
"&"                     { return BITAND;     }
"!&"                    { return BITNAND;    }
"|"                     { return BITOR;      }
"^"                     { return BITXOR;     }
"=="                    { return EQ;         }
"<>"                    { return NE;         }
"!="                    { return NE;         }
"<"                     { return LT;         }
"<="                    { return LE;         }
">"                     { return GT;         }
">="                    { return GE;         }
"~"                     { return COMPLEMENT; }

\.?"include"            {
                            // Handle `include' directive
                            yy_push_state(INC_END, yyscanner);
                            yy_push_state(INC, yyscanner);
                            yylval->array.size = -1;
                        }
<INC,INC_END>
{
    {WSPACE}            { /* eat up white space */ }
    ;{COMMENT}          { return COMMENT; }
    {COMMENT}           { /* ignore commets */ }
}
<INITIAL,INC>\"         {
                            // Beginning of a string, i.e. --> "some string"
                            yy_push_state(STR, yyscanner);
                            yyextra->m_strMaxSize = 32;
                            yylval->array.size = 0;
                            yylval->array.data = (unsigned char*) malloc(yyextra->m_strMaxSize);
                        }
'                       {
                            // Beginning of a string, or a character literal; 
                            //+ i.e. --> 'a' (char.), or --> 'some string' (str.)
                            yy_push_state(QUOTE, yyscanner);
                            yyextra->m_strMaxSize = 8;
                            yylval->array.size = 0;
                            yylval->array.data = (unsigned char*) malloc(yyextra->m_strMaxSize);
                        }
<STR>
{
    \"                  {
                            // End of the string, i.e. "my string" <--
                            yy_pop_state(yyscanner);
                            switch ( YY_START )
                            {
                                case INITIAL:
                                    return STRING;
                                case INC:
                                    yy_pop_state(yyscanner);
                                    break;
                                default:
                                    yyextra->lexerMessage ( yylloc,
                                                            CompilerBase::MT_ERROR,
                                                            QObject::tr("syntax not understood").toStdString() );
                                    break;
                            }
                        }
    [^\\"\r\n]+         {
                            // Any string content except for escape sequences, EOL (end of line) is also not allowed

                            // Increase the string size
                            yylval->array.size += yyleng;
                            // Enlarge the string buffer, if necessary
                            enlargeStringBuffer(yylval, yyextra);
                            // Copy matched characters into our string buffer
                            memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
                        }
}
<QUOTE>
{
    '                   {
                            // End of the string, or single character literal; i.e. 'a' <--, or 'some string' <--
                            yy_pop_state(yyscanner);

                            int result = int(yylval->array.data[0]);
                            free(yylval->array.data);

                            if ( yylval->array.size != 1 )
                            {
                                yyextra->lexerMessage ( yylloc,
                                                        CompilerBase::MT_ERROR,
                                                        QObject::tr("character constant has to have 8 bits")
                                                                   .toStdString() );
                            }

                            yylval->number = result;
                            return NUMBER;
                        }
    [^\\'\r\n]+         {
                            // Any string, content except for escape sequences, EOL (end of line) is also not allowed

                            // Increase the string size
                            yylval->array.size += yyleng;
                            // Enlarge the string buffer, if necessary
                            enlargeStringBuffer(yylval, yyextra);
                            // Copy matched characters into our string buffer
                            memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
                        }
}
<STR,QUOTE>
{
    {NLINE}             {
                            yylloc->last_line++;
                            yylloc->last_column = 1;

                            // A string has to be terminated at the same line which it was started on
                            yy_pop_state(yyscanner);
                            yyextra->lexerMessage ( yylloc,
                                                    CompilerBase::MT_ERROR,
                                                    QObject::tr("unterminated string or character constant")
                                                               .toStdString() );

                            // Put the EOL character sequence back onto the input stream
                            char * eol = strdup(yytext);
                            for ( int i = yyleng - 1; i >= 0; --i )
                            {
                                unput(eol[i]);
                            }
                            free(eol);

                            if ( INITIAL == YY_START )
                            {
                                return STRING;
                            }
                        }
    {XESC}              {
                            // Handle C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

                            int size; // Size of the binary value in bytes
                            uint32_t value = escapeSequence(yyextra, yylloc, yytext, &size);

                            // Check whether the conversion was successful
                            if ( 0 == size )
                            {
                                yyextra->lexerMessage ( yylloc, 
                                                        CompilerBase::MT_ERROR,
                                                        QObject::tr("unrecognized escape sequence: ").toStdString() + "`" + yytext + "'" );
                                yyterminate();
                            }

                            // Copy converted escape sequence to the string buffer
                            enlargeStringBuffer(yylval, yyextra, size);
                            for ( int i = 0; i < size; i++ )
                            {
                                yylval->array.data [ yylval->array.size++ ] = (unsigned char) (value & 0xFF);
                                value >>= 8;
                            }
                        }
    \\.                 {
                            // Handle escape sequences inside strings and character literals, and convert the to binary values

                            // Enlarge the string buffer, if necessary
                            enlargeStringBuffer(yylval, yyextra);
                            // Copy converted escape sequence to the string buffer
                            int size;
                            yylval->array.data [ yylval->array.size++ ] = ( unsigned char )
                                                                          escapeSequence ( yyextra,
                                                                                           yylloc,
                                                                                           yytext,
                                                                                           &size );
                        }
    <<EOF>>             {
                            // Handle strings terminated by EOF (End Of File) as ERROR.
                            yy_pop_state(yyscanner);
                            yyextra->lexerMessage ( yylloc,
                                                    CompilerBase::MT_ERROR,
                                                    QObject::tr("unterminated string or character constant")
                                                               .toStdString() );

                            // Discard the string buffer and terminate lexical analysis (this is a fatal error)
                            free(yylval->array.data);
                            yylval->array.size = 0;
                            yyterminate();
                        }
}
<INC,INC_END>
{
    {NLINE}             {
                            yyextra->setInsertEOL();

                            // Attempt to open the specified file

                            // Put the EOL character sequence back onto the input stream
                            char * eol = strdup(yytext);
                            for ( int i = yyleng - 1; i >= 0; --i )
                            {
                                unput(eol[i]);
                            }
                            free(eol);

                            yy_pop_state(yyscanner);

                            if ( 1 > yylval->array.size )
                            {
                                yyextra->lexerMessage ( yylloc,
                                                        CompilerBase::MT_ERROR,
                                                        QObject::tr("no file name specified").toStdString() );
                                return INCLUDE;
                            }
                            enlargeStringBuffer(yylval, yyextra);
                            yylval->array.data [ yylval->array.size ] = '\0';

                            char * filename = new char [ yylval->array.size + 1 ];
                            strcpy(filename, (char*) yylval->array.data);
                            free(yylval->array.data);

                            if ( strlen(filename) != (size_t) yylval->array.size )
                            {
                                yyextra->lexerMessage ( yylloc,
                                                        CompilerBase::MT_WARNING,
                                                        QObject::tr("file name contains a null character")
                                                                   .toStdString() );
                            }

                            FILE * file = yyextra->fileOpen(filename);
                            if ( NULL == file )
                            {
                                yyextra->lexerMessage ( yylloc,
                                                        CompilerBase::MT_ERROR,
                                                        QObject::tr("unable to open the specified file: ")
                                                                   .toStdString() + "`" + filename + "'" );
                                return EOL;
                            }
                            else
                            {
                                yylval->string = filename;

                                yyextra->m_yyllocStack.push_back(*yylloc);
                                PicoBlazeLexer_push_buffer_state(PicoBlazeLexer__create_buffer(file, YY_BUF_SIZE, yyscanner), yyscanner);

                                yylloc->last_line = 1;
                                yylloc->last_column = 1;

                                return INCLUDE;
                            }
                        }
    .                   {
                            // Anything else results in an error, it wouldn't make sense otherwise
                            yyextra->lexerMessage ( yylloc,
                                                    CompilerBase::MT_ERROR,
                                                    QObject::tr("unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'" );
                            yyterminate();
                        }
}
[01]+b                  {
                            // Binary number (max. 64 digits, max. 32 bits)
                            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `b'
                            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 64, 2);
                            return NUMBER;
                        }
[0-9A-F]+h              {
                            // Hexadecimal number (max. 16 digits, max. 32 bits)
                            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `h'
                            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 16, 16);
                            return NUMBER;
                        }
[0-7]+[oq]              {
                            // Octal number (max. 21 digits, max. 32 bits)
                            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `o' or `q'
                            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 21, 8);
                            return NUMBER;
                        }
[0-9]+d                 {
                            // Decimal number (max. 10 digits, max. 32 bits)
                            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `d'
                            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
                            return NUMBER;
                        }
0b[01]+                 {
                            // Binary number (max. 64 digits, max. 32 bits)
                            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
                            return NUMBER;
                        }
0x[0-9A-F]+             {
                            // Hexadecimal number (max. 16 digits, max. 32 bits)
                            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
                            return NUMBER;
                        }
0[0-7]+                 {
                            // Octal number (max. 21 digits, max. 32 bits)
                            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 1), 21, 8);
                            return NUMBER;
                        }
[0-9]+                  {
                            // Decimal number (max. 10 digits, max. 32 bits)
                            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
                            return NUMBER;
                        }
{ID}:                   {
                            // Label, e.g. `main:'

                            // Remove the trailing `:'
                            yytext [ yyleng - 1 ] = '\0';

                            // Convert the string to upper case characters
                            for ( int i = 0; i < yyleng; i++ )
                            {
                                yytext[i] = toupper(yytext[i]);
                            }

                            // Return as label
                            yylval->string = yytext;
                            return LABEL;
                        }
[0-9]{ID}:              {
                            // Invalid label declaration => ERROR
                            yyextra -> lexerMessage ( yylloc,
                                                      CompilerBase::MT_ERROR,
                                                      QObject::tr("label cannot start with a digit: ").toStdString() + "`" + std::string(yytext) + "'" );
                        }
\$[_A-Z0-9]+            {
                            // Unrecognized token => ERROR
                            yyextra -> lexerMessage ( yylloc,
                                                      CompilerBase::MT_ERROR,
                                                      QObject::tr("invalid token: ").toStdString() + "`" + std::string(yytext) + "'" );
                        }
{ID}|"$"                {
                            // Arbitrary identifier, e.g. `MYREG_U1'

                            // Convert the string to upper case characters
                            for ( int i = 0; i < yyleng; i++ )
                            {
                                yytext[i] = toupper(yytext[i]);
                            }

                            // Return as general identifier
                            yylval->string = yytext;
                            return IDENTIFIER;
                        }
[0-9]{ID}               {
                            // Invalid identifier declaration => ERROR
                            yyextra -> lexerMessage ( yylloc,
                                                      CompilerBase::MT_ERROR,
                                                      QObject::tr("identifier cannot start with a digit: ").toStdString() + "`" + std::string(yytext) + "'" );
                        }
<<EOF>>                 {
                            // Handle end of file; possibly switch back to previous file, in case "include" was used
                            PicoBlazeLexer_pop_buffer_state(yyscanner);
                            if ( !YY_CURRENT_BUFFER )
                            {
                                yyterminate();
                            }
                            else
                            {
                                yyextra->popFileName();
                                *yylloc = yyextra->m_yyllocStack.back();
                                yyextra->m_yyllocStack.pop_back();
                            }
                        }
.                       {
                            // Unrecognized token => ERROR
                            yyextra -> lexerMessage ( yylloc,
                                                      CompilerBase::MT_ERROR,
                                                      QObject::tr("unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'" );
                        }

%%

/* --------------------------------------------------------------------------- */
/* EPILOGUE - USER CODE - FUNCTION DEFINITIONS                                 */
/* --------------------------------------------------------------------------- */

inline void enlargeStringBuffer ( YYSTYPE * semval,
                                  CompilerParserInterface * compiler,
                                  int byMin )
{
    if ( ( byMin + semval->array.size ) >= compiler->m_strMaxSize )
    {
        compiler->m_strMaxSize = 2 * semval->array.size;
        semval->array.data = (unsigned char*) realloc(semval->array.data, compiler->m_strMaxSize);
    }
}
