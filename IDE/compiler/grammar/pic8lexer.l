/* ========================================================================== */
/**
 * @brief
 *
 * ...
 *
 * (C) copyright 2013 Moravia Microsystems, s.r.o.
 *
 * @author Martin Ošmera <martin.osmera@gmail.com>
 */
/* ========================================================================== */


/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
    // Standard header files
    #include <iostream>
    #include <cctype>
    #include <cstdlib>
    #include <cstdio>
    #include <cstdint>
    // Assembler interface to the syntax analyzer (parser) and the lexical analyzer (lexer/scaner)
    #include "CompilerParserInterface.h"
    // Header file for the parser generated by Bison
    #include "pic8parser.h"
    // Functions for handling escape sequences in strings, etc.
    #include "LexerUtils.h"
    using namespace LexerUtils;

    // Each time lexer matches a string, move the end cursor to its end.
    #define YY_USER_ACTION \
        yylloc->last_column += yyleng;

    /**
     * @brief
     * @param yylval: [InOut]
     */
    inline void enlargeStringBuffer(YYSTYPE * yylval, CompilerParserInterface * compiler, int byMin = 1);
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="CompilerParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="pic8lexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="pic8lexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-insensitive scanner */
%option case-insensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* enable use of start condition stacks */
%option stack
/* get rid of the warning message: 'int yy_top_state(yyscan_t)’ defined but not used */
%option noyy_top_state

/*
 * Named regular expressions used in the lexer
 */
/* White space */
WSPACE  ([ \t]|\u00A0)+
/* New line */
NLINE   (\r?\n)|(\n?\r)
/* An identifier in Assembly language */
ID      [_A-Z][_A-Z0-9]*
/* Comment, in this case it starts with a semicolon (`;') */
COMMENT (;[^\r\n]*)
/* C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177' */
XESC    (\\[0-7]{1,3})|(\\x[0-9A-F]{1,2})|(\\[uU][0-9A-F]{1,8})

/*
 * Exclusive start conditions
 */
/* Inside a string, e.g. "my string" */
%x STR
/* Inside a string, or a character literal; e.g. 'my string', or 'a' */
%x QUOTE
/* Multi-line comment */
%x MCOMMENT
/* Inside an INCLUDE directive */
%x INC
%x INC_END


/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
    // Terminate lexical analysis, in case all input files have been closed using the EXIT' directive.
    if ( NULL == pic8lexer_get_in(yyscanner) ) {
        yyterminate();
    }

    // At each yylex invocation, mark the current position as the start of the next token.
    yylloc_param->first_line   = yylloc_param->last_line;
    yylloc_param->first_column = yylloc_param->last_column;
%}

{WSPACE}        { /* eat up white space */ }
{NLINE}         {
            yylloc->last_line++;
            yylloc->last_column = 1;
            return EOL;
        }

;{COMMENT}      { return COMMENT; }
{COMMENT}       { /* ignore ordinary comment */ }
<INITIAL,INC,INC_END>{
    "/*"            { yy_push_state(MCOMMENT, yyscanner); }
}
<MCOMMENT>{
    "*/"            { yy_pop_state(yyscanner); }
    [^*\n]*         { /* eat anything that's not a '*' */ }
    "*"+[^*/\n]*    { /* eat up '*'s not followed by '/'s */ }
    {NLINE}         {
                yylloc->last_line++;
                yylloc->last_column = 1;
                return EOL;
            }
}

\.?"define"     { return D_DEFINE; }
"#define"       { return D_DEFINE; }
\.?"undefine"   { return D_UNDEFINE; }
"#undefine"     { return D_UNDEFINE; }
"#ifdef"        { return D_DC_IFDEF; }
"#ifndef"       { return D_DC_IFNDEF; }
"#endif"        { return D_DC_ENDIF; }
\.?"constant"   { return D_CONSTANT; }
\.?"processor"  { return D_PROCESSOR; }
\.?"radix"      { return D_RADIX; }
\.?"variable"   { return D_VARIABLE; }
\.?"while"      { return D_WHILE; }
\.?"__badram"   { return D___BADRAM; }
\.?"__badrom"   { return D___BADROM; }
\.?"__config"   { return D___CONFIG; }
\.?"config"     { return D_CONFIG; }
\.?"__idlocs"   { return D___IDLOCS; }
\.?"__maxram"   { return D___MAXRAM; }
\.?"__maxrom"   { return D___MAXROM; }
\.?"cblock"     { return D_CBLOCK; }
\.?"da"         { return D_DA; }
\.?"data"       { return D_DATA; }
\.?"db"         { return D_DB; }
\.?"de"         { return D_DE; }
\.?"dt"         { return D_DT; }
\.?"dw"         { return D_DW; }
\.?"endc"       { return D_ENDC; }
\.?"fill"       { return D_FILL; }
\.?"res"        { return D_RES; }
\.?"error"      { return D_ERROR; }
\.?"errorlevel" { return D_ERRORLEVEL; }
\.?"list"       { return D_LIST; }
\.?"messg"      { return D_MESSG; }
\.?"nolist"     { return D_NOLIST; }
\."page"        { return D_PAGE; }
\.?"space"      { return D_SKIP; }
\.?"subtitle"   { return D_SUBTITLE; }
\.?"title"      { return D_TITLE; }
\.?"expand"     { return D_EXPAND; }
\.?"noexpand"   { return D_NOEXPAND; }
\.?"access_ovr" { return D_ACCESS_OVR; }
\.?"bankisel"   { return D_BANKISEL; }
\.?"banksel"    { return D_BANKSEL; }
\.?"code"       { return D_CODE; }
\.?"code_pack"  { return D_CODE_PACK; }
\.?"extern"     { return D_EXTERN; }
\.?"global"     { return D_GLOBAL; }
\.?"idata"      { return D_IDATA; }
\.?"idata_acs"  { return D_IDATA_ACS; }
\.?"pagesel"    { return D_PAGESEL; }
\.?"pageselw"   { return D_PAGESELW; }
\.?"udata"      { return D_UDATA; }
\.?"udata_acs"  { return D_UDATA_ACS; }
\.?"udata_ovr"  { return D_UDATA_OVR; }
\.?"udata_shr"  { return D_UDATA_SHR; }
\.?"if"         { return D_IF; }
\.?"ifn"        { return D_IFN; }
\.?"ifdef"      { return D_IFDEF; }
\.?"ifndef"     { return D_IFNDEF; }
\.?"elseifb"    { return D_ELSEIFB; }
\.?"elseifnb"   { return D_ELSEIFNB; }
\.?"else"       { return D_ELSE; }
\.?"elseif"     { return D_ELSEIF; }
\.?"elseifn"    { return D_ELSEIFN; }
\.?"elseifdef"  { return D_ELSEIFDEF; }
\.?"elseifndef" { return D_ELSEIFNDEF; }
\.?"endif"      { return D_ENDIF; }
\.?"local"      { return D_LOCAL; }
\.?"ifnb"       { return D_IFNB; }
\.?"ifb"        { return D_IFB; }
\.?"skip"       { return D_SKIP; }
\.?"endmacro"   { return D_ENDMACRO; }
\.?"endm"       { return D_ENDM; }
\.?"exitm"      { return D_EXITM; }
\.?"rept"       { return D_REPT; }
\.?"macro"      { return D_MACRO; }
\.?"equ"        { return D_EQU; }
\.?"org"        { return D_ORG; }
\.?"set"        { return D_SET; }
\.?"endw"       { return D_ENDW; }
\.?"end"        {
            // Close the current file
            pic8lexer_pop_buffer_state(yyscanner);
            if ( YY_CURRENT_BUFFER ) {
                yyextra->popFileName();
                *yylloc = yyextra->m_yyllocStack.back();
                yyextra->m_yyllocStack.pop_back();
            } else {
                pic8lexer_set_in(NULL, yyscanner);
            }

            return D_END;
        }

"addwf"         { return I_ADDWF; }
"andwf"         { return I_ANDWF; }
"clrf"          { return I_CLRF; }
"clrw"          { return I_CLRW; }
"comf"          { return I_COMF; }
"decf"          { return I_DECF; }
"decfsz"        { return I_DECFSZ; }
"incf"          { return I_INCF; }
"incfsz"        { return I_INCFSZ; }
"iorwf"         { return I_IORWF; }
"movf"          { return I_MOVF; }
"movwf"         { return I_MOVWF; }
"nop"           { return I_NOP; }
"rlf"           { return I_RLF; }
"rrf"           { return I_RRF; }
"subwf"         { return I_SUBWF; }
"swapf"         { return I_SWAPF; }
"xorwf"         { return I_XORWF; }
"bcf"           { return I_BCF; }
"bsf"           { return I_BSF; }
"btfsc"         { return I_BTFSC; }
"btfss"         { return I_BTFSS; }
"addlw"         { return I_ADDLW; }
"andlw"         { return I_ANDLW; }
"call"          { return I_CALL; }
"clrwdt"        { return I_CLRWDT; }
"goto"          { return I_GOTO; }
"iorlw"         { return I_IORLW; }
"movlw"         { return I_MOVLW; }
"retfie"        { return I_RETFIE; }
"retlw"         { return I_RETLW; }
"return"        { return I_RETURN; }
"sleep"         { return I_SLEEP; }
"sublw"         { return I_SUBLW; }
"xorlw"         { return I_XORLW; }
"option"        { return I_OPTION; }
"tris"          { return I_TRIS; }

"high"          { return F_HIGH; }
"low"           { return F_LOW; }
"byte2"         { return F_BYTE2; }
"byte3"         { return F_BYTE3; }
"byte4"         { return F_BYTE4; }
"lwrd"          { return F_LWRD; }
"hwrd"          { return F_HWRD; }
"page"          { return F_PAGE; }
"exp2"          { return F_EXP2; }
"log2"          { return F_LOG2; }
"#v"            { return F_V; }

":"             { return COLON; }
".."            { return INTERVAL; }
"("             { return LP; }
")"             { return RP; }
","             { return COMMA; }
"/"             { return SLASH; }
"+"             { return PLUS; }
"-"             { return MINUS; }
"*"             { return ASTERISK; }
"!"             { return NOT; }
"%"             { return MOD; }
"<<"            { return SHL; }
">>"            { return SHR; }
"&&"            { return AND; }
"||"            { return OR; }
"^^"            { return XOR; }
"&"             { return BITAND; }
"|"             { return BITOR; }
"^"             { return BITXOR; }
"=="            { return EQ; }
"<>"            { return NE; }
"!="            { return NE; }
"<"             { return LT; }
"<="            { return LE; }
">"             { return GT; }
">="            { return GE; }
"="             { return ASSIGN; }
"~"             { return COMPLEMET; }
"+="            { return ADD_ASSIGN; }
"-="            { return SUB_ASSIGN; }
"*="            { return MUL_ASSIGN; }
"/="            { return DIV_ASSIGN; }
"%="            { return MOD_ASSIGN; }
"<<="           { return SHL_ASSIGN; }
">>="           { return SHR_ASSIGN; }
"&="            { return AND_ASSIGN; }
"|="            { return ORB_ASSIGN; }
"^="            { return XOR_ASSIGN; }
"++"            { return INCREMENT; }
"--"            { return DECREMENT; }

"#include"      {
            // Handle `include' directive
            yy_push_state(INC_END, yyscanner);
            yy_push_state(INC, yyscanner);
            yylval->array.size = -1;
        }
<INC,INC_END>{
    {WSPACE}        { /* eat up white space */ }
    ;{COMMENT}      { return COMMENT; }
    {COMMENT}       { /* ignore commets */ }
}
<INITIAL,INC>\" {
            // Beginning of a string, i.e. --> "some string"
            yy_push_state(STR, yyscanner);
            yyextra->m_strMaxSize = 32;
            yylval->array.size = 0;
            yylval->array.data = (unsigned char*) malloc(yyextra->m_strMaxSize);
        }
'               {
            // Beginning of a string, or a character literal; i.e. --> 'a' (char.), or --> 'some string' (str.)
            yy_push_state(QUOTE, yyscanner);
            yyextra->m_strMaxSize = 8;
            yylval->array.size = 0;
            yylval->array.data = (unsigned char*) malloc(yyextra->m_strMaxSize);
        }
<STR>{
    \"              {
                // End of the string, i.e. "my string" <--
                yy_pop_state(yyscanner);
                switch ( YY_START ) {
                    case INITIAL:
                        return STRING;
                    case INC:
                        yy_pop_state(yyscanner);
                        break;
                    default:
                        yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                            QObject::tr("syntax not understood").toStdString());
                        break;
                }
            }
    [^\\"\r\n]+     {
                // Any string content except for escape sequences, EOL (end of line) is also not allowed

                // Increase the string size
                yylval->array.size += yyleng;
                // Enlarge the string buffer, if necessary
                enlargeStringBuffer(yylval, yyextra);
                // Copy matched characters into our string buffer
                memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
            }
}
<QUOTE>{
    '               {
                // End of the string, or single character literal; i.e. 'a' <--, or 'some string' <--
                yy_pop_state(yyscanner);
                if ( yylval->array.size == 1 ) {
                    yylval->number = int(yylval->array.data[0]);
                    return NUMBER;
                } else {
                    yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                        QObject::tr("character constant is too long").toStdString());
                }
            }
    [^\\'\r\n]+     {
                // Any string, content except for escape sequences, EOL (end of line) is also not allowed

                // Increase the string size
                yylval->array.size += yyleng;
                // Enlarge the string buffer, if necessary
                enlargeStringBuffer(yylval, yyextra);
                // Copy matched characters into our string buffer
                memcpy(yylval->array.data + yylval->array.size - yyleng, yytext, yyleng);
            }
}
<STR,QUOTE>{
    {NLINE}         {
                // A string has to be terminated at the same line which it was started on
                yy_pop_state(yyscanner);
                yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                    QObject::tr("unterminated string or character constant").toStdString());

                // Put the EOL character sequence back onto the input stream
                char * eol = strdup(yytext);
                for ( int i = yyleng - 1; i >= 0; --i ) {
                    unput(eol[i]);
                }
                free(eol);

                if ( INITIAL == YY_START ) {
                    return STRING;
                }
            }
    {XESC}          {
                // Handle C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

                int size; // Size of the binary value in bytes
                uint32_t value = escapeSequence(yyextra, yylloc, yytext, &size);

                // Check whether the conversion was successful
                if ( 0 == size ) {
                    yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                        QObject::tr("unrecognized escape sequence: ").toStdString() + "`" + yytext + "'");
                    yyterminate();
                }

                // Copy converted escape sequence to the string buffer
                enlargeStringBuffer(yylval, yyextra, size);
                for ( int i = 0; i < size; i++ ) {
                    yylval->array.data [ yylval->array.size++ ] = (unsigned char) (value & 0xFF);
                    value >>= 8;
                }
            }
    \\.             {
                // Handle escape sequences inside strings and character literals, and convert the to binary values

                // Enlarge the string buffer, if necessary
                enlargeStringBuffer(yylval, yyextra);
                // Copy converted escape sequence to the string buffer
                int size;
                yylval->array.data [ yylval->array.size++ ] = (unsigned char) escapeSequence(yyextra, yylloc, yytext, &size);
            }
    <<EOF>>         {
                // Handle strings terminated by EOF (End Of File) as ERROR, of course.
                yy_pop_state(yyscanner);
                yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                    QObject::tr("unterminated string or character constant").toStdString());

                // Discard the string buffer and terminate lexical analysis (this is a fatal error)
                free(yylval->array.data);
                yylval->array.size = 0;
                yyterminate();
            }
}
<INC,INC_END>{
    {NLINE}         {
                // Attempt to open the specified file

                // Put the EOL character sequence back onto the input stream
                char * eol = strdup(yytext);
                for ( int i = yyleng - 1; i >= 0; --i ) {
                    unput(eol[i]);
                }
                free(eol);

                yy_pop_state(yyscanner);

                if ( 1 > yylval->array.size ) {
                    yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                        QObject::tr("no file name specified").toStdString());
                    return INCLUDE;
                }
                enlargeStringBuffer(yylval, yyextra);
                yylval->array.data [ yylval->array.size ] = '\0';

                char * filename = (char*) yylval->array.data;

                if ( strlen(filename) != (size_t) yylval->array.size ) {
                    yyextra->lexerMessage(yylloc, CompilerBase::MT_WARNING,
                        QObject::tr("file name contains a null character").toStdString() );
                }

                FILE * file = yyextra->fileOpen(filename);
                if ( NULL == file ) {
                    yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                        QObject::tr("unable to open the specified file: ").toStdString() + "`" + filename + "'" );
                    return INCLUDE;
                } else {
                    yylval->string = filename;

                    yyextra->m_yyllocStack.push_back(*yylloc);
                    pic8lexer_push_buffer_state(pic8lexer__create_buffer(file, YY_BUF_SIZE, yyscanner), yyscanner);

                    yylloc->last_line = 1;
                    yylloc->last_column = 1;

                    return INCLUDE;
                }
            }
    .               {
                // Anything else results in an error, it wouldn't make sense otherwise
                yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                    QObject::tr("unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'");
                yyterminate();
            }
}
[01]+b          {
            // Binary number (max. 64 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `b'
            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 64, 2);
            return NUMBER;
        }
[0-9A-F]+h      {
            // Hexadecimal number (max. 16 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `h'
            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 16, 16);
            return NUMBER;
        }
[0-7]+[oq]      {
            // Octal number (max. 21 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `o' or `q'
            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 21, 8);
            return NUMBER;
        }
[0-9]+d         {
            // Decimal number (max. 10 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing `d'
            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
            return NUMBER;
        }
0b[01]+         {
            // Binary number (max. 64 digits, max. 32 bits)
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
            return NUMBER;
        }
0x[0-9A-F]+     {
            // Hexadecimal number (max. 16 digits, max. 32 bits)
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
            return NUMBER;
        }
0[0-7]+         {
            // Octal number (max. 21 digits, max. 32 bits)
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 1), 21, 8);
            return NUMBER;
        }
[0-9]+          {
            // Decimal number (max. 10 digits, max. 32 bits)
            yylval->number = convertStrToNumber(yyextra, yylloc, yytext, 10, 10);
            return NUMBER;
        }
b'[01]+'        {
            // Binary number (max. 64 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing '
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 64, 2);
            return NUMBER;
        }
h'[0-9A-F]+'    {
            // Hexadecimal number (max. 16 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing '
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 16, 16);
            return NUMBER;
        }
o'[0-7]+'       {
            // Octal number (max. 21 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing '
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 21, 8);
            return NUMBER;
        }
d'[0-9]+'               {
            // Decimal number (max. 10 digits, max. 32 bits)
            yytext [ yyleng - 1 ] = '\0'; // Remove the trailing '
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 2), 10, 10);
            return NUMBER;
        }
\.[0-9]+                {
            // Decimal number (max. 10 digits, max. 32 bits)
            yylval->number = convertStrToNumber(yyextra, yylloc, (yytext + 1), 10, 10);
            return NUMBER;
        }


{ID}:           {
            // Label, e.g. `main:'

            // Remove the trailing `:'
            yytext [ yyleng - 1 ] = '\0';

            // Convert the string to upper case characters
            for ( int i = 0; i < yyleng; i++ ) {
                yytext[i] = toupper(yytext[i]);
            }

            // Return as label
            yylval->string = yytext;
            return LABEL;
        }
{ID}|"$"        {
            // Arbitrary identifier, e.g. `MYREG_U1'

            // Convert the string to upper case characters
            for ( int i = 0; i < yyleng; i++ ) {
                yytext[i] = toupper(yytext[i]);
            }

            // Return as general identifier
            yylval->string = yytext;
            return IDENFIFIER;
        }
<<EOF>>         {
            // Handle end of file; possibly switch back to previous file, in case "include" was used
            pic8lexer_pop_buffer_state(yyscanner);
            if ( !YY_CURRENT_BUFFER ) {
                yyterminate();
            } else {
                yyextra->popFileName();
                *yylloc = yyextra->m_yyllocStack.back();
                yyextra->m_yyllocStack.pop_back();
            }
        }
.               {
            // Unrecognized token => ERROR
            yyextra->lexerMessage(yylloc, CompilerBase::MT_ERROR,
                QObject::tr("unrecognized token: ").toStdString() + "`" + std::string(yytext) + "'");
        }

%%

/* --------------------------------------------------------------------------- */
/* EPILOGUE - USER CODE - FUNCTION DEFINITIONS                                 */
/* --------------------------------------------------------------------------- */

inline void enlargeStringBuffer(YYSTYPE * semval, CompilerParserInterface * compiler, int byMin) {
    if ( ( byMin + semval->array.size ) >= compiler->m_strMaxSize ) {
        compiler->m_strMaxSize = 2 * semval->array.size;
        semval->array.data = (unsigned char*) realloc(semval->array.data, compiler->m_strMaxSize);
    }
}
