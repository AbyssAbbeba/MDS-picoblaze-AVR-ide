/* ========================================================================== */
/**
 * @brief
 *
 * ...
 *
 * (C) copyright 2013 Moravia Microsystems, s.r.o.
 *
 * @author Martin Ošmera <martin.osmera@gmail.com>
 */
/* ========================================================================== */


/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
    // Standard header files
    #include <iostream>

    // Header file for the parser generated by Bison
    #include "moraviaScriptParser.h"

    // Each time lexer matches a string, move the end cursor to its end.
    #define YY_USER_ACTION \
        yylloc->last_column += yyleng;
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="MScriptParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="moraviaScriptLexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="moraviaScriptLexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-sensitive scanner */
%option case-sensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* enable use of start condition stacks */
%option stack
/* get rid of the warning message: 'int yy_top_state(yyscan_t)’ defined but not used */
%option noyy_top_state
/* To suppress the warning message "yyunput defined but not used". */
%option nounput


/*
 * Named regular expressions used in the lexer
 */
/* White space */
WSPACE  ([ \t]|\u00A0)+
/* New line */
NLINE   (\r?\n)|(\n?\r)
/* An identifier in the language */
ID      [_a-zA-Z][_a-zA-Z0-9]*
/* Comment, in this case it starts with a semicolon (`;') */
COMMENT (\/\/\/*[^\r\n]*)
/* C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177' */
XESC    (\\[0-7]{1,3})|(\\x[0-9A-F]{1,2})|(\\[uU][0-9A-F]{1,8})

/*
 * Exclusive start conditions
 */
/* Inside a string, e.g. "my string" */
%x STR
/* Inside a character literal; e.g. 'm', or '\x45' */
%x QUOTE
/* Multi-line comment */
%x MCOMMENT


/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
    // At each yylex invocation, mark the current position as the start of the next token.
    yylloc_param->first_line   = yylloc_param->last_line;
    yylloc_param->first_column = yylloc_param->last_column;
%}

{WSPACE}                { /* eat up white space */ }
{NLINE}                 {
                            yylloc->last_line++;
                            yylloc->last_column = 1;
/*                             return EOL; */
                        }

{COMMENT}               { /* ignore ordinary comment */ }
<INITIAL>
{
    "/*"                { yy_push_state(MCOMMENT, yyscanner); }
}
<MCOMMENT>
{
    "*/"                { yy_pop_state(yyscanner); }
    [^*\n]*             { /* eat anything that's not a '*' */ }
    "*"+[^*/\n]*        { /* eat up '*'s not followed by '/'s */ }
    {NLINE}             {
                            yylloc->last_line++;
                            yylloc->last_column = 1;
/*                             return EOL; */
                        }
}

"if"            { return KW_IF; }
"else"          { return KW_ELSE; }
"for"           { return KW_FOR; }
"while"         { return KW_WHILE; }

";"             { return EOS; }

"("             { return B_RND_LEFT; }
")"             { return B_RND_RIGHT; }
"["             { return B_SQR_LEFT; }
"]"             { return B_SQR_RIGHT; }
"{"             { return B_CRL_LEFT; }
"}"             { return B_CRL_RIGHT; }

"@"             { return O_AT; }
","             { return O_COMMA; }
"/"             { return O_SLASH; }
"+"             { return O_PLUS; }
"-"             { return O_MINUS; }
"*"             { return O_ASTERISK; }
"!"             { return O_NOT; }
"%"             { return O_MOD; }
"<<"            { return O_SHL; }
">>"            { return O_SHR; }
"&&"            { return O_AND; }
"||"            { return O_OR; }
"&"             { return O_BITAND; }
"|"             { return O_BITOR; }
"^"             { return O_BITXOR; }
"=="            { return O_EQ; }
"<>"            { return O_NE; }
"!="            { return O_NE; }
"<"             { return O_LT; }
"<="            { return O_LE; }
">"             { return O_GT; }
">="            { return O_GE; }
"="             { return O_ASSIGN; }
"~"             { return O_COMPLEMET; }
"+="            { return O_ADD_ASSIGN; }
"-="            { return O_SUB_ASSIGN; }
"*="            { return O_MUL_ASSIGN; }
"/="            { return O_DIV_ASSIGN; }
"%="            { return O_MOD_ASSIGN; }
"<<="           { return O_SHL_ASSIGN; }
">>="           { return O_SHR_ASSIGN; }
"&="            { return O_AND_ASSIGN; }
"|="            { return O_ORB_ASSIGN; }
"^="            { return O_XOR_ASSIGN; }
"++"            { return O_INCREMENT; }
"--"            { return O_DECREMENT; }
