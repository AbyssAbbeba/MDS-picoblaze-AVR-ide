/* ========================================================================== */
/**
 * @brief
 *
 * ...
 *
 * (C) copyright 2013 Moravia Microsystems, s.r.o.
 *
 * @author Martin Ošmera <martin.osmera@moravia-microsystems.com>
 */
/* ========================================================================== */


/* -------------------------------------------------------------------------- */
/* PROLOGUE - FLEX DECLARATIONS                                               */
/* -------------------------------------------------------------------------- */

%{
    // Standard header files.
    #include <cmath>
    #include <cctype>
    #include <cstdio>
    #include <cstdint>
    #include <cstdlib>
    #include <iostream>

    // Header file for the parser generated by Bison
    #include "MScriptParser.h"

    // MScript language interpreter header files.
    #include "MScriptLexerAuxFunc.h"
    #include "MScriptParserInterface.h"

    // Each time lexer matches a string, move the end cursor to its end.
    #define YY_USER_ACTION \
        yylloc->last_column += yyleng;

    /**
     * @brief
     * @param[in,out] semval
     * @param[in,out] core
     * @param[in] byMin
     */
    inline void enlargeStringBuffer ( YYSTYPE * semval,
                                      MScriptParserInterface * core,
                                      int byMin = 1 );
%}

/* data type of the user-specific data to be stored in compiler */
%option extra-type="MScriptParserInterface *"
/* instructs flex to write a C header to FILE */
%option header-file="MScriptLexer.h"
/* changes the default `yy' prefix used by flex for all globally-visible variable and function names */
%option prefix="MScriptLexer_"
/* instruct flex that GNU bison %locations are being used */
%option bison-locations
/* instructs flex to generate a C scanner that is meant to be called by a GNU bison parser */
%option bison-bridge
/* instructs flex to generate a case-sensitive scanner */
%option case-sensitive
/* instructs flex to generate a scanner which never considers its input interactive */
%option never-interactive
/* instructs flex to generate a reentrant C scanner */
%option reentrant
/* instructs flex to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters */
%option 8bit
/* in general, you use `-B' when you are certain that your scanner will never be used interactively */
%option batch
/* suppresses inclusion of the non-ANSI header file unistd.h. */
%option nounistd
/* directs flex to generate a scanner that maintains the number of the current line read from its input */
%option yylineno
/* makes the scanner not call yywrap() upon an end-of-file */
%option noyywrap
/* generate warning messages */
%option warn
/* enable use of start condition stacks */
%option stack
/* get rid of the warning message: 'int yy_top_state(yyscan_t)’ defined but not used */
%option noyy_top_state
/* To suppress the warning message "yyunput defined but not used". */
%option nounput


/*
 * Named regular expressions used in the lexer
 */
/* White space. */
WSPACE  ([ \t]|\u00A0)+
/* New line */
NLINE   (\r?\n)|(\n?\r)
/* Comment, in this case it starts with a semicolon (`;'). */
COMMENT (\/\/\/*[^\r\n]*)
/* C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'. */
XESC    (\\[0-7]{1,3})|(\\x[0-9A-F]{1,2})|(\\[uU][0-9A-F]{1,8})
/* Floating point number. */
FLOAT   [0-9]+\.[0-9]+(e[+-][0-9]+)?
/* Namespace separator. */
NSEP    ::
/* An identifier in the language. */
ID      [_a-zA-Z][_a-zA-Z0-9]*
/* ID with namespaces. */
EID     ({NSEP})?{ID}

/*
 * Exclusive start conditions
 */
/* Inside a string, e.g. "my string" */
%x STR
/* Multi-line comment */
%x MCOMMENT


/* -------------------------------------------------------------------------- */
/* LEXICAL RULES                                                              */
/* -------------------------------------------------------------------------- */

%%

%{
    // At each yylex invocation, mark the current position as the start of the next token.
    yylloc_param->first_line   = yylloc_param->last_line;
    yylloc_param->first_column = yylloc_param->last_column;
%}

 /* White space: */
{WSPACE}        { /* eat up white space */ }
{NLINE}         {
                    yylloc->last_line++;
                    yylloc->last_column = 1;
                }
 /* Comments: */
{COMMENT}       { /* ignore ordinary comment */ }
<INITIAL>
{
    "/*"        { yy_push_state(MCOMMENT, yyscanner); }
}
<MCOMMENT>
{
   "*/"         { yy_pop_state(yyscanner); }
   [^*\n]*      { /* eat anything that's not a '*' */ }
   "*"+[^*/\n]* { /* eat up '*'s not followed by '/'s */ }
   {NLINE}      {
                    yylloc->last_line++;
                    yylloc->last_column = 1;
                }
}

 /* Special tokens: */
";"             { return EOS;             }

 /* Key Words: */
"if"            { return KW_IF;           }
"else"          { return KW_ELSE;         }
"for"           { return KW_FOR;          }
"while"         { return KW_WHILE;        }
"func"          { return KW_FUNC;         }
"do"            { return KW_DO;           }
"return"        { return KW_RETURN;       }
"break"         { return KW_BREAK;        }
"continue"      { return KW_CONTINUE;     }
"switch"        { return KW_SWITCH;       }
"case"          { return KW_CASE;         }
"default"       { return KW_DEFAULT;      }
"delete"        { return KW_DELETE;       }
"var"           { return KW_VAR;          }
"const"         { return KW_CONST;        }
"namespace"     { return KW_NAMESPACE;    }
"include"       { return KW_INCLUDE;      }
"eval"          { return KW_EVAL;         }

 /* Special values: */
"EMPTY"         { return SV_EMPTY;        }
"INFINITY"      { return SV_INFINITY;     }
"NAN"           { return SV_NAN;          }
"M_PI"          { return SV_PI;           }
"M_E"           { return SV_E;            }

 /* Brackets: */
"("             { return B_RND_LEFT;      }
")"             { return B_RND_RIGHT;     }
"["             { return B_SQR_LEFT;      }
"]"             { return B_SQR_RIGHT;     }
"{"             { return B_CRL_LEFT;      }
"}"             { return B_CRL_RIGHT;     }

 /* Expression operators: */
":"             { return O_COLON;         }
"?"             { return O_QUESTION_MARK; }
","             { return O_COMMA;         }
"/"             { return O_SLASH;         }
"+"             { return O_PLUS;          }
"-"             { return O_MINUS;         }
"*"             { return O_ASTERISK;      }
"!"             { return O_NOT;           }
"%"             { return O_MOD;           }
"<<"            { return O_SHL;           }
">>"            { return O_SHR;           }
"&&"            { return O_AND;           }
"||"            { return O_OR;            }
"&"             { return O_BITAND;        }
"|"             { return O_BITOR;         }
"^"             { return O_BITXOR;        }
"=="            { return O_EQ;            }
"<>"            { return O_NE;            }
"!="            { return O_NE;            }
"<"             { return O_LT;            }
"<="            { return O_LE;            }
">"             { return O_GT;            }
">="            { return O_GE;            }
"="             { return O_ASSIGN;        }
"~"             { return O_COMPLEMET;     }
"+="            { return O_ADD_ASSIGN;    }
"-="            { return O_SUB_ASSIGN;    }
"*="            { return O_MUL_ASSIGN;    }
"/="            { return O_DIV_ASSIGN;    }
"%="            { return O_MOD_ASSIGN;    }
"<<="           { return O_SHL_ASSIGN;    }
">>="           { return O_SHR_ASSIGN;    }
"&="            { return O_BAND_ASSIGN;   }
"|="            { return O_BOR_ASSIGN;    }
"&&="           { return O_LAND_ASSIGN;   }
"||="           { return O_LOR_ASSIGN;    }
"^="            { return O_XOR_ASSIGN;    }
"**="           { return O_POW_ASSIGN;    }
"++"            { return O_INCREMENT;     }
"--"            { return O_DECREMENT;     }
"**"            { return O_POWER;         }

 /*
  * Built-in functions:
  */
 /* Datatype recognition. */
"isbool"        { return F_ISBOOL;        }
"isint"         { return F_ISINT;         }
"isstring"      { return F_ISSTRING;      }
"isfloat"       { return F_ISFLOAT;       }
"iscomplex"     { return F_ISCOMPLEX;     }
"isempty"       { return F_ISEMPTY;       }
 /* Datatype conversion. */
"bool"          { return F_BOOL;          }
"int"           { return F_INT;           }
"string"        { return F_STRING;        }
"float"         { return F_FLOAT;         }
"complex"       { return F_COMPLEX;       }
 /* Floating point value classification. */
"isnan"         { return F_ISNAN;         }
"isinfinity"    { return F_ISINFINITY;    }
"ispositive"    { return F_ISPOSITIVE;    }
"isnegative"    { return F_ISNEGATIVE;    }
"isfinite"      { return F_ISFINITE;      }
 /* Complex plane decomposition. */
"Re"            { return F_RE;            }
"Im"            { return F_IM;            }
 /* Trigonometric functions. */
"sin"           { return F_SIN;           }
"cos"           { return F_COS;           }
"tan"           { return F_TAN;           }
 /* Inverse trigonometric functions. */
"asin"          { return F_ARCSIN;        }
"acos"          { return F_ARCCOS;        }
"atan"          { return F_ARCTAN;        }
 /* Hyperbolic functions. */
"sinh"          { return F_SINH;          }
"cosh"          { return F_COSH;          }
"tanh"          { return F_TANH;          }
 /* Inverse hyperbolic functions. */
"asinh"         { return F_ARCSINH;       }
"acosh"         { return F_ARCCOSH;       }
"atanh"         { return F_ARCTANH;       }
 /* Other functions. */
"ceil"          { return F_CEIL;          }
"round"         { return F_ROUND;         }
"floor"         { return F_FLOOR;         }
"abs"           { return F_ABS;           }
"min"           { return F_MIN;           }
"max"           { return F_MAX;           }
"length"        { return F_LENGTH;        }

 /*
  * Numbers:
  */
 /* Boolean numbers: */
"true"          {
                    yylval->boolean = true;
                    return BOOLEAN;
                }
"false"         {
                    yylval->boolean = false;
                    return BOOLEAN;
                }
 /* Integral numbers: */
0b[01]+         {
                    // Binary number.
                    yylval->integer = MScriptLexerAuxFunc::str2int ( yyextra, yylloc, ( yytext + 2 ), 2 );
                    return INTEGER;
                }
0x[0-9A-F]+     {
                    // Hexadecimal number.
                    yylval->integer = MScriptLexerAuxFunc::str2int ( yyextra, yylloc, ( yytext + 2 ), 16 );
                    return INTEGER;
                }
0[0-7]+         {
                    // Octal number.
                    yylval->integer = MScriptLexerAuxFunc::str2int ( yyextra, yylloc, ( yytext + 1 ), 8 );
                    return INTEGER;
                }
[0-9]+          {
                    // Decimal number.
                    yylval->integer = MScriptLexerAuxFunc::str2int ( yyextra, yylloc, yytext, 10 );
                    return INTEGER;
                }
 /* Real numbers: */
{FLOAT}         {
                    // Floating point number.
                    yylval->real = MScriptLexerAuxFunc::str2float ( yyextra, yylloc, yytext );
                    return REAL;
                }
 /* Imaginary numbers: */
{FLOAT}i        {
                    // Floating point number.
                    yytext [ strlen(yytext) - 1 ] = '\0';
                    yylval->imaginary = MScriptLexerAuxFunc::str2float ( yyextra, yylloc, yytext );
                    return IMAGINARY;
                }
0b[01]+i        {
                    // Binary number.
                    yytext [ strlen(yytext) - 1 ] = '\0';
                    yylval->imaginary = (double) MScriptLexerAuxFunc::str2int ( yyextra, yylloc, ( yytext + 2 ), 2 );
                    return IMAGINARY;
                }
0x[0-9A-F]+i    {
                    // Hexadecimal number.
                    yytext [ strlen(yytext) - 1 ] = '\0';
                    yylval->imaginary = (double) MScriptLexerAuxFunc::str2int ( yyextra, yylloc, ( yytext + 2 ), 16 );
                    return IMAGINARY;
                }
0[0-7]+i        {
                    // Octal number.
                    yytext [ strlen(yytext) - 1 ] = '\0';
                    yylval->imaginary = (double) MScriptLexerAuxFunc::str2int ( yyextra, yylloc, ( yytext + 1 ), 8 );
                    return IMAGINARY;
                }
[0-9]+i         {
                    // Decimal number.
                    yytext [ strlen(yytext) - 1 ] = '\0';
                    yylval->imaginary = (double) MScriptLexerAuxFunc::str2int ( yyextra, yylloc, yytext, 10 );
                    return IMAGINARY;
                }
 /* Special numbers: */
"NaN"           {
                    // Not a Number.
                    yylval->real = nan("");
                    return REAL;
                }
"INF"           {
                    // Positive infinity.
                    yylval->real = HUGE_VAL;
                    return REAL;
                }
"NEGINF"        {
                    // Negative infinity.
                    yylval->real = -HUGE_VAL;
                    return REAL;
                }

 /* Character literals: */
'{XESC}'        {
                    // Handle C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

                    int size; // Size of the binary value in bytes
                    yylval->integer = (long long) MScriptLexerAuxFunc::escapeSequence(yyextra, yylloc, yytext, &size);

                    // Check whether the conversion was successful
                    if ( 0 == size )
                    {
                        yyextra->lexerMessage ( yylloc,
                                                MScriptBase::MT_ERROR,
                                                QObject::tr ( "unrecognized escape sequence: " ).toStdString()
                                                            + "`" + yytext + "'" );
                        yyterminate();
                    }

                    return INTEGER;
                }
'\\''           {
                    yylval->integer = (long long) '\'';
                    return INTEGER;
                }
'[^']'          {
                    yylval->integer = (long long) yytext[1];
                    return INTEGER;
                }

 /* Identifiers: */
{ID}            {
                    // Arbitrary identifier, e.g. `MYREG_U1'.

                    // Convert the string to upper case characters.
                    for ( int i = 0; i < yyleng; i++ )
                    {
                        yytext[i] = yytext[i];
                    }

                    // Return as general identifier.
                    yylval->symbol = yytext;
                    return IDENTIFIER;
                }
{EID}(::{ID})*  {
                    // Identifier with namespaces, e.g. `::MyNS::Main::func'.

                    // Convert the string to upper case characters.
                    for ( int i = 0; i < yyleng; i++ )
                    {
                        yytext[i] = yytext[i];
                    }

                    // Return as general identifier.
                    yylval->symbol = yytext;
                    return NSID;
                }

 /* Strings: */
<INITIAL>\"     {
                    // Beginning of a string, i.e. --> "some string"
                    yy_push_state(STR, yyscanner);
                    yyextra->m_strMaxSize = 32;
                    yylval->string.size = 0;
                    yylval->string.data = (char*) malloc(yyextra->m_strMaxSize);
                }
<STR>
{
    \"          {
                    // End of the string, i.e. "my string" <--
                    yy_pop_state(yyscanner);
                    if ( INITIAL == YY_START )
                    {
                        return STRING;
                    }
                    else
                    {
                        yyextra->lexerMessage ( yylloc,
                                                MScriptBase::MT_ERROR,
                                                QObject::tr("syntax not understood").toStdString() );
                    }
                }
    [^\\"]+     {
                    // Any string content except for escape sequences.

                    // Increase the string size
                    yylval->string.size += yyleng;
                    // Enlarge the string buffer, if necessary
                    enlargeStringBuffer(yylval, yyextra);
                    // Copy matched characters into our string buffer
                    memcpy(yylval->string.data + yylval->string.size - yyleng, yytext, yyleng);
                }
    {XESC}      {
                    // Handle C like escape sequence, such as `\x4A', `\uABCD', `\U1234abcd', and `\177'

                    int size; // Size of the binary value in bytes
                    uint32_t value = MScriptLexerAuxFunc::escapeSequence(yyextra, yylloc, yytext, &size);

                    // Check whether the conversion was successful
                    if ( 0 == size )
                    {
                        yyextra->lexerMessage ( yylloc,
                                                MScriptBase::MT_ERROR,
                                                QObject::tr ( "unrecognized escape sequence: " ).toStdString()
                                                            + "`" + yytext + "'" );
                        yyterminate();
                    }

                    // Copy converted escape sequence to the string buffer.
                    enlargeStringBuffer(yylval, yyextra, size);
                    for ( int i = 0; i < size; i++ )
                    {
                        yylval->string.data [ yylval->string.size++ ] = (char) (value & 0xFF);
                        value >>= 8;
                    }
                }
    \\.         {
                    // Handle escape sequences inside strings, and convert the to binary values.

                    // Enlarge the string buffer, if necessary
                    enlargeStringBuffer(yylval, yyextra);
                    // Copy converted escape sequence to the string buffer
                    int size;
                    yylval->string.data [ yylval->string.size++ ]
                        = (char) MScriptLexerAuxFunc::escapeSequence(yyextra, yylloc, yytext, &size);
                }
    <<EOF>>     {
                    // Handle strings terminated by EOF (End Of File) as ERROR.
                    yy_pop_state(yyscanner);
                    yyextra->lexerMessage ( yylloc,
                                            MScriptBase::MT_ERROR,
                                            QObject::tr("unterminated string or character constant").toStdString() );

                    // Discard the string buffer and terminate lexical analysis (this is a fatal error)
                    free(yylval->string.data);
                    yylval->string.size = 0;
                    yyterminate();
                }
}

%%

/* --------------------------------------------------------------------------- */
/* EPILOGUE - USER CODE - FUNCTION DEFINITIONS                                 */
/* --------------------------------------------------------------------------- */

inline void enlargeStringBuffer ( YYSTYPE * semval,
                                  MScriptParserInterface * core,
                                  int byMin )
{
    if ( ( byMin + semval->string.size ) >= core->m_strMaxSize )
    {
        core->m_strMaxSize = 2 * semval->string.size;
        semval->string.data = (char*) realloc(semval->string.data, core->m_strMaxSize);
    }
}
