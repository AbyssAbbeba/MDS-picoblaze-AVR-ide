
; Martin Madron
; 2013/2014
; Picoblaze source code for ML505 board
;**************************************************************************************
        DEVICE          KCPSM3

; Special Register usage
;**************************************************************************************
temp1           REG             sF
temp2           REG             sE
temp3           REG             sD

; Port definitions
LCD_Instruction           PORT            0x01          ; only two upper bits are used
LCD_data                  PORT            0x02          ; data for LCD
;
;
;**************************************************************************************
;Useful data constants
;**************************************************************************************
;ASCII table
;
CONSTANT character_a, 61h
CONSTANT character_b, 62h
CONSTANT character_c, 63h
CONSTANT character_d, 64h
CONSTANT character_e, 65h
CONSTANT character_f, 66h
CONSTANT character_g, 67h
CONSTANT character_h, 68h
CONSTANT character_i, 69h
CONSTANT character_j, 6Ah
CONSTANT character_k, 6Bh
CONSTANT character_l, 6Ch
CONSTANT character_m, 6Dh
CONSTANT character_n, 6Eh
CONSTANT character_o, 6Fh
CONSTANT character_p, 70h
CONSTANT character_q, 71h
CONSTANT character_r, 72h
CONSTANT character_s, 73h
CONSTANT character_t, 74h
CONSTANT character_u, 75h
CONSTANT character_v, 76h
CONSTANT character_w, 77h
CONSTANT character_x, 78h
CONSTANT character_y, 79h
CONSTANT character_z, 7Ah
CONSTANT character_A, 41h
CONSTANT character_B, 42h
CONSTANT character_C, 43h
CONSTANT character_D, 44h
CONSTANT character_E, 45h
CONSTANT character_F, 46h
CONSTANT character_G, 47h
CONSTANT character_H, 48h
CONSTANT character_I, 49h
CONSTANT character_J, 4Ah
CONSTANT character_K, 4Bh
CONSTANT character_L, 4Ch
CONSTANT character_M, 4Dh
CONSTANT character_N, 4Eh
CONSTANT character_O, 4Fh
CONSTANT character_P, 50h
CONSTANT character_Q, 51h
CONSTANT character_R, 52h
CONSTANT character_S, 53h
CONSTANT character_T, 54h
CONSTANT character_U, 55h
CONSTANT character_V, 56h
CONSTANT character_W, 57h
CONSTANT character_X, 58h
CONSTANT character_Y, 59h
CONSTANT character_Z, 5Ah
CONSTANT character_0, 30h
CONSTANT character_1, 31h
CONSTANT character_2, 32h
CONSTANT character_3, 33h
CONSTANT character_4, 34h
CONSTANT character_5, 35h
CONSTANT character_6, 36h
CONSTANT character_7, 37h
CONSTANT character_8, 38h
CONSTANT character_9, 39h
CONSTANT character_colon, 3Ah
CONSTANT character_stop, 2Eh
CONSTANT character_semi_colon, 3Bh
CONSTANT character_minus, 2Dh
CONSTANT character_divide, 2Fh          ;'/'
CONSTANT character_plus, 2Bh
CONSTANT character_comma, 2Ch
CONSTANT character_less_than, 3Ch
CONSTANT character_greater_than, 3Eh
CONSTANT character_equals, 3Dh
CONSTANT character_space, 20h
CONSTANT character_CR, 0Dh              ;carriage return
CONSTANT character_question, 3Fh        ;'?'
CONSTANT character_dollar, 24h
CONSTANT character_exclaim, 21h         ;'!'
CONSTANT character_BS, 08h              ;Back Space command character
;
            ;

            ;**************************************************************************************
            ;Initialise the system
            ;**************************************************************************************
            ;
            ;
            ORG         0x000
            JUMP        Main
            ;**************************************************************************************
            ; Main program
            ;**************************************************************************************
MAIN:
            ; initialise the system, (waits for 1sec)
            CALL        INIT        

                       ;
INIT:       CALL        wait_1s
            

            ;**************************************************************************************
            ;Software delay routines
            ;**************************************************************************************
            ;
            ;
            ;
            ;Delay of 1us.
            ;
            ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
            ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
            ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
            ;
            ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
            ;
            ;Registers used s0
            ;
delay_1us:  LOAD s0, delay_1us_constant
wait_1us:   SUB s0, 01
            JUMP NZ, wait_1us
            RETURN
            ;
            ;Delay of 40us.
            ;
            ;Registers used s0, s1
            ;
delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
wait_40us:  CALL delay_1us
            SUB s1, 01
            JUMP NZ, wait_40us
            RETURN
            ;
            ;
            ;Delay of 1ms.
            ;
            ;Registers used s0, s1, s2
            ;
delay_1ms:  LOAD s2, 19                         ;25 x 40us = 1ms
wait_1ms:   CALL delay_40us
            SUB s2, 01
            JUMP NZ, wait_1ms
            RETURN
            ;
            ;Delay of 20ms.
            ;
            ;Delay of 20ms used during initialisation.
            ;
            ;Registers used s0, s1, s2, s3
            ;
delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
wait_20ms:  CALL delay_1ms
            SUB s3, 01
            JUMP NZ, wait_20ms
            RETURN
            ;
            ;Delay of approximately 1 second.
            ;
            ;Registers used s0, s1, s2, s3, s4
            ;
delay_1s:   LOAD s4, 32                         ;50 x 20ms = 1000ms
wait_1s:    CALL delay_20ms
            SUB s4, 01
            JUMP NZ, wait_1s
            RETURN
            ;
            ;

                                   ;**************************************************************************************
                       ;LCD Character Module Routines
                       ;**************************************************************************************
                       ;
                       ;LCD module is a 16 character by 2 line display but all displays are very similar
                       ;The 4-wire data interface will be used (DB4 to DB7).
                       ;
                       ;The LCD modules are relatively slow and software delay loops are used to slow down
                       ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
                       ;a different section (see above in this case).
                       ;
                       ;
                       ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
                       ;
                       ;Register s4 should define the current state of the LCD output port.
                       ;
                       ;Registers used s0, s4
                       ;
          LCD_pulse_E: XOR s4, LCD_E                       ;E=1
                       OUTPUT s4, LCD_output_port
                       CALL delay_1us
                       XOR s4, LCD_E                       ;E=0
                       OUTPUT s4, LCD_output_port
                       RETURN
                       ;
                       ;Write 4-bit instruction to LCD display.
                       ;
                       ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
                       ;Note that this routine does not release the master enable but as it is only
                       ;used during initialisation and as part of the 8-bit instruction write it
                       ;should be acceptable.
                       ;
                       ;Registers used s4
                       ;
      LCD_write_inst4: AND s4, F8                          ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
                       OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
                       CALL LCD_pulse_E
                       RETURN
                       ;
                       ;
                       ;Write 8-bit instruction to LCD display.
                       ;
                       ;The 8-bit instruction should be provided in register s5.
                       ;Instructions are written using the following sequence
                       ; Upper nibble
                       ; wait >1us
                       ; Lower nibble
                       ; wait >40us
                       ;
                       ;Registers used s0, s1, s4, s5
                       ;
      LCD_write_inst8: LOAD s4, s5
                       AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
                       OR s4, LCD_drive                    ;Enable=1
                       CALL LCD_write_inst4                ;write upper nibble
                       CALL delay_1us                      ;wait >1us
                       LOAD s4, s5                         ;select lower nibble with
                       SL1 s4                              ;Enable=1
                       SL0 s4                              ;RS=0 Instruction
                       SL0 s4                              ;RW=0 Write
                       SL0 s4                              ;E=0
                       CALL LCD_write_inst4                ;write lower nibble
                       CALL delay_40us                     ;wait >40us
                       LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
                       OUTPUT s4, LCD_output_port          ;Release master enable
                       RETURN
                       ;
                       ;
                       ;
                       ;Write 8-bit data to LCD display.
                       ;
                       ;The 8-bit data should be provided in register s5.
                       ;Data bytes are written using the following sequence
                       ; Upper nibble
                       ; wait >1us
                       ; Lower nibble
                       ; wait >40us
                       ;
                       ;Registers used s0, s1, s4, s5
                       ;
       LCD_write_data: LOAD s4, s5
                       AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
                       OR s4, 0C                           ;Enable=1 RS=1 Data, RW=0 Write, E=0
                       OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
                       CALL LCD_pulse_E                    ;write upper nibble
                       CALL delay_1us                      ;wait >1us
                       LOAD s4, s5                         ;select lower nibble with
                       SL1 s4                              ;Enable=1
                       SL1 s4                              ;RS=1 Data
                       SL0 s4                              ;RW=0 Write
                       SL0 s4                              ;E=0
                       OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
                       CALL LCD_pulse_E                    ;write lower nibble
                       CALL delay_40us                     ;wait >40us
                       LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
                       OUTPUT s4, LCD_output_port          ;Release master enable
                       RETURN
                       ;
                       ;
                       ;
                       ;
                       ;Read 8-bit data from LCD display.
                       ;
                       ;The 8-bit data will be read from the current LCD memory address
                       ;and will be returned in register s5.
                       ;It is advisable to set the LCD address (cursor position) before
                       ;using the data read for the first time otherwise the display may
                       ;generate invalid data on the first read.
                       ;
                       ;Data bytes are read using the following sequence
                       ; Upper nibble
                       ; wait >1us
                       ; Lower nibble
                       ; wait >40us
                       ;
                       ;Registers used s0, s1, s4, s5
                       ;
       LCD_read_data8: LOAD s4, 0E                         ;Enable=1 RS=1 Data, RW=1 Read, E=0
                       OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
                       XOR s4, LCD_E                       ;E=1
                       OUTPUT s4, LCD_output_port
                       CALL delay_1us                      ;wait >260ns to access data
                       INPUT s5, LCD_input_port            ;read upper nibble
                       XOR s4, LCD_E                       ;E=0
                       OUTPUT s4, LCD_output_port
                       CALL delay_1us                      ;wait >1us
                       XOR s4, LCD_E                       ;E=1
                       OUTPUT s4, LCD_output_port
                       CALL delay_1us                      ;wait >260ns to access data
                       INPUT s0, LCD_input_port            ;read lower nibble
                       XOR s4, LCD_E                       ;E=0
                       OUTPUT s4, LCD_output_port
                       AND s5, F0                          ;merge upper and lower nibbles
                       SR0 s0
                       SR0 s0
                       SR0 s0
                       SR0 s0
                       OR s5, s0
                       LOAD s4, 04                         ;Enable=0 RS=1 Data, RW=0 Write, E=0
                       OUTPUT s4, LCD_output_port          ;Stop reading 5V device and release master enable
                       CALL delay_40us                     ;wait >40us
                       RETURN
                       ;
                       ;
                       ;Reset and initialise display to communicate using 4-bit data mode
                       ;Includes routine to clear the display.
                       ;
                       ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
                       ;following by the 8-bit instructions to set up the display.
                       ;
                       ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
                       ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
                       ;  0E = '00001' Display control, '1' display on, '1' cursor off, '0' cursor blink off
                       ;  01 = '00000001' Display clear
                       ;
                       ;Registers used s0, s1, s2, s3, s4
                       ;
            LCD_reset: CALL delay_20ms                     ;wait more that 15ms for display to be ready
                       LOAD s4, 30
                       CALL LCD_write_inst4                ;send '3'
                       CALL delay_20ms                     ;wait >4.1ms
                       CALL LCD_write_inst4                ;send '3'
                       CALL delay_1ms                      ;wait >100us
                       CALL LCD_write_inst4                ;send '3'
                       CALL delay_40us                     ;wait >40us
                       LOAD s4, 20
                       CALL LCD_write_inst4                ;send '2'
                       CALL delay_40us                     ;wait >40us
                       LOAD s5, 28                         ;Function set
                       CALL LCD_write_inst8
                       LOAD s5, 06                         ;Entry mode
                       CALL LCD_write_inst8
                       LOAD s5, 0E                         ;Display control
                       CALL LCD_write_inst8
            LCD_clear: LOAD s5, 01                         ;Display clear
                       CALL LCD_write_inst8
                       CALL delay_1ms                      ;wait >1.64ms for display to clear
                       CALL delay_1ms
                       RETURN
                       ;
                       ;Position the cursor ready for characters to be written.
                       ;The display is formed of 2 lines of 16 characters and each
                       ;position has a corresponding address as indicated below.
                       ;
                       ;                   Character position
                       ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
                       ;
                       ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
                       ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
                       ;
                       ;This routine will set the cursor position using the value provided
                       ;in register s5. The upper nibble will define the line and the lower
                       ;nibble the character position on the line.
                       ; Example s5 = 2B will position the cursor on line 2 position 11
                       ;
                       ;Registers used s0, s1, s2, s3, s4
                       ;
           LCD_cursor: TEST s5, 10                         ;test for line 1
                       JUMP Z, set_line2
                       AND s5, 0F                          ;make address in range 80 to 8F for line 1
                       OR s5, 80
                       CALL LCD_write_inst8                ;instruction write to set cursor
                       RETURN
            set_line2: AND s5, 0F                          ;make address in range C0 to CF for line 2
                       OR s5, C0
                       CALL LCD_write_inst8                ;instruction write to set cursor
                       RETURN
                       ;
                       ;This routine will shift the complete display one position to the left.
                       ;The cursor position and LCD memory contents will not change.
                       ;
                       ;
                       ;Registers used s0, s1, s2, s3, s4, s5
                       ;
       LCD_shift_left: LOAD s5, 18                         ;shift display left
                       CALL LCD_write_inst8
                       RETURN
                       ;

            ;
            ;**************************************************************************************
            ; Interrupt Service Routine (ISR)
            ;**************************************************************************************
            ;
            ; Interrupts are not used in this program.
            ;
ISR:        RETURNI ENABLE
            ;
            ;
            ;**************************************************************************************
            ; Interrupt Vector
            ;**************************************************************************************
            ;
            ADDRESS 3FF
            JUMP ISR
            ;
            ;
