  00041            1     character_a             EQU             0x41
  00046            2     character_f             EQU             0x46
  00049            3     character_i             EQU             0x49
  0004C            4     character_l             EQU             0x4c
  00050            5     character_p             EQU             0x50
  00053            6     character_s             EQU             0x53
                   7     device kcpsm6
                   8     ; KCPSM3 Program - LED control with Pulse Width Modulation (PWM).
                   9     ;
                  10     ; Design provided for use with the design 'low_cost_design_authentication_for_spartan_3e.vhd'
                  11     ; and the Spartan-3E Starter Kit. This design provides the token 'real' application to be
                  12     ; protected by design authentication.
                  13     ;
                  14     ; Ken Chapman - Xilinx Ltd
                  15     ;
                  16     ; Version v1.00 - 9th November 2006
                  17     ;
                  18     ; This code automatically sequences the LEDs on the board using PWM to change intensity.
                  19     ; It also checks for correct design authentication and will perform a different sequence if
                  20     ; the design is not authorised.
                  21     ;
                  22     ;
                  23     ;**************************************************************************************
                  24     ; NOTICE:
                  25     ;
                  26     ; Copyright Xilinx, Inc. 2006.   This code may be contain portions patented by other
                  27     ; third parties.  By providing this core as one possible implementation of a standard,
                  28     ; Xilinx is making no representation that the provided implementation of this standard
                  29     ; is free from any claims of infringement by any third party.  Xilinx expressly
                  30     ; disclaims any warranty with respect to the adequacy of the implementation, including
                  31     ; but not limited to any warranty or representation that the implementation is free
                  32     ; from claims of any third party.  Furthermore, Xilinx is providing this core as a
                  33     ; courtesy to you and suggests that you contact all third parties to obtain the
                  34     ; necessary rights to use this implementation.
                  35     ;
                  36     ;
                  37     ;**************************************************************************************
                  38     ; Port definitions
                  39     ;**************************************************************************************
                  40     ;
                  41     ;
                  42     ;
  00080           43     led_port                EQU             0x80                    ;8 simple LEDs
  00001           44     led0                    EQU             0x01                    ;       LD0 - bit0
  00002           45     led1                    EQU             0x02                    ;       LD1 - bit1
  00004           46     led2                    EQU             0x04                    ;       LD2 - bit2
  00008           47     led3                    EQU             0x08                    ;       LD3 - bit3
  00010           48     led4                    EQU             0x10                    ;       LD4 - bit4
  00020           49     led5                    EQU             0x20                    ;       LD5 - bit5
  00040           50     led6                    EQU             0x40                    ;       LD6 - bit6
  00080           51     led7                    EQU             0x80                    ;       LD7 - bit7
                  52     ;
  00000           53     led_read_port           EQU             0x00                    ;read back of current LED drive values
                  54     ;
                  55     ;
  00040           56     security_request_port   EQU             0x40                    ;Port to stimulate security KCPSM3 processor
  00001           57     security_interrupt      EQU             0x01                    ; interrupt - bit0
                  58     ;
                  59     ;
                  60     ;A FIFO buffer links the security KCPSM3 processor to the application KCPSM3 processor.
                  61     ;  This application processor controls and reads the FIFO.
                  62     ;  The security processor writes to the FIFO.
                  63     ;
  00020           64     link_fifo_control_port  EQU             0x20                    ;FIFO control
  00001           65     link_fifo_reset         EQU             0x01                    ;     reset - bit0
                  66     ;
  00001           67     link_fifo_status_port   EQU             0x01                    ;FIFO status input
  00001           68     link_fifo_data_present  EQU             0x01                    ;      half full - bit0
  00002           69     link_fifo_half_full     EQU             0x02                    ;           full - bit1
  00004           70     link_fifo_full          EQU             0x04                    ;   data present - bit2
                  71     ;
  00002           72     link_fifo_read_port     EQU             0x02                    ;read FIFO data
                  73     ;
                  74     ;
                  75     ;
                  76     ;**************************************************************************************
                  77     ; Special Register usage
                  78     ;**************************************************************************************
                  79     ;
                  80     ;
                  81     ;
                  82     ;
                  83     ;**************************************************************************************
                  84     ;Scratch Pad Memory Locations
                  85     ;**************************************************************************************
                  86     ;
  00000           87     pwm_duty_counter        EQU             0x00                    ;Duty Counter 0 to 255 within 1KHz period (1ms)
  00001           88     pwm_channel0            EQU             0x01                    ;PWM settings for each channel
  00002           89     pwm_channel1            EQU             0x02                    ; Channels 0 to 7 = LEDs 0 to 7
  00003           90     pwm_channel2            EQU             0x03
  00004           91     pwm_channel3            EQU             0x04
  00005           92     pwm_channel4            EQU             0x05
  00006           93     pwm_channel5            EQU             0x06
  00007           94     pwm_channel6            EQU             0x07
  00008           95     pwm_channel7            EQU             0x08
  0000D           96     isr_preserve_s0         EQU             0x0d                    ;preserve register contents during Interrupt Service Routine
  0000E           97     isr_preserve_s1         EQU             0x0e
  0000F           98     isr_preserve_s2         EQU             0x0f
                  99     ;
                 100     ;
  00010          101     led0_sequence           EQU             0x10                    ;LED sequence values
  00011          102     led1_sequence           EQU             0x11
  00012          103     led2_sequence           EQU             0x12
  00013          104     led3_sequence           EQU             0x13
  00014          105     led4_sequence           EQU             0x14
  00015          106     led5_sequence           EQU             0x15
  00016          107     led6_sequence           EQU             0x16
  00017          108     led7_sequence           EQU             0x17
                 109     ;
                 110     ;
                 111     ;
                 112     ;**************************************************************************************
                 113     ;Useful data constants
                 114     ;**************************************************************************************
                 115     ;
                 116     ;
                 117     ;
                 118     ;
                 119     ;
                 120     ;
                 121     ;
                 122     ;**************************************************************************************
                 123     ;Initialise the system
                 124     ;**************************************************************************************
                 125     ;
                 126     ; All PWM channels initialise to off (zero).
                 127     ; Simple I/O outputs will remain off at all times.
                 128     ;
000 01000        129     cold_start:             LOAD            s0, #0x00
001 01101        130                             LOAD            s1, #pwm_channel0
002 2E010        131     clear_loop:             STORE           s0, @s1
003 1D108        132                             COMPARE         s1, #pwm_channel7
004 32007        133                             JUMP            z, enable_int
005 11101        134                             ADD             s1, #0x01
006 22002        135                             JUMP            clear_loop
                 136     ;
007 28001        137     enable_int:             ENABLE          interrupt               ;interrupts used to set PWM frequency
                 138     ;
                 139     ;
                 140     ; Initialise LED pattern sequence
                 141     ;
008 01001        142                             LOAD            s0, #0x01               ;trigger to start wave pattern
009 2F010        143                             STORE           s0, led0_sequence
00A 01000        144                             LOAD            s0, #0x00
00B 2F011        145                             STORE           s0, led1_sequence
00C 2F012        146                             STORE           s0, led2_sequence
00D 2F013        147                             STORE           s0, led3_sequence
00E 2F014        148                             STORE           s0, led4_sequence
00F 2F015        149                             STORE           s0, led5_sequence
010 2F016        150                             STORE           s0, led6_sequence
011 2F017        151                             STORE           s0, led7_sequence
                 152     ;
                 153     ;
                 154     ; Reset authentication check counter
                 155     ;
012 01F00        156                             LOAD            sf, #0x00
                 157     ;
                 158     ;
                 159     ;**************************************************************************************
                 160     ; Main program
                 161     ;**************************************************************************************
                 162     ;
                 163     ; Provides a pattern of interest on the LEDs :-)
                 164     ;
                 165     ; Each LED increases intensity in 8 steps and then decreases intensity in 8 steps until it is off.
                 166     ; The middle LEDs (LD2 to LD5) each start to turn on when either neighbour is turned half on and increasing
                 167     ; to provide the effect of a passing a 'wave' of light passing from side to side. The pair of LEDs at each
                 168     ; (LD0, Ld1 and LD6, LD7) are required to reflect the 'wave' so that the pattern continues.
                 169     ;
                 170     ; I'm sure this code cold be written in more elegant way, but I leave that as an exercise to you :-)
                 171     ;
                 172     ;
                 173     ; Using a simple software counter (implemented by register sF) the design occasionally requests an
                 174     ; authorisation message from the authentication processor. If it receives a PASS message it continues
                 175     ; normally but if it receives a FAIL message the LED pattern is changed.
                 176     ;
                 177     ;
                 178     ;
013 11F01        179     warm_start:             ADD             sf, #0x01               ;authentication check timer
014 3A0B6        180                             JUMP            c, authentication_check ;Check made approximately every 8 seconds.
                 181     ;
015 01203        182     normal_led_sequence:    LOAD            s2, #0x03               ;simple delay loop (delay will be increased by ISR processing)
016 011FF        183     delay_s2_loop:          LOAD            s1, #0xff
017 010FF        184     delay_s1_loop:          LOAD            s0, #0xff
018 19001        185     delay_s0_loop:          SUB             s0, #0x01
019 3E018        186                             JUMP            nc, delay_s0_loop
01A 19101        187                             SUB             s1, #0x01
01B 3E017        188                             JUMP            nc, delay_s1_loop
01C 19201        189                             SUB             s2, #0x01
01D 3E016        190                             JUMP            nc, delay_s2_loop
                 191     ;
                 192     ;Pattern generation
                 193     ;
01E 0B010        194                             FETCH           s0, led0_sequence       ;read sequence for LED0
01F 1D000        195                             COMPARE         s0, #0x00
020 32026        196                             JUMP            z, test_led0_start
021 19020        197                             SUB             s0, #0x20               ;Count longer to ensure end stops then reset count if maximum
022 32029        198                             JUMP            z, update_led0
023 11020        199                             ADD             s0, #0x20
024 11001        200     inc_led0:               ADD             s0, #0x01               ;increment counter
025 22029        201                             JUMP            update_led0
026 0B111        202     test_led0_start:        FETCH           s1, led1_sequence       ;start LED0 if LED1 = 4
027 1D104        203                             COMPARE         s1, #0x04
028 32024        204                             JUMP            z, inc_led0
029 2F010        205     update_led0:            STORE           s0, led0_sequence
02A 200A8        206                             CALL            led_to_duty
02B 2F101        207                             STORE           s1, pwm_channel0
                 208     ;
02C 0B110        209                             FETCH           s1, led0_sequence       ; refresh LED1 if LED0 = 11 (0B hex) to reflect wave
02D 1D10B        210                             COMPARE         s1, #0x0b
02E 36031        211                             JUMP            nz, normal_led1
02F 01004        212                             LOAD            s0, #0x04
030 2203F        213                             JUMP            update_led1
031 0B011        214     normal_led1:            FETCH           s0, led1_sequence       ;read sequence for LED1
032 1D000        215                             COMPARE         s0, #0x00
033 32039        216                             JUMP            z, test_led1_start
034 19010        217                             SUB             s0, #0x10               ;reset count if maximum
035 3203F        218                             JUMP            z, update_led1
036 11010        219                             ADD             s0, #0x10
037 11001        220     inc_led1:               ADD             s0, #0x01               ;increment counter
038 2203F        221                             JUMP            update_led1
039 0B110        222     test_led1_start:        FETCH           s1, led0_sequence       ;start LED1 if LED0 = 11 (0B hex) to reflect wave
03A 1D10B        223                             COMPARE         s1, #0x0b
03B 32037        224                             JUMP            z, inc_led1
03C 0B112        225                             FETCH           s1, led2_sequence       ;start LED1 if LED2 = 4
03D 1D104        226                             COMPARE         s1, #0x04
03E 32037        227                             JUMP            z, inc_led1
03F 2F011        228     update_led1:            STORE           s0, led1_sequence
040 200A8        229                             CALL            led_to_duty
041 2F102        230                             STORE           s1, pwm_channel1
                 231     ;
042 0B012        232                             FETCH           s0, led2_sequence       ;read sequence for LED2
043 1D000        233                             COMPARE         s0, #0x00
044 3204A        234                             JUMP            z, test_led2_start
045 19010        235                             SUB             s0, #0x10               ;reset count if maximum
046 32050        236                             JUMP            z, update_led2
047 11010        237                             ADD             s0, #0x10
048 11001        238     inc_led2:               ADD             s0, #0x01               ;increment counter
049 22050        239                             JUMP            update_led2
04A 0B111        240     test_led2_start:        FETCH           s1, led1_sequence       ;start LED2 if LED1 = 4
04B 1D104        241                             COMPARE         s1, #0x04
04C 32048        242                             JUMP            z, inc_led2
04D 0B113        243                             FETCH           s1, led3_sequence       ;start LED2 if LED3 = 4
04E 1D104        244                             COMPARE         s1, #0x04
04F 32048        245                             JUMP            z, inc_led2
050 2F012        246     update_led2:            STORE           s0, led2_sequence
051 200A8        247                             CALL            led_to_duty
052 2F103        248                             STORE           s1, pwm_channel2
                 249     ;
                 250     ;
053 0B013        251                             FETCH           s0, led3_sequence       ;read sequence for LED3
054 1D000        252                             COMPARE         s0, #0x00
055 3205B        253                             JUMP            z, test_led3_start
056 19010        254                             SUB             s0, #0x10               ;reset count if maximum
057 32061        255                             JUMP            z, update_led3
058 11010        256                             ADD             s0, #0x10
059 11001        257     inc_led3:               ADD             s0, #0x01               ;increment counter
05A 22061        258                             JUMP            update_led3
05B 0B112        259     test_led3_start:        FETCH           s1, led2_sequence       ;start LED3 if LED2 = 4
05C 1D104        260                             COMPARE         s1, #0x04
05D 32059        261                             JUMP            z, inc_led3
05E 0B114        262                             FETCH           s1, led4_sequence       ;start LED3 if LED4 = 4
05F 1D104        263                             COMPARE         s1, #0x04
060 32059        264                             JUMP            z, inc_led3
061 2F013        265     update_led3:            STORE           s0, led3_sequence
062 200A8        266                             CALL            led_to_duty
063 2F104        267                             STORE           s1, pwm_channel3
                 268     ;
064 0B014        269                             FETCH           s0, led4_sequence       ;read sequence for LED4
065 1D000        270                             COMPARE         s0, #0x00
066 3206C        271                             JUMP            z, test_led4_start
067 19010        272                             SUB             s0, #0x10               ;reset count if maximum
068 32072        273                             JUMP            z, update_led4
069 11010        274                             ADD             s0, #0x10
06A 11001        275     inc_led4:               ADD             s0, #0x01               ;increment counter
06B 22072        276                             JUMP            update_led4
06C 0B113        277     test_led4_start:        FETCH           s1, led3_sequence       ;start LED4 if LED3 = 4
06D 1D104        278                             COMPARE         s1, #0x04
06E 3206A        279                             JUMP            z, inc_led4
06F 0B115        280                             FETCH           s1, led5_sequence       ;start LED4 if LED5 = 4
070 1D104        281                             COMPARE         s1, #0x04
071 3206A        282                             JUMP            z, inc_led4
072 2F014        283     update_led4:            STORE           s0, led4_sequence
073 200A8        284                             CALL            led_to_duty
074 2F105        285                             STORE           s1, pwm_channel4
                 286     ;
075 0B015        287                             FETCH           s0, led5_sequence       ;read sequence for LED5
076 1D000        288                             COMPARE         s0, #0x00
077 3207D        289                             JUMP            z, test_led5_start
078 19010        290                             SUB             s0, #0x10               ;reset count if maximum
079 32083        291                             JUMP            z, update_led5
07A 11010        292                             ADD             s0, #0x10
07B 11001        293     inc_led5:               ADD             s0, #0x01               ;increment counter
07C 22083        294                             JUMP            update_led5
07D 0B114        295     test_led5_start:        FETCH           s1, led4_sequence       ;start LED5 if LED4 = 4
07E 1D104        296                             COMPARE         s1, #0x04
07F 3207B        297                             JUMP            z, inc_led5
080 0B116        298                             FETCH           s1, led6_sequence       ;start LED5 if LED6 = 4
081 1D104        299                             COMPARE         s1, #0x04
082 3207B        300                             JUMP            z, inc_led5
083 2F015        301     update_led5:            STORE           s0, led5_sequence
084 200A8        302                             CALL            led_to_duty
085 2F106        303                             STORE           s1, pwm_channel5
                 304     ;
086 0B117        305                             FETCH           s1, led7_sequence       ; refresh LED6 if LED7 = 11 (0B hex) to reflect wave
087 1D10B        306                             COMPARE         s1, #0x0b
088 3608B        307                             JUMP            nz, normal_led6
089 01004        308                             LOAD            s0, #0x04
08A 22096        309                             JUMP            update_led6
08B 0B016        310     normal_led6:            FETCH           s0, led6_sequence       ;read sequence for LED6
08C 1D000        311                             COMPARE         s0, #0x00
08D 32093        312                             JUMP            z, test_led6_start
08E 19010        313                             SUB             s0, #0x10               ;reset count if maximum
08F 32096        314                             JUMP            z, update_led6
090 11010        315                             ADD             s0, #0x10
091 11001        316     inc_led6:               ADD             s0, #0x01               ;increment counter
092 22096        317                             JUMP            update_led6
093 0B115        318     test_led6_start:        FETCH           s1, led5_sequence       ;start LED6 if LED5 = 4
094 1D104        319                             COMPARE         s1, #0x04
095 32091        320                             JUMP            z, inc_led6
096 2F016        321     update_led6:            STORE           s0, led6_sequence
097 200A8        322                             CALL            led_to_duty
098 2F107        323                             STORE           s1, pwm_channel6
                 324     ;
099 0B017        325                             FETCH           s0, led7_sequence       ;read sequence for LED7
09A 1D000        326                             COMPARE         s0, #0x00
09B 320A1        327                             JUMP            z, test_led7_start
09C 19020        328                             SUB             s0, #0x20               ;Count longer to ensure end stops then reset count if maximum
09D 320A4        329                             JUMP            z, update_led7
09E 11020        330                             ADD             s0, #0x20
09F 11001        331     inc_led7:               ADD             s0, #0x01               ;increment counter
0A0 220A4        332                             JUMP            update_led7
0A1 0B116        333     test_led7_start:        FETCH           s1, led6_sequence       ;start LED7 if LED6 = 4
0A2 1D104        334                             COMPARE         s1, #0x04
0A3 3209F        335                             JUMP            z, inc_led7
0A4 2F017        336     update_led7:            STORE           s0, led7_sequence
0A5 200A8        337                             CALL            led_to_duty
0A6 2F108        338                             STORE           s1, pwm_channel7
0A7 22013        339                             JUMP            warm_start
                 340     ;
                 341     ;
                 342     ; Convert LED sequence number into PWM intensity figure
                 343     ;
                 344     ; LEDs duty cycle values are 0,1,2,4,8,16,32 and 64 because they appear to give what
                 345     ; appears to be a fairly liner change in intensity and provides a simple way to set
                 346     ; the duty value.
                 347     ;
                 348     ; Provide sequence value in register s0 and intensity will be
                 349     ; returned in register s1.
                 350     ;
                 351     ; s0   s1
                 352     ; 00   00
                 353     ; 01   01
                 354     ; 02   02
                 355     ; 03   04
                 356     ; 04   08
                 357     ; 05   10
                 358     ; 06   20
                 359     ; 07   40
                 360     ; 08   80
                 361     ; 09   40
                 362     ; 0A   20
                 363     ; 0B   10
                 364     ; 0C   08
                 365     ; 0D   04
                 366     ; 0E   02
                 367     ; 0F   01
                 368     ; 10   00  and zero for all larger values of s0
                 369     ;
0A8 01100        370     led_to_duty:            LOAD            s1, #0x00
0A9 1D000        371                             COMPARE         s0, #0x00               ;test for zero
0AA 31000        372                             RETURN          z
0AB 01101        373                             LOAD            s1, #0x01               ;inject '1'
0AC 19001        374     go_up_loop:             SUB             s0, #0x01
0AD 31000        375                             RETURN          z
0AE 14106        376                             SL0             s1                      ;multiply by 2
0AF 3A0B1        377                             JUMP            c, go_down
0B0 220AC        378                             JUMP            go_up_loop
0B1 01140        379     go_down:                LOAD            s1, #0x40
0B2 19001        380     go_down_loop:           SUB             s0, #0x01
0B3 31000        381                             RETURN          z
0B4 1410E        382                             SR0             s1                      ;divide by 2
0B5 220B2        383                             JUMP            go_down_loop
                 384     ;
                 385     ;
                 386     ;
                 387     ;**************************************************************************************
                 388     ; Authentication Check and fail procedure
                 389     ;**************************************************************************************
                 390     ;
                 391     ; The authentication check is performed by issuing and interrupt to the authentication
                 392     ; processor and then observing the simple text string that it returns via the link FIFO
                 393     ; buffer.
                 394     ;
                 395     ; PASS - Design is authorised to work.
                 396     ; FAIL - Design is not authorised and should stop working normally.
                 397     ;
                 398     ;
                 399     ;ASCII character values that are used in messages
                 400     ;
                 401     ; >>>>> (line moved to the beginning) <<<<<
                 402     ; >>>>> (line moved to the beginning) <<<<<
                 403     ; >>>>> (line moved to the beginning) <<<<<
                 404     ; >>>>> (line moved to the beginning) <<<<<
                 405     ; >>>>> (line moved to the beginning) <<<<<
                 406     ; >>>>> (line moved to the beginning) <<<<<
                 407     ;
                 408     ;
0B6 01001        409     authentication_check:   LOAD            s0, #link_fifo_reset    ;clear link FIFO to ensure no unexpected characters
0B7 2D020        410                             OUTPUT          s0, link_fifo_control_port
0B8 01000        411                             LOAD            s0, #0x00
0B9 2D020        412                             OUTPUT          s0, link_fifo_control_port
                 413     ;
0BA 01001        414                             LOAD            s0, #security_interrupt ;generate interrupt to authentication processor
0BB 2D040        415                             OUTPUT          s0, security_request_port
0BC 01000        416                             LOAD            s0, #0x00
0BD 2D040        417                             OUTPUT          s0, security_request_port
                 418     ;
0BE 200F9        419                             CALL            read_link_fifo          ;read each character and compare
0BF 1D050        420                             COMPARE         s0, #character_p
0C0 360CB        421                             JUMP            nz, fail_confirm
0C1 200F9        422                             CALL            read_link_fifo
0C2 1D041        423                             COMPARE         s0, #character_a
0C3 360CB        424                             JUMP            nz, fail_confirm
0C4 200F9        425                             CALL            read_link_fifo
0C5 1D053        426                             COMPARE         s0, #character_s
0C6 360CB        427                             JUMP            nz, fail_confirm
0C7 200F9        428                             CALL            read_link_fifo
0C8 1D053        429                             COMPARE         s0, #character_s
0C9 360CB        430                             JUMP            nz, fail_confirm
0CA 22015        431                             JUMP            normal_led_sequence     ;Continue normal operation for PASS message
                 432     ;
                 433     ;
                 434     ; To confirm that the authentication is really a FAIL message
                 435     ; another request is made to the authentication processor and tested.
                 436     ;
0CB 010FF        437     fail_confirm:           LOAD            s0, #0xff               ;short delay to ensure authentication processor is ready
0CC 19001        438     request_delay:          SUB             s0, #0x01               ;   to respond to new interrupt request
0CD 360CC        439                             JUMP            nz, request_delay
                 440     ;
0CE 01001        441                             LOAD            s0, #link_fifo_reset    ;clear link FIFO to ensure no unexpected characters
0CF 2D020        442                             OUTPUT          s0, link_fifo_control_port
0D0 01000        443                             LOAD            s0, #0x00
0D1 2D020        444                             OUTPUT          s0, link_fifo_control_port
                 445     ;
0D2 01001        446                             LOAD            s0, #security_interrupt ;generate interrupt to authentication processor
0D3 2D040        447                             OUTPUT          s0, security_request_port
0D4 01000        448                             LOAD            s0, #0x00
0D5 2D040        449                             OUTPUT          s0, security_request_port
                 450     ;
0D6 200F9        451                             CALL            read_link_fifo          ;read each character and compare
0D7 1D046        452                             COMPARE         s0, #character_f
0D8 36015        453                             JUMP            nz, normal_led_sequence
0D9 200F9        454                             CALL            read_link_fifo
0DA 1D041        455                             COMPARE         s0, #character_a
0DB 36015        456                             JUMP            nz, normal_led_sequence
0DC 200F9        457                             CALL            read_link_fifo
0DD 1D049        458                             COMPARE         s0, #character_i
0DE 36015        459                             JUMP            nz, normal_led_sequence
0DF 200F9        460                             CALL            read_link_fifo
0E0 1D04C        461                             COMPARE         s0, #character_l
0E1 36015        462                             JUMP            nz, normal_led_sequence
                 463     ;
                 464     ;
                 465     ; When the design fails to authenticate the LEDs will appear to
                 466     ; turn on and then slowly fade to off using PWM.
                 467     ;
0E2 010FF        468     failed_led_sequence:    LOAD            s0, #0xff               ;maximum intensity on all LEDs
0E3 01400        469                             LOAD            s4, #0x00               ;reset fade rate control
0E4 01101        470     all_led_fade:           LOAD            s1, #pwm_channel0
0E5 2E010        471     all_led_fade_loop:      STORE           s0, @s1
0E6 1D108        472                             COMPARE         s1, #pwm_channel7
0E7 320EA        473                             JUMP            z, decay_leds
0E8 11101        474                             ADD             s1, #0x01
0E9 220E5        475                             JUMP            all_led_fade_loop
0EA 00140        476     decay_leds:             LOAD            s1, s4                  ;software delay starts quickly and slows down because LEDs are non-linear.
0EB 01218        477     wait_s1:                LOAD            s2, #0x18
0EC 013FF        478     wait_s2:                LOAD            s3, #0xff
0ED 19301        479     wait_s3:                SUB             s3, #0x01
0EE 360ED        480                             JUMP            nz, wait_s3
0EF 19201        481                             SUB             s2, #0x01
0F0 360EC        482                             JUMP            nz, wait_s2
0F1 19101        483                             SUB             s1, #0x01
0F2 360EB        484                             JUMP            nz, wait_s1
0F3 1D000        485                             COMPARE         s0, #0x00               ;test for fully off
0F4 320F8        486                             JUMP            z, stop_completely
0F5 19001        487                             SUB             s0, #0x01               ;fade LEDs
0F6 11401        488                             ADD             s4, #0x01               ;slow fade rate as intensity decreases
0F7 220E4        489                             JUMP            all_led_fade
                 490     ;
0F8 220F8        491     stop_completely:        JUMP            stop_completely
                 492     ;
                 493     ;**************************************************************************************
                 494     ; Read Byte from Link FIFO
                 495     ;**************************************************************************************
                 496     ;
                 497     ; The routine first tests the FIFO buffer to see if data is present.
                 498     ; If the FIFO is empty, the routine waits until there is a character to read.
                 499     ; the read value is returned in register s0.
                 500     ;
                 501     ;
0F9 09001        502     read_link_fifo:         INPUT           s0, link_fifo_status_port ;test FIFO buffer
0FA 0D001        503                             TEST            s0, #link_fifo_data_present ;wait if empty
0FB 320F9        504                             JUMP            z, read_link_fifo
0FC 09002        505                             INPUT           s0, link_fifo_read_port ;read data from FIFO
0FD 25000        506                             RETURN
                 507     ;
                 508     ;
                 509     ;**************************************************************************************
                 510     ; Interrupt Service Routine (ISR)
                 511     ;**************************************************************************************
                 512     ;
                 513     ; Interrupts occur at 3.92us intervals and are used to generate the PWM pulses generated
                 514     ; at a PRF of 1KHz. The 3.92us interrupt rate corresponds with a resolution of 256 steps
                 515     ; over the 1ms associated with the 1KHz PRF.
                 516     ;
                 517     ; The ISR is self contained and all registers used are preserved. Scratch pad memory
                 518     ; locations are used to determine the desired duty factor for each of 8 channels.
                 519     ;
                 520     ; Note that an interrupt is generated every 196 clock cycles. This means that there is
                 521     ; only time to execute 98 instructions between each interrupt. This ISR is 35 instructions
                 522     ; long. A further 3 instructions are also consumed by the interrupt process
                 523     ; (abandoned instruction, virtual CALL to 3FF and the interrupt vector JUMP) and hence
                 524     ; PicoBlaze has approximately 63% of its time available for other tasks in the main program.
                 525     ;
                 526     ; Although a loop would normal be employed in software to process each of 8 channels,
                 527     ; the implementation of a loop would increase the number of instructions which needed to
                 528     ; be executed significantly reduce the time available for the main program to operate.
                 529     ; Consequently the code is written out in a linear fashion which consumes more program
                 530     ; space but which executes faster.
                 531     ;
0FE 2F00D        532     isr:                    STORE           s0, isr_preserve_s0     ;preserve registers to be used
0FF 2F10E        533                             STORE           s1, isr_preserve_s1
100 2F20F        534                             STORE           s2, isr_preserve_s2
                 535     ;Determine the number of steps currently through the 1ms PWM cycle
101 0B100        536                             FETCH           s1, pwm_duty_counter    ;read 8-bit counter of steps
102 11101        537                             ADD             s1, #0x01               ;increment counter (will roll over to zero)
103 2F100        538                             STORE           s1, pwm_duty_counter    ;update count value in memory for next interrupt.
                 539     ;Read duty factor for each channel and compare it with the duty counter and set or
                 540     ;reset a bit in register s2 accordingly.
104 0B008        541                             FETCH           s0, pwm_channel7        ;read desired setting of pulse width
105 1C100        542                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
106 14200        543                             SLA             s2                      ;shift carry into register s2
107 0B007        544                             FETCH           s0, pwm_channel6        ;read desired setting of pulse width
108 1C100        545                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
109 14200        546                             SLA             s2                      ;shift carry into register s2
10A 0B006        547                             FETCH           s0, pwm_channel5        ;read desired setting of pulse width
10B 1C100        548                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
10C 14200        549                             SLA             s2                      ;shift carry into register s2
10D 0B005        550                             FETCH           s0, pwm_channel4        ;read desired setting of pulse width
10E 1C100        551                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
10F 14200        552                             SLA             s2                      ;shift carry into register s2
110 0B004        553                             FETCH           s0, pwm_channel3        ;read desired setting of pulse width
111 1C100        554                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
112 14200        555                             SLA             s2                      ;shift carry into register s2
113 0B003        556                             FETCH           s0, pwm_channel2        ;read desired setting of pulse width
114 1C100        557                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
115 14200        558                             SLA             s2                      ;shift carry into register s2
116 0B002        559                             FETCH           s0, pwm_channel1        ;read desired setting of pulse width
117 1C100        560                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
118 14200        561                             SLA             s2                      ;shift carry into register s2
119 0B001        562                             FETCH           s0, pwm_channel0        ;read desired setting of pulse width
11A 1C100        563                             COMPARE         s1, s0                  ;set carry flag if duty factor > duty counter
11B 14200        564                             SLA             s2                      ;shift carry into register s2
11C 2D280        565                             OUTPUT          s2, led_port            ;drive LEDs
11D 0B00D        566                             FETCH           s0, isr_preserve_s0     ;restore register values
11E 0B10E        567                             FETCH           s1, isr_preserve_s1
11F 0B20F        568                             FETCH           s2, isr_preserve_s2
120 29001        569                             RETURNI         enable
                 570     ;
                 571     ;
                 572     ;**************************************************************************************
                 573     ; Interrupt Vector
                 574     ;**************************************************************************************
                 575     ;
  003FF          576                             ORG             0x3ff
3FF 220FE        577                             JUMP            isr
                 578     ;
                 579     ;
                 580
