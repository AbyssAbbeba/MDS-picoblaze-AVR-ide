                   1     ; KCPSM3 Program - Implementation of the SHA-1 algorithm for use with the
                   2     ;                  DS2432 secure memory on the Spartan-3E Starter Kit.
                   3     ;
                   4     ; Ken Chapman - Xilinx Ltd
                   5     ;
                   6     device kcpsm3
                   7     ; Version v1.00 - 19th April 2006
                   8     ;
                   9     ;
                  10     ; IMPORTANT - This design builds on the reference design called "PicoBlaze
                  11     ;             DS2432 communicator". It is highly recommend that you look at that
                  12     ;             design before proceeding with this one.
                  13     ;
                  14     ;
                  15     ; This program uses a 9600 baud UART connection to allow communication with the
                  16     ; 1-wire interface of the DS2432 memory device from Dallas Semiconductor.
                  17     ;
                  18     ; The program only supports a limited number of the DS2432 commands to focus on
                  19     ; those aspects which use the SHA-1 algorithm.
                  20     ;
                  21     ; Note that the code performing the SHA-1 algorithm interacts with the hardware of
                  22     ; this complete reference design. The hardware provides a 16 word (32-bit) buffer
                  23     ; combined used in the initialisation of the algorithm and subsequent computation
                  24     ; of the Wt words.
                  25     ;
                  26     ;
                  27     ; The DS2432 should be programmed with a 64-bit secret. The following constants
                  28     ; define the secret which will be used. Obviously this would be be changed in a
                  29     ; real application and further measures taken to prevent it easily being found.
                  30     ; The secret is 64-bits formed of 8 bytes. 'secret0' would be stored at address
                  31     ; 0080 of the DS2432 and 'secret7' at address 0087. The write buffer and load
                  32     ; first secret commands allow you to set any secret into the DS2432 device but
                  33     ; this program always uses the secret defined in these constants such that you can
                  34     ; experiment with secrets which do and do not match.
                  35     ;
                  36     ;
  00001           37     secret0                 EQU             0x01
  00023           38     secret1                 EQU             0x23
  00045           39     secret2                 EQU             0x45
  00067           40     secret3                 EQU             0x67
  00089           41     secret4                 EQU             0x89
  000AB           42     secret5                 EQU             0xab
  000CD           43     secret6                 EQU             0xcd
  000EF           44     secret7                 EQU             0xef
                  45     ;
                  46     ;
                  47     ; Bytes 4, 5 and 6 of the DS2432 scratch pad memory are used in the SHA-1 algorithm.
                  48     ; These should be set using the write scratchpad memory command before using the
                  49     ; read authenticated page command. HOWEVER, it is also important that you also use
                  50     ; the read scratchpad command BEFORE using the read authenticated page command. This
                  51     ; is because this program only copies the bytes 4, 5 and 6 during a read such that
                  52     ; they are can be used by the PicoBlaze SHA-1 algorithm. This limitation is deliberate
                  53     ; so that you can experiment and prove that the SHA-1 results will not match if
                  54     ; the same 'challenge' bytes are not used.
                  55     ;
                  56     ;
                  57     ;**************************************************************************************
                  58     ; Port definitions
                  59     ;**************************************************************************************
                  60     ;
                  61     ;
  00040           62     status_port             EQU             0x40                    ;UART status input
  00001           63     tx_half_full            EQU             0x01                    ;  Transmitter     half full - bit0
  00002           64     tx_full                 EQU             0x02                    ;    FIFO               full - bit1
  00004           65     rx_data_present         EQU             0x04                    ;  Receiver     data present - bit2
  00008           66     rx_half_full            EQU             0x08                    ;    FIFO          half full - bit3
  00010           67     rx_full                 EQU             0x10                    ;                   full - bit4
  00020           68     spare1                  EQU             0x20                    ;                  spare '0' - bit5
  00040           69     spare2                  EQU             0x40                    ;                  spare '0' - bit6
  00080           70     spare3                  EQU             0x80                    ;                  spare '0' - bit7
                  71     ;
  00080           72     uart_read_port          EQU             0x80                    ;UART Rx data input
                  73     ;
  00004           74     uart_write_port         EQU             0x04                    ;UART Tx data output
                  75     ;
                  76     ;
  000C0           77     ds_wire_in_port         EQU             0xc0                    ;Read signal from DS2432 device
  00008           78     ds_wire_out_port        EQU             0x08                    ;Drive signal to DS2432 device (open collector)
  00001           79     ds_wire                 EQU             0x01                    ;       Signal is bit0 in both cases
                  80     ;
                  81     ;
                  82     ;
                  83     ; The following ports access the 'Wt' word buffer. This buffer holds 16 words
                  84     ; of 32-bits organised as a 64-byte shift register. Hence each word is stored
                  85     ; by writing 4 bytes. As each byte is written, all bytes shift along such that
                  86     ; older Wt values can be read from consistent port addresses.
                  87     ;
  00010           88     w_word_write_port       EQU             0x10                    ;Write byte to Wt buffer
                  89     ;
  00008           90     wt_minus3_byte0_read_port EQU           0x08                    ;Read of Wt-3
  00009           91     wt_minus3_byte1_read_port EQU           0x09
  0000A           92     wt_minus3_byte2_read_port EQU           0x0a
  0000B           93     wt_minus3_byte3_read_port EQU           0x0b
                  94     ;
  0001C           95     wt_minus8_byte0_read_port EQU           0x1c                    ;Read of Wt-8
  0001D           96     wt_minus8_byte1_read_port EQU           0x1d
  0001E           97     wt_minus8_byte2_read_port EQU           0x1e
  0001F           98     wt_minus8_byte3_read_port EQU           0x1f
                  99     ;
  00034          100     wt_minus14_byte0_read_port EQU          0x34                    ;Read of Wt-14
  00035          101     wt_minus14_byte1_read_port EQU          0x35
  00036          102     wt_minus14_byte2_read_port EQU          0x36
  00037          103     wt_minus14_byte3_read_port EQU          0x37
                 104     ;
  0003C          105     wt_minus16_byte0_read_port EQU          0x3c                    ;Read of Wt-16
  0003D          106     wt_minus16_byte1_read_port EQU          0x3d
  0003E          107     wt_minus16_byte2_read_port EQU          0x3e
  0003F          108     wt_minus16_byte3_read_port EQU          0x3f
                 109     ;
                 110     ;
                 111     ;**************************************************************************************
                 112     ; Special Register usage
                 113     ;**************************************************************************************
                 114     ;
  0000F          115     uart_data               REG             sf                      ;used to pass data to and from the UART
                 116     ;
                 117     ;
                 118     ;**************************************************************************************
                 119     ; Scratch Pad Memory Locations
                 120     ;**************************************************************************************
                 121     ;
                 122     ; Scratch pad memory provides 64 bytes in the address range 00 to 3F hex.
                 123     ;
                 124     ;
                 125     ; Locations for device family code, serial number and 8-bit CRC value
                 126     ;
  00000          127     family_code             EQU             0x00
  00001          128     serial_number0          EQU             0x01                    ;48-bit serial number LS-Byte first
  00002          129     serial_number1          EQU             0x02
  00003          130     serial_number2          EQU             0x03
  00004          131     serial_number3          EQU             0x04
  00005          132     serial_number4          EQU             0x05
  00006          133     serial_number5          EQU             0x06
  00007          134     read_rom_crc            EQU             0x07                    ;8-bit CRC
                 135     ;
                 136     ;
                 137     ; Locations for variables used in SHA-1 algorithm.
                 138     ; Each variable is 32-bits and requires 4 bytes to store.
                 139     ; '0' indicates the least significant byte and '3' the most significant byte.
                 140     ;
                 141     ; Note that the concatenation of 'A', 'B', 'C', 'D' and 'E' will be the 160-bit MAC.
                 142     ;
  00008          143     var_a0                  EQU             0x08                    ;Variable 'A'
  00009          144     var_a1                  EQU             0x09
  0000A          145     var_a2                  EQU             0x0a
  0000B          146     var_a3                  EQU             0x0b
                 147     ;
  0000C          148     var_b0                  EQU             0x0c                    ;Variable 'B'
  0000D          149     var_b1                  EQU             0x0d
  0000E          150     var_b2                  EQU             0x0e
  0000F          151     var_b3                  EQU             0x0f
                 152     ;
  00010          153     var_c0                  EQU             0x10                    ;Variable 'C'
  00011          154     var_c1                  EQU             0x11
  00012          155     var_c2                  EQU             0x12
  00013          156     var_c3                  EQU             0x13
                 157     ;
  00014          158     var_d0                  EQU             0x14                    ;Variable 'D'
  00015          159     var_d1                  EQU             0x15
  00016          160     var_d2                  EQU             0x16
  00017          161     var_d3                  EQU             0x17
                 162     ;
  00018          163     var_e0                  EQU             0x18                    ;Variable 'E'
  00019          164     var_e1                  EQU             0x19
  0001A          165     var_e2                  EQU             0x1a
  0001B          166     var_e3                  EQU             0x1b
                 167     ;
                 168     ;
                 169     ; Copy of data in the scratchpad memory of the DS2432.
                 170     ; This is only updated by the read scratchpad memory command.
                 171     ; '0' indicates the data in the least significant location.
                 172     ;
  0001C          173     scratchpad0             EQU             0x1c
  0001D          174     scratchpad1             EQU             0x1d
  0001E          175     scratchpad2             EQU             0x1e
  0001F          176     scratchpad3             EQU             0x1f
  00020          177     scratchpad4             EQU             0x20
  00021          178     scratchpad5             EQU             0x21
  00022          179     scratchpad6             EQU             0x22
  00023          180     scratchpad7             EQU             0x23
                 181     ;
                 182     ;
                 183     ;
                 184     ;**************************************************************************************
                 185     ; Useful data constants
                 186     ;**************************************************************************************
                 187     ;
                 188     ; Constant to define a software delay of 1us. This must be adjusted to reflect the
                 189     ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 190     ; calculation highly predictable. The '6' in the following equation even allows for
                 191     ; 'CALL delay_1us' instruction in the initiating code.
                 192     ;
                 193     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 194     ;
                 195     ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 196     ; For clock rates below 10MHz the value of 1 must be used and the operation will
                 197     ; become lower than intended.
                 198     ;
  0000B          199     delay_1us_constant      EQU             0x0b
                 200     ;
                 201     ;
                 202     ;
                 203     ;ASCII table
                 204     ;
  00061          205     character_a             EQU             0x61
  00062          206     character_b             EQU             0x62
  00063          207     character_c             EQU             0x63
  00064          208     character_d             EQU             0x64
  00065          209     character_e             EQU             0x65
  00066          210     character_f             EQU             0x66
  00067          211     character_g             EQU             0x67
  00068          212     character_h             EQU             0x68
  00069          213     character_i             EQU             0x69
  0006A          214     character_j             EQU             0x6a
  0006B          215     character_k             EQU             0x6b
  0006C          216     character_l             EQU             0x6c
  0006D          217     character_m             EQU             0x6d
  0006E          218     character_n             EQU             0x6e
  0006F          219     character_o             EQU             0x6f
  00070          220     character_p             EQU             0x70
  00071          221     character_q             EQU             0x71
  00072          222     character_r             EQU             0x72
  00073          223     character_s             EQU             0x73
  00074          224     character_t             EQU             0x74
  00075          225     character_u             EQU             0x75
  00076          226     character_v             EQU             0x76
  00077          227     character_w             EQU             0x77
  00078          228     character_x             EQU             0x78
  00079          229     character_y             EQU             0x79
  0007A          230     character_z             EQU             0x7a
  00041          231     _character_a            EQU             0x41
  00042          232     _character_b            EQU             0x42
  00043          233     _character_c            EQU             0x43
  00044          234     _character_d            EQU             0x44
  00045          235     _character_e            EQU             0x45
  00046          236     _character_f            EQU             0x46
  00047          237     _character_g            EQU             0x47
  00048          238     _character_h            EQU             0x48
  00049          239     _character_i            EQU             0x49
  0004A          240     _character_j            EQU             0x4a
  0004B          241     _character_k            EQU             0x4b
  0004C          242     _character_l            EQU             0x4c
  0004D          243     _character_m            EQU             0x4d
  0004E          244     _character_n            EQU             0x4e
  0004F          245     _character_o            EQU             0x4f
  00050          246     _character_p            EQU             0x50
  00051          247     _character_q            EQU             0x51
  00052          248     _character_r            EQU             0x52
  00053          249     _character_s            EQU             0x53
  00054          250     _character_t            EQU             0x54
  00055          251     _character_u            EQU             0x55
  00056          252     _character_v            EQU             0x56
  00057          253     _character_w            EQU             0x57
  00058          254     _character_x            EQU             0x58
  00059          255     _character_y            EQU             0x59
  0005A          256     _character_z            EQU             0x5a
  00030          257     character_0             EQU             0x30
  00031          258     character_1             EQU             0x31
  00032          259     character_2             EQU             0x32
  00033          260     character_3             EQU             0x33
  00034          261     character_4             EQU             0x34
  00035          262     character_5             EQU             0x35
  00036          263     character_6             EQU             0x36
  00037          264     character_7             EQU             0x37
  00038          265     character_8             EQU             0x38
  00039          266     character_9             EQU             0x39
  0003A          267     character_colon         EQU             0x3a
  0002E          268     character_fullstop      EQU             0x2e
  0003B          269     character_semi_colon    EQU             0x3b
  0002D          270     character_minus         EQU             0x2d
  0002B          271     character_plus          EQU             0x2b
  0002C          272     character_comma         EQU             0x2c
  0003C          273     character_less_than     EQU             0x3c                    ;'<'
  0003E          274     character_greater_than  EQU             0x3e                    ;'>'
  00028          275     character_open          EQU             0x28                    ;'('
  00029          276     character_close         EQU             0x29                    ;')'
  0002F          277     character_divide        EQU             0x2f                    ;'/'
  0003D          278     character_equals        EQU             0x3d
  00020          279     character_space         EQU             0x20
  0000D          280     character_cr            EQU             0x0d                    ;carriage return
  0000A          281     character_lf            EQU             0x0a                    ;line feed
  0003F          282     character_question      EQU             0x3f                    ;'?'
  00024          283     character_dollar        EQU             0x24
  00021          284     character_exclaim       EQU             0x21                    ;'!'
  00008          285     character_bs            EQU             0x08                    ;Back Space command character
  00011          286     character_xon           EQU             0x11                    ;Flow control ON
  00013          287     character_xoff          EQU             0x13                    ;Flow control OFF
                 288     ;
                 289     ;
                 290     ;**************************************************************************************
                 291     ; Initialise the system and welcome message
                 292     ;**************************************************************************************
                 293     ;
000 30230        294     cold_start:             CALL            ds_wire_init            ;Ensure DS_wire is not driven (pulled High)
001 3029A        295                             CALL            delay_1s                ;Allow everything to settle!
002 3030A        296     welcome_start:          CALL            send_welcome            ;start up message and version number
                 297     ;
                 298     ;
                 299     ;**************************************************************************************
                 300     ; Reset Main menu and command selection
                 301     ;**************************************************************************************
                 302     ;
                 303     ; The main program allows you to use four of the DS2432 memory and SHA function
                 304     ; commands. A simple menu is displayed and you are guided to enter more information
                 305     ; when required. All the communication and protocol required to get the DS2432 ready
                 306     ; to receive memory and SHA function commands has been automated although information
                 307     ; is displayed to indicate the procedures being executed.
                 308     ;
                 309     ; Before any memory and function commands are available a master reset and read ROM
                 310     ; command must be issued.
                 311     ;
003 302EC        312     warm_start:             CALL            send_cr
004 302EC        313                             CALL            send_cr
005 30233        314                             CALL            ds_init_regular_mode    ;master reset
006 35803        315                             JUMP            c, warm_start           ;repeat reset if no presence pulse detected
007 3001D        316                             CALL            read_rom_command        ;read ROM command and display results
                 317     ;
                 318     ; After a valid ROM command the DS2432 specific memory commands and SHA-1
                 319     ; functions become accessible. This program assumes that the ROM command did
                 320     ; 'Pass' so you will need to check yourself. If this program automatically
                 321     ; reset the DS2432 and tried again and there was a fault it would just cause
                 322     ; the display to roll continuously and not be very informative!
                 323     ;
                 324     ; Each of the DS2432 commands selected from the menu will require the master reset
                 325     ; and read ROM command to be repeated before being able to proceed with the next
                 326     ; memory or SHA-1 function. This is automated by the program.
                 327     ;
                 328     ;
008 30344        329     ds2432_menu:            CALL            send_ds2432_menu        ;Menu and command selection
009 302EC        330                             CALL            send_cr
                 331     ;
00A 302EC        332     ds2432_prompt:          CALL            send_cr                 ;prompt for user input
00B 302EC        333                             CALL            send_cr
00C 00F3E        334                             LOAD            uart_data, #character_greater_than ;prompt for input
00D 302A5        335                             CALL            send_to_uart
00E 302E1        336                             CALL            read_upper_case
00F 14031        337                             COMPARE         s0, #character_1        ;test for commands and execute as required
010 35053        338                             JUMP            z, write_scratchpad_command
011 14032        339                             COMPARE         s0, #character_2
012 35079        340                             JUMP            z, read_scratchpad_command
013 14033        341                             COMPARE         s0, #character_3
014 35040        342                             JUMP            z, load_first_secret_command
015 14034        343                             COMPARE         s0, #character_4
016 3509D        344                             JUMP            z, read_auth_page_command
017 302EC        345                             CALL            send_cr                 ;no valid command input
018 00F3F        346                             LOAD            uart_data, #character_question ;display ???
019 302A5        347                             CALL            send_to_uart
01A 302A5        348                             CALL            send_to_uart
01B 302A5        349                             CALL            send_to_uart
01C 3400A        350                             JUMP            ds2432_prompt           ;Try again!
                 351     ;
                 352     ;
                 353     ;
                 354     ;
                 355     ;**************************************************************************************
                 356     ; DS2432 Read ROM Command.
                 357     ;**************************************************************************************
                 358     ;
                 359     ; The read ROM command (33 hex) allows the 8-bit family code, 48-bit unique serial
                 360     ; number and 8-bit CRC to be read from the DS2432 device.
                 361     ;
                 362     ; This routine reads the values and places them in KCPSM3 scratch pad memory
                 363     ; locations for future reference. These locations should be defined with constants
                 364     ; as follows and MUST be in consecutive ascending locations.
                 365     ;
                 366     ;  family_code
                 367     ;     Location to store family code which should be 33 hex
                 368     ;  serial_number0 to serial_number5
                 369     ;     6 bytes to hold 48-bit serial number (LS-byte first).
                 370     ;  read_ROM_CRC
                 371     ;     8-bit CRC value for the above data.
                 372     ;
                 373     ;
                 374     ; The routine also displays the values read and performs a verification of the
                 375     ; 8-bit CRC displaying a 'Pass' or 'Fail' message as appropriate.
                 376     ;
01D 00333        377     read_rom_command:       LOAD            s3, #0x33               ;Read ROM Command
01E 3024E        378                             CALL            write_byte_slow         ;transmit command
01F 00500        379                             LOAD            s5, #family_code        ;memory pointer
020 3026F        380     read_rom_loop:          CALL            read_byte_slow          ;read response into s3
021 2F350        381                             STORE           s3, @s5                 ;store value
022 14507        382                             COMPARE         s5, #read_rom_crc       ;8-bytes to read
023 35026        383                             JUMP            z, display_rom
024 18501        384                             ADD             s5, #0x01
025 34020        385                             JUMP            read_rom_loop
026 302EC        386     display_rom:            CALL            send_cr
027 303D6        387                             CALL            send_code               ;'code=' to display family code
028 06000        388                             FETCH           s0, family_code
029 302C2        389                             CALL            send_hex_byte
02A 302EC        390                             CALL            send_cr
02B 303DC        391                             CALL            send_sn                 ;'s/n=' to display family code
02C 00506        392                             LOAD            s5, #serial_number5     ;memory pointer starting MS-byte first
02D 07050        393     disp_serial_loop:       FETCH           s0, @s5
02E 302C2        394                             CALL            send_hex_byte
02F 14501        395                             COMPARE         s5, #serial_number0
030 35033        396                             JUMP            z, end_serial
031 1C501        397                             SUB             s5, #0x01
032 3402D        398                             JUMP            disp_serial_loop
033 302EC        399     end_serial:             CALL            send_cr
034 303E2        400                             CALL            send_crc                ;'CRC=' to display CRC value
035 06007        401                             FETCH           s0, read_rom_crc
036 302C2        402                             CALL            send_hex_byte
037 302EC        403                             CALL            send_cr
038 301F1        404                             CALL            compute_crc8            ;compute CRC value in s0
039 06107        405                             FETCH           s1, read_rom_crc        ;compare with received value
03A 15010        406                             COMPARE         s0, s1
03B 3543E        407                             JUMP            nz, crc8_fail
03C 303AD        408                             CALL            send_pass
03D 2A000        409                             RETURN
03E 303B4        410     crc8_fail:              CALL            send_fail
03F 2A000        411                             RETURN
                 412     ;
                 413     ;
                 414     ;
                 415     ;**************************************************************************************
                 416     ; DS2432 Load First Secret Command.
                 417     ;**************************************************************************************
                 418     ;
                 419     ; This command will only be valid if the write scratchpad memory command has previously
                 420     ; been used to define the new secret to be stored at address 0080.
                 421     ;
                 422     ; The Load First Secret Command (5A hex) will only copy the scratchpad contents into                           ;
                 423     ; the EEPROM array of the DS2432 if the address was correctly specified in the
                 424     ; write scratchpad command. This routine will assume that the address specified
                 425     ; was 0080. If everything is OK with the programming of the secret, the DS2432 responds
                 426     ; with 'AA' hex after the command and this routine will report 'Pass'. You can further
                 427     ; check using a read scratchpad command and look to see if E/S has changed from '5F'
                 428     ; to 'DF' which indicates the successful write.
                 429     ;
                 430     ; Note that this program defines the secret to be used by the PicoBlaze SHA-1 algorithm
                 431     ; in the constants 'secret0' through to 'secret7'. Only if you program the DS2432
                 432     ; with a matching secret will the read authenticated message command result in a
                 433     ; 'Pass' being reported for the MAC. This Load First Secret Command routine deliberately
                 434     ; does not update the secret used by the PicoBlaze SHA-1 algorithm so that you can
                 435     ; prove that only a DS2432 with the matching secret will generate matching MAC
                 436     ; responses.
                 437     ;
                 438     ;
                 439     ;
040 0035A        440     load_first_secret_command: LOAD         s3, #0x5a               ;Load First Secret Command
041 3024E        441                             CALL            write_byte_slow         ;transmit command
042 00380        442                             LOAD            s3, #0x80               ;TA1 value for secret = 80 hex
043 3024E        443                             CALL            write_byte_slow
044 00300        444                             LOAD            s3, #0x00               ;TA2 value for secret = 00 hex
045 3024E        445                             CALL            write_byte_slow
046 0035F        446                             LOAD            s3, #0x5f               ;E/S value before writing = 5F hex
047 3024E        447                             CALL            write_byte_slow
048 30295        448                             CALL            delay_20ms              ;write takes place in 10ms
049 302EC        449                             CALL            send_cr
04A 30391        450                             CALL            send_secret
04B 302EF        451                             CALL            send_space
04C 3026F        452                             CALL            read_byte_slow          ;read data into s3
04D 143AA        453                             COMPARE         s3, #0xaa               ;test response
04E 35051        454                             JUMP            z, secret_pass
04F 303B4        455                             CALL            send_fail
050 34003        456                             JUMP            warm_start
051 303AD        457     secret_pass:            CALL            send_pass
052 34003        458                             JUMP            warm_start
                 459     ;
                 460     ;
                 461     ;**************************************************************************************
                 462     ; DS2432 Write Scratchpad Memory Command.
                 463     ;**************************************************************************************
                 464     ;
                 465     ; The write scratchpad memory command (0F hex) allows 8-bytes of data to be written
                 466     ; together with a target address for final storage in the main memory map. The
                 467     ; DS2432 scratch pad is also used to define a 3 byte 'challenge' used in the
                 468     ; SHA-1 algorithm.
                 469     ;
                 470     ; The DS2432 provides an initial confirmation of the write by returning a 16-bit CRC
                 471     ; value which KCPSM3 tests. The CRC is computed based on the command, address and
                 472     ; data transmitted (11 bytes). PicoBlaze also computes the CRC and and tests this
                 473     ; against the value received from the DS2432.
                 474     ;
                 475     ; This routine prompts the user to enter the 16-bit target address is to be loaded
                 476     ; into the target address registers TA2 and TA1 in the DS2432 device. Note that only
                 477     ; address values below 0090 hex are valid. If the address is too high, then the
                 478     ; DS2432 aborts the command and this routine will too.
                 479     ;
                 480     ; Also note that the address will be forced internally to the DS2432 to match an
                 481     ; 8-byte boundary address in which the least significant 3-bits are reset to '000'
                 482     ; regardless of the address provided. The CRC still reflects the transmitted address.
                 483     ;
                 484     ; After providing a valid address, the routine then prompts the user to enter
                 485     ; 8 bytes of data which are written to the DS2432.
                 486     ;
                 487     ;
                 488     ;
053 3020B        489     write_scratchpad_command: CALL          clear_crc16             ;prepare CRC registers [sE,sD]
054 0030F        490                             LOAD            s3, #0x0f               ;write scratchpad memory Command
055 3024E        491                             CALL            write_byte_slow         ;transmit command
056 3020E        492                             CALL            compute_crc16           ;compute CRC for value in 's3'
057 303BD        493     wsc_addr_loop:          CALL            send_address            ;obtain 16-bit address 0000 to FFFF in [s5,s4]
058 302E6        494                             CALL            obtain_8bits
059 35857        495                             JUMP            c, wsc_addr_loop        ;bad input address
05A 01500        496                             LOAD            s5, s0
05B 302E6        497                             CALL            obtain_8bits
05C 35857        498                             JUMP            c, wsc_addr_loop        ;bad input address
05D 01400        499                             LOAD            s4, s0
05E 01340        500                             LOAD            s3, s4                  ;transmit target address TA1 (LS-Byte)
05F 3024E        501                             CALL            write_byte_slow
060 3020E        502                             CALL            compute_crc16           ;compute CRC for value in 's3'
061 01350        503                             LOAD            s3, s5                  ;transmit target address TA2 (MS-Byte)
062 3024E        504                             CALL            write_byte_slow
063 3020E        505                             CALL            compute_crc16           ;compute CRC for value in 's3'
064 14500        506                             COMPARE         s5, #0x00               ;check address less than 0090 hex
065 35403        507                             JUMP            nz, warm_start          ;DS2432 aborts command and so do we!
066 14490        508                             COMPARE         s4, #0x90               ;no need to read data bytes.
067 35C03        509                             JUMP            nc, warm_start
068 00400        510                             LOAD            s4, #0x00               ;initialise byte counter
069 303C8        511     wsc_data_loop:          CALL            send_data               ;obtain a byte of data
06A 01F40        512                             LOAD            uart_data, s4           ;display which byte requested
06B 18F30        513                             ADD             uart_data, #character_0 ;convert to ASCII
06C 302A5        514                             CALL            send_to_uart
06D 303C5        515                             CALL            send_equals
06E 302E6        516                             CALL            obtain_8bits
06F 35869        517                             JUMP            c, wsc_data_loop        ;bad input data
070 01300        518                             LOAD            s3, s0                  ;transmit byte
071 3024E        519                             CALL            write_byte_slow
072 3020E        520                             CALL            compute_crc16           ;compute CRC for value in 's3'
073 18401        521                             ADD             s4, #0x01               ;count bytes
074 14408        522                             COMPARE         s4, #0x08
075 35469        523                             JUMP            nz, wsc_data_loop
076 302EC        524                             CALL            send_cr
077 3021C        525                             CALL            read_send_test_crc16    ;read, display and test CRC value
078 34003        526                             JUMP            warm_start
                 527     ;
                 528     ;
                 529     ;
                 530     ;**************************************************************************************
                 531     ; DS2432 Read Scratchpad Memory Command.
                 532     ;**************************************************************************************
                 533     ;
                 534     ; The read scratchpad memory command (AA hex) allows the 8-bytes of data previously
                 535     ; to be written into the scratchpad memory to be read back for verification together with
                 536     ; the target address, a transfer status register (E/S) and a 16-bit CRC value.
                 537     ;
                 538     ; The 16-bit CRC is formed of the command byte, address TA1 and TA2, E/S byte and 8 data
                 539     ; bytes as transmitted (12 bytes). These may not be the same as the values provided
                 540     ; during a previous write to scratchpad memory. PicoBlaze also computes the CRC and
                 541     ; and tests this against the value received from the DS2432.
                 542     ;
                 543     ; The 8 bytes of data are also copied to PicoBlaze memory at locations defined by the
                 544     ; constants 'scratchpad0' to 'scratchpad7'. Three bytes are used as a 'challenge'
                 545     ; by the SHA-1 algorithm.
                 546     ;
                 547     ;
                 548     ;
079 3020B        549     read_scratchpad_command: CALL           clear_crc16             ;prepare CRC registers [sE,sD]
07A 003AA        550                             LOAD            s3, #0xaa               ;read scratchpad memory Command
07B 3024E        551                             CALL            write_byte_slow         ;transmit command
07C 3020E        552                             CALL            compute_crc16           ;compute CRC for value in 's3'
07D 303BD        553                             CALL            send_address            ;display 'Address='
07E 3026F        554                             CALL            read_byte_slow          ;read address into [s5,s4]
07F 3020E        555                             CALL            compute_crc16           ;compute CRC for value in 's3'
080 01430        556                             LOAD            s4, s3
081 3026F        557                             CALL            read_byte_slow
082 3020E        558                             CALL            compute_crc16           ;compute CRC for value in 's3'
083 01530        559                             LOAD            s5, s3
084 01050        560                             LOAD            s0, s5                  ;display address
085 302C2        561                             CALL            send_hex_byte
086 01040        562                             LOAD            s0, s4
087 302C2        563                             CALL            send_hex_byte
088 303CE        564                             CALL            send_es                 ;display 'E/S='
089 3026F        565                             CALL            read_byte_slow          ;read E/S register
08A 3020E        566                             CALL            compute_crc16           ;compute CRC for value in 's3'
08B 01030        567                             LOAD            s0, s3                  ;display value
08C 302C2        568                             CALL            send_hex_byte
08D 303C8        569                             CALL            send_data               ;display 'Data='
08E 303C5        570                             CALL            send_equals
08F 0041C        571                             LOAD            s4, #scratchpad0        ;pointer to memory and byte counter
090 302EF        572     rsc_loop:               CALL            send_space
091 3026F        573                             CALL            read_byte_slow          ;read data byte
092 3020E        574                             CALL            compute_crc16           ;compute CRC for value in 's3'
093 2F340        575                             STORE           s3, @s4                 ;store value in memory
094 01030        576                             LOAD            s0, s3                  ;display value
095 302C2        577                             CALL            send_hex_byte
096 14423        578                             COMPARE         s4, #scratchpad7        ;count bytes
097 3509A        579                             JUMP            z, end_rsc_data_loop
098 18401        580                             ADD             s4, #0x01
099 34090        581                             JUMP            rsc_loop
09A 302EC        582     end_rsc_data_loop:      CALL            send_cr
09B 3021C        583                             CALL            read_send_test_crc16    ;read, display and test CRC value
09C 34003        584                             JUMP            warm_start
                 585     ;
                 586     ;
                 587     ;
                 588     ;
                 589     ;
                 590     ;**************************************************************************************
                 591     ; DS2432 Read Authenticated Page Command.
                 592     ;**************************************************************************************
                 593     ;
                 594     ; The read authenticated page command (A5 hex) allows the 8-byte secret to be tested
                 595     ; without it actually being read (which would obviously give away the secret!).
                 596     ;
                 597     ; This routine has been written to work with page 0 but could easily be changed and
                 598     ; is documented below. During the first part of the command, the 32 bytes
                 599     ; contained in the page are read back from the DS2432 and these are used in
                 600     ; the preparation of the table required for the for SHA-1 algorithm. Other values
                 601     ; stored in the table are the secret, serial number of the DS2432, family code, some
                 602     ; constants, 4-bits of the page address and a 3 byte 'challenge' currently set into
                 603     ; the DS2432 scratchpad memory.
                 604     ;
                 605     ; NOTE - The read scratchpad command must be executed before this routine in order
                 606     ; that the 3 byte 'challenge' of scratchpad memory is known to PicoBlaze.
                 607     ;
                 608     ; During this command, two 16-bit CRC values are generated which PicoBlaze also
                 609     ; computes and tests. The first is formed of the command byte, address TA1 and TA2,
                 610     ; all the bytes of the page read and an 'FF' byte. The second is formed of the 20
                 611     ; bytes of the 160-but message authentication code (MAC).
                 612     ;
                 613     ;
                 614     ; Preparing the table.
                 615     ;
                 616     ; The table is stored in the external 'Wt' buffer and must first be initialised with the
                 617     ; 16 'M' words (32-bit words each requiring 4 bytes). This is achieved by shifting in
                 618     ; each word in sequence. Storing each word most significant byte first is a natural
                 619     ; fit with the reading of the page data from the DS2432 and the way each 'M' word
                 620     ; is organised. Notice how this causes least significant bytes to be swapped with most
                 621     ; significant bytes!
                 622     ;
                 623     ;          [31:24]      [23:16]      [15:8]       [7:0]
                 624     ;
                 625     ;   M0 = [secret0    , secret1    , secret2    , secret3    ]
                 626     ;   M1 = [page_data0 , page_data1 , page_data2 , page_data3 ]
                 627     ;   M2 = [page_data4 , page_data5 , page_data6 , page_data7 ]
                 628     ;   M3 = [page_data8 , page_data9 , page_data10, page_data11]
                 629     ;   M4 = [page_data12, page_data13, page_data14, page_data15]
                 630     ;   M5 = [page_data16, page_data17, page_data18, page_data19]
                 631     ;   M6 = [page_data20, page_data21, page_data22, page_data23]
                 632     ;   M7 = [page_data24, page_data25, page_data26, page_data27]
                 633     ;   M8 = [page_data28, page_data29, page_data30, page_data31]
                 634     ;   M9 = [   FF      ,    FF      ,    FF      ,    FF      ]
                 635     ;  M10 = [   40      ,    33      , serial_num0, serial_num1]
                 636     ;  M11 = [serial_num2, serial_num3, serial_num4, serial_num5]
                 637     ;  M12 = [secret4    , secret5    , secret6    , secret7    ]
                 638     ;  M13 = [scratchpad4, scratchpad5, scratchpad6,    80      ]
                 639     ;  M14 = [   00      ,    00      ,    00      ,    00      ]
                 640     ;  M15 = [   00      ,    00      ,    01      ,    B8      ]
                 641     ;
                 642     ; In M10, the '33' is the family code and the '40' is made up of a constant bit
                 643     ; pattern '0100' and then bits [8:5] of the page address. This gives 4 possible values
                 644     ; for this byte during a Read Authenticated Page Command, but this routine is currently
                 645     ; fixed to work with page 0 only.
                 646     ;        40 - page 0
                 647     ;        41 - page 1
                 648     ;        42 - page 2
                 649     ;        43 - page 3
                 650     ;
                 651     ; M13 contains the 3 byte challenge from the scratch pad memory. This assumes that a
                 652     ; read scratchpad command has previously been used and the bytes held in the DS2432
                 653     ; scratchpad match those held in the PicoBlaze memory.
                 654     ;
                 655     ;
                 656     ; The 160-bit Message Authentication Code (MAC) is computed from the table using the SHA-1
                 657     ; algorithm. This algorithm actually results in 5 variables 'A', 'B', 'C', 'D' and 'E'
                 658     ; which are 32-bit values each formed of 4 bytes. The MAC is the concatenation of
                 659     ; the variables. To match the same order in which the Read Authenticated Page Command
                 660     ; sends the MAC, the variables must be read in the order 'E', 'D', 'C', 'B' and 'A' and
                 661     ; with the least significant byte of each variable first.
                 662     ;
                 663     ;
                 664     ;
                 665     ;
                 666     ;
09D 00001        667     read_auth_page_command: LOAD            s0, #secret0            ;store M0 (secret 0, 1, 2 and 3) in Wt buffer.
09E 2C010        668                             OUTPUT          s0, w_word_write_port
09F 00023        669                             LOAD            s0, #secret1
0A0 2C010        670                             OUTPUT          s0, w_word_write_port
0A1 00045        671                             LOAD            s0, #secret2
0A2 2C010        672                             OUTPUT          s0, w_word_write_port
0A3 00067        673                             LOAD            s0, #secret3
0A4 2C010        674                             OUTPUT          s0, w_word_write_port
                 675     ;
                 676     ;Start of DS2432 command
                 677     ;
0A5 3020B        678                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
0A6 003A5        679                             LOAD            s3, #0xa5               ;read authenticated page command
0A7 3024E        680                             CALL            write_byte_slow         ;transmit command
0A8 3020E        681                             CALL            compute_crc16           ;compute CRC for value in 's3'
0A9 00500        682                             LOAD            s5, #0x00               ;set address for page 0
0AA 00400        683                             LOAD            s4, #0x00               ;  [TA2,TA1]=0000 hex
0AB 01340        684                             LOAD            s3, s4                  ;transmit TA1
0AC 3024E        685                             CALL            write_byte_slow
0AD 3020E        686                             CALL            compute_crc16           ;compute CRC for value in 's3'
0AE 01350        687                             LOAD            s3, s5                  ;transmit TA2
0AF 3024E        688                             CALL            write_byte_slow
0B0 3020E        689                             CALL            compute_crc16           ;compute CRC for value in 's3'
                 690     ;
                 691     ;Read 32-bytes of data associated with page 0
                 692     ;Store these as M1 through to M8
                 693     ;
0B1 302EC        694     rapc_line_loop:         CALL            send_cr
0B2 01050        695                             LOAD            s0, s5                  ;display 16-bit address
0B3 302C2        696                             CALL            send_hex_byte
0B4 01040        697                             LOAD            s0, s4
0B5 302C2        698                             CALL            send_hex_byte
0B6 302EF        699                             CALL            send_space
0B7 302EF        700                             CALL            send_space
0B8 302EF        701     rapc_data_loop:         CALL            send_space
0B9 3026F        702                             CALL            read_byte_slow          ;read data into s3
0BA 3020E        703                             CALL            compute_crc16           ;compute CRC for value in 's3'
0BB 2C310        704                             OUTPUT          s3, w_word_write_port   ;store as 'M' word
0BC 01030        705                             LOAD            s0, s3                  ;display byte
0BD 302C2        706                             CALL            send_hex_byte
0BE 18401        707                             ADD             s4, #0x01               ;increment address
0BF 1A500        708                             ADDCY           s5, #0x00
0C0 12407        709                             TEST            s4, #0x07               ;test for 8-byte boundary
0C1 354B8        710                             JUMP            nz, rapc_data_loop
0C2 14420        711                             COMPARE         s4, #0x20               ;test for last address
0C3 354B1        712                             JUMP            nz, rapc_line_loop
0C4 302EC        713                             CALL            send_cr
                 714     ;
                 715     ;Read one byte that should be value FF hex
                 716     ;
0C5 3026F        717                             CALL            read_byte_slow          ;read data into s3
0C6 3020E        718                             CALL            compute_crc16           ;compute CRC for value in 's3'
0C7 01030        719                             LOAD            s0, s3                  ;display byte
0C8 302C2        720                             CALL            send_hex_byte
0C9 302EC        721                             CALL            send_cr
0CA 3021C        722                             CALL            read_send_test_crc16    ;read, display and test CRC value
                 723     ;
                 724     ;Complete table by stroring M9 through to M15
                 725     ;
0CB 000FF        726                             LOAD            s0, #0xff               ;W9 = FF FF FF FF
0CC 00104        727                             LOAD            s1, #0x04
0CD 2C010        728     store_w9:               OUTPUT          s0, w_word_write_port
0CE 1C101        729                             SUB             s1, #0x01
0CF 354CD        730                             JUMP            nz, store_w9
                 731     ;
0D0 00040        732                             LOAD            s0, #0x40               ;W10 begins with 40 for page 0
0D1 2C010        733                             OUTPUT          s0, w_word_write_port
                 734     ;
                 735     ;W10 ends with family code and serial number 0 and 1.
                 736     ;W11 is formed of serial number 2, 3, 4 and 5.
                 737     ;All of this information is in PicoBlaze memory having been read by the
                 738     ;read ROM command.
                 739     ;
0D2 00100        740                             LOAD            s1, #family_code        ;pointer to memory
0D3 00207        741                             LOAD            s2, #0x07               ;7 bytes to read and store
0D4 07010        742     next_m10_m11:           FETCH           s0, @s1
0D5 2C010        743                             OUTPUT          s0, w_word_write_port
0D6 18101        744                             ADD             s1, #0x01               ;increment pointer
0D7 1C201        745                             SUB             s2, #0x01
0D8 354D4        746                             JUMP            nz, next_m10_m11
                 747     ;
0D9 00089        748                             LOAD            s0, #secret4            ;store M12 (secret 4, 5, 6 and 7) in Wt buffer
0DA 2C010        749                             OUTPUT          s0, w_word_write_port
0DB 000AB        750                             LOAD            s0, #secret5
0DC 2C010        751                             OUTPUT          s0, w_word_write_port
0DD 000CD        752                             LOAD            s0, #secret6
0DE 2C010        753                             OUTPUT          s0, w_word_write_port
0DF 000EF        754                             LOAD            s0, #secret7
0E0 2C010        755                             OUTPUT          s0, w_word_write_port
                 756     ;
0E1 06020        757                             FETCH           s0, scratchpad4         ;M13 uses scratchpad 4, 5, and 6 and '80' hex
0E2 2C010        758                             OUTPUT          s0, w_word_write_port
0E3 06021        759                             FETCH           s0, scratchpad5
0E4 2C010        760                             OUTPUT          s0, w_word_write_port
0E5 06022        761                             FETCH           s0, scratchpad6
0E6 2C010        762                             OUTPUT          s0, w_word_write_port
0E7 00080        763                             LOAD            s0, #0x80
0E8 2C010        764                             OUTPUT          s0, w_word_write_port
                 765     ;
0E9 00000        766                             LOAD            s0, #0x00               ;W14 = 00 00 00 00   W15 = 00 00 01 B8
0EA 00106        767                             LOAD            s1, #0x06
0EB 2C010        768     store_w14_w15:          OUTPUT          s0, w_word_write_port
0EC 1C101        769                             SUB             s1, #0x01
0ED 354EB        770                             JUMP            nz, store_w14_w15
0EE 00001        771                             LOAD            s0, #0x01
0EF 2C010        772                             OUTPUT          s0, w_word_write_port
0F0 000B8        773                             LOAD            s0, #0xb8
0F1 2C010        774                             OUTPUT          s0, w_word_write_port
                 775     ;
                 776     ;Compute the SHA-1 algorithm at the same time that the DS2432 is also computing (2ms).
                 777     ;
0F2 30115        778                             CALL            compute_sha1
                 779     ;
                 780     ;The 160-bit Message Authentication Code is read from the DS2432 as 20 bytes
                 781     ;and compared with the concatenation of variables E, D, C, B and A in that order
                 782     ;with each variable received from the DS2432 least significant byte first.
                 783     ;Each received byte is also used to form a 16-bit CRC value which is tested to
                 784     ;reveal any communication errors.
                 785     ;
                 786     ;
0F3 303E7        787                             CALL            send_mac                ;display 'mac='
0F4 3020B        788                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
0F5 00C00        789                             LOAD            sc, #0x00               ;Clear byte match counter
0F6 00B18        790                             LOAD            sb, #var_e0             ;start match with LS-Byte of variable 'E'
0F7 00A04        791     mac_match_var:          LOAD            sa, #0x04               ;4 bytes to match in each variable
0F8 079B0        792     mac_match_byte:         FETCH           s9, @sb                 ;read variable byte from local SHA-1
0F9 3026F        793                             CALL            read_byte_slow          ;read DS2432 byte into s3
0FA 3020E        794                             CALL            compute_crc16           ;compute CRC for value in 's3'
0FB 15390        795                             COMPARE         s3, s9                  ;compare MAC values
0FC 354FE        796                             JUMP            nz, display_mac_byte    ;count matching bytes
0FD 18C01        797                             ADD             sc, #0x01               ;decrement match counter
0FE 01030        798     display_mac_byte:       LOAD            s0, s3                  ;display byte
0FF 302C2        799                             CALL            send_hex_byte
100 302EF        800                             CALL            send_space
101 1CA01        801                             SUB             sa, #0x01               ;counts bytes per variable
102 35105        802                             JUMP            z, next_mac_var
103 18B01        803                             ADD             sb, #0x01
104 340F8        804                             JUMP            mac_match_byte
105 14B0B        805     next_mac_var:           COMPARE         sb, #var_a3             ;test for last byte
106 35109        806                             JUMP            z, report_mac
107 1CB07        807                             SUB             sb, #0x07               ;point to next variable
108 340F7        808                             JUMP            mac_match_var
                 809     ;
                 810     ;MAC has passed if all 20 bytes matched
                 811     ;
109 302EC        812     report_mac:             CALL            send_cr
10A 14C14        813                             COMPARE         sc, #0x14               ;20 bytes should have matched
10B 3550E        814                             JUMP            nz, mac_fail
10C 303AD        815                             CALL            send_pass
10D 3410F        816                             JUMP            read_mac_crc
10E 303B4        817     mac_fail:               CALL            send_fail
                 818     ;
                 819     ;Next two bytes received are the 16-bit CRC
                 820     ;Read 16-bit CRC into [s5,s4] and send value to UART
                 821     ;
10F 3021C        822     read_mac_crc:           CALL            read_send_test_crc16    ;read, display and test CRC value
                 823     ;
                 824     ;Read one byte that should be value AA hex.
                 825     ;  Would actually read AA hex continuously until master reset
                 826     ;
110 3026F        827                             CALL            read_byte_slow          ;read data into s3
111 01030        828                             LOAD            s0, s3                  ;display byte
112 302C2        829                             CALL            send_hex_byte
113 302EC        830                             CALL            send_cr
                 831     ;
114 34003        832                             JUMP            warm_start
                 833     ;
                 834     ;
                 835     ;**************************************************************************************
                 836     ; Compute SHA-1 Algorithm.
                 837     ;**************************************************************************************
                 838     ;
                 839     ; Computes the SHA-1 algorithm based on the initial table of values (M0 through to M15)
                 840     ; which are stored in the external Wt buffer.
                 841     ;
                 842     ; The SHA-1 algorithms uses 5 variables called 'A', 'B', 'C', 'D' and 'E'. Each variable
                 843     ; is 32-bits and stored as 4 bytes in PicoBlaze scratch pad memory. The locations must
                 844     ; be defined using constants 'var_A0' thought to 'var_E3' in ascending locations.
                 845     ;
                 846     ; Constants must also be used to define access to the external Wt buffer.
                 847     ;
                 848     ; During this process, register 'sE' is used to count iterations from 0 to 79 (4F hex).
                 849     ; Other registers are consistently grouped as follows to support 32-bit operations.
                 850     ;
                 851     ; Register set [s5,s4,s3,s2] is used as a temporary 32-bit word
                 852     ; Register set [s9,s8,s7,s6] is used as a temporary 32-bit word
                 853     ; Register set [sD,sC,sB,sA] is used as a temporary 32-bit word
                 854     ;
                 855     ;
                 856     ; Initialise the 32-bit variables
                 857     ;
                 858     ;
115 00001        859     compute_sha1:           LOAD            s0, #0x01               ;A=67452301
116 2E008        860                             STORE           s0, var_a0
117 00023        861                             LOAD            s0, #0x23
118 2E009        862                             STORE           s0, var_a1
119 00045        863                             LOAD            s0, #0x45
11A 2E00A        864                             STORE           s0, var_a2
11B 00067        865                             LOAD            s0, #0x67
11C 2E00B        866                             STORE           s0, var_a3
11D 00089        867                             LOAD            s0, #0x89               ;B=EFCDAB89
11E 2E00C        868                             STORE           s0, var_b0
11F 000AB        869                             LOAD            s0, #0xab
120 2E00D        870                             STORE           s0, var_b1
121 000CD        871                             LOAD            s0, #0xcd
122 2E00E        872                             STORE           s0, var_b2
123 000EF        873                             LOAD            s0, #0xef
124 2E00F        874                             STORE           s0, var_b3
125 000FE        875                             LOAD            s0, #0xfe               ;C=98BADCFE
126 2E010        876                             STORE           s0, var_c0
127 000DC        877                             LOAD            s0, #0xdc
128 2E011        878                             STORE           s0, var_c1
129 000BA        879                             LOAD            s0, #0xba
12A 2E012        880                             STORE           s0, var_c2
12B 00098        881                             LOAD            s0, #0x98
12C 2E013        882                             STORE           s0, var_c3
12D 00076        883                             LOAD            s0, #0x76               ;D=10325476
12E 2E014        884                             STORE           s0, var_d0
12F 00054        885                             LOAD            s0, #0x54
130 2E015        886                             STORE           s0, var_d1
131 00032        887                             LOAD            s0, #0x32
132 2E016        888                             STORE           s0, var_d2
133 00010        889                             LOAD            s0, #0x10
134 2E017        890                             STORE           s0, var_d3
135 000F0        891                             LOAD            s0, #0xf0               ;E=C3D2E1F0
136 2E018        892                             STORE           s0, var_e0
137 000E1        893                             LOAD            s0, #0xe1
138 2E019        894                             STORE           s0, var_e1
139 000D2        895                             LOAD            s0, #0xd2
13A 2E01A        896                             STORE           s0, var_e2
13B 000C3        897                             LOAD            s0, #0xc3
13C 2E01B        898                             STORE           s0, var_e3
                 899     ;
                 900     ;
13D 00E00        901                             LOAD            se, #0x00               ;reset iteration counter
                 902     ;
                 903     ;
                 904     ;Compute ft(B,C,D) in register set [s5,s4,s3,s2] and then add constant Kt.
                 905     ;
                 906     ;Iterations 0 to 19 - process type 1
                 907     ;   ft = (B and C) or ((not B) and D)
                 908     ;  Then the constant Kt=5A827999 will be added
                 909     ;
                 910     ;Iterations 20 to 39  and iterations 60 to 79  - process type 2
                 911     ;   ft = B xor C xor D
                 912     ;  Then the constant Kt=6ED9EBA1 will be added for iterations 20 to 39
                 913     ;  Then the constant Kt=CA62C1D6 will be added for iterations 60 to 79
                 914     ;
                 915     ;Iterations 40 to 59  - process type 3
                 916     ;   ft = (B and C) or (B and D) or (C and D)
                 917     ;  Then the constant Kt=8F1BBCDC will be added
                 918     ;
13E 0650F        919     next_sha1_iteration:    FETCH           s5, var_b3              ;B in [s5,s4,s3,s2]
13F 0640E        920                             FETCH           s4, var_b2
140 0630D        921                             FETCH           s3, var_b1
141 0620C        922                             FETCH           s2, var_b0
142 30176        923                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
143 06D17        924                             FETCH           sd, var_d3              ;D in [sD,sC,sB,sA]
144 06C16        925                             FETCH           sc, var_d2
145 06B15        926                             FETCH           sb, var_d1
146 06A14        927                             FETCH           sa, var_d0
                 928     ;
                 929     ;Determine process type
                 930     ;
147 14E14        931                             COMPARE         se, #0x14               ;set carry flag for iterations <20
148 35961        932                             JUMP            c, ft_type1
149 14E28        933                             COMPARE         se, #0x28               ;set carry flag for iterations <40
14A 3594D        934                             JUMP            c, ft_type2
14B 14E3C        935                             COMPARE         se, #0x3c               ;set carry flag for iterations <60
14C 3597B        936                             JUMP            c, ft_type3
                 937     ;
                 938     ;   ft = B xor C xor D
                 939     ;
                 940     ;       B xor C     =        B       xor       C
                 941     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [s9,s8,s7,s6]
                 942     ;
                 943     ;   B xor C xor D   =    (B xor C)   xor       D
                 944     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [sD,sC,sB,sA]
                 945     ;
                 946     ;
14D 0F590        947     ft_type2:               XOR             s5, s9                  ;B xor C in [s5,s4,s3,s2]
14E 0F480        948                             XOR             s4, s8
14F 0F370        949                             XOR             s3, s7
150 0F260        950                             XOR             s2, s6
151 0F5D0        951                             XOR             s5, sd                  ;(B xor C) xor D in [s5,s4,s3,s2]
152 0F4C0        952                             XOR             s4, sc
153 0F3B0        953                             XOR             s3, sb
154 0F2A0        954                             XOR             s2, sa
155 14E3C        955                             COMPARE         se, #0x3c               ;set carry flag for iterations <60
156 35D5C        956                             JUMP            nc, kt_ca62c1d6
157 182A1        957                             ADD             s2, #0xa1               ;add Kt=6ED9EBA1
158 1A3EB        958                             ADDCY           s3, #0xeb
159 1A4D9        959                             ADDCY           s4, #0xd9
15A 1A56E        960                             ADDCY           s5, #0x6e
15B 34194        961                             JUMP            compute_tmp
15C 182D6        962     kt_ca62c1d6:            ADD             s2, #0xd6               ;add Kt=CA62C1D6
15D 1A3C1        963                             ADDCY           s3, #0xc1
15E 1A462        964                             ADDCY           s4, #0x62
15F 1A5CA        965                             ADDCY           s5, #0xca
160 34194        966                             JUMP            compute_tmp
                 967     ;
                 968     ;   ft = (B and C) or ((not B) and D)
                 969     ;
                 970     ;       B and C     =        C       and       B
                 971     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                 972     ;
                 973     ;       not B       =        B       xor   FFFFFFFF
                 974     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [FF,FF,FF,FF]
                 975     ;
                 976     ;   (not B) and D   =    (not B)     and       D
                 977     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                 978     ;
                 979     ;   ;(B and C) or ((not B) and D)  =  ((not B) and D)  or   (B and C)
                 980     ;            [s5,s4,s3,s2]         =   [s5,s4,s3,s2]   or  [s9,s8,s7,s6]
                 981     ;
161 0B950        982     ft_type1:               AND             s9, s5                  ;B and C in [s9,s8,s7,s6]
162 0B840        983                             AND             s8, s4
163 0B730        984                             AND             s7, s3
164 0B620        985                             AND             s6, s2
165 0E5FF        986                             XOR             s5, #0xff               ;(not B) in [s5,s4,s3,s2]
166 0E4FF        987                             XOR             s4, #0xff
167 0E3FF        988                             XOR             s3, #0xff
168 0E2FF        989                             XOR             s2, #0xff
169 0B5D0        990                             AND             s5, sd                  ;((not B) and D) in [s5,s4,s3,s2]
16A 0B4C0        991                             AND             s4, sc
16B 0B3B0        992                             AND             s3, sb
16C 0B2A0        993                             AND             s2, sa
16D 0D590        994                             OR              s5, s9                  ;(B and C) or ((not B) and D) in [s5,s4,s3,s2]
16E 0D480        995                             OR              s4, s8
16F 0D370        996                             OR              s3, s7
170 0D260        997                             OR              s2, s6
171 18299        998                             ADD             s2, #0x99               ;add Kt=5A827999
172 1A379        999                             ADDCY           s3, #0x79
173 1A482       1000                             ADDCY           s4, #0x82
174 1A55A       1001                             ADDCY           s5, #0x5a
175 34194       1002                             JUMP            compute_tmp
                1003     ;
                1004     ;Routine to fetch variable 'C' into register set [s9,s8,s7,s6]
                1005     ;
176 06913       1006     fetch_c:                FETCH           s9, var_c3
177 06812       1007                             FETCH           s8, var_c2
178 06711       1008                             FETCH           s7, var_c1
179 06610       1009                             FETCH           s6, var_c0
17A 2A000       1010                             RETURN
                1011     ;
                1012     ;   ft = (B and C) or (B and D) or (C and D)
                1013     ;
                1014     ;       B and C     =        C       and       B
                1015     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                1016     ;
                1017     ;       B and D     =        B       and       D
                1018     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                1019     ;
                1020     ;  (B and C) or (B and D)   =    (B and D)    or    (B and C)
                1021     ;      [s5,s4,s3,s2]        =  [s5,s4,s3,s2]  or  [s9,s8,s7,s6]
                1022     ;
                1023     ;     read C again into [s9,s8,s7,s6]
                1024     ;
                1025     ;       C and D     =        C       and       D
                1026     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [sD,sC,sB,sA]
                1027     ;
                1028     ;  ((B and C) or (B and D)) or (C and D)   =    ((B and C) or (B and D)) or   (C and D)
                1029     ;               [s5,s4,s3,s2]              =           [s5,s4,s3,s2]     or  [s9,s8,s7,s6]
                1030     ;
17B 0B950       1031     ft_type3:               AND             s9, s5                  ;(B and C) in [s9,s8,s7,s6]
17C 0B840       1032                             AND             s8, s4
17D 0B730       1033                             AND             s7, s3
17E 0B620       1034                             AND             s6, s2
17F 0B5D0       1035                             AND             s5, sd                  ;(B and D) in [s5,s4,s3,s2]
180 0B4C0       1036                             AND             s4, sc
181 0B3B0       1037                             AND             s3, sb
182 0B2A0       1038                             AND             s2, sa
183 0D590       1039                             OR              s5, s9                  ;(B and C) or (B and D) in [s5,s4,s3,s2]
184 0D480       1040                             OR              s4, s8
185 0D370       1041                             OR              s3, s7
186 0D260       1042                             OR              s2, s6
187 30176       1043                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
188 0B9D0       1044                             AND             s9, sd                  ;(C and D) in [s9,s8,s7,s6]
189 0B8C0       1045                             AND             s8, sc
18A 0B7B0       1046                             AND             s7, sb
18B 0B6A0       1047                             AND             s6, sa
18C 0D590       1048                             OR              s5, s9                  ;(B and C) or (B and D) or (C and D) in [s5,s4,s3,s2]
18D 0D480       1049                             OR              s4, s8
18E 0D370       1050                             OR              s3, s7
18F 0D260       1051                             OR              s2, s6
190 182DC       1052                             ADD             s2, #0xdc               ;add Kt=8F1BBCDC
191 1A3BC       1053                             ADDCY           s3, #0xbc
192 1A41B       1054                             ADDCY           s4, #0x1b
193 1A58F       1055                             ADDCY           s5, #0x8f
                1056     ;
                1057     ;Add variable 'E' to [s5,s4,s3,s2]
                1058     ;
194 06018       1059     compute_tmp:            FETCH           s0, var_e0
195 19200       1060                             ADD             s2, s0
196 06019       1061                             FETCH           s0, var_e1
197 1B300       1062                             ADDCY           s3, s0
198 0601A       1063                             FETCH           s0, var_e2
199 1B400       1064                             ADDCY           s4, s0
19A 0601B       1065                             FETCH           s0, var_e3
19B 1B500       1066                             ADDCY           s5, s0
                1067     ;
                1068     ;Add variable 'A' rotated left 5 places
                1069     ;
19C 0690B       1070                             FETCH           s9, var_a3              ;A in [s9,s8,s7,s6]
19D 0680A       1071                             FETCH           s8, var_a2
19E 06709       1072                             FETCH           s7, var_a1
19F 06608       1073                             FETCH           s6, var_a0
1A0 00005       1074                             LOAD            s0, #0x05               ;rotate left 5 places
1A1 301E7       1075                             CALL            rotate_word_left_n_places
1A2 19260       1076                             ADD             s2, s6                  ;add to TMP
1A3 1B370       1077                             ADDCY           s3, s7
1A4 1B480       1078                             ADDCY           s4, s8
1A5 1B590       1079                             ADDCY           s5, s9
                1080     ;
                1081     ;
                1082     ;Compute Wt in register set [s9,s8,s7,s6]
                1083     ;  Value computed is also stored back in the external buffer for
                1084     ;  use in later iterations as well as being added to TMP.
                1085     ;
                1086     ;Iterations 0 to 15
                1087     ;  Wt = Mt
                1088     ; This only requires Wt-16 to be read and then shifted back into the buffer again.
                1089     ;
                1090     ;Iterations 0 to 15
                1091     ;  Wt = rotate_left_1_place(Wt-3 xor Wt-8 xor Wt-14 xor Wt-16)
                1092     ; This requires all data values to be read first. Then XORed and rotated before
                1093     ; shifting the new Wt word into the buffer.
                1094     ;
                1095     ;
1A6 0493F       1096                             INPUT           s9, wt_minus16_byte3_read_port ;Read Wt-16 value
1A7 0483E       1097                             INPUT           s8, wt_minus16_byte2_read_port
1A8 0473D       1098                             INPUT           s7, wt_minus16_byte1_read_port
1A9 0463C       1099                             INPUT           s6, wt_minus16_byte0_read_port
1AA 14E10       1100                             COMPARE         se, #0x10               ;set carry flag for iterations 0 to 15
1AB 359C5       1101                             JUMP            c, store_wt
                1102     ;
                1103     ;Read other Wt words and perform XOR
                1104     ;
1AC 04037       1105                             INPUT           s0, wt_minus14_byte3_read_port ;XOR with Wt-14 value
1AD 0F900       1106                             XOR             s9, s0
1AE 04036       1107                             INPUT           s0, wt_minus14_byte2_read_port
1AF 0F800       1108                             XOR             s8, s0
1B0 04035       1109                             INPUT           s0, wt_minus14_byte1_read_port
1B1 0F700       1110                             XOR             s7, s0
1B2 04034       1111                             INPUT           s0, wt_minus14_byte0_read_port
1B3 0F600       1112                             XOR             s6, s0
1B4 0401F       1113                             INPUT           s0, wt_minus8_byte3_read_port ;XOR with Wt-8 value
1B5 0F900       1114                             XOR             s9, s0
1B6 0401E       1115                             INPUT           s0, wt_minus8_byte2_read_port
1B7 0F800       1116                             XOR             s8, s0
1B8 0401D       1117                             INPUT           s0, wt_minus8_byte1_read_port
1B9 0F700       1118                             XOR             s7, s0
1BA 0401C       1119                             INPUT           s0, wt_minus8_byte0_read_port
1BB 0F600       1120                             XOR             s6, s0
1BC 0400B       1121                             INPUT           s0, wt_minus3_byte3_read_port ;XOR with Wt-3 value
1BD 0F900       1122                             XOR             s9, s0
1BE 0400A       1123                             INPUT           s0, wt_minus3_byte2_read_port
1BF 0F800       1124                             XOR             s8, s0
1C0 04009       1125                             INPUT           s0, wt_minus3_byte1_read_port
1C1 0F700       1126                             XOR             s7, s0
1C2 04008       1127                             INPUT           s0, wt_minus3_byte0_read_port
1C3 0F600       1128                             XOR             s6, s0
1C4 301EB       1129                             CALL            rotate_word_left        ;rotate XORed word left by one place
                1130     ;
                1131     ;Store new Wt value in external buffer
                1132     ;
1C5 2C910       1133     store_wt:               OUTPUT          s9, w_word_write_port
1C6 2C810       1134                             OUTPUT          s8, w_word_write_port
1C7 2C710       1135                             OUTPUT          s7, w_word_write_port
1C8 2C610       1136                             OUTPUT          s6, w_word_write_port
                1137     ;
                1138     ;Add new computed Wt value to TMP in [s5,s4,s3,s2]
                1139     ;
1C9 19260       1140                             ADD             s2, s6
1CA 1B370       1141                             ADDCY           s3, s7
1CB 1B480       1142                             ADDCY           s4, s8
1CC 1B590       1143                             ADDCY           s5, s9
                1144     ;
                1145     ;TMP is now complete in [s5,s4,s3,s2]
                1146     ;
                1147     ;
                1148     ;copy values
                1149     ;  E <= D
                1150     ;  D <= C
                1151     ;  C <= B (this will need to be rotated 30 places afterwards)
                1152     ;  B <= A
                1153     ;
1CD 00D04       1154                             LOAD            sd, #0x04               ;4 bytes per word to copy
1CE 00C1B       1155     copy_var_loop:          LOAD            sc, #var_e3
1CF 00B1A       1156                             LOAD            sb, #var_e2
1D0 07AB0       1157     move_var_loop:          FETCH           sa, @sb
1D1 2FAC0       1158                             STORE           sa, @sc
1D2 1CC01       1159                             SUB             sc, #0x01
1D3 1CB01       1160                             SUB             sb, #0x01
1D4 14C08       1161                             COMPARE         sc, #var_a0
1D5 355D0       1162                             JUMP            nz, move_var_loop
1D6 1CD01       1163                             SUB             sd, #0x01
1D7 355CE       1164                             JUMP            nz, copy_var_loop
                1165     ;
                1166     ;rotate 'C' (the previous 'B') left 30 places
                1167     ;
1D8 30176       1168                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
1D9 0001E       1169                             LOAD            s0, #0x1e               ;rotate left 30 places
1DA 301E7       1170                             CALL            rotate_word_left_n_places
1DB 2E913       1171                             STORE           s9, var_c3
1DC 2E812       1172                             STORE           s8, var_c2
1DD 2E711       1173                             STORE           s7, var_c1
1DE 2E610       1174                             STORE           s6, var_c0
                1175     ;
                1176     ;  A <= TMP
                1177     ;
1DF 2E50B       1178                             STORE           s5, var_a3
1E0 2E40A       1179                             STORE           s4, var_a2
1E1 2E309       1180                             STORE           s3, var_a1
1E2 2E208       1181                             STORE           s2, var_a0
                1182     ;
                1183     ;count iterations
                1184     ;
1E3 14E4F       1185                             COMPARE         se, #0x4f               ;test for last iteration = 79 decimal (4F hex)
1E4 2B000       1186                             RETURN          z
1E5 18E01       1187                             ADD             se, #0x01
1E6 3413E       1188                             JUMP            next_sha1_iteration
                1189     ;
                1190     ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1191     ; by the number of places specified in register 's0'.
                1192     ;
1E7 301EB       1193     rotate_word_left_n_places: CALL         rotate_word_left
1E8 1C001       1194                             SUB             s0, #0x01
1E9 355E7       1195                             JUMP            nz, rotate_word_left_n_places
1EA 2A000       1196                             RETURN
                1197     ;
                1198     ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1199     ; by one place.
                1200     ;
1EB 12980       1201     rotate_word_left:       TEST            s9, #0x80               ;test MSB of word
1EC 20600       1202                             SLA             s6
1ED 20700       1203                             SLA             s7
1EE 20800       1204                             SLA             s8
1EF 20900       1205                             SLA             s9
1F0 2A000       1206                             RETURN
                1207     ;
                1208     ;**************************************************************************************
                1209     ; Compute 8-bit CRC used by DS2432.
                1210     ;**************************************************************************************
                1211     ;
                1212     ; The DS2432 computes an 8-bit CRC using the polynomial X8 + X5 + X4 + 1.
                1213     ; See the DS2432 data sheet for full details.
                1214     ;
                1215     ; Test input value of value 00 00 00 01 B8 1C 02
                1216     ; should produce CRC=A2.
                1217     ;
                1218     ; This routine computes the same CRC based on the values stored in the KCPSM3
                1219     ; scratch pad memory by the read ROM command. The result is returned in register s0.
                1220     ;
                1221     ; Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9
                1222     ;
                1223     ;
                1224     ; Start by loading family code and serial number (56-bits) into register set
                1225     ; [s9,s8,s7,s6,s5,s4,s3] so that it can be shifted out LSB first.
                1226     ;
                1227     ;
1F1 06300       1228     compute_crc8:           FETCH           s3, family_code
1F2 06401       1229                             FETCH           s4, serial_number0
1F3 06502       1230                             FETCH           s5, serial_number1
1F4 06603       1231                             FETCH           s6, serial_number2
1F5 06704       1232                             FETCH           s7, serial_number3
1F6 06805       1233                             FETCH           s8, serial_number4
1F7 06906       1234                             FETCH           s9, serial_number5
1F8 00238       1235                             LOAD            s2, #0x38               ;56 bits to shift (38 hex)
1F9 00000       1236                             LOAD            s0, #0x00               ;clear CRC value
1FA 01100       1237     crc8_loop:              LOAD            s1, s0                  ;copy current CRC value
1FB 0F130       1238                             XOR             s1, s3                  ;Need to know LSB XOR next input bit
1FC 12101       1239                             TEST            s1, #0x01               ;test result of XOR in LSB
1FD 35DFF       1240                             JUMP            nc, crc8_shift
1FE 0E018       1241                             XOR             s0, #0x18               ;compliment bits 3 and 4 of CRC
1FF 2010E       1242     crc8_shift:             SR0             s1                      ;Carry gets LSB XOR next input bit
200 20008       1243                             SRA             s0                      ;shift Carry into MSB to form new CRC value
201 2090E       1244                             SR0             s9                      ;shift input value
202 20808       1245                             SRA             s8
203 20708       1246                             SRA             s7
204 20608       1247                             SRA             s6
205 20508       1248                             SRA             s5
206 20408       1249                             SRA             s4
207 20308       1250                             SRA             s3
208 1C201       1251                             SUB             s2, #0x01               ;count iterations
209 355FA       1252                             JUMP            nz, crc8_loop
20A 2A000       1253                             RETURN
                1254     ;
                1255     ;
                1256     ;
                1257     ;**************************************************************************************
                1258     ; Clear or Compute 16-bit CRC used by DS2432.
                1259     ;**************************************************************************************
                1260     ;
                1261     ; The DS2432 computes a 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                1262     ; See the DS2432 data sheet for full details.
                1263     ;
                1264     ; Note that the value formed in the CRC shift register MUST BE INVERTED to give the
                1265     ; same value as that sent from the DS2432 during scratchpad write, scratchpad read
                1266     ; and read auth page commands.
                1267     ;
                1268     ; The 16-bit CRC is computed using a different number of bytes depending on the
                1269     ; command. This routine has been written such that the CRC can be computed one
                1270     ; byte at a time. The byte to be processed should be provided in register 's3'
                1271     ; and the contents of this register are preserved.
                1272     ;
                1273     ; This routine computes the 16-bit CRC in the register pair [sE,sD] and these
                1274     ; registers must not be disturbed between calls of this routine.
                1275     ;
                1276     ; Before starting a CRC computation the 'clear_CRC16' should be used.
                1277     ;
                1278     ; Registers used s0,s1,s3,sD,sE
                1279     ;    s3 is preserved.
                1280     ;    sD and sE should not be disturbed between calls if CRC value is required.
                1281     ;
                1282     ;
20B 00E00       1283     clear_crc16:            LOAD            se, #0x00               ;[sE,sD]=0000
20C 00D00       1284                             LOAD            sd, #0x00
20D 2A000       1285                             RETURN
                1286     ;
20E 00108       1287     compute_crc16:          LOAD            s1, #0x08               ;8-bits to shift
20F 010D0       1288     crc16_loop:             LOAD            s0, sd                  ;copy current CRC value
210 0F030       1289                             XOR             s0, s3                  ;Need to know LSB XOR next input bit
211 12001       1290                             TEST            s0, #0x01               ;test result of XOR in LSB
212 35E15       1291                             JUMP            nc, crc16_shift
213 0ED02       1292                             XOR             sd, #0x02               ;compliment bit 1 of CRC
214 0EE40       1293                             XOR             se, #0x40               ;compliment bit 14 of CRC
215 2000E       1294     crc16_shift:            SR0             s0                      ;Carry gets LSB XOR next input bit
216 20E08       1295                             SRA             se                      ;shift Carry into MSB to form new CRC value
217 20D08       1296                             SRA             sd
218 2030C       1297                             RR              s3                      ;shift input value
219 1C101       1298                             SUB             s1, #0x01               ;count bits
21A 3560F       1299                             JUMP            nz, crc16_loop          ;next bit
21B 2A000       1300                             RETURN
                1301     ;
                1302     ;
                1303     ;**************************************************************************************
                1304     ; Read 16-bit CRC from DS2432, send value received to UART and test result.
                1305     ;**************************************************************************************
                1306     ;
                1307     ; The computed CRC value for comparison must be in register pair [sE,sD]
                1308     ;
21C 3026F       1309     read_send_test_crc16:   CALL            read_byte_slow          ;read 16-bit CRC into [s5,s4]
21D 01430       1310                             LOAD            s4, s3
21E 3026F       1311                             CALL            read_byte_slow
21F 01530       1312                             LOAD            s5, s3
220 303E2       1313                             CALL            send_crc                ;'crc=' to display CRC value
221 01050       1314                             LOAD            s0, s5
222 302C2       1315                             CALL            send_hex_byte
223 01040       1316                             LOAD            s0, s4
224 302C2       1317                             CALL            send_hex_byte
225 302EC       1318                             CALL            send_cr
226 0EDFF       1319                             XOR             sd, #0xff               ;1's complement the computed CRC value
227 0EEFF       1320                             XOR             se, #0xff
228 154D0       1321                             COMPARE         s4, sd                  ;test received value with computed value
229 3562E       1322                             JUMP            nz, crc16_fail
22A 155E0       1323                             COMPARE         s5, se
22B 3562E       1324                             JUMP            nz, crc16_fail
22C 303AD       1325                             CALL            send_pass               ;display 'Pass' with carriage return
22D 2A000       1326                             RETURN
22E 303B4       1327     crc16_fail:             CALL            send_fail               ;display 'Fail' with carriage return
22F 2A000       1328                             RETURN
                1329     ;
                1330     ;
                1331     ;**************************************************************************************
                1332     ; Initialise the DS2432 1-wire interface.
                1333     ;**************************************************************************************
                1334     ;
                1335     ; The 1-wire interface is an open-collector communication scheme employing an external
                1336     ; pull-up resistor of 680 Ohms.
                1337     ;
                1338     ; The hardware section of this translates the one bit signal from PicoBlaze such that
                1339     ; when this signal is Low the output is driven Low, but when it is High, it turns off
                1340     ; the output buffer and the signal is pulled High externally.
                1341     ;
                1342     ; This initialisation routine simply ensures that the line is High after configuration.
                1343     ; It is vital that DS_wire is generally in the High state because it is the only way in
                1344     ; which the DS2432 device derives power to operate.
                1345     ;
                1346     ; Registers used s0
                1347     ;
230 00001       1348     ds_wire_init:           LOAD            s0, #ds_wire
231 2C008       1349                             OUTPUT          s0, ds_wire_out_port
232 2A000       1350                             RETURN
                1351     ;
                1352     ;
                1353     ;**************************************************************************************
                1354     ; DS2432 initialisation - Regular Speed.
                1355     ;**************************************************************************************
                1356     ;
                1357     ; The initialisation sequence must be performed before any communication can be
                1358     ; made with the DS2432 device. This involves the application of an active Low master
                1359     ; reset pulse.
                1360     ;
                1361     ; The regular (slow) speed communication is established by transmitting an active
                1362     ; Low reset pulse for a duration of at least 480us. This design generates a 500us pulse.
                1363     ;
                1364     ; The DS2432 acknowledges the reset and the setting of regular mode by generating an
                1365     ; active Low 'Rx Presence Pulse'. This presence pulse can start 15 to 60us after the
                1366     ; reset pulse and will end between 120 and 300us after the reset pulse.
                1367     ;
                1368     ; To confirm that regular mode has been set, this routine confirms that the presence pulse
                1369     ; is active only after 60us have elapsed since the reset pulse. This ensures that the
                1370     ; faster presence pulse of overdrive mode can not be detected.
                1371     ;
                1372     ; The carry flag will be set if no valid presence pulse was received (wire remained High) and
                1373     ; can be used to indicate an initialisation failure or success.
                1374     ;
                1375     ; The routine only completes 300us after the presence pulse to ensure the DS2432 has
                1376     ; completed the presence pulse and is ready for the first operation.
                1377     ;
                1378     ; Registers used s0,s1,s2
                1379     ;
233 00000       1380     ds_init_regular_mode:   LOAD            s0, #0x00               ;transmit reset pulse
234 2C008       1381                             OUTPUT          s0, ds_wire_out_port
                1382     ;Delay of 500us is equivalent to 12500 instructions at 50MHz.
                1383     ;This delay loop is formed of 28 instructions requiring 446 repetitions.
235 00201       1384                             LOAD            s2, #0x01               ;[s3,s2]=445 decimal (01BD hex)
236 001BD       1385                             LOAD            s1, #0xbd
237 30287       1386     rm_wait_500us:          CALL            delay_1us               ;25 instructions including CALL
238 1C101       1387                             SUB             s1, #0x01               ;decrement delay counter
239 1E200       1388                             SUBCY           s2, #0x00
23A 35E37       1389                             JUMP            nc, rm_wait_500us       ;repeat until -1
23B 00001       1390                             LOAD            s0, #0x01               ;end of regular reset pulse
23C 2C008       1391                             OUTPUT          s0, ds_wire_out_port
                1392     ;Delay of 60us is equivalent to 1500 instructions at 50MHz.
                1393     ;This delay and is formed of 27 instructions requiring 56 repetitions.
23D 00138       1394                             LOAD            s1, #0x38               ;56 (38 hex)
23E 30287       1395     rm_wait_60us:           CALL            delay_1us               ;25 instructions including CALL
23F 1C101       1396                             SUB             s1, #0x01               ;decrement delay counter
240 3563E       1397                             JUMP            nz, rm_wait_60us        ;repeat until zero
                1398     ;The DS_wire is now checked at approximately 1us intervals for the next 240us looking
                1399     ;to detect an active Low presence pulse. The 240us is equivalent to 6000 instructions
                1400     ;at 50MHz and this polling loop is formed of 33 instructions requiring 182 repetitions.
241 00201       1401                             LOAD            s2, #0x01               ;set bit which will be reset by a presence pulse
242 001B6       1402                             LOAD            s1, #0xb6               ;182 (B6 hex)
243 30287       1403     rm_poll_240us:          CALL            delay_1us               ;25 instructions including CALL
244 3024A       1404                             CALL            read_ds_wire            ;read wire - 5 instructions including CALL
245 0B200       1405                             AND             s2, s0                  ;clear flag if DS_wire was Low
246 1C101       1406                             SUB             s1, #0x01               ;decrement delay counter
247 35643       1407                             JUMP            nz, rm_poll_240us       ;repeat until zero
248 12201       1408                             TEST            s2, #0x01               ;set carry flag if no pulse detected
249 2A000       1409                             RETURN
                1410     ;
                1411     ;
                1412     ;**************************************************************************************
                1413     ; Read the DS_wire
                1414     ;**************************************************************************************
                1415     ;
                1416     ; The DS_wire signal is read and returned in bit0 of register 's0'.
                1417     ; Additionally the carry flag is set if the signal is High and reset if Low
                1418     ;
                1419     ; Registers used s0
                1420     ;
24A 040C0       1421     read_ds_wire:           INPUT           s0, ds_wire_in_port
24B 0A001       1422                             AND             s0, #ds_wire            ;ensure only bit0 is active
24C 12001       1423                             TEST            s0, #ds_wire            ;set carry flag if DS_wire is High
24D 2A000       1424                             RETURN
                1425     ;
                1426     ;
                1427     ;
                1428     ;**************************************************************************************
                1429     ; Write a byte to DS2432 in regular speed mode.
                1430     ;**************************************************************************************
                1431     ;
                1432     ; Bytes are written to the DS2432 with LSB first.
                1433     ;
                1434     ; The byte to be written should be provided in register 's3' and this will be preserved.
                1435     ;
                1436     ; Registers used s0,s1,s2,s3
                1437     ;
24E 00208       1438     write_byte_slow:        LOAD            s2, #0x08               ;8 bits to transmit
24F 2030C       1439     wbs_loop:               RR              s3                      ;test next bit LSB first
250 35A53       1440                             JUMP            c, wbs1                 ;transmit '0' or '1'
251 30257       1441                             CALL            write_low_slow
252 34254       1442                             JUMP            next_slow_bit
253 30262       1443     wbs1:                   CALL            write_high_slow
254 1C201       1444     next_slow_bit:          SUB             s2, #0x01               ;count bits
255 3564F       1445                             JUMP            nz, wbs_loop            ;repeat until 8-bits transmitted
256 2A000       1446                             RETURN
                1447     ;
                1448     ;
                1449     ;
                1450     ;**************************************************************************************
                1451     ; Write a '0' to DS_wire in regular speed mode.
                1452     ;**************************************************************************************
                1453     ;
                1454     ; To write a '0' to the DS_wire the signal must be Low for 60 to 120us. This design
                1455     ; generates a 78us active Low pulse.
                1456     ;
                1457     ; The DS2432 then requires at least 1us of recovery time for which this routine
                1458     ; provides a 2us delay such that the entire write Low process (slot time) is 80us.
                1459     ; A recovery time of 1us was also found to be marginal in practice probably due
                1460     ; to the rise time of the DS_wire via the external pull up resistor.
                1461     ;
                1462     ; Registers used s0,s1
                1463     ;
257 00000       1464     write_low_slow:         LOAD            s0, #0x00               ;transmit Low pulse
258 2C008       1465                             OUTPUT          s0, ds_wire_out_port
                1466     ;Delay of 78us is equivalent to 1950 instructions at 50MHz.
                1467     ;This delay loop is formed of 27 instructions requiring 72 repetitions.
259 00148       1468                             LOAD            s1, #0x48               ;72 (48 hex)
25A 30287       1469     wls_wait_78us:          CALL            delay_1us               ;25 instructions including CALL
25B 1C101       1470                             SUB             s1, #0x01               ;decrement delay counter
25C 3565A       1471                             JUMP            nz, wls_wait_78us       ;repeat until zero
25D 00001       1472                             LOAD            s0, #0x01               ;end of Low pulse
25E 2C008       1473                             OUTPUT          s0, ds_wire_out_port
25F 30287       1474                             CALL            delay_1us               ;2us recovery time
260 30287       1475                             CALL            delay_1us
261 2A000       1476                             RETURN
                1477     ;
                1478     ;
                1479     ;**************************************************************************************
                1480     ; Write a '1' to DS_wire in regular speed mode.
                1481     ;**************************************************************************************
                1482     ;
                1483     ; To write a '1' to the DS_wire the signal must be Low for 1 to 15us to instigate the
                1484     ; write of the data. This design generates an 8us active Low pulse for this purpose.
                1485     ;
                1486     ; Then the output must be High for 53 to 114us to provide the '1' for the DS2432 to
                1487     ; read and then provide recovery time. This design implements a 72us delay such that
                1488     ; the entire write High process (slot time) is 80us
                1489     ;
                1490     ; Registers used s0,s1
                1491     ;
262 00000       1492     write_high_slow:        LOAD            s0, #0x00               ;transmit Low pulse
263 2C008       1493                             OUTPUT          s0, ds_wire_out_port
                1494     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1495     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
264 00108       1496                             LOAD            s1, #0x08               ;8 (08 hex)
265 30287       1497     whs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
266 1C101       1498                             SUB             s1, #0x01               ;decrement delay counter
267 35665       1499                             JUMP            nz, whs_wait_8us        ;repeat until zero
268 00001       1500                             LOAD            s0, #0x01               ;end of Low pulse
269 2C008       1501                             OUTPUT          s0, ds_wire_out_port
                1502     ;Delay of 72us is equivalent to 1800 instructions at 50MHz.
                1503     ;This delay loop is formed of 27 instructions requiring 67 repetitions.
26A 00143       1504                             LOAD            s1, #0x43               ;67 (43 hex)
26B 30287       1505     whs_wait_72us:          CALL            delay_1us               ;25 instructions including CALL
26C 1C101       1506                             SUB             s1, #0x01               ;decrement delay counter
26D 3566B       1507                             JUMP            nz, whs_wait_72us       ;repeat until zero
26E 2A000       1508                             RETURN
                1509     ;
                1510     ;
                1511     ;
                1512     ;**************************************************************************************
                1513     ; Read a byte from DS2432 in regular speed mode.
                1514     ;**************************************************************************************
                1515     ;
                1516     ; Bytes are read from the DS2432 with LSB first.
                1517     ;
                1518     ; The byte read will be returned in register 's3'.
                1519     ;
                1520     ; Registers used s0,s1,s2,s3
                1521     ;
26F 00208       1522     read_byte_slow:         LOAD            s2, #0x08               ;8 bits to receive
270 30274       1523     rbs_loop:               CALL            read_bit_slow           ;read next bit LSB first
271 1C201       1524                             SUB             s2, #0x01               ;count bits
272 35670       1525                             JUMP            nz, rbs_loop            ;repeat until 8-bits received
273 2A000       1526                             RETURN
                1527     ;
                1528     ;
                1529     ;
                1530     ;
                1531     ;**************************************************************************************
                1532     ; Read a data bit sent from the DS2432 in regular speed mode.
                1533     ;**************************************************************************************
                1534     ;
                1535     ; To read a bit, PicoBlaze must initiate the processed with an active Low pulse of
                1536     ; 1 to 15us. This design generates a 4us active Low pulse for this purpose.
                1537     ;
                1538     ; Then DS2432 responds to the Low pulse by diving DS_wire in two different ways
                1539     ; depending on the logic level it is trying to send back.
                1540     ;
                1541     ; For a logic '0' the DS2432 will drive the DS-wire Low for up to 15us after
                1542     ; the start of the instigating pulse. Therefore PicoBlaze must read the DS-wire
                1543     ; before this time has elapsed but only after it has itself released the wire.
                1544     ;
                1545     ; For a logic '1' the DS2432 will do nothing and hence the DS-wire will be pulled
                1546     ; High by the external resistor after PicoBlaze has released the wire. PicoBlaze
                1547     ; will sample the wire and detect the High level.
                1548     ;
                1549     ; In this design, PicoBlaze needs to detect the logic state of the wire after
                1550     ; releasing the wire at 4us. Sampling the wire too quickly would not provide
                1551     ; adequate time for a High signal to be formed by the pull up resistor. However, it
                1552     ; must sample the wire before 15us have elapsed and any potential Low is removed.
                1553     ; This design samples the wire at 12us which is 8us after the initiation pulse ends.
                1554     ;
                1555     ; A further delay of 68us is then allowed for the DS2432 to stop transmitting and
                1556     ; to recover. This also mean that the entire read process (slot time) is 80us.
                1557     ;
                1558     ; The received data bit is SHIFTED into the MSB of register 's3'. In this way
                1559     ; the reception of 8-bits will shift the first bit into the LSB position of 's3'.
                1560     ;
                1561     ; Registers used s0,s1,s3
                1562     ;
274 00000       1563     read_bit_slow:          LOAD            s0, #0x00               ;transmit Low pulse
275 2C008       1564                             OUTPUT          s0, ds_wire_out_port
                1565     ;Delay of 4us is equivalent to 100 instructions at 50MHz.
                1566     ;This delay loop is formed of 27 instructions requiring 4 repetitions.
276 00104       1567                             LOAD            s1, #0x04               ;4 (04 hex)
277 30287       1568     rbs_wait_4us:           CALL            delay_1us               ;25 instructions including CALL
278 1C101       1569                             SUB             s1, #0x01               ;decrement delay counter
279 35677       1570                             JUMP            nz, rbs_wait_4us        ;repeat until zero
27A 00001       1571                             LOAD            s0, #0x01               ;end of Low pulse
27B 2C008       1572                             OUTPUT          s0, ds_wire_out_port
                1573     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1574     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
27C 00108       1575                             LOAD            s1, #0x08               ;8 (08 hex)
27D 30287       1576     rbs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
27E 1C101       1577                             SUB             s1, #0x01               ;decrement delay counter
27F 3567D       1578                             JUMP            nz, rbs_wait_8us        ;repeat until zero
280 3024A       1579                             CALL            read_ds_wire            ;sample wire (carry = state)
281 20308       1580                             SRA             s3                      ;shift received bit into MSB of s3
                1581     ;Delay of 68us is equivalent to 1700 instructions at 50MHz.
                1582     ;This delay loop is formed of 27 instructions requiring 63 repetitions.
282 0013F       1583                             LOAD            s1, #0x3f               ;63 (3F hex)
283 30287       1584     rbs_wait_68us:          CALL            delay_1us               ;25 instructions including CALL
284 1C101       1585                             SUB             s1, #0x01               ;decrement delay counter
285 35683       1586                             JUMP            nz, rbs_wait_68us       ;repeat until zero
286 2A000       1587                             RETURN
                1588     ;
                1589     ;
                1590     ;**************************************************************************************
                1591     ; Software delay routines
                1592     ;**************************************************************************************
                1593     ;
                1594     ; Delay of 1us.
                1595     ;
                1596     ; Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1597     ; executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1598     ; the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1599     ;
                1600     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1601     ;
                1602     ; Register used s0
                1603     ;
287 0000B       1604     delay_1us:              LOAD            s0, #delay_1us_constant
288 1C001       1605     wait_1us:               SUB             s0, #0x01
289 35688       1606                             JUMP            nz, wait_1us
28A 2A000       1607                             RETURN
                1608     ;
                1609     ; Delay of 40us.
                1610     ;
                1611     ; Registers used s0, s1
                1612     ;
28B 00128       1613     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
28C 30287       1614     wait_40us:              CALL            delay_1us
28D 1C101       1615                             SUB             s1, #0x01
28E 3568C       1616                             JUMP            nz, wait_40us
28F 2A000       1617                             RETURN
                1618     ;
                1619     ;
                1620     ; Delay of 1ms.
                1621     ;
                1622     ; Registers used s0, s1, s2
                1623     ;
290 00219       1624     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
291 3028B       1625     wait_1ms:               CALL            delay_40us
292 1C201       1626                             SUB             s2, #0x01
293 35691       1627                             JUMP            nz, wait_1ms
294 2A000       1628                             RETURN
                1629     ;
                1630     ; Delay of 20ms.
                1631     ;
                1632     ; Registers used s0, s1, s2, s3
                1633     ;
295 00314       1634     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
296 30290       1635     wait_20ms:              CALL            delay_1ms
297 1C301       1636                             SUB             s3, #0x01
298 35696       1637                             JUMP            nz, wait_20ms
299 2A000       1638                             RETURN
                1639     ;
                1640     ; Delay of approximately 1 second.
                1641     ;
                1642     ; Registers used s0, s1, s2, s3, s4
                1643     ;
29A 00414       1644     delay_1s:               LOAD            s4, #0x14               ;50 x 20ms = 1000ms
29B 30295       1645     wait_1s:                CALL            delay_20ms
29C 1C401       1646                             SUB             s4, #0x01
29D 3569B       1647                             JUMP            nz, wait_1s
29E 2A000       1648                             RETURN
                1649     ;
                1650     ;
                1651     ;**************************************************************************************
                1652     ; UART communication routines
                1653     ;**************************************************************************************
                1654     ;
                1655     ; Read one character from the UART
                1656     ;
                1657     ; Character read will be returned in a register called 'UART_data'.
                1658     ;
                1659     ; The routine first tests the receiver FIFO buffer to see if data is present.
                1660     ; If the FIFO is empty, the routine waits until there is a character to read.
                1661     ; As this could take any amount of time the wait loop could include a call to a
                1662     ; subroutine which performs a useful function.
                1663     ;
                1664     ;
                1665     ; Registers used s0 and UART_data
                1666     ;
29F 04040       1667     read_from_uart:         INPUT           s0, status_port         ;test Rx_FIFO buffer
2A0 12004       1668                             TEST            s0, #rx_data_present    ;wait if empty
2A1 356A3       1669                             JUMP            nz, read_character
2A2 3429F       1670                             JUMP            read_from_uart
2A3 04F80       1671     read_character:         INPUT           uart_data, uart_read_port ;read from FIFO
2A4 2A000       1672                             RETURN
                1673     ;
                1674     ;
                1675     ;
                1676     ; Transmit one character to the UART
                1677     ;
                1678     ; Character supplied in register called 'UART_data'.
                1679     ;
                1680     ; The routine first tests the transmit FIFO buffer to see if it is full.
                1681     ; If the FIFO is full, then the routine waits until it there is space.
                1682     ;
                1683     ; Registers used s0
                1684     ;
2A5 04040       1685     send_to_uart:           INPUT           s0, status_port         ;test Tx_FIFO buffer
2A6 12002       1686                             TEST            s0, #tx_full            ;wait if full
2A7 352A9       1687                             JUMP            z, uart_write
2A8 342A5       1688                             JUMP            send_to_uart
2A9 2CF04       1689     uart_write:             OUTPUT          uart_data, uart_write_port
2AA 2A000       1690                             RETURN
                1691     ;
                1692     ;
                1693     ;**************************************************************************************
                1694     ; Useful ASCII conversion and handling routines
                1695     ;**************************************************************************************
                1696     ;
                1697     ;
                1698     ; Convert character to upper case
                1699     ;
                1700     ; The character supplied in register s0.
                1701     ; If the character is in the range 'a' to 'z', it is converted
                1702     ; to the equivalent upper case character in the range 'A' to 'Z'.
                1703     ; All other characters remain unchanged.
                1704     ;
                1705     ; Registers used s0.
                1706     ;
2AB 14061       1707     upper_case:             COMPARE         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
2AC 2B800       1708                             RETURN          c
2AD 1407B       1709                             COMPARE         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
2AE 2BC00       1710                             RETURN          nc
2AF 0A0DF       1711                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
2B0 2A000       1712                             RETURN
                1713     ;
                1714     ;
                1715     ; Convert hexadecimal value provided in register s0 into ASCII characters
                1716     ;
                1717     ; The value provided must can be any value in the range 00 to FF and will be converted into
                1718     ; two ASCII characters.
                1719     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1720     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1721     ;
                1722     ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1723     ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1724     ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1725     ;
                1726     ; Registers used s0, s1 and s2.
                1727     ;
2B1 01100       1728     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
2B2 2000E       1729                             SR0             s0                      ;isolate upper nibble
2B3 2000E       1730                             SR0             s0
2B4 2000E       1731                             SR0             s0
2B5 2000E       1732                             SR0             s0
2B6 302BD       1733                             CALL            hex_to_ascii            ;convert
2B7 01200       1734                             LOAD            s2, s0                  ;upper nibble value in s2
2B8 01010       1735                             LOAD            s0, s1                  ;restore complete value
2B9 0A00F       1736                             AND             s0, #0x0f               ;isolate lower nibble
2BA 302BD       1737                             CALL            hex_to_ascii            ;convert
2BB 01100       1738                             LOAD            s1, s0                  ;lower nibble value in s1
2BC 2A000       1739                             RETURN
                1740     ;
                1741     ; Convert hexadecimal value provided in register s0 into ASCII character
                1742     ;
                1743     ;Register used s0
                1744     ;
2BD 1C00A       1745     hex_to_ascii:           SUB             s0, #0x0a               ;test if value is in range 0 to 9
2BE 35AC0       1746                             JUMP            c, number_char
2BF 18007       1747                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
2C0 1803A       1748     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
2C1 2A000       1749                             RETURN
                1750     ;
                1751     ;
                1752     ; Send the two character HEX value of the register contents 's0' to the UART
                1753     ;
                1754     ; Registers used s0, s1, s2
                1755     ;
2C2 302B1       1756     send_hex_byte:          CALL            hex_byte_to_ascii
2C3 01F20       1757                             LOAD            uart_data, s2
2C4 302A5       1758                             CALL            send_to_uart
2C5 01F10       1759                             LOAD            uart_data, s1
2C6 302A5       1760                             CALL            send_to_uart
2C7 2A000       1761                             RETURN
                1762     ;
                1763     ;
                1764     ;
                1765     ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                1766     ; an equivalent hexadecimal value in register 's0'.
                1767     ;     The upper nibble is represented by an ASCII character in register s3.
                1768     ;     The lower nibble is represented by an ASCII character in register s2.
                1769     ;
                1770     ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1771     ; will be set on return.
                1772     ;
                1773     ; Registers used s0, s2 and s3.
                1774     ;
2C8 01030       1775     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
2C9 302D5       1776                             CALL            ascii_to_hex            ;convert to value
2CA 2B800       1777                             RETURN          c                       ;reject if out of range
2CB 01300       1778                             LOAD            s3, s0                  ;remember value
2CC 20306       1779                             SL0             s3                      ;multiply value by 16 to put in upper nibble
2CD 20306       1780                             SL0             s3
2CE 20306       1781                             SL0             s3
2CF 20306       1782                             SL0             s3
2D0 01020       1783                             LOAD            s0, s2                  ;Take lower nibble
2D1 302D5       1784                             CALL            ascii_to_hex            ;convert to value
2D2 2B800       1785                             RETURN          c                       ;reject if out of range
2D3 0D030       1786                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
2D4 2A000       1787                             RETURN
                1788     ;
                1789     ;
                1790     ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1791     ;
                1792     ; If character is not valid for hex, then CARRY is set on return.
                1793     ;
                1794     ; Register used s0
                1795     ;
2D5 180B9       1796     ascii_to_hex:           ADD             s0, #0xb9               ;test for above ASCII code 46 ('F')
2D6 2B800       1797                             RETURN          c
2D7 1C0E9       1798                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
2D8 2B800       1799                             RETURN          c                       ;reject below ASCII code 30 ('0')
2D9 1C011       1800                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
2DA 35EDF       1801                             JUMP            nc, ascii_letter
2DB 18007       1802                             ADD             s0, #0x07               ;test for above ASCII code 46 ('F')
2DC 2B800       1803                             RETURN          c
2DD 1C0F6       1804                             SUB             s0, #0xf6               ;convert to range 00 to 09
2DE 2A000       1805                             RETURN
2DF 1800A       1806     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
2E0 2A000       1807                             RETURN
                1808     ;
                1809     ;
                1810     ; Read one character from UART and echo.
                1811     ; Convert to upper case and return.
                1812     ;
                1813     ;
2E1 3029F       1814     read_upper_case:        CALL            read_from_uart          ;read command character from UART
2E2 302A5       1815                             CALL            send_to_uart            ;echo character
2E3 010F0       1816                             LOAD            s0, uart_data           ;convert to upper case
2E4 302AB       1817                             CALL            upper_case
2E5 2A000       1818                             RETURN
                1819     ;
                1820     ;
                1821     ; Read two hex characters from UART and convert to single byte data
                1822     ;
2E6 302E1       1823     obtain_8bits:           CALL            read_upper_case         ;obtain one byte from UART
2E7 01300       1824                             LOAD            s3, s0
2E8 302E1       1825                             CALL            read_upper_case
2E9 01200       1826                             LOAD            s2, s0
2EA 302C8       1827                             CALL            ascii_byte_to_hex
2EB 2A000       1828                             RETURN
                1829     ;
                1830     ;**************************************************************************************
                1831     ; Text messages
                1832     ;**************************************************************************************
                1833     ;
                1834     ;
                1835     ; Send Carriage Return to the UART
                1836     ;
2EC 00F0D       1837     send_cr:                LOAD            uart_data, #character_cr
2ED 302A5       1838                             CALL            send_to_uart
2EE 2A000       1839                             RETURN
                1840     ;
                1841     ; Send a space to the UART
                1842     ;
2EF 00F20       1843     send_space:             LOAD            uart_data, #character_space
2F0 302A5       1844                             CALL            send_to_uart
2F1 2A000       1845                             RETURN
                1846     ;
                1847     ;
                1848     ; Send a minus sign to the UART
                1849     ;
2F2 00F2D       1850     send_minus:             LOAD            uart_data, #character_minus
2F3 302A5       1851                             CALL            send_to_uart
2F4 2A000       1852                             RETURN
                1853     ;
                1854     ;
                1855     ; Send the letter 't' to the UART
                1856     ;
2F5 00F74       1857     send_t:                 LOAD            uart_data, #character_t
2F6 302A5       1858                             CALL            send_to_uart
2F7 2A000       1859                             RETURN
                1860     ;
                1861     ; Send the letter 'e' to the UART
                1862     ;
2F8 00F65       1863     send_e:                 LOAD            uart_data, #character_e
2F9 302A5       1864                             CALL            send_to_uart
2FA 2A000       1865                             RETURN
                1866     ;
                1867     ; Send the letter 'a' to the UART
                1868     ;
2FB 00F61       1869     send_a:                 LOAD            uart_data, #character_a
2FC 302A5       1870                             CALL            send_to_uart
2FD 2A000       1871                             RETURN
                1872     ;
                1873     ;
                1874     ; Send the letter 'd' to the UART
                1875     ;
2FE 00F64       1876     send_d:                 LOAD            uart_data, #character_d
2FF 302A5       1877                             CALL            send_to_uart
300 2A000       1878                             RETURN
                1879     ;
                1880     ;
                1881     ; Send the letter 'r' to the UART
                1882     ;
301 00F72       1883     send_r:                 LOAD            uart_data, #character_r
302 302A5       1884                             CALL            send_to_uart
303 2A000       1885                             RETURN
                1886     ;
                1887     ;
                1888     ; Send the letter 's' to the UART
                1889     ;
304 00F73       1890     send_s:                 LOAD            uart_data, #character_s
305 302A5       1891                             CALL            send_to_uart
306 2A000       1892                             RETURN
                1893     ;
                1894     ;
                1895     ; Send the letter 'c' to the UART
                1896     ;
307 00F63       1897     send_c:                 LOAD            uart_data, #character_c
308 302A5       1898                             CALL            send_to_uart
309 2A000       1899                             RETURN
                1900     ;
                1901     ;
                1902     ; Send 'PicoBlaze SHA-1 Algorithm v1.00' string to the UART
                1903     ;
30A 302EC       1904     send_welcome:           CALL            send_cr
30B 302EC       1905                             CALL            send_cr
30C 00F50       1906                             LOAD            uart_data, #_character_p
30D 302A5       1907                             CALL            send_to_uart
30E 00F69       1908                             LOAD            uart_data, #character_i
30F 302A5       1909                             CALL            send_to_uart
310 30307       1910                             CALL            send_c
311 00F6F       1911                             LOAD            uart_data, #character_o
312 302A5       1912                             CALL            send_to_uart
313 00F42       1913                             LOAD            uart_data, #_character_b
314 302A5       1914                             CALL            send_to_uart
315 00F6C       1915                             LOAD            uart_data, #character_l
316 302A5       1916                             CALL            send_to_uart
317 302FB       1917                             CALL            send_a
318 00F7A       1918                             LOAD            uart_data, #character_z
319 302A5       1919                             CALL            send_to_uart
31A 302F8       1920                             CALL            send_e
31B 302EF       1921                             CALL            send_space
31C 00F53       1922                             LOAD            uart_data, #_character_s
31D 302A5       1923                             CALL            send_to_uart
31E 00F48       1924                             LOAD            uart_data, #_character_h
31F 302A5       1925                             CALL            send_to_uart
320 00F41       1926                             LOAD            uart_data, #_character_a
321 302A5       1927                             CALL            send_to_uart
322 302F2       1928                             CALL            send_minus
323 00F31       1929                             LOAD            uart_data, #character_1
324 302A5       1930                             CALL            send_to_uart
325 302EF       1931                             CALL            send_space
326 00F41       1932                             LOAD            uart_data, #_character_a
327 302A5       1933                             CALL            send_to_uart
328 00F6C       1934                             LOAD            uart_data, #character_l
329 302A5       1935                             CALL            send_to_uart
32A 00F67       1936                             LOAD            uart_data, #character_g
32B 302A5       1937                             CALL            send_to_uart
32C 00F6F       1938                             LOAD            uart_data, #character_o
32D 302A5       1939                             CALL            send_to_uart
32E 30301       1940                             CALL            send_r
32F 00F69       1941                             LOAD            uart_data, #character_i
330 302A5       1942                             CALL            send_to_uart
331 302F5       1943                             CALL            send_t
332 00F68       1944                             LOAD            uart_data, #character_h
333 302A5       1945                             CALL            send_to_uart
334 00F6D       1946                             LOAD            uart_data, #character_m
335 302A5       1947                             CALL            send_to_uart
336 302EF       1948                             CALL            send_space
337 00F76       1949                             LOAD            uart_data, #character_v
338 302A5       1950                             CALL            send_to_uart
339 00F31       1951                             LOAD            uart_data, #character_1
33A 302A5       1952                             CALL            send_to_uart
33B 00F2E       1953                             LOAD            uart_data, #character_fullstop
33C 302A5       1954                             CALL            send_to_uart
33D 00F30       1955                             LOAD            uart_data, #character_0
33E 302A5       1956                             CALL            send_to_uart
33F 00F30       1957                             LOAD            uart_data, #character_0
340 302A5       1958                             CALL            send_to_uart
341 302EC       1959                             CALL            send_cr
342 302EC       1960                             CALL            send_cr
343 2A000       1961                             RETURN
                1962     ;
                1963     ;
                1964     ;
                1965     ;
                1966     ;
                1967     ;
                1968     ; Send DS2432 menu to the UART
                1969     ;
344 302EC       1970     send_ds2432_menu:       CALL            send_cr
345 302EC       1971                             CALL            send_cr
346 00F31       1972                             LOAD            uart_data, #character_1
347 302A5       1973                             CALL            send_to_uart
348 302F2       1974                             CALL            send_minus
349 303A5       1975                             CALL            send_write
34A 302EF       1976                             CALL            send_space
34B 30384       1977                             CALL            send_scratchpad
34C 302EC       1978                             CALL            send_cr
34D 00F32       1979                             LOAD            uart_data, #character_2
34E 302A5       1980                             CALL            send_to_uart
34F 302F2       1981                             CALL            send_minus
350 3039F       1982                             CALL            send_read
351 302EF       1983                             CALL            send_space
352 30384       1984                             CALL            send_scratchpad
353 302EC       1985                             CALL            send_cr
354 00F33       1986                             LOAD            uart_data, #character_3
355 302A5       1987                             CALL            send_to_uart
356 302F2       1988                             CALL            send_minus
357 00F4C       1989                             LOAD            uart_data, #_character_l
358 302A5       1990                             CALL            send_to_uart
359 00F6F       1991                             LOAD            uart_data, #character_o
35A 302A5       1992                             CALL            send_to_uart
35B 302FB       1993                             CALL            send_a
35C 302FE       1994                             CALL            send_d
35D 302EF       1995                             CALL            send_space
35E 00F66       1996                             LOAD            uart_data, #character_f
35F 302A5       1997                             CALL            send_to_uart
360 00F69       1998                             LOAD            uart_data, #character_i
361 302A5       1999                             CALL            send_to_uart
362 30301       2000                             CALL            send_r
363 30304       2001                             CALL            send_s
364 302F5       2002                             CALL            send_t
365 302EF       2003                             CALL            send_space
366 30391       2004                             CALL            send_secret
367 302EC       2005                             CALL            send_cr
368 00F34       2006                             LOAD            uart_data, #character_4
369 302A5       2007                             CALL            send_to_uart
36A 302F2       2008                             CALL            send_minus
36B 3039F       2009                             CALL            send_read
36C 302EF       2010                             CALL            send_space
36D 00F61       2011                             LOAD            uart_data, #character_a
36E 302A5       2012                             CALL            send_to_uart
36F 00F75       2013                             LOAD            uart_data, #character_u
370 302A5       2014                             CALL            send_to_uart
371 302F5       2015                             CALL            send_t
372 00F68       2016                             LOAD            uart_data, #character_h
373 302A5       2017                             CALL            send_to_uart
374 302EF       2018                             CALL            send_space
375 00F50       2019                             LOAD            uart_data, #_character_p
376 302A5       2020                             CALL            send_to_uart
377 302FB       2021                             CALL            send_a
378 00F67       2022                             LOAD            uart_data, #character_g
379 302A5       2023                             CALL            send_to_uart
37A 302F8       2024                             CALL            send_e
37B 302EC       2025                             CALL            send_cr
37C 2A000       2026                             RETURN
                2027     ;
                2028     ;
                2029     ;
                2030     ; Send carriage return, 'OK' and carriage return to the UART
                2031     ;
37D 302EC       2032     send_ok:                CALL            send_cr
37E 00F4F       2033                             LOAD            uart_data, #_character_o
37F 302A5       2034                             CALL            send_to_uart
380 00F4B       2035                             LOAD            uart_data, #_character_k
381 302A5       2036                             CALL            send_to_uart
382 302EC       2037                             CALL            send_cr
383 2A000       2038                             RETURN
                2039     ;
                2040     ;
                2041     ; Send 'scratchpad' to the UART
                2042     ;
384 30304       2043     send_scratchpad:        CALL            send_s
385 30307       2044                             CALL            send_c
386 30301       2045                             CALL            send_r
387 302FB       2046                             CALL            send_a
388 302F5       2047                             CALL            send_t
389 30307       2048                             CALL            send_c
38A 00F68       2049                             LOAD            uart_data, #character_h
38B 302A5       2050                             CALL            send_to_uart
38C 00F70       2051                             LOAD            uart_data, #character_p
38D 302A5       2052                             CALL            send_to_uart
38E 302FB       2053                             CALL            send_a
38F 302FE       2054                             CALL            send_d
390 2A000       2055                             RETURN
                2056     ;
                2057     ;
                2058     ; Send 'secret' to the UART
                2059     ;
391 30304       2060     send_secret:            CALL            send_s
392 302F8       2061                             CALL            send_e
393 30307       2062                             CALL            send_c
394 30301       2063                             CALL            send_r
395 302F8       2064                             CALL            send_e
396 302F5       2065                             CALL            send_t
397 2A000       2066                             RETURN
                2067     ;
                2068     ;
                2069     ; Send 'Byte' to the UART
                2070     ;
398 00F42       2071     send_byte:              LOAD            uart_data, #_character_b
399 302A5       2072                             CALL            send_to_uart
39A 00F79       2073                             LOAD            uart_data, #character_y
39B 302A5       2074                             CALL            send_to_uart
39C 302F5       2075                             CALL            send_t
39D 302F8       2076                             CALL            send_e
39E 2A000       2077                             RETURN
                2078     ;
                2079     ;
                2080     ; Send 'Read' to the UART
                2081     ;
39F 00F52       2082     send_read:              LOAD            uart_data, #_character_r
3A0 302A5       2083                             CALL            send_to_uart
3A1 302F8       2084                             CALL            send_e
3A2 302FB       2085                             CALL            send_a
3A3 302FE       2086                             CALL            send_d
3A4 2A000       2087                             RETURN
                2088     ;
                2089     ;
                2090     ; Send 'Write' to the UART
                2091     ;
3A5 00F57       2092     send_write:             LOAD            uart_data, #_character_w
3A6 302A5       2093                             CALL            send_to_uart
3A7 30301       2094                             CALL            send_r
3A8 00F69       2095                             LOAD            uart_data, #character_i
3A9 302A5       2096                             CALL            send_to_uart
3AA 302F5       2097                             CALL            send_t
3AB 302F8       2098                             CALL            send_e
3AC 2A000       2099                             RETURN
                2100     ;
                2101     ;
                2102     ; Send 'Pass' to the UART
                2103     ;
3AD 00F50       2104     send_pass:              LOAD            uart_data, #_character_p
3AE 302A5       2105                             CALL            send_to_uart
3AF 302FB       2106                             CALL            send_a
3B0 30304       2107                             CALL            send_s
3B1 30304       2108                             CALL            send_s
3B2 302EC       2109                             CALL            send_cr
3B3 2A000       2110                             RETURN
                2111     ;
                2112     ;
                2113     ; Send 'Fail' to the UART
                2114     ;
3B4 00F46       2115     send_fail:              LOAD            uart_data, #_character_f
3B5 302A5       2116                             CALL            send_to_uart
3B6 302FB       2117                             CALL            send_a
3B7 00F69       2118                             LOAD            uart_data, #character_i
3B8 302A5       2119                             CALL            send_to_uart
3B9 00F6C       2120                             LOAD            uart_data, #character_l
3BA 302A5       2121                             CALL            send_to_uart
3BB 302EC       2122                             CALL            send_cr
3BC 2A000       2123                             RETURN
                2124     ;
                2125     ;
                2126     ; Send 'address=' to the UART
                2127     ;
3BD 302EC       2128     send_address:           CALL            send_cr
3BE 302FB       2129                             CALL            send_a
3BF 302FE       2130                             CALL            send_d
3C0 302FE       2131                             CALL            send_d
3C1 30301       2132                             CALL            send_r
3C2 302F8       2133                             CALL            send_e
3C3 30304       2134                             CALL            send_s
3C4 30304       2135                             CALL            send_s
3C5 00F3D       2136     send_equals:            LOAD            uart_data, #character_equals
3C6 302A5       2137                             CALL            send_to_uart
3C7 2A000       2138                             RETURN
                2139     ;
                2140     ;
                2141     ; Send 'data' to the UART
                2142     ;
3C8 302EC       2143     send_data:              CALL            send_cr
3C9 302FE       2144                             CALL            send_d
3CA 302FB       2145                             CALL            send_a
3CB 302F5       2146                             CALL            send_t
3CC 302FB       2147                             CALL            send_a
3CD 2A000       2148                             RETURN
                2149     ;
                2150     ;
                2151     ; Send 'E/S=' to the UART
                2152     ;
3CE 302EC       2153     send_es:                CALL            send_cr
3CF 00F45       2154                             LOAD            uart_data, #_character_e
3D0 302A5       2155                             CALL            send_to_uart
3D1 00F2F       2156                             LOAD            uart_data, #character_divide
3D2 302A5       2157                             CALL            send_to_uart
3D3 00F53       2158                             LOAD            uart_data, #_character_s
3D4 302A5       2159                             CALL            send_to_uart
3D5 343C5       2160                             JUMP            send_equals
                2161     ;
                2162     ;
                2163     ; Send 'code=' to the UART
                2164     ;
3D6 30307       2165     send_code:              CALL            send_c
3D7 00F6F       2166                             LOAD            uart_data, #character_o
3D8 302A5       2167                             CALL            send_to_uart
3D9 302FE       2168                             CALL            send_d
3DA 302F8       2169                             CALL            send_e
3DB 343C5       2170                             JUMP            send_equals
                2171     ;
                2172     ;
                2173     ; Send 's/n=' to the UART
                2174     ;
3DC 30304       2175     send_sn:                CALL            send_s
3DD 00F2F       2176                             LOAD            uart_data, #character_divide
3DE 302A5       2177                             CALL            send_to_uart
3DF 00F6E       2178                             LOAD            uart_data, #character_n
3E0 302A5       2179                             CALL            send_to_uart
3E1 343C5       2180                             JUMP            send_equals
                2181     ;
                2182     ;
                2183     ; Send 'crc=' to the UART
                2184     ;
3E2 30307       2185     send_crc:               CALL            send_c
3E3 00F72       2186                             LOAD            uart_data, #character_r
3E4 302A5       2187                             CALL            send_to_uart
3E5 30307       2188                             CALL            send_c
3E6 343C5       2189                             JUMP            send_equals
                2190     ;
                2191     ;
                2192     ;
                2193     ; Send 'mac=' to the UART
                2194     ;
3E7 00F6D       2195     send_mac:               LOAD            uart_data, #character_m
3E8 302A5       2196                             CALL            send_to_uart
3E9 302FB       2197                             CALL            send_a
3EA 30307       2198                             CALL            send_c
3EB 343C5       2199                             JUMP            send_equals
                2200     ;
                2201     ;
                2202     ;**************************************************************************************
                2203     ; Interrupt Service Routine (ISR)
                2204     ;**************************************************************************************
                2205     ;
                2206     ; Interrupts are not used in this design. This is a place keeper only.
                2207     ;
  003FE         2208                             ORG             0x3fe
3FE 38001       2209     isr:                    RETURNI         enable
                2210     ;
                2211     ;
                2212     ;**************************************************************************************
                2213     ; Interrupt Vector
                2214     ;**************************************************************************************
                2215     ;
  003FF         2216                             ORG             0x3ff
3FF 343FE       2217                             JUMP            isr
                2218     ;
                2219     ;
                2220
