                   1     ;KCPSM3 Program - UART programming of SPI Flash memory on Spartan-3E Starter Kit.
                   2     device kcpsm1
                   3     ;
                   4     ;Ken Chapman - Xilinx Ltd
                   5     ;
                   6     ;Version v1.00 - 11th November 2005
                   7     ;
                   8     ;This program uses a 115200 baud UART connection with XON/XOFF flow control
                   9     ;to allow a standard MCS file for the configuration of a Spartan-3E device to
                  10     ;be programmed into the ST Microelectronics M25P16 device on the board.
                  11     ;
                  12     ;
                  13     ;
                  14     ;As well as the port connections vital to communication with the UART and the SPI
                  15     ;FLASH memory, there are additional port connections used to disable the other
                  16     ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
                  17     ;controlled at the hardware level, they are included in this code to aid
                  18     ;future investigations of communication with the other SPI devices using PicoBlaze.
                  19     ;
                  20     ;
                  21     ;
                  22     ;
                  23     ;Port definitions
                  24     ;
  00000           25     status_port             EQU             0x00                    ;UART and filter status input
  00001           26     tx_data_present         EQU             0x01                    ;  Transmitter  data present - bit0
  00002           27     tx_half_full            EQU             0x02                    ;    FIFO          half full - bit1
  00004           28     tx_full                 EQU             0x04                    ;                       full - bit2
  00008           29     rx_data_present         EQU             0x08                    ;               data present - bit3
  00010           30     rx_half_full            EQU             0x10                    ;  Receiver        half full - bit4
  00020           31     rx_full                 EQU             0x20                    ;    FIFO               full - bit5
                  32     ;
  00001           33     uart_read_port          EQU             0x01                    ;UART Rx data input
                  34     ;
  00010           35     uart_write_port         EQU             0x10                    ;UART Tx data output
                  36     ;
                  37     ;
  00008           38     spi_control_port        EQU             0x08                    ;SPI clock and chip selects
  00001           39     spi_sck                 EQU             0x01                    ;                  SCK - bit0
  00002           40     spi_rom_cs              EQU             0x02                    ;    serial rom select - bit1
  00004           41     spi_spare_control       EQU             0x04                    ;                spare - bit2
  00008           42     spi_amp_cs              EQU             0x08                    ;     amplifier select - bit3
  00010           43     spi_adc_conv            EQU             0x10                    ;          A/D convert - bit4
  00020           44     spi_dac_cs              EQU             0x20                    ;           D/A select - bit5
  00040           45     spi_amp_shdn            EQU             0x40                    ;       amplifier SHDN - bit6
  00080           46     spi_dac_clr             EQU             0x80                    ;            D/A clear - bit7
                  47     ;
  00004           48     spi_output_port         EQU             0x04                    ;SPI data output
  00080           49     spi_sdo                 EQU             0x80                    ;   SDO - bit7
                  50     ;
  00002           51     spi_input_port          EQU             0x02                    ;SPI data input
  00080           52     spi_sdi                 EQU             0x80                    ;             SDI - bit7
  00040           53     spi_amp_sdi             EQU             0x40                    ;   amplifier SDI - bit6
                  54     ;
                  55     ;
                  56     ;
                  57     ;
                  58     ;Special Register usage
                  59     ;
  0000F           60     uart_data               REG             sf                      ;used to pass data to and from the UART
                  61     ;
                  62     ;
                  63     ;Useful data constants
                  64     ;
                  65     ;
                  66     ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                  67     ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                  68     ;calculation highly predictable. The '6' in the following equation even allows for
                  69     ;'CALL delay_1us' instruction in the initiating code.
                  70     ;
                  71     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                  72     ;
                  73     ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                  74     ;For clock rates below 10MHz the value of 1 must be used and the operation will
                  75     ;become lower than intended.
                  76     ;
  0000B           77     delay_1us_constant      EQU             0x0b
                  78     ;
                  79     ;
                  80     ;Useful constants
                  81     ;
                  82     ;
                  83     ;ASCII table
                  84     ;
  00061           85     character_a             EQU             0x61
  00062           86     character_b             EQU             0x62
  00063           87     character_c             EQU             0x63
  00064           88     character_d             EQU             0x64
  00065           89     character_e             EQU             0x65
  00066           90     character_f             EQU             0x66
  00067           91     character_g             EQU             0x67
  00068           92     character_h             EQU             0x68
  00069           93     character_i             EQU             0x69
  0006A           94     character_j             EQU             0x6a
  0006B           95     character_k             EQU             0x6b
  0006C           96     character_l             EQU             0x6c
  0006D           97     character_m             EQU             0x6d
  0006E           98     character_n             EQU             0x6e
  0006F           99     character_o             EQU             0x6f
  00070          100     character_p             EQU             0x70
  00071          101     character_q             EQU             0x71
  00072          102     character_r             EQU             0x72
  00073          103     character_s             EQU             0x73
  00074          104     character_t             EQU             0x74
  00075          105     character_u             EQU             0x75
  00076          106     character_v             EQU             0x76
  00077          107     character_w             EQU             0x77
  00078          108     character_x             EQU             0x78
  00079          109     character_y             EQU             0x79
  0007A          110     character_z             EQU             0x7a
  00041          111     _character_a            EQU             0x41
  00042          112     _character_b            EQU             0x42
  00043          113     _character_c            EQU             0x43
  00044          114     _character_d            EQU             0x44
  00045          115     _character_e            EQU             0x45
  00046          116     _character_f            EQU             0x46
  00047          117     _character_g            EQU             0x47
  00048          118     _character_h            EQU             0x48
  00049          119     _character_i            EQU             0x49
  0004A          120     _character_j            EQU             0x4a
  0004B          121     _character_k            EQU             0x4b
  0004C          122     _character_l            EQU             0x4c
  0004D          123     _character_m            EQU             0x4d
  0004E          124     _character_n            EQU             0x4e
  0004F          125     _character_o            EQU             0x4f
  00050          126     _character_p            EQU             0x50
  00051          127     _character_q            EQU             0x51
  00052          128     _character_r            EQU             0x52
  00053          129     _character_s            EQU             0x53
  00054          130     _character_t            EQU             0x54
  00055          131     _character_u            EQU             0x55
  00056          132     _character_v            EQU             0x56
  00057          133     _character_w            EQU             0x57
  00058          134     _character_x            EQU             0x58
  00059          135     _character_y            EQU             0x59
  0005A          136     _character_z            EQU             0x5a
  00030          137     character_0             EQU             0x30
  00031          138     character_1             EQU             0x31
  00032          139     character_2             EQU             0x32
  00033          140     character_3             EQU             0x33
  00034          141     character_4             EQU             0x34
  00035          142     character_5             EQU             0x35
  00036          143     character_6             EQU             0x36
  00037          144     character_7             EQU             0x37
  00038          145     character_8             EQU             0x38
  00039          146     character_9             EQU             0x39
  0003A          147     character_colon         EQU             0x3a
  0002E          148     character_fullstop      EQU             0x2e
  0003B          149     character_semi_colon    EQU             0x3b
  0002D          150     character_minus         EQU             0x2d
  0002B          151     character_plus          EQU             0x2b
  0002C          152     character_comma         EQU             0x2c
  0003C          153     character_less_than     EQU             0x3c                    ;'<'
  0003E          154     character_greater_than  EQU             0x3e                    ;'>'
  00028          155     character_open          EQU             0x28                    ;'('
  00029          156     character_close         EQU             0x29                    ;')'
  0002F          157     character_divide        EQU             0x2f                    ;'/'
  0003D          158     character_equals        EQU             0x3d
  00020          159     character_space         EQU             0x20
  0000D          160     character_cr            EQU             0x0d                    ;carriage return
  0000A          161     character_lf            EQU             0x0a                    ;line feed
  0003F          162     character_question      EQU             0x3f                    ;'?'
  00024          163     character_dollar        EQU             0x24
  00021          164     character_exclaim       EQU             0x21                    ;'!'
  00008          165     character_bs            EQU             0x08                    ;Back Space command character
  00011          166     character_xon           EQU             0x11                    ;Flow control ON
  00013          167     character_xoff          EQU             0x13                    ;Flow control OFF
                 168     ;
                 169     ;
                 170     ;Scratch Pad Memory Locations
                 171     ;
                 172     ;
  00000          173     isr_preserve_s0         EQU             0x00                    ;preserve register during ISR
                 174     ;
  00001          175     page_address_h          EQU             0x01                    ;Remember page address for SPI boundary checking.
  00002          176     page_address_m          EQU             0x02                    ;high, middle and low bytes
  00003          177     page_address_l          EQU             0x03
                 178     ;
  00004          179     spi_control_status      EQU             0x04                    ;SPI status signals
                 180     ;
                 181     ;
                 182     ;
                 183     ;Store up to one line of an MCS file as bytes
                 184     ;A typical data line consists of:-
                 185     ;:     Start character which is not stored
                 186     ;10    Number of data bytes included (16 in this case)
                 187     ;aaaa  Lower 16-bits of the storage address
                 188     ;00    Record type (data in this case)
                 189     ;dddd...   Data bytes (typically 16 which is the maximum)
                 190     ;cc    Checksum
                 191     ;CR/LF Line will end in carriage return and/or line feed which is not stored.
                 192     ;
                 193     ;So a total of 21 could be stored before processing.
                 194     ;
  0002B          195     line_start              EQU             0x2b                    ;21 bytes until end of memory
                 196     ;
                 197     ;
                 198     ;Initialise the system and welcome message
                 199     ;
                 200     ;
000 0830E        201     cold_start:             CALL            spi_init                ;initialise SPI bus ports
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
001 083AA        202                             CALL            delay_1s                ;delay because UART is fast and JTAG startup sequence can be slow
W: value out of range: 0x1aa, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaa.
002 08030        203                             ENABLE          interrupt               ;Interrupt is used for XON/XOFF flow control
003 0831D        204     welcome_start:          CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
004 08323        205                             CALL            send_welcome            ;start up message and version number
W: value out of range: 0x223, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x23.
                 206     ;
                 207     ;Main menu and command selection
                 208     ;
                 209     ;
                 210     ;
005 083BD        211     warm_start:             CALL            send_menu               ;Menu and command selection
W: value out of range: 0x2bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
006 0831D        212     prompt:                 CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
007 0831D        213                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
008 00F3E        214                             LOAD            uart_data, #character_greater_than ;prompt for input
009 083C1        215                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
00A 0831D        216                             CALL            read_upper_case
                 217                             COMPARE         s0, #_character_e       ;command test
E: instruction not supported on the this device: COMPARE sX, kk.
00B 09133        218                             JUMP            z, erase_command
                 219                             COMPARE         s0, #_character_s       ;command test
E: instruction not supported on the this device: COMPARE sX, kk.
00C 09140        220                             JUMP            z, sector_erase_command
                 221                             COMPARE         s0, #_character_p       ;command test
E: instruction not supported on the this device: COMPARE sX, kk.
00D 09154        222                             JUMP            z, program_command
                 223                             COMPARE         s0, #_character_r       ;command test
E: instruction not supported on the this device: COMPARE sX, kk.
00E 09159        224                             JUMP            z, read_command
                 225                             COMPARE         s0, #_character_i       ;command test
E: instruction not supported on the this device: COMPARE sX, kk.
00F 09122        226                             JUMP            z, id_command
                 227                             COMPARE         s0, #_character_h       ;command test
E: instruction not supported on the this device: COMPARE sX, kk.
010 09103        228                             JUMP            z, welcome_start
011 0831D        229                             CALL            send_cr                 ;no valid command input
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
012 00F3F        230                             LOAD            uart_data, #character_question ;display ???
013 083C1        231                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
014 083C1        232                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
015 083C1        233                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
016 08106        234                             JUMP            prompt                  ;Try again!
                 235     ;
                 236     ;
017 083AF        237     read_upper_case:        CALL            read_from_uart          ;read command character from UART
W: value out of range: 0x1af, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaf.
018 083C1        238                             CALL            send_to_uart            ;echo character
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
019 0C0F0        239                             LOAD            s0, uart_data           ;convert to upper case
01A 083CE        240                             CALL            upper_case
W: value out of range: 0x1ce, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xce.
01B 08080        241                             RETURN
                 242     ;
                 243     ;**************************************************************************************
                 244     ;ID Command - Read and display the ID for the SPI FLASH memory
                 245     ;**************************************************************************************
                 246     ;
                 247     ;Normal response should be
                 248     ;   s9 = Manufacturer Identification = 20 hex
                 249     ;   s8 = Memory Type = 20 hex
                 250     ;   s7 = Memory Capacity = 15 hex
                 251     ;
01C 0831D        252     id_command:             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
01D 0833E        253                             CALL            read_spi_flash_id
W: value out of range: 0x13e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x3e.
01E 08328        254                             CALL            send_id
W: value out of range: 0x328, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x28.
01F 00F3D        255                             LOAD            uart_data, #character_equals
020 083C1        256                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
021 08320        257                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
022 0C090        258                             LOAD            s0, s9
023 083F7        259                             CALL            send_hex_byte
W: value out of range: 0x1f7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf7.
024 08320        260                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
025 0C080        261                             LOAD            s0, s8
026 083F7        262                             CALL            send_hex_byte
W: value out of range: 0x1f7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf7.
027 08320        263                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
028 0C070        264                             LOAD            s0, s7
029 083F7        265                             CALL            send_hex_byte
W: value out of range: 0x1f7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf7.
02A 08320        266                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
02B 0831D        267                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
02C 08106        268                             JUMP            prompt
                 269     ;
                 270     ;**************************************************************************************
                 271     ;Erase Command - Perform bulk erase of the SPI FLASH memory and display messages
                 272     ;**************************************************************************************
                 273     ;
02D 0831D        274     erase_command:          CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
02E 0832D        275                             CALL            send_confirm            ;confirm command with a 'Y' which must be upper case
W: value out of range: 0x32d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2d.
02F 083AF        276                             CALL            read_from_uart          ;read command character from UART
W: value out of range: 0x1af, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaf.
030 083C1        277                             CALL            send_to_uart            ;echo input
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
                 278                             COMPARE         uart_data, #_character_y
E: instruction not supported on the this device: COMPARE sX, kk.
031 0953E        279                             JUMP            nz, abort_erase
032 0831D        280                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
033 08393        281                             CALL            send_erase_in_progress
W: value out of range: 0x293, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x93.
034 08373        282                             CALL            bulk_erase_spi
W: value out of range: 0x173, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x73.
035 083B6        283                             CALL            send_ok
W: value out of range: 0x2b6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb6.
036 08106        284                             JUMP            prompt
                 285     ;
037 0834A        286     abort_erase:            CALL            send_abort
W: value out of range: 0x34a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4a.
038 08106        287                             JUMP            prompt
                 288     ;
                 289     ;
                 290     ;**************************************************************************************
                 291     ;Sector Erase Command - Performs erase of lowest 5 sectors SPI FLASH memory which
                 292     ;covers the address range 000000 to 04FFFF in which the configuration for an XC3S500E
                 293     ;would be able to fit.
                 294     ;**************************************************************************************
                 295     ;
039 0831D        296     sector_erase_command:   CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
03A 0832D        297                             CALL            send_confirm            ;confirm command with a 'Y' which must be upper case
W: value out of range: 0x32d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2d.
03B 083AF        298                             CALL            read_from_uart          ;read command character from UART
W: value out of range: 0x1af, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaf.
03C 083C1        299                             CALL            send_to_uart            ;echo input
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
                 300                             COMPARE         uart_data, #_character_y
E: instruction not supported on the this device: COMPARE sX, kk.
03D 0953E        301                             JUMP            nz, abort_erase
03E 0831D        302                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
03F 08393        303                             CALL            send_erase_in_progress
W: value out of range: 0x293, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x93.
040 00900        304                             LOAD            s9, #0x00               ;any address inside sector 0
041 0835F        305                             CALL            erase_spi_sector
W: value out of range: 0x15f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5f.
042 00901        306                             LOAD            s9, #0x01               ;any address inside sector 1
043 0835F        307                             CALL            erase_spi_sector
W: value out of range: 0x15f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5f.
044 00902        308                             LOAD            s9, #0x02               ;any address inside sector 2
045 0835F        309                             CALL            erase_spi_sector
W: value out of range: 0x15f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5f.
046 00903        310                             LOAD            s9, #0x03               ;any address inside sector 3
047 0835F        311                             CALL            erase_spi_sector
W: value out of range: 0x15f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5f.
048 00904        312                             LOAD            s9, #0x04               ;any address inside sector 4
049 0835F        313                             CALL            erase_spi_sector
W: value out of range: 0x15f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5f.
04A 083B6        314                             CALL            send_ok
W: value out of range: 0x2b6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb6.
04B 08106        315                             JUMP            prompt
                 316     ;
                 317     ;
                 318     ;**************************************************************************************
                 319     ;Program Command - Program SPI FLASH memory with MCS file
                 320     ;**************************************************************************************
                 321     ;
04C 0831D        322     program_command:        CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
04D 0836C        323                             CALL            send_waiting_mcs_file
W: value out of range: 0x26c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6c.
04E 0836F        324                             CALL            program_mcs
04F 083B6        325                             CALL            send_ok
W: value out of range: 0x2b6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb6.
050 08106        326                             JUMP            prompt
                 327     ;
                 328     ;
                 329     ;**************************************************************************************
                 330     ;Read Command - Read one page of memory at specified address
                 331     ;**************************************************************************************
                 332     ;
051 08357        333     read_command:           CALL            send_page_address       ;obtain 24-bit address
W: value out of range: 0x357, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x57.
052 08369        334                             CALL            obtain_8bits
053 09959        335                             JUMP            c, read_command         ;bad input address
                 336                             COMPARE         s0, #0x20               ;test for address greater than 1FFFFF
E: instruction not supported on the this device: COMPARE sX, kk.
054 09D59        337                             JUMP            nc, read_command        ;value too big
055 0C900        338                             LOAD            s9, s0
056 08369        339                             CALL            obtain_8bits
057 09959        340                             JUMP            c, read_command         ;bad input address
058 0C800        341                             LOAD            s8, s0
059 08369        342                             CALL            obtain_8bits
05A 09959        343                             JUMP            c, read_command         ;bad input address
05B 0C700        344                             LOAD            s7, s0
05C 0831D        345                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
05D 083C9        346                             CALL            send_spi_page
05E 083B6        347                             CALL            send_ok
W: value out of range: 0x2b6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb6.
05F 08106        348                             JUMP            prompt
060 0831D        349     obtain_8bits:           CALL            read_upper_case         ;obtain one byte from UART
061 0C300        350                             LOAD            s3, s0
062 0831D        351                             CALL            read_upper_case
063 0C200        352                             LOAD            s2, s0
064 08304        353                             CALL            ascii_byte_to_hex
W: value out of range: 0x204, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
065 08080        354                             RETURN
                 355     ;
                 356     ;
                 357     ;
                 358     ;**************************************************************************************
                 359     ;Program SPI FLASH with MCS file
                 360     ;**************************************************************************************
                 361     ;
                 362     ;Reads the MCS file from the UART and programs the SPI FLASH device at the locations.
                 363     ;specified by the file contents.
                 364     ;
                 365     ;One important factor of programming the SPI FLASH for use as configuration
                 366     ;memory is that the bits within each byte must be in reverse order. This
                 367     ;is because an SPI device outputs data MSB first compared with a Xilinx
                 368     ;serial PROM which outputs LSB first. Therefore this routine will swap
                 369     ;the bits of each byte provided by the MCS file before programming.
                 370     ;
                 371     ;This routine will continue until an end of file record is detected.
                 372     ;For each line of MCS received, the current address will be output so that
                 373     ;progress can be monitored.
                 374     ;
                 375     ;Register sA is used to remember if a page is currently open (01) or closed (00)
                 376     ;for writing on the SPI memory.
                 377     ;
066 00A00        378     program_mcs:            LOAD            sa, #0x00               ;page is closed
067 083A9        379     next_prog_line:         CALL            read_mcs_line           ;read line
068 083B9        380                             CALL            mcs_address             ;find start address and record type
                 381                             COMPARE         sb, #0x01               ;test for end record
E: instruction not supported on the this device: COMPARE sX, kk.
069 091A5        382                             JUMP            z, end_program_mcs
06A 083FD        383                             CALL            send_hex_3bytes         ;send address for other lines
W: value out of range: 0x1fd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfd.
06B 0831D        384                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
                 385                             COMPARE         sb, #0x04               ;test for extended address record
E: instruction not supported on the this device: COMPARE sX, kk.
06C 091A1        386                             JUMP            z, mcs_address_boundary
                 387     ;
                 388     ;Assume data record type 00 now and program SPI page
                 389     ;
06D 06E01        390                             SUB             se, #0x01               ;location of checksum just after last stored data byte
06E 00D2B        391                             LOAD            sd, #line_start         ;Point to first data byte
06F 04D04        392                             ADD             sd, #0x04
                 393                             COMPARE         sa, #0x00               ;check if page is closed
E: instruction not supported on the this device: COMPARE sX, kk.
070 09188        394                             JUMP            z, program_byte         ;jump if page needs to be opened
                 395                             FETCH           s2, page_address_h      ;check new address is sequential
E: instruction not supported on the this device: FETCH sX, ss.
                 396                             COMPARE         s2, s9
E: instruction not supported on the this device: COMPARE sX, sY.
071 09586        397                             JUMP            nz, addr_out_of_sequence
                 398                             FETCH           s2, page_address_m      ;check new address is sequential
E: instruction not supported on the this device: FETCH sX, ss.
                 399                             COMPARE         s2, s8
E: instruction not supported on the this device: COMPARE sX, sY.
072 09586        400                             JUMP            nz, addr_out_of_sequence
                 401                             FETCH           s2, page_address_l      ;check new address is sequential
E: instruction not supported on the this device: FETCH sX, ss.
                 402                             COMPARE         s2, s7
E: instruction not supported on the this device: COMPARE sX, sY.
073 09188        403                             JUMP            z, program_byte         ;continue with open page
074 0838F        404     addr_out_of_sequence:   CALL            close_prog_page_spi     ;close page because address out of sequence
W: value out of range: 0x18f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8f.
075 00A00        405                             LOAD            sa, #0x00               ;page is now closed
  00088          406     program_byte:           COMPARE         sa, #0x00               ;check if page is closed
E: instruction not supported on the this device: COMPARE sX, kk.
076 0958C        407                             JUMP            nz, page_is_open        ;jump is page already open
077 08381        408                             CALL            open_prog_page_spi      ;open page with address [s9,s8,s7]
W: value out of range: 0x181, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x81.
078 00A01        409                             LOAD            sa, #0x01               ;page is open
  0008C          410     page_is_open:           FETCH           s1, @sd                 ;fetch data byte
E: instruction not supported on the this device: FETCH sX, sY.
079 00008        411                             LOAD            s0, #0x08               ;reverse order of bits
07A 0D10E        412     swap_bits:              SR0             s1
07B 0D200        413                             SLA             s2
07C 06001        414                             SUB             s0, #0x01
07D 0958E        415                             JUMP            nz, swap_bits           ;swapped bits now in s2
07E 08312        416                             CALL            spi_flash_tx_rx         ;program byte into SPI memory
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
07F 04701        417                             ADD             s7, #0x01               ;increment address to keep track
080 05800        418                             ADDCY           s8, #0x00
081 05900        419                             ADDCY           s9, #0x00
                 420                             COMPARE         s7, #0x00               ;test if crossing page boundary FF to 00
E: instruction not supported on the this device: COMPARE sX, kk.
082 0959A        421                             JUMP            nz, byte_programmed
083 0838F        422                             CALL            close_prog_page_spi
W: value out of range: 0x18f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8f.
084 00A00        423                             LOAD            sa, #0x00               ;page is now closed
085 04D01        424     byte_programmed:        ADD             sd, #0x01               ;move to next byte
                 425                             COMPARE         sd, se                  ;check for last on line
E: instruction not supported on the this device: COMPARE sX, sY.
086 09588        426                             JUMP            nz, program_byte        ;fetch next byte to program
                 427                             STORE           s9, page_address_h      ;remember next address in sequence
E: instruction not supported on the this device: STORE sX, ss.
                 428                             STORE           s8, page_address_m
E: instruction not supported on the this device: STORE sX, ss.
                 429                             STORE           s7, page_address_l
E: instruction not supported on the this device: STORE sX, ss.
087 08170        430                             JUMP            next_prog_line          ;read next line for programming
  000A1          431     mcs_address_boundary:   COMPARE         sa, #0x00               ;check if page needs to be closed
E: instruction not supported on the this device: COMPARE sX, kk.
088 09170        432                             JUMP            z, next_prog_line
089 0838F        433                             CALL            close_prog_page_spi
W: value out of range: 0x18f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8f.
08A 0816F        434                             JUMP            program_mcs
  000A5          435     end_program_mcs:        COMPARE         sa, #0x00               ;check if page needs to be closed
E: instruction not supported on the this device: COMPARE sX, kk.
08B 09080        436                             RETURN          z
08C 0838F        437                             CALL            close_prog_page_spi
W: value out of range: 0x18f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8f.
08D 08080        438                             RETURN
                 439     ;
                 440     ;**************************************************************************************
                 441     ;Read one line of an MCS file into scratch pad memory
                 442     ;**************************************************************************************
                 443     ;
                 444     ;Reads one line of MCS file format into scratch pad memory starting at location 'line_start'.
                 445     ;
                 446     ;The routine detects the line start character ':' ignoring any preceding characters. This
                 447     ;will remove any additional CR or LF characters.
                 448     ;
                 449     ;It then reads each subsequent pair of ASCII characters, converts them to true hex in the
                 450     ;range 00 to FF and stores them in scratch pad memory.
                 451     ;
                 452     ;The end of the line is determined by either a CR or LF character.
                 453     ;
                 454     ;The value last returned in register 'sE' will be the pointer to the location in
                 455     ;scratch pad memory following the last byte for the line read.
                 456     ;
08E 00E2B        457     read_mcs_line:          LOAD            se, #line_start         ;initialise SPM memory pointer
08F 083AF        458     wait_mcs_line_start:    CALL            read_from_uart          ;read character
W: value out of range: 0x1af, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaf.
                 459                             COMPARE         uart_data, #character_colon ;test for start character
E: instruction not supported on the this device: COMPARE sX, kk.
090 095AA        460                             JUMP            nz, wait_mcs_line_start
091 083AF        461     read_mcs_byte:          CALL            read_from_uart          ;read character
W: value out of range: 0x1af, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaf.
                 462                             COMPARE         uart_data, #character_cr ;test for end of line
E: instruction not supported on the this device: COMPARE sX, kk.
092 09080        463                             RETURN          z
                 464                             COMPARE         uart_data, #character_lf ;test for end of line
E: instruction not supported on the this device: COMPARE sX, kk.
093 09080        465                             RETURN          z
094 0C3F0        466                             LOAD            s3, uart_data           ;upper nibble character
095 083AF        467                             CALL            read_from_uart          ;read character
W: value out of range: 0x1af, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaf.
096 0C2F0        468                             LOAD            s2, uart_data           ;lower nibble character
097 08304        469                             CALL            ascii_byte_to_hex       ;convert to true hex value
W: value out of range: 0x204, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
                 470                             STORE           s0, @se                 ;write to SPM
E: instruction not supported on the this device: STORE sX, sY.
098 04E01        471                             ADD             se, #0x01               ;increment pointer
099 081AD        472                             JUMP            read_mcs_byte
                 473     ;
                 474     ;
                 475     ;**************************************************************************************
                 476     ;Determine the current address for the line of an MCS file in scratch pad memory
                 477     ;**************************************************************************************
                 478     ;
                 479     ;Checks the existing line data stored in scratch pad memory starting at location
                 480     ;'line_start' and determines the current address.
                 481     ;
                 482     ;The address is in the register set [s9,s8,s7] before and after this routine is
                 483     ;executed because not all address bits are defined by a given line of MCS and
                 484     ;the undefined bits remain constant.
                 485     ;
                 486     ;A record type of 04 will update [s9].
                 487     ;A record type of 00 will update [s8,s7].
                 488     ;
                 489     ;On return, the register sB will contain the record type and
                 490     ;register sC will indicate the number of data bytes stored.
                 491     ;
09A 00D2B        492     mcs_address:            LOAD            sd, #line_start         ;initialise SPM memory pointer
                 493                             FETCH           sc, @sd                 ;read number of bytes on line
E: instruction not supported on the this device: FETCH sX, sY.
09B 04D03        494                             ADD             sd, #0x03               ;move to record type
                 495                             FETCH           sb, @sd                 ;read record type
E: instruction not supported on the this device: FETCH sX, sY.
                 496                             COMPARE         sb, #0x00               ;test for data record
E: instruction not supported on the this device: COMPARE sX, kk.
09C 091C4        497                             JUMP            z, new_low_address
                 498                             COMPARE         sb, #0x04               ;test for data record
E: instruction not supported on the this device: COMPARE sX, kk.
09D 09480        499                             RETURN          nz
09E 04D02        500                             ADD             sd, #0x02               ;read upper 8-bits
                 501                             FETCH           s9, @sd
E: instruction not supported on the this device: FETCH sX, sY.
09F 08080        502                             RETURN
0A0 06D01        503     new_low_address:        SUB             sd, #0x01               ;read lower 8-bits
                 504                             FETCH           s7, @sd
E: instruction not supported on the this device: FETCH sX, sY.
0A1 06D01        505                             SUB             sd, #0x01               ;read middle 8-bits
                 506                             FETCH           s8, @sd
E: instruction not supported on the this device: FETCH sX, sY.
0A2 08080        507                             RETURN
                 508     ;
                 509     ;**************************************************************************************
                 510     ;Read a page from SPI FLASH memory and display
                 511     ;**************************************************************************************
                 512     ;
                 513     ;The start address should be provided in register set [s9,s8,s7].
                 514     ;The display will be next 256 bytes displayed as 16 lines of 16 bytes
                 515     ;with each line commencing with the address of the first byte.
                 516     ;
                 517     ;
0A3 00610        518     send_spi_page:          LOAD            s6, #0x10               ;16 lines to display
0A4 0831D        519     send_spi_line:          CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
0A5 083FD        520                             CALL            send_hex_3bytes         ;display address
W: value out of range: 0x1fd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfd.
0A6 08320        521                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
0A7 00510        522                             LOAD            s5, #0x10               ;16 lines to display
0A8 08320        523     send_spi_byte:          CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
0A9 0834E        524                             CALL            read_spi_byte           ;read byte into s2
W: value out of range: 0x14e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
0AA 04701        525                             ADD             s7, #0x01               ;increment SPI FLASH address
0AB 05800        526                             ADDCY           s8, #0x00
0AC 05900        527                             ADDCY           s9, #0x00
0AD 0C020        528                             LOAD            s0, s2                  ;display byte
0AE 083F7        529                             CALL            send_hex_byte
W: value out of range: 0x1f7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf7.
0AF 06501        530                             SUB             s5, #0x01               ;count bytes per line
0B0 095CE        531                             JUMP            nz, send_spi_byte
0B1 06601        532                             SUB             s6, #0x01               ;count lines
0B2 095CA        533                             JUMP            nz, send_spi_line
0B3 0831D        534                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
0B4 08080        535                             RETURN
                 536     ;
                 537     ;**************************************************************************************
                 538     ;Test of SPI FLASH memory operations
                 539     ;**************************************************************************************
                 540     ;
                 541     ;Sector 18 (120000 to 12FFFF) is used.
                 542     ;A page (123400 to 1234FF) is programmed with a test pattern 00 to FF.
                 543     ;The pattern is verified and then the sector erased and a blank check performed.
                 544     ;
                 545     ;Note that the page used is already blank (all locations contain FF hex)
                 546     ;as with any device supplied (initial delivery state).
                 547     ;
                 548     ;Program page with test pattern
                 549     ;
0B5 00912        550     memory_test:            LOAD            s9, #0x12               ;select page address 123400
0B6 00834        551                             LOAD            s8, #0x34
0B7 00700        552                             LOAD            s7, #0x00
0B8 08381        553                             CALL            open_prog_page_spi      ; program test pattern 00 to FF
W: value out of range: 0x181, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x81.
0B9 0C270        554     pattern_loop:           LOAD            s2, s7
0BA 08312        555                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
0BB 04701        556                             ADD             s7, #0x01
0BC 09DDF        557                             JUMP            nc, pattern_loop
0BD 0838F        558                             CALL            close_prog_page_spi     ; program test pattern 00 to FF
W: value out of range: 0x18f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8f.
                 559     ;
                 560     ;Verify test pattern by reading back page
                 561     ;
0BE 00F70        562                             LOAD            uart_data, #character_p ;p for pass
0BF 00912        563                             LOAD            s9, #0x12               ;select page address 123400
0C0 00834        564                             LOAD            s8, #0x34
0C1 00700        565                             LOAD            s7, #0x00
0C2 0834E        566     verify_test_page:       CALL            read_spi_byte           ;read byte into s2
W: value out of range: 0x14e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
                 567                             COMPARE         s2, s7                  ;check test pattern data value
E: instruction not supported on the this device: COMPARE sX, sY.
0C3 095EE        568                             JUMP            nz, memory_verify_fail
0C4 04701        569                             ADD             s7, #0x01               ;next location
0C5 095E8        570                             JUMP            nz, verify_test_page    ;loop until roll over page
0C6 081EF        571                             JUMP            memory_verify_result
0C7 00F66        572     memory_verify_fail:     LOAD            uart_data, #character_f ;f for fail
0C8 083C1        573     memory_verify_result:   CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
0C9 08080        574                             RETURN
                 575     ;
                 576     ;Erase sector with test pattern and verify blank
                 577     ;
0CA 00912        578     erase_test_sector:      LOAD            s9, #0x12               ;sector 18 start address 120000
0CB 00800        579                             LOAD            s8, #0x00
0CC 00700        580                             LOAD            s7, #0x00
0CD 0835F        581                             CALL            erase_spi_sector
W: value out of range: 0x15f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5f.
0CE 00F70        582                             LOAD            uart_data, #character_p ;p for pass
0CF 00912        583                             LOAD            s9, #0x12               ;select page address 123400
0D0 00834        584                             LOAD            s8, #0x34
0D1 00700        585                             LOAD            s7, #0x00
0D2 0834E        586     verify_blank_page:      CALL            read_spi_byte           ;read byte into s2
W: value out of range: 0x14e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
                 587                             COMPARE         s2, #0xff               ;check blank 'FF'
E: instruction not supported on the this device: COMPARE sX, kk.
0D3 095FF        588                             JUMP            nz, memory_blank_fail
0D4 04701        589                             ADD             s7, #0x01               ;next location
0D5 095F9        590                             JUMP            nz, verify_blank_page   ;loop until roll over page
0D6 08100        591                             JUMP            memory_blank_result
W: value out of range: 0x100, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x0.
0D7 00F66        592     memory_blank_fail:      LOAD            uart_data, #character_f ;f for fail
0D8 083C1        593     memory_blank_result:    CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
0D9 08080        594                             RETURN
                 595     ;
                 596     ;
                 597     ;
                 598     ;**************************************************************************************
                 599     ;Test of SPI FLASH memory communications
                 600     ;**************************************************************************************
                 601     ;Link must be installed in J11 to link ROM-CS to CSO_B
                 602     ;
                 603     ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 604     ;and compare with expected response.
                 605     ;   s9 = Manufacturer Identification = 20 hex
                 606     ;   s8 = Memory Type = 20 hex
                 607     ;   s7 = Memory Capacity = 15 hex
                 608     ;
0DA 0833E        609     memory_comms_test:      CALL            read_spi_flash_id
W: value out of range: 0x13e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x3e.
0DB 00F70        610                             LOAD            uart_data, #character_p ;p for pass
                 611                             COMPARE         s9, #0x20
E: instruction not supported on the this device: COMPARE sX, kk.
0DC 0950B        612                             JUMP            nz, spi_flash_id_fail
W: value out of range: 0x10b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
                 613                             COMPARE         s8, #0x20
E: instruction not supported on the this device: COMPARE sX, kk.
0DD 0950B        614                             JUMP            nz, spi_flash_id_fail
W: value out of range: 0x10b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
                 615                             COMPARE         s7, #0x15
E: instruction not supported on the this device: COMPARE sX, kk.
0DE 0950B        616                             JUMP            nz, spi_flash_id_fail
W: value out of range: 0x10b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
0DF 0810C        617                             JUMP            spi_flash_id_result
W: value out of range: 0x10c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc.
0E0 00F66        618     spi_flash_id_fail:      LOAD            uart_data, #character_f ;f for fail
0E1 083C1        619     spi_flash_id_result:    CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
0E2 08080        620                             RETURN
                 621     ;
                 622     ;
                 623     ;
                 624     ;
                 625     ;
                 626     ;
                 627     ;**************************************************************************************
                 628     ;SPI FLASH memory routines
                 629     ;**************************************************************************************
                 630     ;
                 631     ;These routines will work with two output ports and one input port which should be
                 632     ;defined as follows using CONSTANT directives.
                 633     ;   (replace 'pp' with appropriate port address in each case)
                 634     ;In the list of CONSTANT directives, only the ones marked with a * are really required
                 635     ;in an SPI FLASH memory system. The other directives are to control (disable) or
                 636     ;communicate with the other SPI components on the same SPI bus of the Spartan-3E Starter Kit.
                 637     ;
                 638     ;
                 639     ;
                 640     ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects     *
                 641     ;CONSTANT SPI_sck, 01                ;                  SCK - bit0   *
                 642     ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1   *
                 643     ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
                 644     ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
                 645     ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
                 646     ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
                 647     ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
                 648     ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
                 649     ;
                 650     ;CONSTANT SPI_output_port, pp        ;SPI data output                *
                 651     ;CONSTANT SPI_sdo, 80                ;   SDO - bit7                  *
                 652     ;
                 653     ;CONSTANT SPI_input_port, pp         ;SPI data input                 *
                 654     ;CONSTANT SPI_sdi, 80                ;             SDI - bit7        *
                 655     ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
                 656     ;
                 657     ;
                 658     ;A single scratch pad memory location is also employed to remember the status of
                 659     ;the SPI_control_port. This memory location must be defined as follows.
                 660     ;   (replace 'ss' with appropriate memory location)
                 661     ;
                 662     ;CONSTANT SPI_control_status, ss       ;SPI status signals
                 663     ;
                 664     ;Not all the SPI routines will use this memory location because although they
                 665     ;will change the bits on the control port, they will leave them in the same state
                 666     ;as they were in when they started.
                 667     ;
                 668     ;
                 669     ;
                 670     ;
                 671     ;Initialise SPI bus
                 672     ;
                 673     ;This routine should be used to initialise the SPI bus.
                 674     ;The SCK clock is made low.
                 675     ;Device selections are made inactive as follows
                 676     ;   SPI_sck      = 0      Clock is Low (required)
                 677     ;   SPI_rom_cs   = 1      Deselect ROM
                 678     ;   spare        = 1      spare control bit
                 679     ;   SPI_amp_cs   = 1      Deselect amplifier
                 680     ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
                 681     ;   SPI_dac_cs   = 1      Deselect D/A
                 682     ;   SPI_amp_shdn = 0      Amplifier active and available
                 683     ;   SPI_dac_clr  = 1      D/A clear off
                 684     ;
0E3 000AE        685     spi_init:               LOAD            s0, #0xae               ;normally AE
0E4 0E008        686                             OUTPUT          s0, spi_control_port
                 687                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
0E5 08080        688                             RETURN
                 689     ;
                 690     ;
                 691     ;Send and receive one byte to or from the SPI FLASH memory.
                 692     ;
                 693     ;The data supplied in register 's2' is transmitted to the SPI bus and
                 694     ;at the same time any received byte is used to replace the value in 's2'.
                 695     ;The SCK clock is generated by software and results in a communication rate of
                 696     ;2.5Mbit/s with a 50MHz clock.
                 697     ;
                 698     ;Note that you must have previously selected the required device on the bus
                 699     ;before attempting communication and you must subsequently deselect the device
                 700     ;when appropriate.
                 701     ;
                 702     ;Entry to this routine assumes that SCK is already Low and the clock will be Low
                 703     ;at the end of execution (provided in scratch pad memory location SPI_control_status).
                 704     ;
                 705     ;As a 'master' the signal sequence is as follows..
                 706     ;   Receive data bit from SDI line (Flash transmits on previous falling edge)
                 707     ;   Transmit data bit on SDO line
                 708     ;   Drive SCK transition from low to high
                 709     ;   Drive SCK transition from high to low.
                 710     ;
0E6 00108        711     spi_flash_tx_rx:        LOAD            s1, #0x08               ;8-bits to transmit and receive
                 712                             FETCH           s0, spi_control_status  ;read control status bits
E: instruction not supported on the this device: FETCH sX, ss.
0E7 0E204        713     next_spi_flash_bit:     OUTPUT          s2, spi_output_port     ;output data bit ready to be used on rising edge
0E8 0A302        714                             INPUT           s3, spi_input_port      ;read input bit
                 715                             TEST            s3, #spi_sdi            ;detect state of received bit
E: instruction not supported on the this device: TEST sX, kk.
0E9 0D200        716                             SLA             s2                      ;shift new data into result and move to next transmit bit
0EA 03001        717                             XOR             s0, #spi_sck            ;clock High (bit0)
0EB 0E008        718                             OUTPUT          s0, spi_control_port    ;drive clock High
0EC 03001        719                             XOR             s0, #spi_sck            ;clock Low (bit0)
0ED 0E008        720                             OUTPUT          s0, spi_control_port    ;drive clock Low
0EE 06101        721                             SUB             s1, #0x01               ;count bits
0EF 09514        722                             JUMP            nz, next_spi_flash_bit  ;repeat until finished
W: value out of range: 0x114, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x14.
0F0 08080        723                             RETURN
                 724     ;
                 725     ;
                 726     ;Read status register from SPI FLASH memory (ST type M25P16)
                 727     ;
                 728     ;Transmits instruction 05hex and then receives one byte in response
                 729     ;which is returned in register s2.
                 730     ;
                 731     ; bit    meaning
                 732     ;  7    SRWD Status Register Write Protect
                 733     ;  6    '0'
                 734     ;  5    '0'
                 735     ;  4    BP2 Block protect bit
                 736     ;  3    BP1 Block protect bit
                 737     ;  2    BP0 Block protect bit
                 738     ;  1    WEL Write Enable Latch Bit
                 739     ;  0    WIP Write In Progress
                 740     ;
                 741     ;
0F1 0830E        742     read_spi_flash_status:  CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0F2 03002        743                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
0F3 0E008        744                             OUTPUT          s0, spi_control_port
                 745                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
0F4 00205        746                             LOAD            s2, #0x05               ;Read Status register instruction
0F5 08312        747                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
0F6 08312        748                             CALL            spi_flash_tx_rx         ;Receive status register information
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
0F7 03002        749                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
0F8 0E008        750                             OUTPUT          s0, spi_control_port
                 751                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
0F9 08080        752                             RETURN
                 753     ;
                 754     ;Set write enable mode in SPI FLASH memory (ST type M25P16)
                 755     ;
                 756     ;Transmits instruction 06hex.
                 757     ;
0FA 0830E        758     set_spi_flash_wren:     CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0FB 03002        759                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
0FC 0E008        760                             OUTPUT          s0, spi_control_port
                 761                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
0FD 00206        762                             LOAD            s2, #0x06               ;Set write enable mode instruction
0FE 08312        763                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
0FF 03002        764                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
100 0E008        765                             OUTPUT          s0, spi_control_port
                 766                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
101 08080        767                             RETURN
                 768     ;
                 769     ;Reset the write enable mode in SPI FLASH memory (ST type M25P16)
                 770     ;
                 771     ;Transmits instruction 04hex.
                 772     ;
102 0830E        773     reset_spi_flash_wren:   CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
103 03002        774                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
104 0E008        775                             OUTPUT          s0, spi_control_port
                 776                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
105 00204        777                             LOAD            s2, #0x04               ;Reset write enable mode instruction
106 08312        778                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
107 03002        779                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
108 0E008        780                             OUTPUT          s0, spi_control_port
                 781                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
109 08080        782                             RETURN
                 783     ;
                 784     ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 785     ;
                 786     ;Transmits instruction 9Fhex and then reads the 3 byte response into [s9,s8,s7]
                 787     ;
                 788     ;response should be
                 789     ;   s9 = Manufacturer Identification = 20 hex
                 790     ;   s8 = Memory Type = 20 hex
                 791     ;   s7 = Memory Capacity = 15 hex
                 792     ;
10A 0830E        793     read_spi_flash_id:      CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
10B 03002        794                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
10C 0E008        795                             OUTPUT          s0, spi_control_port
                 796                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
10D 0029F        797                             LOAD            s2, #0x9f               ;Read ID instruction
10E 08312        798                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
10F 08312        799                             CALL            spi_flash_tx_rx         ;receive Manufacturer ID
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
110 0C920        800                             LOAD            s9, s2
111 08312        801                             CALL            spi_flash_tx_rx         ;receive Memory Type
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
112 0C820        802                             LOAD            s8, s2
113 08312        803                             CALL            spi_flash_tx_rx         ;receive Memory Capacity
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
114 0C720        804                             LOAD            s7, s2
115 03002        805                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
116 0E008        806                             OUTPUT          s0, spi_control_port
                 807                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
117 08080        808                             RETURN
                 809     ;
                 810     ;Read a single byte from the SPI FLASH memory (ST type M25P16)
                 811     ;
                 812     ;Transmits instruction 03hex followed by a 24-bit address which must be supplied in the
                 813     ;register set [s9,s8,s7]. It then transmits a dummy byte to retrieve the memory data
                 814     ;which is returned in register s2.
                 815     ;
118 0830E        816     read_spi_byte:          CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
119 03002        817                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
11A 0E008        818                             OUTPUT          s0, spi_control_port
                 819                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
11B 00203        820                             LOAD            s2, #0x03               ;Read Data Bytes instruction
11C 08312        821                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
11D 0C290        822                             LOAD            s2, s9                  ;Transmit 24-bit address
11E 08312        823                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
11F 0C280        824                             LOAD            s2, s8
120 08312        825                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
121 0C270        826                             LOAD            s2, s7
122 08312        827                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
123 08312        828                             CALL            spi_flash_tx_rx         ;read data byte
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
124 03002        829                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
125 0E008        830                             OUTPUT          s0, spi_control_port
                 831                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
126 08080        832                             RETURN
                 833     ;
                 834     ;
                 835     ;Erase a single sector from the SPI FLASH memory (ST type M25P16)
                 836     ;
                 837     ;Sets the WREN instruction and then transmits instruction D8 hex followed by a 24-bit
                 838     ;address which must be supplied in the register set [s9,s8,s7]. The address must be
                 839     ;at some location within the sector to be erased. A sector erase can take up to
                 840     ;3 seconds to complete. The routine therefore reads the FLASH status and tests
                 841     ;the write in progress (WIP) bit to test for completion
                 842     ;
127 0832A        843     erase_spi_sector:       CALL            set_spi_flash_wren      ;set write enable mode
W: value out of range: 0x12a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2a.
128 0830E        844                             CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
129 03002        845                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
12A 0E008        846                             OUTPUT          s0, spi_control_port
                 847                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
12B 002D8        848                             LOAD            s2, #0xd8               ;Sector erase mode
12C 08312        849                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
12D 0C290        850                             LOAD            s2, s9                  ;Transmit 24-bit address [s9,s8,s7].
12E 08312        851                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
12F 0C280        852                             LOAD            s2, s8
130 08312        853                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
131 0C270        854                             LOAD            s2, s7
132 08312        855                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
133 03002        856                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
134 0E008        857                             OUTPUT          s0, spi_control_port
                 858                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
135 0831F        859     sector_erase_wait:      CALL            read_spi_flash_status   ;test WIP bit until finished
W: value out of range: 0x11f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1f.
                 860                             TEST            s2, #0x01
E: instruction not supported on the this device: TEST sX, kk.
136 0956F        861                             JUMP            nz, sector_erase_wait
W: value out of range: 0x16f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
137 08080        862                             RETURN
                 863     ;
                 864     ;
                 865     ;
                 866     ;Bulk erase the whole SPI FLASH memory (ST type M25P16)
                 867     ;
                 868     ;Sets the WREN instruction and then transmits instruction C7 hex.
                 869     ;A bulk erase can take up to 40 seconds to complete. The routine therefore reads the
                 870     ;FLASH status and tests the write in progress (WIP) bit to test for completion
                 871     ;
138 0832A        872     bulk_erase_spi:         CALL            set_spi_flash_wren      ;set write enable mode
W: value out of range: 0x12a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2a.
139 0830E        873                             CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
13A 03002        874                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
13B 0E008        875                             OUTPUT          s0, spi_control_port
                 876                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
13C 002C7        877                             LOAD            s2, #0xc7               ;Sector erase mode
13D 08312        878                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
13E 03002        879                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
13F 0E008        880                             OUTPUT          s0, spi_control_port
                 881                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
140 0831F        882     bulk_erase_wait:        CALL            read_spi_flash_status   ;test WIP bit until finished
W: value out of range: 0x11f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1f.
                 883                             TEST            s2, #0x01
E: instruction not supported on the this device: TEST sX, kk.
141 0957D        884                             JUMP            nz, bulk_erase_wait
W: value out of range: 0x17d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7d.
142 08080        885                             RETURN
                 886     ;
                 887     ;
                 888     ;
                 889     ;Open a page for programming.
                 890     ;The 24-bit start address to be supplied in the register set [s9,s8,s7].
                 891     ;Note that s7=00 hex for normal page boundaries but you could start at any address.
                 892     ;Caution : Exceeding s7=FF hex will result in the roll over to 00 hex but without
                 893     ;incrementing to the next page.
                 894     ;
                 895     ;Transmits instruction 02hex followed by the 24-bit start address.
                 896     ;It is then ready to transmit data bytes using the s2 register and the SPI_FLASH_tx_rx
                 897     ;subroutine. After transmitting bytes, close the page with the close_prog_page_spi
                 898     ;routine.
                 899     ;
143 0832A        900     open_prog_page_spi:     CALL            set_spi_flash_wren      ;set write enable mode
W: value out of range: 0x12a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2a.
144 0830E        901                             CALL            spi_init                ;ensure known state of bus and s0 register
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
145 03002        902                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
146 0E008        903                             OUTPUT          s0, spi_control_port
                 904                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
147 00202        905                             LOAD            s2, #0x02               ;Page program mode
148 08312        906                             CALL            spi_flash_tx_rx         ;transmit instruction
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
149 0C290        907                             LOAD            s2, s9                  ;Transmit 24-bit address [s9,s8,s7].
14A 08312        908                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
14B 0C280        909                             LOAD            s2, s8
14C 08312        910                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
14D 0C270        911                             LOAD            s2, s7
14E 08312        912                             CALL            spi_flash_tx_rx
W: value out of range: 0x112, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x12.
14F 08080        913                             RETURN
                 914     ;
                 915     ;
                 916     ;This routine completes a page program operation started with
                 917     ;open_prog_page_spi and data bytes sent with SPI_FLASH_tx_rx.
                 918     ;
                 919     ;A page program can take up to 5ms to complete. The routine therefore reads the
                 920     ;FLASH status and tests the write in progress (WIP) bit to test for completion
                 921     ;
                 922     ;
  0018F          923     close_prog_page_spi:    FETCH           s0, spi_control_status  ;read control status bits
E: instruction not supported on the this device: FETCH sX, ss.
150 03002        924                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
151 0E008        925                             OUTPUT          s0, spi_control_port
                 926                             STORE           s0, spi_control_status  ;preserve status
E: instruction not supported on the this device: STORE sX, ss.
152 0831F        927     page_prog_wait:         CALL            read_spi_flash_status   ;test WIP bit until finished
W: value out of range: 0x11f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1f.
                 928                             TEST            s2, #0x01
E: instruction not supported on the this device: TEST sX, kk.
153 09593        929                             JUMP            nz, page_prog_wait
W: value out of range: 0x193, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x93.
154 08080        930                             RETURN
                 931     ;
                 932     ;**************************************************************************************
                 933     ;Software delay routines
                 934     ;**************************************************************************************
                 935     ;
                 936     ;
                 937     ;
                 938     ;Delay of 1us.
                 939     ;
                 940     ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                 941     ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                 942     ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                 943     ;
                 944     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 945     ;
                 946     ;Registers used s0
                 947     ;
155 0000B        948     delay_1us:              LOAD            s0, #delay_1us_constant
156 06001        949     wait_1us:               SUB             s0, #0x01
157 09598        950                             JUMP            nz, wait_1us
W: value out of range: 0x198, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x98.
158 08080        951                             RETURN
                 952     ;
                 953     ;Delay of 40us.
                 954     ;
                 955     ;Registers used s0, s1
                 956     ;
159 00128        957     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
15A 08397        958     wait_40us:              CALL            delay_1us
W: value out of range: 0x197, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x97.
15B 06101        959                             SUB             s1, #0x01
15C 0959C        960                             JUMP            nz, wait_40us
W: value out of range: 0x19c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9c.
15D 08080        961                             RETURN
                 962     ;
                 963     ;
                 964     ;Delay of 1ms.
                 965     ;
                 966     ;Registers used s0, s1, s2
                 967     ;
15E 00219        968     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
15F 0839B        969     wait_1ms:               CALL            delay_40us
W: value out of range: 0x19b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9b.
160 06201        970                             SUB             s2, #0x01
161 095A1        971                             JUMP            nz, wait_1ms
W: value out of range: 0x1a1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa1.
162 08080        972                             RETURN
                 973     ;
                 974     ;Delay of 20ms.
                 975     ;
                 976     ;Delay of 20ms used during initialisation.
                 977     ;
                 978     ;Registers used s0, s1, s2, s3
                 979     ;
163 00314        980     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
164 083A0        981     wait_20ms:              CALL            delay_1ms
W: value out of range: 0x1a0, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa0.
165 06301        982                             SUB             s3, #0x01
166 095A6        983                             JUMP            nz, wait_20ms
W: value out of range: 0x1a6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa6.
167 08080        984                             RETURN
                 985     ;
                 986     ;Delay of approximately 1 second.
                 987     ;
                 988     ;Registers used s0, s1, s2, s3, s4
                 989     ;
168 00414        990     delay_1s:               LOAD            s4, #0x14               ;50 x 20ms = 1000ms
169 083A5        991     wait_1s:                CALL            delay_20ms
W: value out of range: 0x1a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
16A 06401        992                             SUB             s4, #0x01
16B 095AB        993                             JUMP            nz, wait_1s
W: value out of range: 0x1ab, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xab.
16C 08080        994                             RETURN
                 995     ;
                 996     ;**************************************************************************************
                 997     ;UART communication routines
                 998     ;**************************************************************************************
                 999     ;
                1000     ;Read one character from the UART
                1001     ;
                1002     ;Character read will be returned in a register called 'UART_data'.
                1003     ;
                1004     ;The routine first tests the receiver FIFO buffer to see if data is present.
                1005     ;If the FIFO is empty, the routine waits until there is a character to read.
                1006     ;As this could take any amount of time the wait loop could include a call to a
                1007     ;subroutine which performs a useful function.
                1008     ;
                1009     ;If the received character is an XOFF, then the routine will then wait
                1010     ;for an XON to be received. This means that the rest of the program is held
                1011     ;in suspense and therefore it can not transmit. Once an XON is received, it will
                1012     ;again wait for a normal character before returning.
                1013     ;
                1014     ;NOTE: Characters between the XOFF and XON will be ignored in this version of the
                1015     ;program!!!
                1016     ;
                1017     ;Interrupt is disabled during this routine to prevent a false situation. If the
                1018     ;receiver half-full flag went High it should result in an interrupt transmitting
                1019     ;an XOFF character. However, if this routine were able to read the receiver buffer
                1020     ;at just about the same as the hardware detects the half-full flag, then it could
                1021     ;think that an XON needs to be transmitted.
                1022     ;
                1023     ;
                1024     ;Registers used s0 and UART_data
                1025     ;
16D 08010       1026     read_from_uart:         DISABLE         interrupt
16E 0A000       1027     wait_rx_character:      INPUT           s0, status_port         ;test Rx_FIFO buffer
                1028                             TEST            s0, #rx_data_present
E: instruction not supported on the this device: TEST sX, kk.
16F 095B4       1029                             JUMP            nz, read_character
W: value out of range: 0x1b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
170 081B0       1030                             JUMP            wait_rx_character
W: value out of range: 0x1b0, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb0.
171 0AF01       1031     read_character:         INPUT           uart_data, uart_read_port ;read from FIFO
                1032                             COMPARE         uart_data, #character_xoff ;test for XOFF
E: instruction not supported on the this device: COMPARE sX, kk.
172 091B9       1033                             JUMP            z, wait_xon
W: value out of range: 0x1b9, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb9.
173 08030       1034                             ENABLE          interrupt               ;normal finish
174 08080       1035                             RETURN
175 0A000       1036     wait_xon:               INPUT           s0, status_port         ;test Rx_FIFO buffer
                1037                             TEST            s0, #rx_data_present
E: instruction not supported on the this device: TEST sX, kk.
176 095BD       1038                             JUMP            nz, read_xon
W: value out of range: 0x1bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
177 081B9       1039                             JUMP            wait_xon
W: value out of range: 0x1b9, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb9.
178 0AF01       1040     read_xon:               INPUT           uart_data, uart_read_port ;read from FIFO
                1041                             COMPARE         uart_data, #character_xon ;test for XON
E: instruction not supported on the this device: COMPARE sX, kk.
179 091B0       1042                             JUMP            z, wait_rx_character    ;now wait for normal character
W: value out of range: 0x1b0, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb0.
17A 081B9       1043                             JUMP            wait_xon                ;continue to wait for XON
W: value out of range: 0x1b9, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb9.
                1044     ;
                1045     ;
                1046     ;
                1047     ;Transmit one character to the UART
                1048     ;
                1049     ;Character supplied in register called 'UART_data'.
                1050     ;
                1051     ;The routine first tests the transmit FIFO buffer is empty.
                1052     ;If the FIFO currently has any data, the routine waits until it is empty.
                1053     ;Ultimately this means that only one character is sent at a time which
                1054     ;could be important if the PC at the other end of the link transmits
                1055     ;an XOFF and needs the flow of data to terminate as soon as possible.
                1056     ;
                1057     ;Registers used s0
                1058     ;
17B 0A000       1059     send_to_uart:           INPUT           s0, status_port         ;test Tx_FIFO buffer
                1060                             TEST            s0, #tx_data_present
E: instruction not supported on the this device: TEST sX, kk.
17C 091C5       1061                             JUMP            z, uart_write
W: value out of range: 0x1c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
17D 081C1       1062                             JUMP            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
17E 0EF10       1063     uart_write:             OUTPUT          uart_data, uart_write_port
17F 08080       1064                             RETURN
                1065     ;
                1066     ;Convert value provided in register s0 into ASCII characters
                1067     ;
                1068     ;The value provided must in the range 0 to 99 and will be converted into
                1069     ;two ASCII characters.
                1070     ;     The number of 'tens' will be represented by an ASCII character returned in register s1.
                1071     ;     The number of 'units' will be represented by an ASCII character returned in register s0.
                1072     ;
                1073     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
                1074     ;the actual decimal value.
                1075     ;
                1076     ;Registers used s0 and s1.
                1077     ;
180 00130       1078     decimal_to_ascii:       LOAD            s1, #0x30               ;load 'tens' counter with ASCII for '0'
181 04101       1079     test_for_ten:           ADD             s1, #0x01               ;increment 'tens' value
182 0600A       1080                             SUB             s0, #0x0a               ;try to subtract 10 from the supplied value
183 09DC8       1081                             JUMP            nc, test_for_ten        ;repeat if subtraction was possible without underflow.
W: value out of range: 0x1c8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc8.
184 06101       1082                             SUB             s1, #0x01               ;'tens' value one less ten due to underflow
185 0403A       1083                             ADD             s0, #0x3a               ;restore units value (the remainder) and convert to ASCII
186 08080       1084                             RETURN
                1085     ;
                1086     ;
                1087     ;
                1088     ;Convert character to upper case
                1089     ;
                1090     ;The character supplied in register s0.
                1091     ;If the character is in the range 'a' to 'z', it is converted
                1092     ;to the equivalent upper case character in the range 'A' to 'Z'.
                1093     ;All other characters remain unchanged.
                1094     ;
                1095     ;Registers used s0.
                1096     ;
  001CE         1097     upper_case:             COMPARE         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
E: instruction not supported on the this device: COMPARE sX, kk.
187 09880       1098                             RETURN          c
                1099                             COMPARE         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
E: instruction not supported on the this device: COMPARE sX, kk.
188 09C80       1100                             RETURN          nc
189 010DF       1101                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
18A 08080       1102                             RETURN
                1103     ;
                1104     ;
                1105     ;Convert character '0' to '9' to numerical value in range 0 to 9
                1106     ;
                1107     ;The character supplied in register s0. If the character is in the
                1108     ;range '0' to '9', it is converted to the equivalent decimal value.
                1109     ;Characters not in the range '0' to '9' are signified by the return
                1110     ;with the CARRY flag set.
                1111     ;
                1112     ;Registers used s0.
                1113     ;
18B 040C6       1114     _1char_to_value:        ADD             s0, #0xc6               ;reject character codes above '9' (39 hex)
18C 09880       1115                             RETURN          c                       ;carry flag is set
18D 060F6       1116                             SUB             s0, #0xf6               ;reject character codes below '0' (30 hex)
18E 08080       1117                             RETURN                                  ;carry is set if value not in range
                1118     ;
                1119     ;
                1120     ;Determine the numerical value of a two character decimal string held in
                1121     ;scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
                1122     ;
                1123     ;The string must be stored in two consecutive memory locations and the
                1124     ;location of the first (tens) character supplied in the s1 register.
                1125     ;The result is provided in register s2. Strings not using characters in the
                1126     ;range '0' to '9' are signified by the return with the CARRY flag set.
                1127     ;
                1128     ;Registers used s0, s1 and s2.
                1129     ;
  001D8         1130     _2char_to_value:        FETCH           s0, @s1                 ;read 'tens' character
E: instruction not supported on the this device: FETCH sX, sY.
18F 083D4       1131                             CALL            _1char_to_value         ;convert to numerical value
W: value out of range: 0x1d4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd4.
190 09880       1132                             RETURN          c                       ;bad character - CARRY set
191 0C200       1133                             LOAD            s2, s0
192 0D206       1134                             SL0             s2                      ;multiply 'tens' value by 10 (0A hex)
193 0D206       1135                             SL0             s2
194 0C204       1136                             ADD             s2, s0
195 0D206       1137                             SL0             s2
196 04101       1138                             ADD             s1, #0x01               ;read 'units' character
                1139                             FETCH           s0, @s1
E: instruction not supported on the this device: FETCH sX, sY.
197 083D4       1140                             CALL            _1char_to_value         ;convert to numerical value
W: value out of range: 0x1d4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd4.
198 09880       1141                             RETURN          c                       ;bad character - CARRY set
199 0C204       1142                             ADD             s2, s0                  ;add units to result and clear CARRY flag
19A 08080       1143                             RETURN
                1144     ;
                1145     ;
                1146     ;Convert hexadecimal value provided in register s0 into ASCII characters
                1147     ;
                1148     ;The value provided must can be any value in the range 00 to FF and will be converted into
                1149     ;two ASCII characters.
                1150     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1151     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1152     ;
                1153     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1154     ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1155     ;hexadecimal requiring a further addition of 07 to the 30 already added.
                1156     ;
                1157     ;Registers used s0, s1 and s2.
                1158     ;
19B 0C100       1159     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
19C 0D00E       1160                             SR0             s0                      ;isolate upper nibble
19D 0D00E       1161                             SR0             s0
19E 0D00E       1162                             SR0             s0
19F 0D00E       1163                             SR0             s0
1A0 083F2       1164                             CALL            hex_to_ascii            ;convert
W: value out of range: 0x1f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
1A1 0C200       1165                             LOAD            s2, s0                  ;upper nibble value in s2
1A2 0C010       1166                             LOAD            s0, s1                  ;restore complete value
1A3 0100F       1167                             AND             s0, #0x0f               ;isolate lower nibble
1A4 083F2       1168                             CALL            hex_to_ascii            ;convert
W: value out of range: 0x1f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
1A5 0C100       1169                             LOAD            s1, s0                  ;lower nibble value in s1
1A6 08080       1170                             RETURN
                1171     ;
                1172     ;Convert hexadecimal value provided in register s0 into ASCII character
                1173     ;
                1174     ;Register used s0
                1175     ;
1A7 0600A       1176     hex_to_ascii:           SUB             s0, #0x0a               ;test if value is in range 0 to 9
1A8 099F5       1177                             JUMP            c, number_char
W: value out of range: 0x1f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
1A9 04007       1178                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
1AA 0403A       1179     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
1AB 08080       1180                             RETURN
                1181     ;
                1182     ;
                1183     ;Send the two character HEX value of the register contents 's0' to the UART
                1184     ;
                1185     ;Registers used s0, s1, s2
                1186     ;
1AC 083E6       1187     send_hex_byte:          CALL            hex_byte_to_ascii
W: value out of range: 0x1e6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe6.
1AD 0CF20       1188                             LOAD            uart_data, s2
1AE 083C1       1189                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1AF 0CF10       1190                             LOAD            uart_data, s1
1B0 083C1       1191                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1B1 08080       1192                             RETURN
                1193     ;
                1194     ;
                1195     ;
                1196     ;Send the six character HEX value of the register contents [s9,s8,s7] to the UART
                1197     ;
                1198     ;Registers used s0, s1, s2
                1199     ;
1B2 0C090       1200     send_hex_3bytes:        LOAD            s0, s9
1B3 083F7       1201                             CALL            send_hex_byte
W: value out of range: 0x1f7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf7.
1B4 0C080       1202                             LOAD            s0, s8
1B5 083F7       1203                             CALL            send_hex_byte
W: value out of range: 0x1f7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf7.
1B6 0C070       1204                             LOAD            s0, s7
1B7 083F7       1205                             CALL            send_hex_byte
W: value out of range: 0x1f7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf7.
1B8 08080       1206                             RETURN
                1207     ;
                1208     ;
                1209     ;Convert the HEX ASCII characters contained in 's3' and 's2' into
                1210     ;an equivalent hexadecimal value in register 's0'.
                1211     ;     The upper nibble is represented by an ASCII character in register s3.
                1212     ;     The lower nibble is represented by an ASCII character in register s2.
                1213     ;
                1214     ;Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1215     ;will be set on return.
                1216     ;
                1217     ;Registers used s0, s2 and s3.
                1218     ;
1B9 0C030       1219     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
1BA 08311       1220                             CALL            ascii_to_hex            ;convert to value
W: value out of range: 0x211, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x11.
1BB 09880       1221                             RETURN          c                       ;reject if out of range
1BC 0C300       1222                             LOAD            s3, s0                  ;remember value
1BD 0D306       1223                             SL0             s3                      ;multiply value by 16 to put in upper nibble
1BE 0D306       1224                             SL0             s3
1BF 0D306       1225                             SL0             s3
1C0 0D306       1226                             SL0             s3
1C1 0C020       1227                             LOAD            s0, s2                  ;Take lower nibble
1C2 08311       1228                             CALL            ascii_to_hex            ;convert to value
W: value out of range: 0x211, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x11.
1C3 09880       1229                             RETURN          c                       ;reject if out of range
1C4 0C032       1230                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
1C5 08080       1231                             RETURN
                1232     ;
                1233     ;
                1234     ;Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1235     ;
                1236     ;If character is not valid for hex, then CARRY is set on return.
                1237     ;
                1238     ;Register used s0
                1239     ;
1C6 040B9       1240     ascii_to_hex:           ADD             s0, #0xb9               ;test for above ASCII code 46 ('F')
1C7 09880       1241                             RETURN          c
1C8 060E9       1242                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
1C9 09880       1243                             RETURN          c                       ;reject below ASCII code 30 ('0')
1CA 06011       1244                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
1CB 09D1B       1245                             JUMP            nc, ascii_letter
W: value out of range: 0x21b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1b.
1CC 04007       1246                             ADD             s0, #0x07               ;test for above ASCII code 46 ('F')
1CD 09880       1247                             RETURN          c
1CE 060F6       1248                             SUB             s0, #0xf6               ;convert to range 00 to 09
1CF 08080       1249                             RETURN
1D0 0400A       1250     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
1D1 08080       1251                             RETURN
                1252     ;
                1253     ;
                1254     ;
                1255     ;Send Carriage Return to the UART
                1256     ;
1D2 00F0D       1257     send_cr:                LOAD            uart_data, #character_cr
1D3 083C1       1258                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1D4 08080       1259                             RETURN
                1260     ;
                1261     ;Send a space to the UART
                1262     ;
1D5 00F20       1263     send_space:             LOAD            uart_data, #character_space
1D6 083C1       1264                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1D7 08080       1265                             RETURN
                1266     ;
                1267     ;
                1268     ;**************************************************************************************
                1269     ;Text messages
                1270     ;**************************************************************************************
                1271     ;
                1272     ;
                1273     ;Send 'PicoBlaze SPI FLASH Programmer' string to the UART
                1274     ;
1D8 0831D       1275     send_welcome:           CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
1D9 0831D       1276                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
1DA 00F50       1277                             LOAD            uart_data, #_character_p
1DB 083C1       1278                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1DC 00F69       1279                             LOAD            uart_data, #character_i
1DD 083C1       1280                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1DE 00F63       1281                             LOAD            uart_data, #character_c
1DF 083C1       1282                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1E0 00F6F       1283                             LOAD            uart_data, #character_o
1E1 083C1       1284                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1E2 00F42       1285                             LOAD            uart_data, #_character_b
1E3 083C1       1286                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1E4 00F6C       1287                             LOAD            uart_data, #character_l
1E5 083C1       1288                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1E6 00F61       1289                             LOAD            uart_data, #character_a
1E7 083C1       1290                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1E8 00F7A       1291                             LOAD            uart_data, #character_z
1E9 083C1       1292                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1EA 00F65       1293                             LOAD            uart_data, #character_e
1EB 083C1       1294                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1EC 08320       1295                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
1ED 00F53       1296                             LOAD            uart_data, #_character_s
1EE 083C1       1297                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1EF 00F50       1298                             LOAD            uart_data, #_character_p
1F0 083C1       1299                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1F1 00F49       1300                             LOAD            uart_data, #_character_i
1F2 083C1       1301                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1F3 08320       1302                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
1F4 00F46       1303                             LOAD            uart_data, #_character_f
1F5 083C1       1304                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1F6 00F4C       1305                             LOAD            uart_data, #_character_l
1F7 083C1       1306                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1F8 00F41       1307                             LOAD            uart_data, #_character_a
1F9 083C1       1308                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1FA 00F53       1309                             LOAD            uart_data, #_character_s
1FB 083C1       1310                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1FC 00F48       1311                             LOAD            uart_data, #_character_h
1FD 083C1       1312                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
1FE 08320       1313                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
1FF 00F50       1314                             LOAD            uart_data, #_character_p
200 083C1       1315                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
201 00F72       1316                             LOAD            uart_data, #character_r
202 083C1       1317                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
203 00F6F       1318                             LOAD            uart_data, #character_o
204 083C1       1319                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
205 00F67       1320                             LOAD            uart_data, #character_g
206 083C1       1321                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
207 00F72       1322                             LOAD            uart_data, #character_r
208 083C1       1323                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
209 00F61       1324                             LOAD            uart_data, #character_a
20A 083C1       1325                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
20B 00F6D       1326                             LOAD            uart_data, #character_m
20C 083C1       1327                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
20D 00F6D       1328                             LOAD            uart_data, #character_m
20E 083C1       1329                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
20F 00F65       1330                             LOAD            uart_data, #character_e
210 083C1       1331                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
211 00F72       1332                             LOAD            uart_data, #character_r
212 083C1       1333                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
213 08320       1334                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
214 00F76       1335                             LOAD            uart_data, #character_v
215 083C1       1336                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
216 00F31       1337                             LOAD            uart_data, #character_1
217 083C1       1338                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
218 00F2E       1339                             LOAD            uart_data, #character_fullstop
219 083C1       1340                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
21A 00F30       1341                             LOAD            uart_data, #character_0
21B 083C1       1342                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
21C 00F30       1343                             LOAD            uart_data, #character_0
21D 083C1       1344                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
21E 0831D       1345                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
21F 0831D       1346                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
220 08080       1347                             RETURN
                1348     ;
                1349     ;
                1350     ;
                1351     ;Send 'Waiting_MCS_file' string to the UART
                1352     ;
221 00F57       1353     send_waiting_mcs_file:  LOAD            uart_data, #_character_w
222 083C1       1354                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
223 00F61       1355                             LOAD            uart_data, #character_a
224 083C1       1356                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
225 00F69       1357                             LOAD            uart_data, #character_i
226 083C1       1358                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
227 00F74       1359                             LOAD            uart_data, #character_t
228 083C1       1360                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
229 00F69       1361                             LOAD            uart_data, #character_i
22A 083C1       1362                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
22B 00F6E       1363                             LOAD            uart_data, #character_n
22C 083C1       1364                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
22D 00F67       1365                             LOAD            uart_data, #character_g
22E 083C1       1366                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
22F 08320       1367                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
230 00F66       1368                             LOAD            uart_data, #character_f
231 083C1       1369                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
232 00F6F       1370                             LOAD            uart_data, #character_o
233 083C1       1371                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
234 00F72       1372                             LOAD            uart_data, #character_r
235 083C1       1373                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
236 08320       1374     send_mcs_file:          CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
237 00F4D       1375                             LOAD            uart_data, #_character_m
238 083C1       1376                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
239 00F43       1377                             LOAD            uart_data, #_character_c
23A 083C1       1378                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
23B 00F53       1379                             LOAD            uart_data, #_character_s
23C 083C1       1380                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
23D 08320       1381                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
23E 00F46       1382                             LOAD            uart_data, #_character_f
23F 083C1       1383                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
240 00F69       1384                             LOAD            uart_data, #character_i
241 083C1       1385                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
242 00F6C       1386                             LOAD            uart_data, #character_l
243 083C1       1387                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
244 00F65       1388                             LOAD            uart_data, #character_e
245 083C1       1389                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
246 0831D       1390                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
247 08080       1391                             RETURN
                1392     ;
                1393     ;
                1394     ;Send 'Erase in progress' string to the UART
                1395     ;
248 083AA       1396     send_erase_in_progress: CALL            send_erase
W: value out of range: 0x2aa, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaa.
249 00F69       1397                             LOAD            uart_data, #character_i
24A 083C1       1398                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
24B 00F6E       1399                             LOAD            uart_data, #character_n
24C 083C1       1400                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
24D 08320       1401                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
24E 00F50       1402                             LOAD            uart_data, #_character_p
24F 083C1       1403                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
250 00F72       1404                             LOAD            uart_data, #character_r
251 083C1       1405                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
252 00F6F       1406                             LOAD            uart_data, #character_o
253 083C1       1407                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
254 00F67       1408                             LOAD            uart_data, #character_g
255 083C1       1409                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
256 00F72       1410                             LOAD            uart_data, #character_r
257 083C1       1411                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
258 00F65       1412                             LOAD            uart_data, #character_e
259 083C1       1413                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
25A 00F73       1414                             LOAD            uart_data, #character_s
25B 083C1       1415                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
25C 083C1       1416                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
25D 0831D       1417                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
25E 08080       1418                             RETURN
                1419     ;
                1420     ;
                1421     ;Send 'Erase ' string to the UART
                1422     ;
25F 00F45       1423     send_erase:             LOAD            uart_data, #_character_e
260 083C1       1424                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
261 00F72       1425                             LOAD            uart_data, #character_r
262 083C1       1426                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
263 00F61       1427                             LOAD            uart_data, #character_a
264 083C1       1428                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
265 00F73       1429                             LOAD            uart_data, #character_s
266 083C1       1430                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
267 00F65       1431                             LOAD            uart_data, #character_e
268 083C1       1432                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
269 08320       1433                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
26A 08080       1434                             RETURN
                1435     ;
                1436     ;
                1437     ;Send carriage return, 'OK' and carriage return to the UART
                1438     ;
26B 0831D       1439     send_ok:                CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
26C 00F4F       1440                             LOAD            uart_data, #_character_o
26D 083C1       1441                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
26E 00F4B       1442                             LOAD            uart_data, #_character_k
26F 083C1       1443                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
270 0831D       1444                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
271 08080       1445                             RETURN
                1446     ;
                1447     ;
                1448     ;
                1449     ;Send menu to the UART
                1450     ;
272 0831D       1451     send_menu:              CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
273 00F45       1452                             LOAD            uart_data, #_character_e
274 083C1       1453                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
275 00F2D       1454                             LOAD            uart_data, #character_minus
276 083C1       1455                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
277 083AA       1456                             CALL            send_erase
W: value out of range: 0x2aa, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaa.
278 00F61       1457                             LOAD            uart_data, #character_a
279 083C1       1458                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
27A 00F6C       1459                             LOAD            uart_data, #character_l
27B 083C1       1460                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
27C 083C1       1461                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
27D 0831D       1462                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
27E 00F53       1463                             LOAD            uart_data, #_character_s
27F 083C1       1464                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
280 00F2D       1465                             LOAD            uart_data, #character_minus
281 083C1       1466                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
282 00F53       1467                             LOAD            uart_data, #_character_s
283 083C1       1468                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
284 00F65       1469                             LOAD            uart_data, #character_e
285 083C1       1470                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
286 00F63       1471                             LOAD            uart_data, #character_c
287 083C1       1472                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
288 00F74       1473                             LOAD            uart_data, #character_t
289 083C1       1474                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
28A 00F6F       1475                             LOAD            uart_data, #character_o
28B 083C1       1476                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
28C 00F72       1477                             LOAD            uart_data, #character_r
28D 083C1       1478                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
28E 08320       1479                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
28F 083AA       1480                             CALL            send_erase
W: value out of range: 0x2aa, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaa.
290 0831D       1481                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
291 00F50       1482                             LOAD            uart_data, #_character_p
292 083C1       1483                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
293 00F2D       1484                             LOAD            uart_data, #character_minus
294 083C1       1485                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
295 00F50       1486                             LOAD            uart_data, #_character_p
296 083C1       1487                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
297 00F72       1488                             LOAD            uart_data, #character_r
298 083C1       1489                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
299 00F6F       1490                             LOAD            uart_data, #character_o
29A 083C1       1491                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
29B 00F67       1492                             LOAD            uart_data, #character_g
29C 083C1       1493                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
29D 00F72       1494                             LOAD            uart_data, #character_r
29E 083C1       1495                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
29F 00F61       1496                             LOAD            uart_data, #character_a
2A0 083C1       1497                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2A1 00F6D       1498                             LOAD            uart_data, #character_m
2A2 083C1       1499                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2A3 08381       1500                             CALL            send_mcs_file
W: value out of range: 0x281, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x81.
2A4 00F52       1501                             LOAD            uart_data, #_character_r
2A5 083C1       1502                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2A6 00F2D       1503                             LOAD            uart_data, #character_minus
2A7 083C1       1504                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2A8 00F52       1505                             LOAD            uart_data, #_character_r
2A9 083C1       1506                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2AA 00F65       1507                             LOAD            uart_data, #character_e
2AB 083C1       1508                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2AC 00F61       1509                             LOAD            uart_data, #character_a
2AD 083C1       1510                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2AE 00F64       1511                             LOAD            uart_data, #character_d
2AF 083C1       1512                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2B0 08320       1513                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
2B1 0831F       1514                             CALL            send_page
W: value out of range: 0x31f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1f.
2B2 0831D       1515                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
2B3 00F49       1516                             LOAD            uart_data, #_character_i
2B4 083C1       1517                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2B5 00F2D       1518                             LOAD            uart_data, #character_minus
2B6 083C1       1519                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2B7 00F44       1520                             LOAD            uart_data, #_character_d
2B8 083C1       1521                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2B9 00F65       1522                             LOAD            uart_data, #character_e
2BA 083C1       1523                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2BB 00F76       1524                             LOAD            uart_data, #character_v
2BC 083C1       1525                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2BD 00F69       1526                             LOAD            uart_data, #character_i
2BE 083C1       1527                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2BF 00F63       1528                             LOAD            uart_data, #character_c
2C0 083C1       1529                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2C1 00F65       1530                             LOAD            uart_data, #character_e
2C2 083C1       1531                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2C3 08320       1532                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
2C4 08328       1533                             CALL            send_id
W: value out of range: 0x328, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x28.
2C5 0831D       1534                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
2C6 00F48       1535                             LOAD            uart_data, #_character_h
2C7 083C1       1536                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2C8 00F2D       1537                             LOAD            uart_data, #character_minus
2C9 083C1       1538                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2CA 00F48       1539                             LOAD            uart_data, #_character_h
2CB 083C1       1540                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2CC 00F65       1541                             LOAD            uart_data, #character_e
2CD 083C1       1542                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2CE 00F6C       1543                             LOAD            uart_data, #character_l
2CF 083C1       1544                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2D0 00F70       1545                             LOAD            uart_data, #character_p
2D1 083C1       1546                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2D2 0831D       1547                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
2D3 08080       1548                             RETURN
                1549     ;
                1550     ;
                1551     ;Send 'page' to the UART
                1552     ;
2D4 00F70       1553     send_page:              LOAD            uart_data, #character_p
2D5 083C1       1554                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2D6 00F61       1555                             LOAD            uart_data, #character_a
2D7 083C1       1556                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2D8 00F67       1557                             LOAD            uart_data, #character_g
2D9 083C1       1558                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2DA 00F65       1559                             LOAD            uart_data, #character_e
2DB 083C1       1560                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2DC 08080       1561                             RETURN
                1562     ;
                1563     ;Send 'ID' to the UART
                1564     ;
2DD 00F49       1565     send_id:                LOAD            uart_data, #_character_i
2DE 083C1       1566                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2DF 00F44       1567                             LOAD            uart_data, #_character_d
2E0 083C1       1568                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2E1 08080       1569                             RETURN
                1570     ;
                1571     ;
                1572     ;Send 'Confirm Erase (Y/n) ' to the UART
                1573     ;
2E2 0831D       1574     send_confirm:           CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
2E3 00F43       1575                             LOAD            uart_data, #_character_c
2E4 083C1       1576                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2E5 00F6F       1577                             LOAD            uart_data, #character_o
2E6 083C1       1578                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2E7 00F6E       1579                             LOAD            uart_data, #character_n
2E8 083C1       1580                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2E9 00F66       1581                             LOAD            uart_data, #character_f
2EA 083C1       1582                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2EB 00F69       1583                             LOAD            uart_data, #character_i
2EC 083C1       1584                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2ED 00F72       1585                             LOAD            uart_data, #character_r
2EE 083C1       1586                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2EF 00F6D       1587                             LOAD            uart_data, #character_m
2F0 083C1       1588                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2F1 08320       1589                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
2F2 083AA       1590                             CALL            send_erase
W: value out of range: 0x2aa, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xaa.
2F3 00F28       1591                             LOAD            uart_data, #character_open
2F4 083C1       1592                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2F5 00F59       1593                             LOAD            uart_data, #_character_y
2F6 083C1       1594                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2F7 00F2F       1595                             LOAD            uart_data, #character_divide
2F8 083C1       1596                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2F9 00F6E       1597                             LOAD            uart_data, #character_n
2FA 083C1       1598                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2FB 00F29       1599                             LOAD            uart_data, #character_close
2FC 083C1       1600                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
2FD 08320       1601                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
2FE 08080       1602                             RETURN
                1603     ;
                1604     ;
                1605     ;Send 'Abort' to the UART
                1606     ;
2FF 0831D       1607     send_abort:             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
300 00F41       1608                             LOAD            uart_data, #_character_a
301 083C1       1609                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
302 00F62       1610                             LOAD            uart_data, #character_b
303 083C1       1611                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
304 00F6F       1612                             LOAD            uart_data, #character_o
305 083C1       1613                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
306 00F72       1614                             LOAD            uart_data, #character_r
307 083C1       1615                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
308 00F74       1616                             LOAD            uart_data, #character_t
309 083C1       1617                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
30A 0831D       1618                             CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
30B 08080       1619                             RETURN
                1620     ;
                1621     ;Send 'page address' to the UART
                1622     ;
30C 0831D       1623     send_page_address:      CALL            send_cr
W: value out of range: 0x21d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1d.
30D 0831F       1624                             CALL            send_page
W: value out of range: 0x31f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1f.
30E 08320       1625                             CALL            send_space
W: value out of range: 0x220, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x20.
30F 00F61       1626                             LOAD            uart_data, #character_a
310 083C1       1627                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
311 00F64       1628                             LOAD            uart_data, #character_d
312 083C1       1629                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
313 083C1       1630                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
314 00F72       1631                             LOAD            uart_data, #character_r
315 083C1       1632                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
316 00F65       1633                             LOAD            uart_data, #character_e
317 083C1       1634                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
318 00F73       1635                             LOAD            uart_data, #character_s
319 083C1       1636                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
31A 083C1       1637                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
31B 00F3D       1638                             LOAD            uart_data, #character_equals
31C 083C1       1639                             CALL            send_to_uart
W: value out of range: 0x1c1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc1.
31D 08080       1640                             RETURN
                1641     ;
                1642     ;
                1643     ;**************************************************************************************
                1644     ;Interrupt Service Routine (ISR)
                1645     ;**************************************************************************************
                1646     ;
                1647     ;An interrupt occurs whenever the status of the UART receiver FIFO 'half_full' flag
                1648     ;changes.
                1649     ;
                1650     ;A change from Low to High means that the buffer is becoming full and therefore
                1651     ;an XOFF character must be transmitted.
                1652     ;
                1653     ;A change from High to Low means that the buffer is starting to empty and therefore
                1654     ;an XON character can be transmitted to restart the flow of new characters.
                1655     ;
                1656     ;
  003F5         1657                             ORG             0x3f5                   ;place at end of memory to keep separate
  003F5         1658     isr:                    STORE           s0, isr_preserve_s0     ;preserve register contents
E: instruction not supported on the this device: STORE sX, ss.
3F5 0A000       1659                             INPUT           s0, status_port         ;test 'half_full' status of receiver buffer.
                1660                             TEST            s0, #rx_half_full
E: instruction not supported on the this device: TEST sX, kk.
3F6 091FB       1661                             JUMP            z, isr_send_xon
W: value out of range: 0x3fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3F7 00013       1662                             LOAD            s0, #character_xoff
3F8 081FC       1663                             JUMP            isr_send_character
W: value out of range: 0x3fc, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfc.
3F9 00011       1664     isr_send_xon:           LOAD            s0, #character_xon
3FA 0E010       1665     isr_send_character:     OUTPUT          s0, uart_write_port
                1666                             FETCH           s0, isr_preserve_s0     ;restore register contents
E: instruction not supported on the this device: FETCH sX, ss.
3FB 080F0       1667                             RETURNI         enable
                1668     ;
                1669     ;
                1670     ;**************************************************************************************
                1671     ;Interrupt Vector
                1672     ;**************************************************************************************
                1673     ;
  003FF         1674                             ORG             0x3ff
3FF 081F5       1675                             JUMP            isr
W: value out of range: 0x3f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
                1676     ;
                1677     ;
                1678
