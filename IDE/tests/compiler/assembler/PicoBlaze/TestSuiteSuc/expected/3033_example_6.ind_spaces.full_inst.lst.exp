                   1     ;KCPSM3 Program - SPI Control of Amplifier and A/D converter on Spartan-3E Starter Kit.
                   2     ;
                   3     ;
                   4     ;Ken Chapman - Xilinx Ltd
                   5     ;
                   6     ;Version v1.00 - 21th December 2005
                   7     device kcpsm3
                   8     ;This program uses an 8KHz interrupt to generate test waveforms on the
                   9     ;4 analogue outputs provided by the Linear Technology LTC2624 device.
                  10     ;
                  11     ;As well as the port connections vital to communication with the UART and the SPI
                  12     ;FLASH memory, there are additional port connections used to disable the other
                  13     ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
                  14     ;controlled at the hardware level, they are included in this code to aid
                  15     ;future investigations of communication with the other SPI devices using PicoBlaze.
                  16     ;
                  17     ;Connections to the LEDs, switches and press buttons are provided to aid
                  18     ;development and enable further experiments. Otherwise know as having fun!
                  19     ;
                  20     ;Port definitions
                  21     ;
                  22     ;
  00008           23     spi_control_port        EQU             0x08                    ;SPI clock and chip selects
  00001           24     spi_sck                 EQU             0x01                    ;                  SCK - bit0
  00002           25     spi_rom_cs              EQU             0x02                    ;    serial rom select - bit1
  00004           26     spi_spare_control       EQU             0x04                    ;                spare - bit2
  00008           27     spi_amp_cs              EQU             0x08                    ;     amplifier select - bit3
  00010           28     spi_adc_conv            EQU             0x10                    ;          A/D convert - bit4
  00020           29     spi_dac_cs              EQU             0x20                    ;           D/A select - bit5
  00040           30     spi_amp_shdn            EQU             0x40                    ;       amplifier SHDN - bit6
  00080           31     spi_dac_clr             EQU             0x80                    ;            D/A clear - bit7
                  32     ;
  00004           33     spi_output_port         EQU             0x04                    ;SPI data output
  00080           34     spi_sdo                 EQU             0x80                    ;   SDO - bit7
                  35     ;
  00001           36     spi_input_port          EQU             0x01                    ;SPI data input
  00080           37     spi_sdi                 EQU             0x80                    ;             SDI - bit7
  00040           38     spi_amp_sdi             EQU             0x40                    ;   amplifier SDI - bit6
                  39     ;
                  40     ;
  00080           41     led_port                EQU             0x80                    ;8 simple LEDs
  00001           42     led0                    EQU             0x01                    ;     LED 0 - bit0
  00002           43     led1                    EQU             0x02                    ;         1 - bit1
  00004           44     led2                    EQU             0x04                    ;         2 - bit2
  00008           45     led3                    EQU             0x08                    ;         3 - bit3
  00010           46     led4                    EQU             0x10                    ;         4 - bit4
  00020           47     led5                    EQU             0x20                    ;         5 - bit5
  00040           48     led6                    EQU             0x40                    ;         6 - bit6
  00080           49     led7                    EQU             0x80                    ;         7 - bit7
                  50     ;
                  51     ;
  00000           52     switch_port             EQU             0x00                    ;Read switches and press buttons
  00001           53     btn_north               EQU             0x01                    ;  Buttons     North - bit0
  00002           54     btn_east                EQU             0x02                    ;               East - bit1
  00004           55     btn_south               EQU             0x04                    ;              South - bit2
  00008           56     btn_west                EQU             0x08                    ;               West - bit3
  00010           57     switch0                 EQU             0x10                    ;  Switches        0 - bit4
  00020           58     switch1                 EQU             0x20                    ;                  1 - bit5
  00040           59     switch2                 EQU             0x40                    ;                  2 - bit6
  00080           60     switch3                 EQU             0x80                    ;                  3 - bit7
                  61     ;
                  62     ;LCD interface ports
                  63     ;
                  64     ;The master enable signal is not used by the LCD display itself
                  65     ;but may be required to confirm that LCD communication is active.
                  66     ;This is required on the Spartan-3E Starter Kit if the StrataFLASH
                  67     ;is used because it shares the same data pins and conflicts must be avoided.
                  68     ;
  00040           69     lcd_output_port         EQU             0x40                    ;LCD character module output data and control
  00001           70     lcd_e                   EQU             0x01                    ;   active High Enable        E - bit0
  00002           71     lcd_rw                  EQU             0x02                    ;   Read=1 Write=0           RW - bit1
  00004           72     lcd_rs                  EQU             0x04                    ;   Instruction=0 Data=1     RS - bit2
  00008           73     lcd_drive               EQU             0x08                    ;   Master enable (active High) - bit3
  00010           74     lcd_db4                 EQU             0x10                    ;   4-bit              Data DB4 - bit4
  00020           75     lcd_db5                 EQU             0x20                    ;   interface          Data DB5 - bit5
  00040           76     lcd_db6                 EQU             0x40                    ;                      Data DB6 - bit6
  00080           77     lcd_db7                 EQU             0x80                    ;                      Data DB7 - bit7
                  78     ;
                  79     ;
  00002           80     lcd_input_port          EQU             0x02                    ;LCD character module input data
  00001           81     lcd_read_spare0         EQU             0x01                    ;    Spare bits               - bit0
  00002           82     lcd_read_spare1         EQU             0x02                    ;    are zero                 - bit1
  00004           83     lcd_read_spare2         EQU             0x04                    ;                             - bit2
  00008           84     lcd_read_spare3         EQU             0x08                    ;                             - bit3
  00010           85     lcd_read_db4            EQU             0x10                    ;    4-bit           Data DB4 - bit4
  00020           86     lcd_read_db5            EQU             0x20                    ;    interface       Data DB5 - bit5
  00040           87     lcd_read_db6            EQU             0x40                    ;                    Data DB6 - bit6
  00080           88     lcd_read_db7            EQU             0x80                    ;                    Data DB7 - bit7
                  89     ;
                  90     ;
                  91     ;
                  92     ;
                  93     ;Special Register usage
                  94     ;
                  95     ;
                  96     ;
                  97     ;Scratch Pad Memory Locations
                  98     ;
                  99     ;Values read from the A/D converter
                 100     ;
  00000          101     adc0_lsb                EQU             0x00                    ;ADC Channel 0 value LS-Byte
  00001          102     adc0_msb                EQU             0x01                    ;                    MS-Byte
                 103     ;
  00002          104     adc1_lsb                EQU             0x02                    ;ADC Channel 1 value LS-Byte
  00003          105     adc1_msb                EQU             0x03                    ;                    MS-Byte
                 106     ;
                 107     ;Amplifier gain settings.
                 108     ;
                 109     ;Stored value is the 4-bit code for gain setting
                 110     ;  Code  1   2   3    4     5    6     7
                 111     ;  Gain -1  -2  -5  -10   -20  -50  -100
  00004          112     amp_a_gain              EQU             0x04                    ;Amplifier A gain value
  00005          113     amp_b_gain              EQU             0x05                    ;Amplifier B gain value
                 114     ;
                 115     ;Sample counter used to give activity indication on LEDs
                 116     ;
  00006          117     sample_count            EQU             0x06                    ;8-bit counter LS-Byte
                 118     ;
  00007          119     decimal0                EQU             0x07                    ;5 digit decimal value
  00008          120     decimal1                EQU             0x08
  00009          121     decimal2                EQU             0x09
  0000A          122     decimal3                EQU             0x0a
  0000B          123     decimal4                EQU             0x0b
                 124     ;
                 125     ;
                 126     ;
                 127     ;
                 128     ;Useful data constants
                 129     ;
  00072          130     vref_lsb                EQU             0x72                    ;Reference voltage in milli-volts
  00006          131     vref_msb                EQU             0x06                    ;Nominal value 1.65v so value is 1650 (0672 hex)
                 132     ;
                 133     ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                 134     ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 135     ;calculation highly predictable. The '6' in the following equation even allows for
                 136     ;'CALL delay_1us' instruction in the initiating code.
                 137     ;
                 138     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 139     ;
                 140     ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 141     ;For clock rates below 10MHz the value of 1 must be used and the operation will
                 142     ;become lower than intended.
                 143     ;
  0000B          144     delay_1us_constant      EQU             0x0b
                 145     ;
                 146     ;
                 147     ;
                 148     ;ASCII table
                 149     ;
  00061          150     character_a             EQU             0x61
  00062          151     character_b             EQU             0x62
  00063          152     character_c             EQU             0x63
  00064          153     character_d             EQU             0x64
  00065          154     character_e             EQU             0x65
  00066          155     character_f             EQU             0x66
  00067          156     character_g             EQU             0x67
  00068          157     character_h             EQU             0x68
  00069          158     character_i             EQU             0x69
  0006A          159     character_j             EQU             0x6a
  0006B          160     character_k             EQU             0x6b
  0006C          161     character_l             EQU             0x6c
  0006D          162     character_m             EQU             0x6d
  0006E          163     character_n             EQU             0x6e
  0006F          164     character_o             EQU             0x6f
  00070          165     character_p             EQU             0x70
  00071          166     character_q             EQU             0x71
  00072          167     character_r             EQU             0x72
  00073          168     character_s             EQU             0x73
  00074          169     character_t             EQU             0x74
  00075          170     character_u             EQU             0x75
  00076          171     character_v             EQU             0x76
  00077          172     character_w             EQU             0x77
  00078          173     character_x             EQU             0x78
  00079          174     character_y             EQU             0x79
  0007A          175     character_z             EQU             0x7a
  00041          176     _character_a            EQU             0x41
  00042          177     _character_b            EQU             0x42
  00043          178     _character_c            EQU             0x43
  00044          179     _character_d            EQU             0x44
  00045          180     _character_e            EQU             0x45
  00046          181     _character_f            EQU             0x46
  00047          182     _character_g            EQU             0x47
  00048          183     _character_h            EQU             0x48
  00049          184     _character_i            EQU             0x49
  0004A          185     _character_j            EQU             0x4a
  0004B          186     _character_k            EQU             0x4b
  0004C          187     _character_l            EQU             0x4c
  0004D          188     _character_m            EQU             0x4d
  0004E          189     _character_n            EQU             0x4e
  0004F          190     _character_o            EQU             0x4f
  00050          191     _character_p            EQU             0x50
  00051          192     _character_q            EQU             0x51
  00052          193     _character_r            EQU             0x52
  00053          194     _character_s            EQU             0x53
  00054          195     _character_t            EQU             0x54
  00055          196     _character_u            EQU             0x55
  00056          197     _character_v            EQU             0x56
  00057          198     _character_w            EQU             0x57
  00058          199     _character_x            EQU             0x58
  00059          200     _character_y            EQU             0x59
  0005A          201     _character_z            EQU             0x5a
  00030          202     character_0             EQU             0x30
  00031          203     character_1             EQU             0x31
  00032          204     character_2             EQU             0x32
  00033          205     character_3             EQU             0x33
  00034          206     character_4             EQU             0x34
  00035          207     character_5             EQU             0x35
  00036          208     character_6             EQU             0x36
  00037          209     character_7             EQU             0x37
  00038          210     character_8             EQU             0x38
  00039          211     character_9             EQU             0x39
  0003A          212     character_colon         EQU             0x3a
  0002E          213     character_stop          EQU             0x2e
  0003B          214     character_semi_colon    EQU             0x3b
  0002D          215     character_minus         EQU             0x2d
  0002F          216     character_divide        EQU             0x2f                    ;'/'
  0002B          217     character_plus          EQU             0x2b
  0002C          218     character_comma         EQU             0x2c
  0003C          219     character_less_than     EQU             0x3c
  0003E          220     character_greater_than  EQU             0x3e
  0003D          221     character_equals        EQU             0x3d
  00020          222     character_space         EQU             0x20
  0000D          223     character_cr            EQU             0x0d                    ;carriage return
  0003F          224     character_question      EQU             0x3f                    ;'?'
  00024          225     character_dollar        EQU             0x24
  00021          226     character_exclaim       EQU             0x21                    ;'!'
  00008          227     character_bs            EQU             0x08                    ;Back Space command character
                 228     ;
                 229     ;
                 230     ;
                 231     ;
                 232     ;
                 233     ;
                 234     ;Initialise the system
                 235     ;
                 236     ;
000 3011F        237     cold_start:             CALL            spi_init                ;initialise SPI bus ports
001 301FB        238                             CALL            lcd_reset               ;initialise LCD display
                 239     ;
                 240     ;Write welcome message to LCD display
                 241     ;
002 00510        242                             LOAD            s5, #0x10               ;Line 1 position 0
003 30211        243                             CALL            lcd_cursor
004 3014E        244                             CALL            disp_picoblaze          ;Display 'PicoBlaze Inside'
005 00523        245                             LOAD            s5, #0x23               ;Line 2 position 3
006 30211        246                             CALL            lcd_cursor
007 30161        247                             CALL            disp_adc_control
008 301B3        248                             CALL            delay_1s                ;wait 5 seconds
009 301B3        249                             CALL            delay_1s
00A 301B3        250                             CALL            delay_1s
00B 301B3        251                             CALL            delay_1s
00C 301B3        252                             CALL            delay_1s
00D 3020C        253                             CALL            lcd_clear               ;Clear display
                 254     ;
00E 00000        255                             LOAD            s0, #0x00               ;clear event counter
00F 2E006        256                             STORE           s0, sample_count
                 257     ;
                 258     ;
                 259     ;
                 260     ;
010 00001        261                             LOAD            s0, #0x01               ;set initial amplifier gain to 1 on both channels
011 2E004        262                             STORE           s0, amp_a_gain
012 2E005        263                             STORE           s0, amp_b_gain
013 34092        264                             JUMP            new_gain_set            ;set, display the initial gain and enable interrupts
                 265     ;
                 266     ;
                 267     ;The program is interrupt driven to maintain an 8KHz sample rate. The main body
                 268     ;of the program waits for an interrupt to occur. The interrupt updates all four
                 269     ;analogue outputs with values stored in scratch pad memory. This takes approximately
                 270     ;58us of the 125us available between interrupts. The main program then prepares
                 271     ;new values for the analogue outputs (in less than 67us) before waiting for the
                 272     ;next interrupt.
                 273     ;
                 274     ;
014 00FFF        275     warm_start:             LOAD            sf, #0xff               ;flag set and wait for interrupt to be serviced
015 3C001        276                             ENABLE          interrupt               ;normal operation
016 04E00        277     wait_int:               INPUT           se, switch_port         ;test for button press changes to amplifier gain
017 12E01        278                             TEST            se, #btn_north          ;sE used as this in not effected by ISR
018 35486        279                             JUMP            nz, gain_increase
019 12E04        280                             TEST            se, #btn_south
01A 3548D        281                             JUMP            nz, gain_decrease
01B 14FFF        282                             COMPARE         sf, #0xff               ;wait for interrupt
01C 35016        283                             JUMP            z, wait_int             ;interrupt clears the flag
                 284     ;
                 285     ;
                 286     ;
                 287     ;Drive LEDs with simple binary count of the samples to indicate
                 288     ;that the design is active.
                 289     ;
01D 06006        290                             FETCH           s0, sample_count        ;increment counter
01E 18001        291                             ADD             s0, #0x01
01F 2E006        292                             STORE           s0, sample_count
020 2C080        293                             OUTPUT          s0, led_port            ;count increments at 1Hz
                 294     ;
                 295     ;
                 296     ;Display the A/D Channel 0 value as hex on LCD
                 297     ;
021 0052C        298                             LOAD            s5, #0x2c               ;Line 2 position 12
022 30211        299                             CALL            lcd_cursor
023 06001        300                             FETCH           s0, adc0_msb
024 30199        301                             CALL            disp_hex_byte
025 06000        302                             FETCH           s0, adc0_lsb
026 30199        303                             CALL            disp_hex_byte
                 304     ;
                 305     ;
                 306     ;
                 307     ;Convert A/D channel 0 value to decimal voltage
                 308     ;
                 309     ;The 14-bit signed value from the A/D (sign extended to 16-bits)
                 310     ;relates to a voltage in the range -1.25v to +1.25v at the input
                 311     ;to the A/D converter relative to the 1.65v mid-rail reference point.
                 312     ;
                 313     ;The 14-bit value can be translated into the -1.25v to +1.25v using the
                 314     ;simple equation...
                 315     ;
                 316     ;   ADin = AD_value x 1.25/8192
                 317     ;
                 318     ;It is possible to scale the AD_value by 1.25/8192 using a fixed point
                 319     ;representation.
                 320     ;
                 321     ;However, it is also possible to scale it by another factor at the
                 322     ;same time which nicely converts to a binary value which is readily
                 323     ;converted to decimal. This can be achieved by example...
                 324     ;
                 325     ;For an input to the A/D converter of +1.25v relative to the reference,
                 326     ;the A/D will output the maximum conversion of 1FFF (+8191).
                 327     ;
                 328     ;In this case we would like to have the result value +1.250v which can be represented
                 329     ;by the integer value +1250 with appropiate positioning of the decimal point.
                 330     ;The constant to achieve this conversion is +1250/8191=+0.152606...
                 331     ;Also a number requiring fixed point representation but how many bits to use?
                 332     ;
                 333     ;The way to resolve this is to realise that a multiplication will be
                 334     ;performed and it would be nice if the +1250 result ended up in a register pair.
                 335     ;So if we perform a 16x16-bit multiplication such that the upper 16-bits of
                 336     ;the 32-bit result is the required value, then everything will resolve itself.
                 337     ;
                 338     ;Hence the constant required is actually (1250x(2^16))/8191=+10001 (2711 hex).
                 339     ;
                 340     ;Using the example 1FFF x 2711 = 04E1F8EF
                 341     ;   of which the upper 16-bits = 04E1 (+1249 decimal)
                 342     ;
                 343     ;Likewise the other limit case is E000 x 2711 = FB1DE000
                 344     ;   of which the upper 16-bits = FB1D (-1251 decimal)
                 345     ;
                 346     ;The values can be made perfect by rounding before truncation
                 347     ;
027 06200        348                             FETCH           s2, adc0_lsb            ;Read A/D channel 0 value
028 06301        349                             FETCH           s3, adc0_msb
029 00011        350                             LOAD            s0, #0x11               ;scaling value for input to A/D converter
02A 00127        351                             LOAD            s1, #0x27
02B 300E4        352                             CALL            mult_16x16s             ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
02C 20506        353                             SL0             s5                      ;round value before truncation
02D 1A600        354                             ADDCY           s6, #0x00
02E 1A700        355                             ADDCY           s7, #0x00
                 356     ;
                 357     ;The register pair [s7,s6] now holds the binary value
                 358     ;representing the input level to the A/D converter in milli-volts.
                 359     ;This is now displayed on the LCD. Negative values need to be converted to
                 360     ;signed magnitude for display.
                 361     ;
02F 00520        362                             LOAD            s5, #0x20               ;Line 2 position 0
030 30211        363                             CALL            lcd_cursor
031 3017F        364                             CALL            disp_ad                 ;display A/D=
032 12780        365                             TEST            s7, #0x80               ;test sign bit of value
033 35436        366                             JUMP            nz, neg_ad
034 0052B        367                             LOAD            s5, #character_plus
035 3403B        368                             JUMP            ad_sign
036 0E6FF        369     neg_ad:                 XOR             s6, #0xff               ;complement [s7,s6] to make positive
037 0E7FF        370                             XOR             s7, #0xff
038 18601        371                             ADD             s6, #0x01
039 1A700        372                             ADDCY           s7, #0x00
03A 0052D        373                             LOAD            s5, #character_minus
03B 301D1        374     ad_sign:                CALL            lcd_write_data          ;display sign of value
03C 30074        375                             CALL            disp_volts              ;display 4 digit value as X.XXXv
                 376     ;
                 377     ;Convert A/D channel 0 value to display the VINA decimal voltage
                 378     ;
                 379     ;The same fundamental technique can be used to convert the 14-bit
                 380     ;A/D value into the level at the VINA input except that two more factors
                 381     ;must be considered.
                 382     ;
                 383     ;The first is that the amplifier inverts and has gain. Therefore the
                 384     ;VINA input level is opposite polarity and could be a smaller deviation
                 385     ;from the mid rail 1.65v reference.
                 386     ;
                 387     ;Secondly, to display the actual voltage level at the VINA terminal
                 388     ;the 1.65v offset must be added.
                 389     ;
                 390     ;The voltage at the VINA input is therefore...
                 391     ;
                 392     ;   VINA = [AD_value x (1.25/(8192 x G))]+1.65
                 393     ;
                 394     ;Following the same methodology as for the A/D value, it means that there
                 395     ;is a set of scaling factors to deal with the negative gain values.
                 396     ;
                 397     ; K = (+1250 x (2^16)) / (8191 x G)
                 398     ;
                 399     ;        G             K     (K Hex)
                 400     ;       -1          -10001   (D8EF)
                 401     ;       -2           -5001   (EC77)
                 402     ;       -5           -2000   (F830)
                 403     ;      -10           -1000   (FC18)
                 404     ;      -20            -500   (FE0C)
                 405     ;      -50            -200   (FF38)
                 406     ;     -100            -100   (FF9C)
                 407     ;
03D 06200        408                             FETCH           s2, adc0_lsb            ;Read A/D channel 0 value
03E 06301        409                             FETCH           s3, adc0_msb
03F 06404        410                             FETCH           s4, amp_a_gain          ;read A gain and select appropiate gain setting
040 000EF        411                             LOAD            s0, #0xef               ;scaling value for amplifier gain of -1
041 001D8        412                             LOAD            s1, #0xd8
042 14401        413                             COMPARE         s4, #0x01
043 3505A        414                             JUMP            z, mult_vina
044 00077        415                             LOAD            s0, #0x77               ;scaling value for amplifier gain of -2
045 001EC        416                             LOAD            s1, #0xec
046 14402        417                             COMPARE         s4, #0x02
047 3505A        418                             JUMP            z, mult_vina
048 00030        419                             LOAD            s0, #0x30               ;scaling value for amplifier gain of -5
049 001F8        420                             LOAD            s1, #0xf8
04A 14403        421                             COMPARE         s4, #0x03
04B 3505A        422                             JUMP            z, mult_vina
04C 00018        423                             LOAD            s0, #0x18               ;scaling value for amplifier gain of -10
04D 001FC        424                             LOAD            s1, #0xfc
04E 14405        425                             COMPARE         s4, #0x05
04F 3505A        426                             JUMP            z, mult_vina
050 0000C        427                             LOAD            s0, #0x0c               ;scaling value for amplifier gain of -20
051 001FE        428                             LOAD            s1, #0xfe
052 14406        429                             COMPARE         s4, #0x06
053 3505A        430                             JUMP            z, mult_vina
054 00038        431                             LOAD            s0, #0x38               ;scaling value for amplifier gain of -50
055 001FF        432                             LOAD            s1, #0xff
056 14401        433                             COMPARE         s4, #0x01
057 3505A        434                             JUMP            z, mult_vina
058 0009C        435                             LOAD            s0, #0x9c               ;scaling value for amplifier gain of -100
059 001FF        436                             LOAD            s1, #0xff
05A 300E4        437     mult_vina:              CALL            mult_16x16s             ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
05B 20506        438                             SL0             s5                      ;round value before truncation
05C 1A600        439                             ADDCY           s6, #0x00
05D 1A700        440                             ADDCY           s7, #0x00
05E 18672        441                             ADD             s6, #vref_lsb           ;add 1.65v offset represented at 1650 (0672 hex)
05F 1A706        442                             ADDCY           s7, #vref_msb
                 443     ;
                 444     ;The register pair [s7,s6] now holds the binary value
                 445     ;representing the VINA input level in milli-volts.
                 446     ;This must be a positive value due to the offset of 1.65v
                 447     ;being greater than the maximum relative range of -1.25v to +1.25v.
                 448     ;This binary value can now be converted to a decimal digits
                 449     ;and displayed on the LCD.
                 450     ;
                 451     ;If the A/D value is maximum negative (E000) or maximum positive (1FFF)
                 452     ;then an indication of the actual value being applied being greater or
                 453     ;less than that computed will be made.
                 454     ;
060 00517        455                             LOAD            s5, #0x17               ;Line 1 position 7
061 30211        456                             CALL            lcd_cursor
062 30178        457                             CALL            disp_va                 ;display VA=
063 06200        458                             FETCH           s2, adc0_lsb            ;Read A/D channel 0 value
064 06301        459                             FETCH           s3, adc0_msb
065 143E0        460                             COMPARE         s3, #0xe0               ;test for maximum negative
066 3546C        461                             JUMP            nz, test_max_pos
067 14200        462                             COMPARE         s2, #0x00
068 3546C        463                             JUMP            nz, test_max_pos
069 0053E        464                             LOAD            s5, #character_greater_than ;display >
06A 301D1        465                             CALL            lcd_write_data
06B 34072        466                             JUMP            disp_vina_volts
06C 1431F        467     test_max_pos:           COMPARE         s3, #0x1f               ;test for maximum positive
06D 35472        468                             JUMP            nz, disp_vina_volts
06E 142FF        469                             COMPARE         s2, #0xff
06F 35472        470                             JUMP            nz, disp_vina_volts
070 0053C        471                             LOAD            s5, #character_less_than ;display <
071 301D1        472                             CALL            lcd_write_data
072 30074        473     disp_vina_volts:        CALL            disp_volts              ;display 4 digit value as X.XXXv
073 34014        474                             JUMP            warm_start
                 475     ;
                 476     ;
                 477     ;**************************************************************************************
                 478     ;Display voltage level at in the form X.XXX on the LCD at current cursor position
                 479     ;**************************************************************************************
                 480     ;
                 481     ;Value to be displayed must be unsigned (positive) in the
                 482     ;[s7,s6] register pair. Only the lower 4 digits are displayed.
                 483     ;
074 30102        484     disp_volts:             CALL            integer16_to_bcd        ;convert [s7,s6] to BCD in scratch pad memory
075 0650A        485                             FETCH           s5, decimal3
076 18530        486                             ADD             s5, #0x30               ;convert to ASCII
077 301D1        487                             CALL            lcd_write_data
078 0052E        488                             LOAD            s5, #character_stop
079 301D1        489                             CALL            lcd_write_data
07A 06509        490                             FETCH           s5, decimal2
07B 18530        491                             ADD             s5, #0x30               ;convert to ASCII
07C 301D1        492                             CALL            lcd_write_data
07D 06508        493                             FETCH           s5, decimal1
07E 18530        494                             ADD             s5, #0x30               ;convert to ASCII
07F 301D1        495                             CALL            lcd_write_data
080 06507        496                             FETCH           s5, decimal0
081 18530        497                             ADD             s5, #0x30               ;convert to ASCII
082 301D1        498                             CALL            lcd_write_data
083 00520        499                             LOAD            s5, #character_space    ;ensure next position is cleared
084 301D1        500                             CALL            lcd_write_data
085 2A000        501                             RETURN
                 502     ;
                 503     ;**************************************************************************************
                 504     ;Changing amplifier gain using press buttons
                 505     ;**************************************************************************************
                 506     ;
                 507     ;Possible gain values are
                 508     ;   Gain   Amplifier
                 509     ;            code
                 510     ;    -1        1
                 511     ;    -2        2
                 512     ;    -5        3
                 513     ;   -10        4
                 514     ;   -20        5
                 515     ;   -50        6
                 516     ;  -100        7
                 517     ;
086 3C000        518     gain_increase:          DISABLE         interrupt               ;stop normal operation
087 06004        519                             FETCH           s0, amp_a_gain          ;read current gain
088 18001        520                             ADD             s0, #0x01
089 14008        521                             COMPARE         s0, #0x08               ;test for too big
08A 35492        522                             JUMP            nz, new_gain_set
08B 00007        523                             LOAD            s0, #0x07               ;maximum gain
08C 34092        524                             JUMP            new_gain_set
08D 3C000        525     gain_decrease:          DISABLE         interrupt               ;stop normal operation
08E 06004        526                             FETCH           s0, amp_a_gain          ;read current gain
08F 1C001        527                             SUB             s0, #0x01
090 35492        528                             JUMP            nz, new_gain_set
091 00001        529                             LOAD            s0, #0x01               ;minimum gain
092 2E004        530     new_gain_set:           STORE           s0, amp_a_gain          ;store new value
093 06205        531                             FETCH           s2, amp_b_gain          ;form the amplifier control byte
094 20206        532                             SL0             s2                      ;B amplifier set by upper 4 bits
095 20206        533                             SL0             s2
096 20206        534                             SL0             s2
097 20206        535                             SL0             s2
098 0D200        536                             OR              s2, s0                  ;A amplifier set by lower
099 30122        537                             CALL            set_amp                 ;set SPI amplifier
                 538     ;display gain setting on LCD
09A 00510        539                             LOAD            s5, #0x10               ;Line 1 position 0
09B 30211        540                             CALL            lcd_cursor
09C 00547        541                             LOAD            s5, #_character_g
09D 301D1        542                             CALL            lcd_write_data
09E 0053D        543                             LOAD            s5, #character_equals
09F 301D1        544                             CALL            lcd_write_data
0A0 0052D        545                             LOAD            s5, #character_minus
0A1 301D1        546                             CALL            lcd_write_data
0A2 06004        547                             FETCH           s0, amp_a_gain          ;read A gain setting
0A3 14001        548                             COMPARE         s0, #0x01               ;determine actual gain value
0A4 354AC        549                             JUMP            nz, test_a2
0A5 00531        550                             LOAD            s5, #character_1        ;gain is -1
0A6 301D1        551                             CALL            lcd_write_data
0A7 00520        552                             LOAD            s5, #character_space
0A8 301D1        553                             CALL            lcd_write_data
0A9 00520        554                             LOAD            s5, #character_space
0AA 301D1        555                             CALL            lcd_write_data
0AB 340DF        556                             JUMP            wait_no_press
0AC 14002        557     test_a2:                COMPARE         s0, #0x02
0AD 354B5        558                             JUMP            nz, test_a3
0AE 00532        559                             LOAD            s5, #character_2        ;gain is -2
0AF 301D1        560                             CALL            lcd_write_data
0B0 00520        561                             LOAD            s5, #character_space
0B1 301D1        562                             CALL            lcd_write_data
0B2 00520        563                             LOAD            s5, #character_space
0B3 301D1        564                             CALL            lcd_write_data
0B4 340DF        565                             JUMP            wait_no_press
0B5 14003        566     test_a3:                COMPARE         s0, #0x03
0B6 354BE        567                             JUMP            nz, test_a4
0B7 00535        568                             LOAD            s5, #character_5        ;gain is -5
0B8 301D1        569                             CALL            lcd_write_data
0B9 00520        570                             LOAD            s5, #character_space
0BA 301D1        571                             CALL            lcd_write_data
0BB 00520        572                             LOAD            s5, #character_space
0BC 301D1        573                             CALL            lcd_write_data
0BD 340DF        574                             JUMP            wait_no_press
0BE 14004        575     test_a4:                COMPARE         s0, #0x04
0BF 354C7        576                             JUMP            nz, test_a5
0C0 00531        577                             LOAD            s5, #character_1        ;gain is -10
0C1 301D1        578                             CALL            lcd_write_data
0C2 00530        579                             LOAD            s5, #character_0
0C3 301D1        580                             CALL            lcd_write_data
0C4 00520        581                             LOAD            s5, #character_space
0C5 301D1        582                             CALL            lcd_write_data
0C6 340DF        583                             JUMP            wait_no_press
0C7 14005        584     test_a5:                COMPARE         s0, #0x05
0C8 354D0        585                             JUMP            nz, test_a6
0C9 00532        586                             LOAD            s5, #character_2        ;gain is -20
0CA 301D1        587                             CALL            lcd_write_data
0CB 00530        588                             LOAD            s5, #character_0
0CC 301D1        589                             CALL            lcd_write_data
0CD 00520        590                             LOAD            s5, #character_space
0CE 301D1        591                             CALL            lcd_write_data
0CF 340DF        592                             JUMP            wait_no_press
0D0 14006        593     test_a6:                COMPARE         s0, #0x06
0D1 354D9        594                             JUMP            nz, gain_a7
0D2 00535        595                             LOAD            s5, #character_5        ;gain is -50
0D3 301D1        596                             CALL            lcd_write_data
0D4 00530        597                             LOAD            s5, #character_0
0D5 301D1        598                             CALL            lcd_write_data
0D6 00520        599                             LOAD            s5, #character_space
0D7 301D1        600                             CALL            lcd_write_data
0D8 340DF        601                             JUMP            wait_no_press
0D9 00531        602     gain_a7:                LOAD            s5, #character_1        ;gain is -100
0DA 301D1        603                             CALL            lcd_write_data
0DB 00530        604                             LOAD            s5, #character_0
0DC 301D1        605                             CALL            lcd_write_data
0DD 00530        606                             LOAD            s5, #character_0
0DE 301D1        607                             CALL            lcd_write_data
0DF 301AE        608     wait_no_press:          CALL            delay_20ms              ;delay to help avoid switch bounce
0E0 04000        609                             INPUT           s0, switch_port         ;check for release of press buttons
0E1 12005        610                             TEST            s0, #0x05               ;north and south buttons
0E2 354DF        611                             JUMP            nz, wait_no_press
0E3 34014        612                             JUMP            warm_start
                 613     ;
                 614     ;**************************************************************************************
                 615     ;16-bit by 16-bit Signed multiplier
                 616     ;**************************************************************************************
                 617     ;
                 618     ;16 bit signed multiplication using shift and add technique.
                 619     ;The full precision 32-bit product is returned.
                 620     ;
                 621     ;The key to signed multiplication is to think of all bits of the second operand
                 622     ;[s1,s0] as being positive except for the most significant bit. This means that
                 623     ;the first operand is added to the result in all cases when there is a '1' in the
                 624     ;second operand except for the MSB case when the first operand is subtracted if there
                 625     ;is a '1'.
                 626     ;
                 627     ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
                 628     ;
                 629     ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sA
                 630     ;
0E4 00700        631     mult_16x16s:            LOAD            s7, #0x00               ;clear accumulator
0E5 00600        632                             LOAD            s6, #0x00
0E6 00500        633                             LOAD            s5, #0x00               ;Set bit 14 to act as a bit shift counter
0E7 00400        634                             LOAD            s4, #0x00
0E8 00800        635                             LOAD            s8, #0x00               ;sign extend [s3,s2] to form [s9,s8,s3,s2]
0E9 12380        636                             TEST            s3, #0x80               ;test sign of first operand
0EA 350EC        637                             JUMP            z, m16s_pos
0EB 008FF        638                             LOAD            s8, #0xff
0EC 01980        639     m16s_pos:               LOAD            s9, s8                  ;[s9,s8,s3,s2]=0000xxxx or FFFFxxxx as required
0ED 00A0F        640                             LOAD            sa, #0x0f               ;15 positive shift and add operations to perform
0EE 2010E        641     m16s_loop:              SR0             s1                      ;shift right operand [s1,s0]
0EF 20008        642                             SRA             s0
0F0 35CF5        643                             JUMP            nc, m16s_noadd          ;test for a '1'
0F1 19420        644                             ADD             s4, s2                  ;32-bit addition [s7,s6,s5,s4]=[s7,s6,s5,s4]+[s9,s8,s3,s2]
0F2 1B530        645                             ADDCY           s5, s3
0F3 1B680        646                             ADDCY           s6, s8
0F4 1B790        647                             ADDCY           s7, s9
0F5 20206        648     m16s_noadd:             SL0             s2                      ;multiply first operand by 2
0F6 20300        649                             SLA             s3
0F7 20800        650                             SLA             s8
0F8 20900        651                             SLA             s9
0F9 1CA01        652                             SUB             sa, #0x01
0FA 354EE        653                             JUMP            nz, m16s_loop           ;move to next unsigned bit
0FB 12001        654                             TEST            s0, #0x01               ;test sign bit of operand [s1,s0]
0FC 35D01        655                             JUMP            nc, m16s_nosub
0FD 1D420        656                             SUB             s4, s2                  ;32-bit subtraction [s7,s6,s5,s4]=[s7,s6,s5,s4]-[s9,s8,s3,s2]
0FE 1F530        657                             SUBCY           s5, s3
0FF 1F680        658                             SUBCY           s6, s8
100 1F790        659                             SUBCY           s7, s9
101 2A000        660     m16s_nosub:             RETURN
                 661     ;
                 662     ;
                 663     ;
                 664     ;**************************************************************************************
                 665     ;16-bit positive integer to 5 digit decimal conversion
                 666     ;**************************************************************************************
                 667     ;
                 668     ;Convert the 16 bit value in register set [s7,s6]
                 669     ;into the BCD decimal equivalent located in the scratch pad memory
                 670     ;locations 'decimal0' to 'decimal4' which must be in ascending locations.
                 671     ;
                 672     ;Register set [s9,s8,s7,s6] are preserved.
                 673     ;
                 674     ;
                 675     ;Each digit is formed in turn starting with the least significant.
                 676     ;
                 677     ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8
                 678     ;
102 00005        679     integer16_to_bcd:       LOAD            s0, #0x05               ;5 digits to be formed from value up to 65535
103 00807        680                             LOAD            s8, #decimal0           ;pointer for LS-Digit
104 3010A        681     int_to_bcd_loop:        CALL            divide_16bit_by_10      ;[s7,s6]=[s7,s6]/10  with remainder in s4
105 2F480        682                             STORE           s4, @s8                 ;remainder becomes digit value
106 18801        683                             ADD             s8, #0x01               ;move to next most significant digit
107 1C001        684                             SUB             s0, #0x01               ;one less digit to compute
108 35504        685                             JUMP            nz, int_to_bcd_loop
109 2A000        686                             RETURN
                 687     ;
                 688     ;Divide 16-bit binary integer by 10
                 689     ;
                 690     ;The value to be divided is held in register set [s7,s6]
                 691     ;and this is where the result is returned to.
                 692     ;
                 693     ;At then end of the integer division the remainder in the range 0 to 9
                 694     ;will be in register s4.
                 695     ;
                 696     ;Registers used s1,s2,s3,s4,s5,s6,s7
                 697     ;Other registers are used but are preserved
                 698     ;
10A 01460        699     divide_16bit_by_10:     LOAD            s4, s6                  ;copy input value to [s5,s4]
10B 01570        700                             LOAD            s5, s7
10C 00600        701                             LOAD            s6, #0x00               ;clear result
10D 00700        702                             LOAD            s7, #0x00
10E 00200        703                             LOAD            s2, #0x00               ;initialise '10' value into msb's of set [s3,s2]
10F 003A0        704                             LOAD            s3, #0xa0
110 0010D        705                             LOAD            s1, #0x0d               ;13 subtract and shift iterations to be performed
111 1D420        706     div10_loop:             SUB             s4, s2                  ;perform 16-bit subtract [s5,s4]-[s3,s2]
112 1F530        707                             SUBCY           s5, s3
113 35916        708                             JUMP            c, div10_restore
114 20607        709                             SL1             s6                      ;shift '1' into result because subtract was possible
115 34119        710                             JUMP            div10_shifts
116 19420        711     div10_restore:          ADD             s4, s2                  ;perform 32-bit addition [s5,s4]+[s3,s2]
117 1B530        712                             ADDCY           s5, s3                  ;to restore value
118 20606        713                             SL0             s6                      ;shift '0' into result because subtract was not possible
119 20700        714     div10_shifts:           SLA             s7                      ;complete 16-bit shift left
11A 2030E        715                             SR0             s3                      ;divide '10' value by 2 (shift right 1 place)
11B 20208        716                             SRA             s2
11C 1C101        717                             SUB             s1, #0x01               ;count iterations
11D 35511        718                             JUMP            nz, div10_loop
11E 2A000        719                             RETURN
                 720     ;
                 721     ;
                 722     ;**************************************************************************************
                 723     ;SPI communication routines for Spartan-3E Starter Kit
                 724     ;**************************************************************************************
                 725     ;
                 726     ;These routines will work with two output ports and one input port which should be
                 727     ;defined as follows using CONSTANT directives.
                 728     ;   (replace 'pp' with appropriate port address in each case)
                 729     ;In the list of CONSTANT directives, there are ports associated with all the SPI devices
                 730     ;provided on the board. Even if some devices are not used, it is vital that the remaining
                 731     ;devices are disabled. Leaving all signals connected and use of these routines will ensure
                 732     ;that all other devices are disabled when communicating with a particular device.
                 733     ;
                 734     ;
                 735     ;
                 736     ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects
                 737     ;CONSTANT SPI_sck, 01                ;                  SCK - bit0
                 738     ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1
                 739     ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
                 740     ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
                 741     ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
                 742     ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
                 743     ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
                 744     ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
                 745     ;
                 746     ;CONSTANT SPI_output_port, pp        ;SPI data output
                 747     ;CONSTANT SPI_sdo, 80                ;   SDO - bit7
                 748     ;
                 749     ;CONSTANT SPI_input_port, pp         ;SPI data input
                 750     ;CONSTANT SPI_sdi, 80                ;             SDI - bit7
                 751     ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
                 752     ;
                 753     ;
                 754     ;
                 755     ;
                 756     ;Initialise SPI bus
                 757     ;
                 758     ;This routine should be used to initialise the SPI bus.
                 759     ;The SCK clock is made low.
                 760     ;Device selections are made inactive as follows
                 761     ;   SPI_sck      = 0      Clock is Low (required)
                 762     ;   SPI_rom_cs   = 1      Deselect ROM
                 763     ;   spare        = 1      spare control bit
                 764     ;   SPI_amp_cs   = 1      Deselect amplifier
                 765     ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
                 766     ;   SPI_dac_cs   = 1      Deselect D/A
                 767     ;   SPI_amp_shdn = 0      Amplifier active and available
                 768     ;   SPI_dac_clr  = 1      D/A clear off
                 769     ;
11F 000AE        770     spi_init:               LOAD            s0, #0xae               ;normally AE
120 2C008        771                             OUTPUT          s0, spi_control_port
121 2A000        772                             RETURN
                 773     ;
                 774     ;
                 775     ;
                 776     ;
                 777     ;**************************************************************************************
                 778     ;SPI communication routines for Programmable Amplifier
                 779     ;**************************************************************************************
                 780     ;
                 781     ;
                 782     ;Set the A and B channel gain of the Dual Amplifier (LTC6912-1).
                 783     ;
                 784     ;The gain value should be provided in the s2 register with the upper nibble
                 785     ;defining the gain for the B channel and lower nibble the gain for the A channel.
                 786     ; 0000 = 0 hex = Gain  0 with input hi-Z and output driving
                 787     ; 0001 = 1 hex = Gain -1
                 788     ; 0010 = 2 hex = Gain -2
                 789     ; 0011 = 3 hex = Gain -5
                 790     ; 0100 = 4 hex = Gain -10
                 791     ; 0101 = 5 hex = Gain -20
                 792     ; 0110 = 6 hex = Gain -50
                 793     ; 0111 = 7 hex = Gain -100
                 794     ; 1000 = 8 hex = software shutdown (power on default). Hi-Z output.
                 795     ;
                 796     ;On return, the s2, register will contain the response from the LTC6912-1 amplifier.
                 797     ;This will be the same format and indicate the previous setting of the amplifier.
                 798     ;The response is obtained from the dedicated AMP_SDI signal since the LTC6912 output
                 799     ;is always active and can not be on a shared SPI bus.
                 800     ;
122 3011F        801     set_amp:                CALL            spi_init                ;ensure known state of bus and s0 register
123 0E008        802                             XOR             s0, #spi_amp_cs         ;select low on Amplifier chip select
124 2C008        803                             OUTPUT          s0, spi_control_port
125 00108        804                             LOAD            s1, #0x08               ;8-bits to transmit and receive
126 2C204        805     next_amp_spi_bit:       OUTPUT          s2, spi_output_port     ;output data bit
127 0E001        806                             XOR             s0, #spi_sck            ;clock High (bit0)
128 2C008        807                             OUTPUT          s0, spi_control_port    ;drive clock High
129 04301        808                             INPUT           s3, spi_input_port      ;read input bit
12A 12340        809                             TEST            s3, #spi_amp_sdi        ;detect state of received bit
12B 20200        810                             SLA             s2                      ;shift new data into result and move to next transmit bit
12C 0E001        811                             XOR             s0, #spi_sck            ;clock Low (bit0)
12D 2C008        812                             OUTPUT          s0, spi_control_port    ;drive clock Low
12E 1C101        813                             SUB             s1, #0x01               ;count bits
12F 35526        814                             JUMP            nz, next_amp_spi_bit    ;repeat until finished
130 0E008        815                             XOR             s0, #spi_amp_cs         ;deselect the amplifier
131 2C008        816                             OUTPUT          s0, spi_control_port
132 2A000        817                             RETURN
                 818     ;
                 819     ;
                 820     ;
                 821     ;**************************************************************************************
                 822     ;SPI communication routines for A/D Converter
                 823     ;**************************************************************************************
                 824     ;
                 825     ;
                 826     ;
                 827     ;Sample A/D converter (LTC1407A-1) and return results.
                 828     ;
                 829     ;Note there is a latency of one read to obtain the value. Each read results in the
                 830     ;the analogue inputs being sampled and converted but this value will only be transmitted
                 831     ;during the next read and conversion cycle.
                 832     ;
                 833     ;The results are returned as follows.
                 834     ;   Channel 0 in registers [s9,s8]
                 835     ;   Channel 1 in registers [s7,s6]
                 836     ;Where each is a 14-bit twos complement value sign extended to 16-bits.
                 837     ;
                 838     ;Each 14-bit value represents the analogue voltage in the range -1.25v to +1.25v
                 839     ;relative to the reference voltage of 1.65v (3.3v/2). Hence the actual input voltage
                 840     ;range is 0.4v to 2.9v. Since the input to the A/D is supplied via the programmable
                 841     ;amplifier, the VINA and VINB inputs are inverted and may cover a smaller range if                       ;
                 842     ;desired.
                 843     ;
                 844     ;Examples
                 845     ;   VINA = 0.65v with gain=-1 means input to A/D = 2.65v
                 846     ;      This is equivalent to +1.00v which is value (8192/1.25)*1 = 6553 (1999 hex)
                 847     ;
                 848     ;   VINA = 2.65v with gain=-1 means input to A/D = 0.65v
                 849     ;      This is equivalent to -1.00v which is value (2048/1.25)*-1 = -6553 (E667 hex)
                 850     ;
                 851     ;
                 852     ;Although the A/D converter claims to be an SPI device, it really
                 853     ;does not conform to the normal specification of the 4-wire interface.
                 854     ;
                 855     ;Firstly the CONV signal is only pulsed High and does not behave like
                 856     ;a normal active low select signal. Secondly, the communication is
                 857     ;34 bits which does not fit a byte boundary, and thirdly, the data output
                 858     ;to its SDO pin changes as a result of rising edges of SCK clock which
                 859     ;is not the same as the falling edge used by other devices.
                 860     ;
133 3011F        861     adc_read:               CALL            spi_init                ;ensure known state of bus and s0 register
134 0E010        862                             XOR             s0, #spi_adc_conv       ;Pulse AD-CONV High to take sample and start
135 2C008        863                             OUTPUT          s0, spi_control_port    ;  conversion and transmission of data.
136 0E010        864                             XOR             s0, #spi_adc_conv       ;AD-CONV Low
137 2C008        865                             OUTPUT          s0, spi_control_port
138 00122        866                             LOAD            s1, #0x22               ;34 clocks to read all data
139 0E001        867     next_adc_bit:           XOR             s0, #spi_sck            ;clock High (bit0)
13A 2C008        868                             OUTPUT          s0, spi_control_port    ;drive clock High
13B 0E001        869                             XOR             s0, #spi_sck            ;clock Low (bit0)
13C 2C008        870                             OUTPUT          s0, spi_control_port    ;drive clock Low
13D 04301        871                             INPUT           s3, spi_input_port      ;read input bit
13E 12380        872                             TEST            s3, #spi_sdi            ;detect state of received bit
13F 20600        873                             SLA             s6                      ;shift new data into result registers
140 20700        874                             SLA             s7
141 20800        875                             SLA             s8
142 20900        876                             SLA             s9
143 1C101        877                             SUB             s1, #0x01               ;count bits
144 35539        878                             JUMP            nz, next_adc_bit        ;repeat until finished
145 2090A        879                             SRX             s9                      ;sign extend 14-bit result in [s9,s8]
146 20808        880                             SRA             s8
147 2090A        881                             SRX             s9
148 20808        882                             SRA             s8
149 2070A        883                             SRX             s7                      ;sign extend 14-bit result in [s7,s6]
14A 20608        884                             SRA             s6
14B 2070A        885                             SRX             s7
14C 20608        886                             SRA             s6
14D 2A000        887                             RETURN
                 888     ;
                 889     ;
                 890     ;**************************************************************************************
                 891     ;LCD text messages
                 892     ;**************************************************************************************
                 893     ;
                 894     ;
                 895     ;Display 'PicoBlaze' on LCD at current cursor position
                 896     ;
                 897     ;
14E 00550        898     disp_picoblaze:         LOAD            s5, #_character_p
14F 301D1        899                             CALL            lcd_write_data
150 00569        900                             LOAD            s5, #character_i
151 301D1        901                             CALL            lcd_write_data
152 00563        902                             LOAD            s5, #character_c
153 301D1        903                             CALL            lcd_write_data
154 0056F        904                             LOAD            s5, #character_o
155 301D1        905                             CALL            lcd_write_data
156 00542        906                             LOAD            s5, #_character_b
157 301D1        907                             CALL            lcd_write_data
158 0056C        908                             LOAD            s5, #character_l
159 301D1        909                             CALL            lcd_write_data
15A 00561        910                             LOAD            s5, #character_a
15B 301D1        911                             CALL            lcd_write_data
15C 0057A        912                             LOAD            s5, #character_z
15D 301D1        913                             CALL            lcd_write_data
15E 00565        914                             LOAD            s5, #character_e
15F 301D1        915                             CALL            lcd_write_data
160 2A000        916                             RETURN
                 917     ;
                 918     ;
                 919     ;Display 'ADC Control' on LCD at current cursor position
                 920     ;
                 921     ;
161 00541        922     disp_adc_control:       LOAD            s5, #_character_a
162 301D1        923                             CALL            lcd_write_data
163 00544        924                             LOAD            s5, #_character_d
164 301D1        925                             CALL            lcd_write_data
165 00543        926                             LOAD            s5, #_character_c
166 301D1        927                             CALL            lcd_write_data
167 00520        928                             LOAD            s5, #character_space
168 301D1        929                             CALL            lcd_write_data
169 00543        930                             LOAD            s5, #_character_c
16A 301D1        931                             CALL            lcd_write_data
16B 0056F        932                             LOAD            s5, #character_o
16C 301D1        933                             CALL            lcd_write_data
16D 0056E        934                             LOAD            s5, #character_n
16E 301D1        935                             CALL            lcd_write_data
16F 00574        936                             LOAD            s5, #character_t
170 301D1        937                             CALL            lcd_write_data
171 00572        938                             LOAD            s5, #character_r
172 301D1        939                             CALL            lcd_write_data
173 0056F        940                             LOAD            s5, #character_o
174 301D1        941                             CALL            lcd_write_data
175 0056C        942                             LOAD            s5, #character_l
176 301D1        943                             CALL            lcd_write_data
177 2A000        944                             RETURN
                 945     ;
                 946     ;
                 947     ;Display 'VA=' on LCD at current cursor position
                 948     ;
                 949     ;
178 00556        950     disp_va:                LOAD            s5, #_character_v
179 301D1        951                             CALL            lcd_write_data
17A 00541        952                             LOAD            s5, #_character_a
17B 301D1        953                             CALL            lcd_write_data
17C 0053D        954                             LOAD            s5, #character_equals
17D 301D1        955                             CALL            lcd_write_data
17E 2A000        956                             RETURN
                 957     ;
                 958     ;
                 959     ;Display 'A/D' on LCD at current cursor position
                 960     ;
                 961     ;
17F 00541        962     disp_ad:                LOAD            s5, #_character_a
180 301D1        963                             CALL            lcd_write_data
181 0052F        964                             LOAD            s5, #character_divide
182 301D1        965                             CALL            lcd_write_data
183 00544        966                             LOAD            s5, #_character_d
184 301D1        967                             CALL            lcd_write_data
185 0053D        968                             LOAD            s5, #character_equals
186 301D1        969                             CALL            lcd_write_data
187 2A000        970                             RETURN
                 971     ;
                 972     ;
                 973     ;
                 974     ;**************************************************************************************
                 975     ;Value to ASCII Conversions and LCD display
                 976     ;**************************************************************************************
                 977     ;
                 978     ;Convert hexadecimal value provided in register s0 into ASCII characters
                 979     ;
                 980     ;The value provided must can be any value in the range 00 to FF and will be converted into
                 981     ;two ASCII characters.
                 982     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                 983     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                 984     ;
                 985     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                 986     ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                 987     ;hexadecimal requiring a further addition of 07 to the 30 already added.
                 988     ;
                 989     ;Registers used s0, s1 and s2.
                 990     ;
188 01100        991     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
189 2000E        992                             SR0             s0                      ;isolate upper nibble
18A 2000E        993                             SR0             s0
18B 2000E        994                             SR0             s0
18C 2000E        995                             SR0             s0
18D 30194        996                             CALL            hex_to_ascii            ;convert
18E 01200        997                             LOAD            s2, s0                  ;upper nibble value in s2
18F 01010        998                             LOAD            s0, s1                  ;restore complete value
190 0A00F        999                             AND             s0, #0x0f               ;isolate lower nibble
191 30194       1000                             CALL            hex_to_ascii            ;convert
192 01100       1001                             LOAD            s1, s0                  ;lower nibble value in s1
193 2A000       1002                             RETURN
                1003     ;
                1004     ;Convert hexadecimal value provided in register s0 into ASCII character
                1005     ;
                1006     ;Register used s0
                1007     ;
194 1C00A       1008     hex_to_ascii:           SUB             s0, #0x0a               ;test if value is in range 0 to 9
195 35997       1009                             JUMP            c, number_char
196 18007       1010                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
197 1803A       1011     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
198 2A000       1012                             RETURN
                1013     ;
                1014     ;
                1015     ;Display the two character HEX value of the register contents 's0' on
                1016     ;the LCD display at the current cursor position.
                1017     ;
                1018     ;Registers used s0, s1, s2, s4, s5, s6
                1019     ;
199 30188       1020     disp_hex_byte:          CALL            hex_byte_to_ascii
19A 01610       1021                             LOAD            s6, s1                  ;remember lower hex character
19B 01520       1022                             LOAD            s5, s2                  ;display upper hex character
19C 301D1       1023                             CALL            lcd_write_data
19D 01560       1024                             LOAD            s5, s6                  ;display lower hex character
19E 301D1       1025                             CALL            lcd_write_data
19F 2A000       1026                             RETURN
                1027     ;
                1028     ;
                1029     ;**************************************************************************************
                1030     ;Software delay routines
                1031     ;**************************************************************************************
                1032     ;
                1033     ;
                1034     ;
                1035     ;Delay of 1us.
                1036     ;
                1037     ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1038     ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1039     ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1040     ;
                1041     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1042     ;
                1043     ;Registers used s0
                1044     ;
1A0 0000B       1045     delay_1us:              LOAD            s0, #delay_1us_constant
1A1 1C001       1046     wait_1us:               SUB             s0, #0x01
1A2 355A1       1047                             JUMP            nz, wait_1us
1A3 2A000       1048                             RETURN
                1049     ;
                1050     ;Delay of 40us.
                1051     ;
                1052     ;Registers used s0, s1
                1053     ;
1A4 00128       1054     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
1A5 301A0       1055     wait_40us:              CALL            delay_1us
1A6 1C101       1056                             SUB             s1, #0x01
1A7 355A5       1057                             JUMP            nz, wait_40us
1A8 2A000       1058                             RETURN
                1059     ;
                1060     ;
                1061     ;Delay of 1ms.
                1062     ;
                1063     ;Registers used s0, s1, s2
                1064     ;
1A9 00219       1065     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
1AA 301A4       1066     wait_1ms:               CALL            delay_40us
1AB 1C201       1067                             SUB             s2, #0x01
1AC 355AA       1068                             JUMP            nz, wait_1ms
1AD 2A000       1069                             RETURN
                1070     ;
                1071     ;Delay of 20ms.
                1072     ;
                1073     ;Delay of 20ms used during initialisation.
                1074     ;
                1075     ;Registers used s0, s1, s2, s3
                1076     ;
1AE 00314       1077     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
1AF 301A9       1078     wait_20ms:              CALL            delay_1ms
1B0 1C301       1079                             SUB             s3, #0x01
1B1 355AF       1080                             JUMP            nz, wait_20ms
1B2 2A000       1081                             RETURN
                1082     ;
                1083     ;Delay of approximately 1 second.
                1084     ;
                1085     ;Registers used s0, s1, s2, s3, s4
                1086     ;
1B3 00432       1087     delay_1s:               LOAD            s4, #0x32               ;50 x 20ms = 1000ms
1B4 301AE       1088     wait_1s:                CALL            delay_20ms
1B5 1C401       1089                             SUB             s4, #0x01
1B6 355B4       1090                             JUMP            nz, wait_1s
1B7 2A000       1091                             RETURN
                1092     ;
                1093     ;
                1094     ;
                1095     ;**************************************************************************************
                1096     ;LCD Character Module Routines
                1097     ;**************************************************************************************
                1098     ;
                1099     ;LCD module is a 16 character by 2 line display but all displays are very similar
                1100     ;The 4-wire data interface will be used (DB4 to DB7).
                1101     ;
                1102     ;The LCD modules are relatively slow and software delay loops are used to slow down
                1103     ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
                1104     ;a different section (see above in this case).
                1105     ;
                1106     ;
                1107     ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
                1108     ;
                1109     ;Register s4 should define the current state of the LCD output port.
                1110     ;
                1111     ;Registers used s0, s4
                1112     ;
1B8 0E401       1113     lcd_pulse_e:            XOR             s4, #lcd_e              ;E=1
1B9 2C440       1114                             OUTPUT          s4, lcd_output_port
1BA 301A0       1115                             CALL            delay_1us
1BB 0E401       1116                             XOR             s4, #lcd_e              ;E=0
1BC 2C440       1117                             OUTPUT          s4, lcd_output_port
1BD 2A000       1118                             RETURN
                1119     ;
                1120     ;Write 4-bit instruction to LCD display.
                1121     ;
                1122     ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
                1123     ;Note that this routine does not release the master enable but as it is only
                1124     ;used during initialisation and as part of the 8-bit instruction write it
                1125     ;should be acceptable.
                1126     ;
                1127     ;Registers used s4
                1128     ;
1BE 0A4F8       1129     lcd_write_inst4:        AND             s4, #0xf8               ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
1BF 2C440       1130                             OUTPUT          s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
1C0 301B8       1131                             CALL            lcd_pulse_e
1C1 2A000       1132                             RETURN
                1133     ;
                1134     ;
                1135     ;Write 8-bit instruction to LCD display.
                1136     ;
                1137     ;The 8-bit instruction should be provided in register s5.
                1138     ;Instructions are written using the following sequence
                1139     ; Upper nibble
                1140     ; wait >1us
                1141     ; Lower nibble
                1142     ; wait >40us
                1143     ;
                1144     ;Registers used s0, s1, s4, s5
                1145     ;
1C2 01450       1146     lcd_write_inst8:        LOAD            s4, s5
1C3 0A4F0       1147                             AND             s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1C4 0C408       1148                             OR              s4, #lcd_drive          ;Enable=1
1C5 301BE       1149                             CALL            lcd_write_inst4         ;write upper nibble
1C6 301A0       1150                             CALL            delay_1us               ;wait >1us
1C7 01450       1151                             LOAD            s4, s5                  ;select lower nibble with
1C8 20407       1152                             SL1             s4                      ;Enable=1
1C9 20406       1153                             SL0             s4                      ;RS=0 Instruction
1CA 20406       1154                             SL0             s4                      ;RW=0 Write
1CB 20406       1155                             SL0             s4                      ;E=0
1CC 301BE       1156                             CALL            lcd_write_inst4         ;write lower nibble
1CD 301A4       1157                             CALL            delay_40us              ;wait >40us
1CE 004F0       1158                             LOAD            s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1CF 2C440       1159                             OUTPUT          s4, lcd_output_port     ;Release master enable
1D0 2A000       1160                             RETURN
                1161     ;
                1162     ;
                1163     ;
                1164     ;Write 8-bit data to LCD display.
                1165     ;
                1166     ;The 8-bit data should be provided in register s5.
                1167     ;Data bytes are written using the following sequence
                1168     ; Upper nibble
                1169     ; wait >1us
                1170     ; Lower nibble
                1171     ; wait >40us
                1172     ;
                1173     ;Registers used s0, s1, s4, s5
                1174     ;
1D1 01450       1175     lcd_write_data:         LOAD            s4, s5
1D2 0A4F0       1176                             AND             s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1D3 0C40C       1177                             OR              s4, #0x0c               ;Enable=1 RS=1 Data, RW=0 Write, E=0
1D4 2C440       1178                             OUTPUT          s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
1D5 301B8       1179                             CALL            lcd_pulse_e             ;write upper nibble
1D6 301A0       1180                             CALL            delay_1us               ;wait >1us
1D7 01450       1181                             LOAD            s4, s5                  ;select lower nibble with
1D8 20407       1182                             SL1             s4                      ;Enable=1
1D9 20407       1183                             SL1             s4                      ;RS=1 Data
1DA 20406       1184                             SL0             s4                      ;RW=0 Write
1DB 20406       1185                             SL0             s4                      ;E=0
1DC 2C440       1186                             OUTPUT          s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
1DD 301B8       1187                             CALL            lcd_pulse_e             ;write lower nibble
1DE 301A4       1188                             CALL            delay_40us              ;wait >40us
1DF 004F0       1189                             LOAD            s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1E0 2C440       1190                             OUTPUT          s4, lcd_output_port     ;Release master enable
1E1 2A000       1191                             RETURN
                1192     ;
                1193     ;
                1194     ;
                1195     ;
                1196     ;Read 8-bit data from LCD display.
                1197     ;
                1198     ;The 8-bit data will be read from the current LCD memory address
                1199     ;and will be returned in register s5.
                1200     ;It is advisable to set the LCD address (cursor position) before
                1201     ;using the data read for the first time otherwise the display may
                1202     ;generate invalid data on the first read.
                1203     ;
                1204     ;Data bytes are read using the following sequence
                1205     ; Upper nibble
                1206     ; wait >1us
                1207     ; Lower nibble
                1208     ; wait >40us
                1209     ;
                1210     ;Registers used s0, s1, s4, s5
                1211     ;
1E2 0040E       1212     lcd_read_data8:         LOAD            s4, #0x0e               ;Enable=1 RS=1 Data, RW=1 Read, E=0
1E3 2C440       1213                             OUTPUT          s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
1E4 0E401       1214                             XOR             s4, #lcd_e              ;E=1
1E5 2C440       1215                             OUTPUT          s4, lcd_output_port
1E6 301A0       1216                             CALL            delay_1us               ;wait >260ns to access data
1E7 04502       1217                             INPUT           s5, lcd_input_port      ;read upper nibble
1E8 0E401       1218                             XOR             s4, #lcd_e              ;E=0
1E9 2C440       1219                             OUTPUT          s4, lcd_output_port
1EA 301A0       1220                             CALL            delay_1us               ;wait >1us
1EB 0E401       1221                             XOR             s4, #lcd_e              ;E=1
1EC 2C440       1222                             OUTPUT          s4, lcd_output_port
1ED 301A0       1223                             CALL            delay_1us               ;wait >260ns to access data
1EE 04002       1224                             INPUT           s0, lcd_input_port      ;read lower nibble
1EF 0E401       1225                             XOR             s4, #lcd_e              ;E=0
1F0 2C440       1226                             OUTPUT          s4, lcd_output_port
1F1 0A5F0       1227                             AND             s5, #0xf0               ;merge upper and lower nibbles
1F2 2000E       1228                             SR0             s0
1F3 2000E       1229                             SR0             s0
1F4 2000E       1230                             SR0             s0
1F5 2000E       1231                             SR0             s0
1F6 0D500       1232                             OR              s5, s0
1F7 00404       1233                             LOAD            s4, #0x04               ;Enable=0 RS=1 Data, RW=0 Write, E=0
1F8 2C440       1234                             OUTPUT          s4, lcd_output_port     ;Stop reading 5V device and release master enable
1F9 301A4       1235                             CALL            delay_40us              ;wait >40us
1FA 2A000       1236                             RETURN
                1237     ;
                1238     ;
                1239     ;Reset and initialise display to communicate using 4-bit data mode
                1240     ;Includes routine to clear the display.
                1241     ;
                1242     ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
                1243     ;following by the 8-bit instructions to set up the display.
                1244     ;
                1245     ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
                1246     ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
                1247     ;  0C = '00001' Display control, '1' display on, '0' cursor off, '0' cursor blink off
                1248     ;  01 = '00000001' Display clear
                1249     ;
                1250     ;Registers used s0, s1, s2, s3, s4
                1251     ;
1FB 301AE       1252     lcd_reset:              CALL            delay_20ms              ;wait more that 15ms for display to be ready
1FC 00430       1253                             LOAD            s4, #0x30
1FD 301BE       1254                             CALL            lcd_write_inst4         ;send '3'
1FE 301AE       1255                             CALL            delay_20ms              ;wait >4.1ms
1FF 301BE       1256                             CALL            lcd_write_inst4         ;send '3'
200 301A9       1257                             CALL            delay_1ms               ;wait >100us
201 301BE       1258                             CALL            lcd_write_inst4         ;send '3'
202 301A4       1259                             CALL            delay_40us              ;wait >40us
203 00420       1260                             LOAD            s4, #0x20
204 301BE       1261                             CALL            lcd_write_inst4         ;send '2'
205 301A4       1262                             CALL            delay_40us              ;wait >40us
206 00528       1263                             LOAD            s5, #0x28               ;Function set
207 301C2       1264                             CALL            lcd_write_inst8
208 00506       1265                             LOAD            s5, #0x06               ;Entry mode
209 301C2       1266                             CALL            lcd_write_inst8
20A 0050C       1267                             LOAD            s5, #0x0c               ;Display control
20B 301C2       1268                             CALL            lcd_write_inst8
20C 00501       1269     lcd_clear:              LOAD            s5, #0x01               ;Display clear
20D 301C2       1270                             CALL            lcd_write_inst8
20E 301A9       1271                             CALL            delay_1ms               ;wait >1.64ms for display to clear
20F 301A9       1272                             CALL            delay_1ms
210 2A000       1273                             RETURN
                1274     ;
                1275     ;Position the cursor ready for characters to be written.
                1276     ;The display is formed of 2 lines of 16 characters and each
                1277     ;position has a corresponding address as indicated below.
                1278     ;
                1279     ;                   Character position
                1280     ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
                1281     ;
                1282     ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
                1283     ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
                1284     ;
                1285     ;This routine will set the cursor position using the value provided
                1286     ;in register s5. The upper nibble will define the line and the lower
                1287     ;nibble the character position on the line.
                1288     ; Example s5 = 2B will position the cursor on line 2 position 11
                1289     ;
                1290     ;Registers used s0, s1, s2, s3, s4
                1291     ;
211 12510       1292     lcd_cursor:             TEST            s5, #0x10               ;test for line 1
212 35217       1293                             JUMP            z, set_line2
213 0A50F       1294                             AND             s5, #0x0f               ;make address in range 80 to 8F for line 1
214 0C580       1295                             OR              s5, #0x80
215 301C2       1296                             CALL            lcd_write_inst8         ;instruction write to set cursor
216 2A000       1297                             RETURN
217 0A50F       1298     set_line2:              AND             s5, #0x0f               ;make address in range C0 to CF for line 2
218 0C5C0       1299                             OR              s5, #0xc0
219 301C2       1300                             CALL            lcd_write_inst8         ;instruction write to set cursor
21A 2A000       1301                             RETURN
                1302     ;
                1303     ;
                1304     ;**************************************************************************************
                1305     ;Interrupt Service Routine (ISR)
                1306     ;**************************************************************************************
                1307     ;
                1308     ;Interrupts occur at 1 second intervals.
                1309     ;
                1310     ;Each interrupt is used to take analogue samples and store them in scratch pad memory.
                1311     ;The interrupt clears a 'flag' in register sF so that the main program can advance.
                1312     ;
21B 30133       1313     isr:                    CALL            adc_read                ;read A/D Converter
21C 2E800       1314                             STORE           s8, adc0_lsb            ;store ADC Channel 0
21D 2E901       1315                             STORE           s9, adc0_msb
21E 2E602       1316                             STORE           s6, adc1_lsb            ;store ADC Channel 1
21F 2E703       1317                             STORE           s7, adc1_msb
                1318     ;
220 00F00       1319                             LOAD            sf, #0x00               ;clear flag
221 38001       1320                             RETURNI         enable
                1321     ;
                1322     ;
                1323     ;**************************************************************************************
                1324     ;Interrupt Vector
                1325     ;**************************************************************************************
                1326     ;
  003FF         1327                             ORG             0x3ff
3FF 3421B       1328                             JUMP            isr
                1329     ;
                1330     ;
                1331
