                   1     ; KCPSM3 Program - Implementation of the SHA-1 algorithm for use with the
                   2     ;                  DS2432 secure memory on the Spartan-3E Starter Kit.
                   3     device kcpsm1
                   4     ; Ken Chapman - Xilinx Ltd
                   5     ;
                   6
                   7     ; Version v1.00 - 19th April 2006
                   8     ;
                   9     ;
                  10     ; IMPORTANT - This design builds on the reference design called "PicoBlaze
                  11     ;             DS2432 communicator". It is highly recommend that you look at that
                  12     ;             design before proceeding with this one.
                  13     ;
                  14     ;
                  15     ; This program uses a 9600 baud UART connection to allow communication with the
                  16     ; 1-wire interface of the DS2432 memory device from Dallas Semiconductor.
                  17     ;
                  18     ; The program only supports a limited number of the DS2432 commands to focus on
                  19     ; those aspects which use the SHA-1 algorithm.
                  20     ;
                  21     ; Note that the code performing the SHA-1 algorithm interacts with the hardware of
                  22     ; this complete reference design. The hardware provides a 16 word (32-bit) buffer
                  23     ; combined used in the initialisation of the algorithm and subsequent computation
                  24     ; of the Wt words.
                  25     ;
                  26     ;
                  27     ; The DS2432 should be programmed with a 64-bit secret. The following constants
                  28     ; define the secret which will be used. Obviously this would be be changed in a
                  29     ; real application and further measures taken to prevent it easily being found.
                  30     ; The secret is 64-bits formed of 8 bytes. 'secret0' would be stored at address
                  31     ; 0080 of the DS2432 and 'secret7' at address 0087. The write buffer and load
                  32     ; first secret commands allow you to set any secret into the DS2432 device but
                  33     ; this program always uses the secret defined in these constants such that you can
                  34     ; experiment with secrets which do and do not match.
                  35     ;
                  36     ;
  00001           37     secret0                 EQU             0x01
  00023           38     secret1                 EQU             0x23
  00045           39     secret2                 EQU             0x45
  00067           40     secret3                 EQU             0x67
  00089           41     secret4                 EQU             0x89
  000AB           42     secret5                 EQU             0xab
  000CD           43     secret6                 EQU             0xcd
  000EF           44     secret7                 EQU             0xef
                  45     ;
                  46     ;
                  47     ; Bytes 4, 5 and 6 of the DS2432 scratch pad memory are used in the SHA-1 algorithm.
                  48     ; These should be set using the write scratchpad memory command before using the
                  49     ; read authenticated page command. HOWEVER, it is also important that you also use
                  50     ; the read scratchpad command BEFORE using the read authenticated page command. This
                  51     ; is because this program only copies the bytes 4, 5 and 6 during a read such that
                  52     ; they are can be used by the PicoBlaze SHA-1 algorithm. This limitation is deliberate
                  53     ; so that you can experiment and prove that the SHA-1 results will not match if
                  54     ; the same 'challenge' bytes are not used.
                  55     ;
                  56     ;
                  57     ;**************************************************************************************
                  58     ; Port definitions
                  59     ;**************************************************************************************
                  60     ;
                  61     ;
  00040           62     status_port             EQU             0x40                    ;UART status input
  00001           63     tx_half_full            EQU             0x01                    ;  Transmitter     half full - bit0
  00002           64     tx_full                 EQU             0x02                    ;    FIFO               full - bit1
  00004           65     rx_data_present         EQU             0x04                    ;  Receiver     data present - bit2
  00008           66     rx_half_full            EQU             0x08                    ;    FIFO          half full - bit3
  00010           67     rx_full                 EQU             0x10                    ;                   full - bit4
  00020           68     spare1                  EQU             0x20                    ;                  spare '0' - bit5
  00040           69     spare2                  EQU             0x40                    ;                  spare '0' - bit6
  00080           70     spare3                  EQU             0x80                    ;                  spare '0' - bit7
                  71     ;
  00080           72     uart_read_port          EQU             0x80                    ;UART Rx data input
                  73     ;
  00004           74     uart_write_port         EQU             0x04                    ;UART Tx data output
                  75     ;
                  76     ;
  000C0           77     ds_wire_in_port         EQU             0xc0                    ;Read signal from DS2432 device
  00008           78     ds_wire_out_port        EQU             0x08                    ;Drive signal to DS2432 device (open collector)
  00001           79     ds_wire                 EQU             0x01                    ;       Signal is bit0 in both cases
                  80     ;
                  81     ;
                  82     ;
                  83     ; The following ports access the 'Wt' word buffer. This buffer holds 16 words
                  84     ; of 32-bits organised as a 64-byte shift register. Hence each word is stored
                  85     ; by writing 4 bytes. As each byte is written, all bytes shift along such that
                  86     ; older Wt values can be read from consistent port addresses.
                  87     ;
  00010           88     w_word_write_port       EQU             0x10                    ;Write byte to Wt buffer
                  89     ;
  00008           90     wt_minus3_byte0_read_port EQU           0x08                    ;Read of Wt-3
  00009           91     wt_minus3_byte1_read_port EQU           0x09
  0000A           92     wt_minus3_byte2_read_port EQU           0x0a
  0000B           93     wt_minus3_byte3_read_port EQU           0x0b
                  94     ;
  0001C           95     wt_minus8_byte0_read_port EQU           0x1c                    ;Read of Wt-8
  0001D           96     wt_minus8_byte1_read_port EQU           0x1d
  0001E           97     wt_minus8_byte2_read_port EQU           0x1e
  0001F           98     wt_minus8_byte3_read_port EQU           0x1f
                  99     ;
  00034          100     wt_minus14_byte0_read_port EQU          0x34                    ;Read of Wt-14
  00035          101     wt_minus14_byte1_read_port EQU          0x35
  00036          102     wt_minus14_byte2_read_port EQU          0x36
  00037          103     wt_minus14_byte3_read_port EQU          0x37
                 104     ;
  0003C          105     wt_minus16_byte0_read_port EQU          0x3c                    ;Read of Wt-16
  0003D          106     wt_minus16_byte1_read_port EQU          0x3d
  0003E          107     wt_minus16_byte2_read_port EQU          0x3e
  0003F          108     wt_minus16_byte3_read_port EQU          0x3f
                 109     ;
                 110     ;
                 111     ;**************************************************************************************
                 112     ; Special Register usage
                 113     ;**************************************************************************************
                 114     ;
  0000F          115     uart_data               REG             sf                      ;used to pass data to and from the UART
                 116     ;
                 117     ;
                 118     ;**************************************************************************************
                 119     ; Scratch Pad Memory Locations
                 120     ;**************************************************************************************
                 121     ;
                 122     ; Scratch pad memory provides 64 bytes in the address range 00 to 3F hex.
                 123     ;
                 124     ;
                 125     ; Locations for device family code, serial number and 8-bit CRC value
                 126     ;
  00000          127     family_code             EQU             0x00
  00001          128     serial_number0          EQU             0x01                    ;48-bit serial number LS-Byte first
  00002          129     serial_number1          EQU             0x02
  00003          130     serial_number2          EQU             0x03
  00004          131     serial_number3          EQU             0x04
  00005          132     serial_number4          EQU             0x05
  00006          133     serial_number5          EQU             0x06
  00007          134     read_rom_crc            EQU             0x07                    ;8-bit CRC
                 135     ;
                 136     ;
                 137     ; Locations for variables used in SHA-1 algorithm.
                 138     ; Each variable is 32-bits and requires 4 bytes to store.
                 139     ; '0' indicates the least significant byte and '3' the most significant byte.
                 140     ;
                 141     ; Note that the concatenation of 'A', 'B', 'C', 'D' and 'E' will be the 160-bit MAC.
                 142     ;
  00008          143     var_a0                  EQU             0x08                    ;Variable 'A'
  00009          144     var_a1                  EQU             0x09
  0000A          145     var_a2                  EQU             0x0a
  0000B          146     var_a3                  EQU             0x0b
                 147     ;
  0000C          148     var_b0                  EQU             0x0c                    ;Variable 'B'
  0000D          149     var_b1                  EQU             0x0d
  0000E          150     var_b2                  EQU             0x0e
  0000F          151     var_b3                  EQU             0x0f
                 152     ;
  00010          153     var_c0                  EQU             0x10                    ;Variable 'C'
  00011          154     var_c1                  EQU             0x11
  00012          155     var_c2                  EQU             0x12
  00013          156     var_c3                  EQU             0x13
                 157     ;
  00014          158     var_d0                  EQU             0x14                    ;Variable 'D'
  00015          159     var_d1                  EQU             0x15
  00016          160     var_d2                  EQU             0x16
  00017          161     var_d3                  EQU             0x17
                 162     ;
  00018          163     var_e0                  EQU             0x18                    ;Variable 'E'
  00019          164     var_e1                  EQU             0x19
  0001A          165     var_e2                  EQU             0x1a
  0001B          166     var_e3                  EQU             0x1b
                 167     ;
                 168     ;
                 169     ; Copy of data in the scratchpad memory of the DS2432.
                 170     ; This is only updated by the read scratchpad memory command.
                 171     ; '0' indicates the data in the least significant location.
                 172     ;
  0001C          173     scratchpad0             EQU             0x1c
  0001D          174     scratchpad1             EQU             0x1d
  0001E          175     scratchpad2             EQU             0x1e
  0001F          176     scratchpad3             EQU             0x1f
  00020          177     scratchpad4             EQU             0x20
  00021          178     scratchpad5             EQU             0x21
  00022          179     scratchpad6             EQU             0x22
  00023          180     scratchpad7             EQU             0x23
                 181     ;
                 182     ;
                 183     ;
                 184     ;**************************************************************************************
                 185     ; Useful data constants
                 186     ;**************************************************************************************
                 187     ;
                 188     ; Constant to define a software delay of 1us. This must be adjusted to reflect the
                 189     ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 190     ; calculation highly predictable. The '6' in the following equation even allows for
                 191     ; 'CALL delay_1us' instruction in the initiating code.
                 192     ;
                 193     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 194     ;
                 195     ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 196     ; For clock rates below 10MHz the value of 1 must be used and the operation will
                 197     ; become lower than intended.
                 198     ;
  0000B          199     delay_1us_constant      EQU             0x0b
                 200     ;
                 201     ;
                 202     ;
                 203     ;ASCII table
                 204     ;
  00061          205     character_a             EQU             0x61
  00062          206     character_b             EQU             0x62
  00063          207     character_c             EQU             0x63
  00064          208     character_d             EQU             0x64
  00065          209     character_e             EQU             0x65
  00066          210     character_f             EQU             0x66
  00067          211     character_g             EQU             0x67
  00068          212     character_h             EQU             0x68
  00069          213     character_i             EQU             0x69
  0006A          214     character_j             EQU             0x6a
  0006B          215     character_k             EQU             0x6b
  0006C          216     character_l             EQU             0x6c
  0006D          217     character_m             EQU             0x6d
  0006E          218     character_n             EQU             0x6e
  0006F          219     character_o             EQU             0x6f
  00070          220     character_p             EQU             0x70
  00071          221     character_q             EQU             0x71
  00072          222     character_r             EQU             0x72
  00073          223     character_s             EQU             0x73
  00074          224     character_t             EQU             0x74
  00075          225     character_u             EQU             0x75
  00076          226     character_v             EQU             0x76
  00077          227     character_w             EQU             0x77
  00078          228     character_x             EQU             0x78
  00079          229     character_y             EQU             0x79
  0007A          230     character_z             EQU             0x7a
  00041          231     _character_a            EQU             0x41
  00042          232     _character_b            EQU             0x42
  00043          233     _character_c            EQU             0x43
  00044          234     _character_d            EQU             0x44
  00045          235     _character_e            EQU             0x45
  00046          236     _character_f            EQU             0x46
  00047          237     _character_g            EQU             0x47
  00048          238     _character_h            EQU             0x48
  00049          239     _character_i            EQU             0x49
  0004A          240     _character_j            EQU             0x4a
  0004B          241     _character_k            EQU             0x4b
  0004C          242     _character_l            EQU             0x4c
  0004D          243     _character_m            EQU             0x4d
  0004E          244     _character_n            EQU             0x4e
  0004F          245     _character_o            EQU             0x4f
  00050          246     _character_p            EQU             0x50
  00051          247     _character_q            EQU             0x51
  00052          248     _character_r            EQU             0x52
  00053          249     _character_s            EQU             0x53
  00054          250     _character_t            EQU             0x54
  00055          251     _character_u            EQU             0x55
  00056          252     _character_v            EQU             0x56
  00057          253     _character_w            EQU             0x57
  00058          254     _character_x            EQU             0x58
  00059          255     _character_y            EQU             0x59
  0005A          256     _character_z            EQU             0x5a
  00030          257     character_0             EQU             0x30
  00031          258     character_1             EQU             0x31
  00032          259     character_2             EQU             0x32
  00033          260     character_3             EQU             0x33
  00034          261     character_4             EQU             0x34
  00035          262     character_5             EQU             0x35
  00036          263     character_6             EQU             0x36
  00037          264     character_7             EQU             0x37
  00038          265     character_8             EQU             0x38
  00039          266     character_9             EQU             0x39
  0003A          267     character_colon         EQU             0x3a
  0002E          268     character_fullstop      EQU             0x2e
  0003B          269     character_semi_colon    EQU             0x3b
  0002D          270     character_minus         EQU             0x2d
  0002B          271     character_plus          EQU             0x2b
  0002C          272     character_comma         EQU             0x2c
  0003C          273     character_less_than     EQU             0x3c                    ;'<'
  0003E          274     character_greater_than  EQU             0x3e                    ;'>'
  00028          275     character_open          EQU             0x28                    ;'('
  00029          276     character_close         EQU             0x29                    ;')'
  0002F          277     character_divide        EQU             0x2f                    ;'/'
  0003D          278     character_equals        EQU             0x3d
  00020          279     character_space         EQU             0x20
  0000D          280     character_cr            EQU             0x0d                    ;carriage return
  0000A          281     character_lf            EQU             0x0a                    ;line feed
  0003F          282     character_question      EQU             0x3f                    ;'?'
  00024          283     character_dollar        EQU             0x24
  00021          284     character_exclaim       EQU             0x21                    ;'!'
  00008          285     character_bs            EQU             0x08                    ;Back Space command character
  00011          286     character_xon           EQU             0x11                    ;Flow control ON
  00013          287     character_xoff          EQU             0x13                    ;Flow control OFF
                 288     ;
                 289     ;
                 290     ;**************************************************************************************
                 291     ; Initialise the system and welcome message
                 292     ;**************************************************************************************
                 293     ;
000 08330        294     cold_start:             CALL            ds_wire_init            ;Ensure DS_wire is not driven (pulled High)
W: value out of range: 0x230, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x30.
001 0839A        295                             CALL            delay_1s                ;Allow everything to settle!
W: value out of range: 0x29a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9a.
002 0830A        296     welcome_start:          CALL            send_welcome            ;start up message and version number
W: value out of range: 0x30a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa.
                 297     ;
                 298     ;
                 299     ;**************************************************************************************
                 300     ; Reset Main menu and command selection
                 301     ;**************************************************************************************
                 302     ;
                 303     ; The main program allows you to use four of the DS2432 memory and SHA function
                 304     ; commands. A simple menu is displayed and you are guided to enter more information
                 305     ; when required. All the communication and protocol required to get the DS2432 ready
                 306     ; to receive memory and SHA function commands has been automated although information
                 307     ; is displayed to indicate the procedures being executed.
                 308     ;
                 309     ; Before any memory and function commands are available a master reset and read ROM
                 310     ; command must be issued.
                 311     ;
003 083EC        312     warm_start:             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
004 083EC        313                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
005 08333        314                             CALL            ds_init_regular_mode    ;master reset
W: value out of range: 0x233, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x33.
006 09903        315                             JUMP            c, warm_start           ;repeat reset if no presence pulse detected
007 0831D        316                             CALL            read_rom_command        ;read ROM command and display results
                 317     ;
                 318     ; After a valid ROM command the DS2432 specific memory commands and SHA-1
                 319     ; functions become accessible. This program assumes that the ROM command did
                 320     ; 'Pass' so you will need to check yourself. If this program automatically
                 321     ; reset the DS2432 and tried again and there was a fault it would just cause
                 322     ; the display to roll continuously and not be very informative!
                 323     ;
                 324     ; Each of the DS2432 commands selected from the menu will require the master reset
                 325     ; and read ROM command to be repeated before being able to proceed with the next
                 326     ; memory or SHA-1 function. This is automated by the program.
                 327     ;
                 328     ;
008 08344        329     ds2432_menu:            CALL            send_ds2432_menu        ;Menu and command selection
W: value out of range: 0x344, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x44.
009 083EC        330                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
                 331     ;
00A 083EC        332     ds2432_prompt:          CALL            send_cr                 ;prompt for user input
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
00B 083EC        333                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
00C 00F3E        334                             LOAD            uart_data, #character_greater_than ;prompt for input
00D 083A5        335                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
00E 083E1        336                             CALL            read_upper_case
W: value out of range: 0x2e1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe1.
                 337                             COMPARE         s0, #character_1        ;test for commands and execute as required
E: instruction not supported on the this device: COMPARE sX, kk.
00F 09153        338                             JUMP            z, write_scratchpad_command
                 339                             COMPARE         s0, #character_2
E: instruction not supported on the this device: COMPARE sX, kk.
010 09179        340                             JUMP            z, read_scratchpad_command
                 341                             COMPARE         s0, #character_3
E: instruction not supported on the this device: COMPARE sX, kk.
011 09140        342                             JUMP            z, load_first_secret_command
                 343                             COMPARE         s0, #character_4
E: instruction not supported on the this device: COMPARE sX, kk.
012 0919D        344                             JUMP            z, read_auth_page_command
013 083EC        345                             CALL            send_cr                 ;no valid command input
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
014 00F3F        346                             LOAD            uart_data, #character_question ;display ???
015 083A5        347                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
016 083A5        348                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
017 083A5        349                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
018 0810A        350                             JUMP            ds2432_prompt           ;Try again!
                 351     ;
                 352     ;
                 353     ;
                 354     ;
                 355     ;**************************************************************************************
                 356     ; DS2432 Read ROM Command.
                 357     ;**************************************************************************************
                 358     ;
                 359     ; The read ROM command (33 hex) allows the 8-bit family code, 48-bit unique serial
                 360     ; number and 8-bit CRC to be read from the DS2432 device.
                 361     ;
                 362     ; This routine reads the values and places them in KCPSM3 scratch pad memory
                 363     ; locations for future reference. These locations should be defined with constants
                 364     ; as follows and MUST be in consecutive ascending locations.
                 365     ;
                 366     ;  family_code
                 367     ;     Location to store family code which should be 33 hex
                 368     ;  serial_number0 to serial_number5
                 369     ;     6 bytes to hold 48-bit serial number (LS-byte first).
                 370     ;  read_ROM_CRC
                 371     ;     8-bit CRC value for the above data.
                 372     ;
                 373     ;
                 374     ; The routine also displays the values read and performs a verification of the
                 375     ; 8-bit CRC displaying a 'Pass' or 'Fail' message as appropriate.
                 376     ;
019 00333        377     read_rom_command:       LOAD            s3, #0x33               ;Read ROM Command
01A 0834E        378                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
01B 00500        379                             LOAD            s5, #family_code        ;memory pointer
01C 0836F        380     read_rom_loop:          CALL            read_byte_slow          ;read response into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
                 381                             STORE           s3, @s5                 ;store value
E: instruction not supported on the this device: STORE sX, sY.
                 382                             COMPARE         s5, #read_rom_crc       ;8-bytes to read
E: instruction not supported on the this device: COMPARE sX, kk.
01D 09126        383                             JUMP            z, display_rom
01E 04501        384                             ADD             s5, #0x01
01F 08120        385                             JUMP            read_rom_loop
020 083EC        386     display_rom:            CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
021 083D6        387                             CALL            send_code               ;'code=' to display family code
W: value out of range: 0x3d6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd6.
                 388                             FETCH           s0, family_code
E: instruction not supported on the this device: FETCH sX, ss.
022 083C2        389                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
023 083EC        390                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
024 083DC        391                             CALL            send_sn                 ;'s/n=' to display family code
W: value out of range: 0x3dc, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xdc.
025 00506        392                             LOAD            s5, #serial_number5     ;memory pointer starting MS-byte first
  0002D          393     disp_serial_loop:       FETCH           s0, @s5
E: instruction not supported on the this device: FETCH sX, sY.
026 083C2        394                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
                 395                             COMPARE         s5, #serial_number0
E: instruction not supported on the this device: COMPARE sX, kk.
027 09133        396                             JUMP            z, end_serial
028 06501        397                             SUB             s5, #0x01
029 0812D        398                             JUMP            disp_serial_loop
02A 083EC        399     end_serial:             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
02B 083E2        400                             CALL            send_crc                ;'CRC=' to display CRC value
W: value out of range: 0x3e2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe2.
                 401                             FETCH           s0, read_rom_crc
E: instruction not supported on the this device: FETCH sX, ss.
02C 083C2        402                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
02D 083EC        403                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
02E 083F1        404                             CALL            compute_crc8            ;compute CRC value in s0
W: value out of range: 0x1f1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf1.
                 405                             FETCH           s1, read_rom_crc        ;compare with received value
E: instruction not supported on the this device: FETCH sX, ss.
                 406                             COMPARE         s0, s1
E: instruction not supported on the this device: COMPARE sX, sY.
02F 0953E        407                             JUMP            nz, crc8_fail
030 083AD        408                             CALL            send_pass
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
031 08080        409                             RETURN
032 083B4        410     crc8_fail:              CALL            send_fail
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
033 08080        411                             RETURN
                 412     ;
                 413     ;
                 414     ;
                 415     ;**************************************************************************************
                 416     ; DS2432 Load First Secret Command.
                 417     ;**************************************************************************************
                 418     ;
                 419     ; This command will only be valid if the write scratchpad memory command has previously
                 420     ; been used to define the new secret to be stored at address 0080.
                 421     ;
                 422     ; The Load First Secret Command (5A hex) will only copy the scratchpad contents into                           ;
                 423     ; the EEPROM array of the DS2432 if the address was correctly specified in the
                 424     ; write scratchpad command. This routine will assume that the address specified
                 425     ; was 0080. If everything is OK with the programming of the secret, the DS2432 responds
                 426     ; with 'AA' hex after the command and this routine will report 'Pass'. You can further
                 427     ; check using a read scratchpad command and look to see if E/S has changed from '5F'
                 428     ; to 'DF' which indicates the successful write.
                 429     ;
                 430     ; Note that this program defines the secret to be used by the PicoBlaze SHA-1 algorithm
                 431     ; in the constants 'secret0' through to 'secret7'. Only if you program the DS2432
                 432     ; with a matching secret will the read authenticated message command result in a
                 433     ; 'Pass' being reported for the MAC. This Load First Secret Command routine deliberately
                 434     ; does not update the secret used by the PicoBlaze SHA-1 algorithm so that you can
                 435     ; prove that only a DS2432 with the matching secret will generate matching MAC
                 436     ; responses.
                 437     ;
                 438     ;
                 439     ;
034 0035A        440     load_first_secret_command: LOAD         s3, #0x5a               ;Load First Secret Command
035 0834E        441                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
036 00380        442                             LOAD            s3, #0x80               ;TA1 value for secret = 80 hex
037 0834E        443                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
038 00300        444                             LOAD            s3, #0x00               ;TA2 value for secret = 00 hex
039 0834E        445                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
03A 0035F        446                             LOAD            s3, #0x5f               ;E/S value before writing = 5F hex
03B 0834E        447                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
03C 08395        448                             CALL            delay_20ms              ;write takes place in 10ms
W: value out of range: 0x295, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x95.
03D 083EC        449                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
03E 08391        450                             CALL            send_secret
W: value out of range: 0x391, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x91.
03F 083EF        451                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
040 0836F        452                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
                 453                             COMPARE         s3, #0xaa               ;test response
E: instruction not supported on the this device: COMPARE sX, kk.
041 09151        454                             JUMP            z, secret_pass
042 083B4        455                             CALL            send_fail
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
043 08103        456                             JUMP            warm_start
044 083AD        457     secret_pass:            CALL            send_pass
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
045 08103        458                             JUMP            warm_start
                 459     ;
                 460     ;
                 461     ;**************************************************************************************
                 462     ; DS2432 Write Scratchpad Memory Command.
                 463     ;**************************************************************************************
                 464     ;
                 465     ; The write scratchpad memory command (0F hex) allows 8-bytes of data to be written
                 466     ; together with a target address for final storage in the main memory map. The
                 467     ; DS2432 scratch pad is also used to define a 3 byte 'challenge' used in the
                 468     ; SHA-1 algorithm.
                 469     ;
                 470     ; The DS2432 provides an initial confirmation of the write by returning a 16-bit CRC
                 471     ; value which KCPSM3 tests. The CRC is computed based on the command, address and
                 472     ; data transmitted (11 bytes). PicoBlaze also computes the CRC and and tests this
                 473     ; against the value received from the DS2432.
                 474     ;
                 475     ; This routine prompts the user to enter the 16-bit target address is to be loaded
                 476     ; into the target address registers TA2 and TA1 in the DS2432 device. Note that only
                 477     ; address values below 0090 hex are valid. If the address is too high, then the
                 478     ; DS2432 aborts the command and this routine will too.
                 479     ;
                 480     ; Also note that the address will be forced internally to the DS2432 to match an
                 481     ; 8-byte boundary address in which the least significant 3-bits are reset to '000'
                 482     ; regardless of the address provided. The CRC still reflects the transmitted address.
                 483     ;
                 484     ; After providing a valid address, the routine then prompts the user to enter
                 485     ; 8 bytes of data which are written to the DS2432.
                 486     ;
                 487     ;
                 488     ;
046 0830B        489     write_scratchpad_command: CALL          clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
047 0030F        490                             LOAD            s3, #0x0f               ;write scratchpad memory Command
048 0834E        491                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
049 0830E        492                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
04A 083BD        493     wsc_addr_loop:          CALL            send_address            ;obtain 16-bit address 0000 to FFFF in [s5,s4]
W: value out of range: 0x3bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
04B 083E6        494                             CALL            obtain_8bits
W: value out of range: 0x2e6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe6.
04C 09957        495                             JUMP            c, wsc_addr_loop        ;bad input address
04D 0C500        496                             LOAD            s5, s0
04E 083E6        497                             CALL            obtain_8bits
W: value out of range: 0x2e6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe6.
04F 09957        498                             JUMP            c, wsc_addr_loop        ;bad input address
050 0C400        499                             LOAD            s4, s0
051 0C340        500                             LOAD            s3, s4                  ;transmit target address TA1 (LS-Byte)
052 0834E        501                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
053 0830E        502                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
054 0C350        503                             LOAD            s3, s5                  ;transmit target address TA2 (MS-Byte)
055 0834E        504                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
056 0830E        505                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
                 506                             COMPARE         s5, #0x00               ;check address less than 0090 hex
E: instruction not supported on the this device: COMPARE sX, kk.
057 09503        507                             JUMP            nz, warm_start          ;DS2432 aborts command and so do we!
                 508                             COMPARE         s4, #0x90               ;no need to read data bytes.
E: instruction not supported on the this device: COMPARE sX, kk.
058 09D03        509                             JUMP            nc, warm_start
059 00400        510                             LOAD            s4, #0x00               ;initialise byte counter
05A 083C8        511     wsc_data_loop:          CALL            send_data               ;obtain a byte of data
W: value out of range: 0x3c8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc8.
05B 0CF40        512                             LOAD            uart_data, s4           ;display which byte requested
05C 04F30        513                             ADD             uart_data, #character_0 ;convert to ASCII
05D 083A5        514                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
05E 083C5        515                             CALL            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
05F 083E6        516                             CALL            obtain_8bits
W: value out of range: 0x2e6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe6.
060 09969        517                             JUMP            c, wsc_data_loop        ;bad input data
061 0C300        518                             LOAD            s3, s0                  ;transmit byte
062 0834E        519                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
063 0830E        520                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
064 04401        521                             ADD             s4, #0x01               ;count bytes
                 522                             COMPARE         s4, #0x08
E: instruction not supported on the this device: COMPARE sX, kk.
065 09569        523                             JUMP            nz, wsc_data_loop
066 083EC        524                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
067 0831C        525                             CALL            read_send_test_crc16    ;read, display and test CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
068 08103        526                             JUMP            warm_start
                 527     ;
                 528     ;
                 529     ;
                 530     ;**************************************************************************************
                 531     ; DS2432 Read Scratchpad Memory Command.
                 532     ;**************************************************************************************
                 533     ;
                 534     ; The read scratchpad memory command (AA hex) allows the 8-bytes of data previously
                 535     ; to be written into the scratchpad memory to be read back for verification together with
                 536     ; the target address, a transfer status register (E/S) and a 16-bit CRC value.
                 537     ;
                 538     ; The 16-bit CRC is formed of the command byte, address TA1 and TA2, E/S byte and 8 data
                 539     ; bytes as transmitted (12 bytes). These may not be the same as the values provided
                 540     ; during a previous write to scratchpad memory. PicoBlaze also computes the CRC and
                 541     ; and tests this against the value received from the DS2432.
                 542     ;
                 543     ; The 8 bytes of data are also copied to PicoBlaze memory at locations defined by the
                 544     ; constants 'scratchpad0' to 'scratchpad7'. Three bytes are used as a 'challenge'
                 545     ; by the SHA-1 algorithm.
                 546     ;
                 547     ;
                 548     ;
069 0830B        549     read_scratchpad_command: CALL           clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
06A 003AA        550                             LOAD            s3, #0xaa               ;read scratchpad memory Command
06B 0834E        551                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
06C 0830E        552                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
06D 083BD        553                             CALL            send_address            ;display 'Address='
W: value out of range: 0x3bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
06E 0836F        554                             CALL            read_byte_slow          ;read address into [s5,s4]
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
06F 0830E        555                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
070 0C430        556                             LOAD            s4, s3
071 0836F        557                             CALL            read_byte_slow
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
072 0830E        558                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
073 0C530        559                             LOAD            s5, s3
074 0C050        560                             LOAD            s0, s5                  ;display address
075 083C2        561                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
076 0C040        562                             LOAD            s0, s4
077 083C2        563                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
078 083CE        564                             CALL            send_es                 ;display 'E/S='
W: value out of range: 0x3ce, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xce.
079 0836F        565                             CALL            read_byte_slow          ;read E/S register
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
07A 0830E        566                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
07B 0C030        567                             LOAD            s0, s3                  ;display value
07C 083C2        568                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
07D 083C8        569                             CALL            send_data               ;display 'Data='
W: value out of range: 0x3c8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc8.
07E 083C5        570                             CALL            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
07F 0041C        571                             LOAD            s4, #scratchpad0        ;pointer to memory and byte counter
080 083EF        572     rsc_loop:               CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
081 0836F        573                             CALL            read_byte_slow          ;read data byte
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
082 0830E        574                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
                 575                             STORE           s3, @s4                 ;store value in memory
E: instruction not supported on the this device: STORE sX, sY.
083 0C030        576                             LOAD            s0, s3                  ;display value
084 083C2        577                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
                 578                             COMPARE         s4, #scratchpad7        ;count bytes
E: instruction not supported on the this device: COMPARE sX, kk.
085 0919A        579                             JUMP            z, end_rsc_data_loop
086 04401        580                             ADD             s4, #0x01
087 08190        581                             JUMP            rsc_loop
088 083EC        582     end_rsc_data_loop:      CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
089 0831C        583                             CALL            read_send_test_crc16    ;read, display and test CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
08A 08103        584                             JUMP            warm_start
                 585     ;
                 586     ;
                 587     ;
                 588     ;
                 589     ;
                 590     ;**************************************************************************************
                 591     ; DS2432 Read Authenticated Page Command.
                 592     ;**************************************************************************************
                 593     ;
                 594     ; The read authenticated page command (A5 hex) allows the 8-byte secret to be tested
                 595     ; without it actually being read (which would obviously give away the secret!).
                 596     ;
                 597     ; This routine has been written to work with page 0 but could easily be changed and
                 598     ; is documented below. During the first part of the command, the 32 bytes
                 599     ; contained in the page are read back from the DS2432 and these are used in
                 600     ; the preparation of the table required for the for SHA-1 algorithm. Other values
                 601     ; stored in the table are the secret, serial number of the DS2432, family code, some
                 602     ; constants, 4-bits of the page address and a 3 byte 'challenge' currently set into
                 603     ; the DS2432 scratchpad memory.
                 604     ;
                 605     ; NOTE - The read scratchpad command must be executed before this routine in order
                 606     ; that the 3 byte 'challenge' of scratchpad memory is known to PicoBlaze.
                 607     ;
                 608     ; During this command, two 16-bit CRC values are generated which PicoBlaze also
                 609     ; computes and tests. The first is formed of the command byte, address TA1 and TA2,
                 610     ; all the bytes of the page read and an 'FF' byte. The second is formed of the 20
                 611     ; bytes of the 160-but message authentication code (MAC).
                 612     ;
                 613     ;
                 614     ; Preparing the table.
                 615     ;
                 616     ; The table is stored in the external 'Wt' buffer and must first be initialised with the
                 617     ; 16 'M' words (32-bit words each requiring 4 bytes). This is achieved by shifting in
                 618     ; each word in sequence. Storing each word most significant byte first is a natural
                 619     ; fit with the reading of the page data from the DS2432 and the way each 'M' word
                 620     ; is organised. Notice how this causes least significant bytes to be swapped with most
                 621     ; significant bytes!
                 622     ;
                 623     ;          [31:24]      [23:16]      [15:8]       [7:0]
                 624     ;
                 625     ;   M0 = [secret0    , secret1    , secret2    , secret3    ]
                 626     ;   M1 = [page_data0 , page_data1 , page_data2 , page_data3 ]
                 627     ;   M2 = [page_data4 , page_data5 , page_data6 , page_data7 ]
                 628     ;   M3 = [page_data8 , page_data9 , page_data10, page_data11]
                 629     ;   M4 = [page_data12, page_data13, page_data14, page_data15]
                 630     ;   M5 = [page_data16, page_data17, page_data18, page_data19]
                 631     ;   M6 = [page_data20, page_data21, page_data22, page_data23]
                 632     ;   M7 = [page_data24, page_data25, page_data26, page_data27]
                 633     ;   M8 = [page_data28, page_data29, page_data30, page_data31]
                 634     ;   M9 = [   FF      ,    FF      ,    FF      ,    FF      ]
                 635     ;  M10 = [   40      ,    33      , serial_num0, serial_num1]
                 636     ;  M11 = [serial_num2, serial_num3, serial_num4, serial_num5]
                 637     ;  M12 = [secret4    , secret5    , secret6    , secret7    ]
                 638     ;  M13 = [scratchpad4, scratchpad5, scratchpad6,    80      ]
                 639     ;  M14 = [   00      ,    00      ,    00      ,    00      ]
                 640     ;  M15 = [   00      ,    00      ,    01      ,    B8      ]
                 641     ;
                 642     ; In M10, the '33' is the family code and the '40' is made up of a constant bit
                 643     ; pattern '0100' and then bits [8:5] of the page address. This gives 4 possible values
                 644     ; for this byte during a Read Authenticated Page Command, but this routine is currently
                 645     ; fixed to work with page 0 only.
                 646     ;        40 - page 0
                 647     ;        41 - page 1
                 648     ;        42 - page 2
                 649     ;        43 - page 3
                 650     ;
                 651     ; M13 contains the 3 byte challenge from the scratch pad memory. This assumes that a
                 652     ; read scratchpad command has previously been used and the bytes held in the DS2432
                 653     ; scratchpad match those held in the PicoBlaze memory.
                 654     ;
                 655     ;
                 656     ; The 160-bit Message Authentication Code (MAC) is computed from the table using the SHA-1
                 657     ; algorithm. This algorithm actually results in 5 variables 'A', 'B', 'C', 'D' and 'E'
                 658     ; which are 32-bit values each formed of 4 bytes. The MAC is the concatenation of
                 659     ; the variables. To match the same order in which the Read Authenticated Page Command
                 660     ; sends the MAC, the variables must be read in the order 'E', 'D', 'C', 'B' and 'A' and
                 661     ; with the least significant byte of each variable first.
                 662     ;
                 663     ;
                 664     ;
                 665     ;
                 666     ;
08B 00001        667     read_auth_page_command: LOAD            s0, #secret0            ;store M0 (secret 0, 1, 2 and 3) in Wt buffer.
08C 0E010        668                             OUTPUT          s0, w_word_write_port
08D 00023        669                             LOAD            s0, #secret1
08E 0E010        670                             OUTPUT          s0, w_word_write_port
08F 00045        671                             LOAD            s0, #secret2
090 0E010        672                             OUTPUT          s0, w_word_write_port
091 00067        673                             LOAD            s0, #secret3
092 0E010        674                             OUTPUT          s0, w_word_write_port
                 675     ;
                 676     ;Start of DS2432 command
                 677     ;
093 0830B        678                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
094 003A5        679                             LOAD            s3, #0xa5               ;read authenticated page command
095 0834E        680                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
096 0830E        681                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
097 00500        682                             LOAD            s5, #0x00               ;set address for page 0
098 00400        683                             LOAD            s4, #0x00               ;  [TA2,TA1]=0000 hex
099 0C340        684                             LOAD            s3, s4                  ;transmit TA1
09A 0834E        685                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
09B 0830E        686                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
09C 0C350        687                             LOAD            s3, s5                  ;transmit TA2
09D 0834E        688                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
09E 0830E        689                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
                 690     ;
                 691     ;Read 32-bytes of data associated with page 0
                 692     ;Store these as M1 through to M8
                 693     ;
09F 083EC        694     rapc_line_loop:         CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
0A0 0C050        695                             LOAD            s0, s5                  ;display 16-bit address
0A1 083C2        696                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0A2 0C040        697                             LOAD            s0, s4
0A3 083C2        698                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0A4 083EF        699                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
0A5 083EF        700                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
0A6 083EF        701     rapc_data_loop:         CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
0A7 0836F        702                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
0A8 0830E        703                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0A9 0E310        704                             OUTPUT          s3, w_word_write_port   ;store as 'M' word
0AA 0C030        705                             LOAD            s0, s3                  ;display byte
0AB 083C2        706                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0AC 04401        707                             ADD             s4, #0x01               ;increment address
0AD 05500        708                             ADDCY           s5, #0x00
                 709                             TEST            s4, #0x07               ;test for 8-byte boundary
E: instruction not supported on the this device: TEST sX, kk.
0AE 095B8        710                             JUMP            nz, rapc_data_loop
                 711                             COMPARE         s4, #0x20               ;test for last address
E: instruction not supported on the this device: COMPARE sX, kk.
0AF 095B1        712                             JUMP            nz, rapc_line_loop
0B0 083EC        713                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
                 714     ;
                 715     ;Read one byte that should be value FF hex
                 716     ;
0B1 0836F        717                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
0B2 0830E        718                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0B3 0C030        719                             LOAD            s0, s3                  ;display byte
0B4 083C2        720                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0B5 083EC        721                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
0B6 0831C        722                             CALL            read_send_test_crc16    ;read, display and test CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
                 723     ;
                 724     ;Complete table by stroring M9 through to M15
                 725     ;
0B7 000FF        726                             LOAD            s0, #0xff               ;W9 = FF FF FF FF
0B8 00104        727                             LOAD            s1, #0x04
0B9 0E010        728     store_w9:               OUTPUT          s0, w_word_write_port
0BA 06101        729                             SUB             s1, #0x01
0BB 095CD        730                             JUMP            nz, store_w9
                 731     ;
0BC 00040        732                             LOAD            s0, #0x40               ;W10 begins with 40 for page 0
0BD 0E010        733                             OUTPUT          s0, w_word_write_port
                 734     ;
                 735     ;W10 ends with family code and serial number 0 and 1.
                 736     ;W11 is formed of serial number 2, 3, 4 and 5.
                 737     ;All of this information is in PicoBlaze memory having been read by the
                 738     ;read ROM command.
                 739     ;
0BE 00100        740                             LOAD            s1, #family_code        ;pointer to memory
0BF 00207        741                             LOAD            s2, #0x07               ;7 bytes to read and store
  000D4          742     next_m10_m11:           FETCH           s0, @s1
E: instruction not supported on the this device: FETCH sX, sY.
0C0 0E010        743                             OUTPUT          s0, w_word_write_port
0C1 04101        744                             ADD             s1, #0x01               ;increment pointer
0C2 06201        745                             SUB             s2, #0x01
0C3 095D4        746                             JUMP            nz, next_m10_m11
                 747     ;
0C4 00089        748                             LOAD            s0, #secret4            ;store M12 (secret 4, 5, 6 and 7) in Wt buffer
0C5 0E010        749                             OUTPUT          s0, w_word_write_port
0C6 000AB        750                             LOAD            s0, #secret5
0C7 0E010        751                             OUTPUT          s0, w_word_write_port
0C8 000CD        752                             LOAD            s0, #secret6
0C9 0E010        753                             OUTPUT          s0, w_word_write_port
0CA 000EF        754                             LOAD            s0, #secret7
0CB 0E010        755                             OUTPUT          s0, w_word_write_port
                 756     ;
                 757                             FETCH           s0, scratchpad4         ;M13 uses scratchpad 4, 5, and 6 and '80' hex
E: instruction not supported on the this device: FETCH sX, ss.
0CC 0E010        758                             OUTPUT          s0, w_word_write_port
                 759                             FETCH           s0, scratchpad5
E: instruction not supported on the this device: FETCH sX, ss.
0CD 0E010        760                             OUTPUT          s0, w_word_write_port
                 761                             FETCH           s0, scratchpad6
E: instruction not supported on the this device: FETCH sX, ss.
0CE 0E010        762                             OUTPUT          s0, w_word_write_port
0CF 00080        763                             LOAD            s0, #0x80
0D0 0E010        764                             OUTPUT          s0, w_word_write_port
                 765     ;
0D1 00000        766                             LOAD            s0, #0x00               ;W14 = 00 00 00 00   W15 = 00 00 01 B8
0D2 00106        767                             LOAD            s1, #0x06
0D3 0E010        768     store_w14_w15:          OUTPUT          s0, w_word_write_port
0D4 06101        769                             SUB             s1, #0x01
0D5 095EB        770                             JUMP            nz, store_w14_w15
0D6 00001        771                             LOAD            s0, #0x01
0D7 0E010        772                             OUTPUT          s0, w_word_write_port
0D8 000B8        773                             LOAD            s0, #0xb8
0D9 0E010        774                             OUTPUT          s0, w_word_write_port
                 775     ;
                 776     ;Compute the SHA-1 algorithm at the same time that the DS2432 is also computing (2ms).
                 777     ;
0DA 08315        778                             CALL            compute_sha1
W: value out of range: 0x115, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x15.
                 779     ;
                 780     ;The 160-bit Message Authentication Code is read from the DS2432 as 20 bytes
                 781     ;and compared with the concatenation of variables E, D, C, B and A in that order
                 782     ;with each variable received from the DS2432 least significant byte first.
                 783     ;Each received byte is also used to form a 16-bit CRC value which is tested to
                 784     ;reveal any communication errors.
                 785     ;
                 786     ;
0DB 083E7        787                             CALL            send_mac                ;display 'mac='
W: value out of range: 0x3e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
0DC 0830B        788                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
0DD 00C00        789                             LOAD            sc, #0x00               ;Clear byte match counter
0DE 00B18        790                             LOAD            sb, #var_e0             ;start match with LS-Byte of variable 'E'
0DF 00A04        791     mac_match_var:          LOAD            sa, #0x04               ;4 bytes to match in each variable
  000F8          792     mac_match_byte:         FETCH           s9, @sb                 ;read variable byte from local SHA-1
E: instruction not supported on the this device: FETCH sX, sY.
0E0 0836F        793                             CALL            read_byte_slow          ;read DS2432 byte into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
0E1 0830E        794                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
                 795                             COMPARE         s3, s9                  ;compare MAC values
E: instruction not supported on the this device: COMPARE sX, sY.
0E2 095FE        796                             JUMP            nz, display_mac_byte    ;count matching bytes
0E3 04C01        797                             ADD             sc, #0x01               ;decrement match counter
0E4 0C030        798     display_mac_byte:       LOAD            s0, s3                  ;display byte
0E5 083C2        799                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0E6 083EF        800                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
0E7 06A01        801                             SUB             sa, #0x01               ;counts bytes per variable
0E8 09105        802                             JUMP            z, next_mac_var
W: value out of range: 0x105, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5.
0E9 04B01        803                             ADD             sb, #0x01
0EA 081F8        804                             JUMP            mac_match_byte
  00105          805     next_mac_var:           COMPARE         sb, #var_a3             ;test for last byte
E: instruction not supported on the this device: COMPARE sX, kk.
0EB 09109        806                             JUMP            z, report_mac
W: value out of range: 0x109, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9.
0EC 06B07        807                             SUB             sb, #0x07               ;point to next variable
0ED 081F7        808                             JUMP            mac_match_var
                 809     ;
                 810     ;MAC has passed if all 20 bytes matched
                 811     ;
0EE 083EC        812     report_mac:             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
                 813                             COMPARE         sc, #0x14               ;20 bytes should have matched
E: instruction not supported on the this device: COMPARE sX, kk.
0EF 0950E        814                             JUMP            nz, mac_fail
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0F0 083AD        815                             CALL            send_pass
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
0F1 0810F        816                             JUMP            read_mac_crc
W: value out of range: 0x10f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf.
0F2 083B4        817     mac_fail:               CALL            send_fail
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
                 818     ;
                 819     ;Next two bytes received are the 16-bit CRC
                 820     ;Read 16-bit CRC into [s5,s4] and send value to UART
                 821     ;
0F3 0831C        822     read_mac_crc:           CALL            read_send_test_crc16    ;read, display and test CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
                 823     ;
                 824     ;Read one byte that should be value AA hex.
                 825     ;  Would actually read AA hex continuously until master reset
                 826     ;
0F4 0836F        827                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
0F5 0C030        828                             LOAD            s0, s3                  ;display byte
0F6 083C2        829                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0F7 083EC        830                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
                 831     ;
0F8 08103        832                             JUMP            warm_start
                 833     ;
                 834     ;
                 835     ;**************************************************************************************
                 836     ; Compute SHA-1 Algorithm.
                 837     ;**************************************************************************************
                 838     ;
                 839     ; Computes the SHA-1 algorithm based on the initial table of values (M0 through to M15)
                 840     ; which are stored in the external Wt buffer.
                 841     ;
                 842     ; The SHA-1 algorithms uses 5 variables called 'A', 'B', 'C', 'D' and 'E'. Each variable
                 843     ; is 32-bits and stored as 4 bytes in PicoBlaze scratch pad memory. The locations must
                 844     ; be defined using constants 'var_A0' thought to 'var_E3' in ascending locations.
                 845     ;
                 846     ; Constants must also be used to define access to the external Wt buffer.
                 847     ;
                 848     ; During this process, register 'sE' is used to count iterations from 0 to 79 (4F hex).
                 849     ; Other registers are consistently grouped as follows to support 32-bit operations.
                 850     ;
                 851     ; Register set [s5,s4,s3,s2] is used as a temporary 32-bit word
                 852     ; Register set [s9,s8,s7,s6] is used as a temporary 32-bit word
                 853     ; Register set [sD,sC,sB,sA] is used as a temporary 32-bit word
                 854     ;
                 855     ;
                 856     ; Initialise the 32-bit variables
                 857     ;
                 858     ;
0F9 00001        859     compute_sha1:           LOAD            s0, #0x01               ;A=67452301
                 860                             STORE           s0, var_a0
E: instruction not supported on the this device: STORE sX, ss.
0FA 00023        861                             LOAD            s0, #0x23
                 862                             STORE           s0, var_a1
E: instruction not supported on the this device: STORE sX, ss.
0FB 00045        863                             LOAD            s0, #0x45
                 864                             STORE           s0, var_a2
E: instruction not supported on the this device: STORE sX, ss.
0FC 00067        865                             LOAD            s0, #0x67
                 866                             STORE           s0, var_a3
E: instruction not supported on the this device: STORE sX, ss.
0FD 00089        867                             LOAD            s0, #0x89               ;B=EFCDAB89
                 868                             STORE           s0, var_b0
E: instruction not supported on the this device: STORE sX, ss.
0FE 000AB        869                             LOAD            s0, #0xab
                 870                             STORE           s0, var_b1
E: instruction not supported on the this device: STORE sX, ss.
0FF 000CD        871                             LOAD            s0, #0xcd
                 872                             STORE           s0, var_b2
E: instruction not supported on the this device: STORE sX, ss.
100 000EF        873                             LOAD            s0, #0xef
                 874                             STORE           s0, var_b3
E: instruction not supported on the this device: STORE sX, ss.
101 000FE        875                             LOAD            s0, #0xfe               ;C=98BADCFE
                 876                             STORE           s0, var_c0
E: instruction not supported on the this device: STORE sX, ss.
102 000DC        877                             LOAD            s0, #0xdc
                 878                             STORE           s0, var_c1
E: instruction not supported on the this device: STORE sX, ss.
103 000BA        879                             LOAD            s0, #0xba
                 880                             STORE           s0, var_c2
E: instruction not supported on the this device: STORE sX, ss.
104 00098        881                             LOAD            s0, #0x98
                 882                             STORE           s0, var_c3
E: instruction not supported on the this device: STORE sX, ss.
105 00076        883                             LOAD            s0, #0x76               ;D=10325476
                 884                             STORE           s0, var_d0
E: instruction not supported on the this device: STORE sX, ss.
106 00054        885                             LOAD            s0, #0x54
                 886                             STORE           s0, var_d1
E: instruction not supported on the this device: STORE sX, ss.
107 00032        887                             LOAD            s0, #0x32
                 888                             STORE           s0, var_d2
E: instruction not supported on the this device: STORE sX, ss.
108 00010        889                             LOAD            s0, #0x10
                 890                             STORE           s0, var_d3
E: instruction not supported on the this device: STORE sX, ss.
109 000F0        891                             LOAD            s0, #0xf0               ;E=C3D2E1F0
                 892                             STORE           s0, var_e0
E: instruction not supported on the this device: STORE sX, ss.
10A 000E1        893                             LOAD            s0, #0xe1
                 894                             STORE           s0, var_e1
E: instruction not supported on the this device: STORE sX, ss.
10B 000D2        895                             LOAD            s0, #0xd2
                 896                             STORE           s0, var_e2
E: instruction not supported on the this device: STORE sX, ss.
10C 000C3        897                             LOAD            s0, #0xc3
                 898                             STORE           s0, var_e3
E: instruction not supported on the this device: STORE sX, ss.
                 899     ;
                 900     ;
10D 00E00        901                             LOAD            se, #0x00               ;reset iteration counter
                 902     ;
                 903     ;
                 904     ;Compute ft(B,C,D) in register set [s5,s4,s3,s2] and then add constant Kt.
                 905     ;
                 906     ;Iterations 0 to 19 - process type 1
                 907     ;   ft = (B and C) or ((not B) and D)
                 908     ;  Then the constant Kt=5A827999 will be added
                 909     ;
                 910     ;Iterations 20 to 39  and iterations 60 to 79  - process type 2
                 911     ;   ft = B xor C xor D
                 912     ;  Then the constant Kt=6ED9EBA1 will be added for iterations 20 to 39
                 913     ;  Then the constant Kt=CA62C1D6 will be added for iterations 60 to 79
                 914     ;
                 915     ;Iterations 40 to 59  - process type 3
                 916     ;   ft = (B and C) or (B and D) or (C and D)
                 917     ;  Then the constant Kt=8F1BBCDC will be added
                 918     ;
  0013E          919     next_sha1_iteration:    FETCH           s5, var_b3              ;B in [s5,s4,s3,s2]
E: instruction not supported on the this device: FETCH sX, ss.
                 920                             FETCH           s4, var_b2
E: instruction not supported on the this device: FETCH sX, ss.
                 921                             FETCH           s3, var_b1
E: instruction not supported on the this device: FETCH sX, ss.
                 922                             FETCH           s2, var_b0
E: instruction not supported on the this device: FETCH sX, ss.
10E 08376        923                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
W: value out of range: 0x176, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x76.
                 924                             FETCH           sd, var_d3              ;D in [sD,sC,sB,sA]
E: instruction not supported on the this device: FETCH sX, ss.
                 925                             FETCH           sc, var_d2
E: instruction not supported on the this device: FETCH sX, ss.
                 926                             FETCH           sb, var_d1
E: instruction not supported on the this device: FETCH sX, ss.
                 927                             FETCH           sa, var_d0
E: instruction not supported on the this device: FETCH sX, ss.
                 928     ;
                 929     ;Determine process type
                 930     ;
                 931                             COMPARE         se, #0x14               ;set carry flag for iterations <20
E: instruction not supported on the this device: COMPARE sX, kk.
10F 09961        932                             JUMP            c, ft_type1
W: value out of range: 0x161, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x61.
                 933                             COMPARE         se, #0x28               ;set carry flag for iterations <40
E: instruction not supported on the this device: COMPARE sX, kk.
110 0994D        934                             JUMP            c, ft_type2
W: value out of range: 0x14d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4d.
                 935                             COMPARE         se, #0x3c               ;set carry flag for iterations <60
E: instruction not supported on the this device: COMPARE sX, kk.
111 0997B        936                             JUMP            c, ft_type3
W: value out of range: 0x17b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7b.
                 937     ;
                 938     ;   ft = B xor C xor D
                 939     ;
                 940     ;       B xor C     =        B       xor       C
                 941     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [s9,s8,s7,s6]
                 942     ;
                 943     ;   B xor C xor D   =    (B xor C)   xor       D
                 944     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [sD,sC,sB,sA]
                 945     ;
                 946     ;
112 0C593        947     ft_type2:               XOR             s5, s9                  ;B xor C in [s5,s4,s3,s2]
113 0C483        948                             XOR             s4, s8
114 0C373        949                             XOR             s3, s7
115 0C263        950                             XOR             s2, s6
116 0C5D3        951                             XOR             s5, sd                  ;(B xor C) xor D in [s5,s4,s3,s2]
117 0C4C3        952                             XOR             s4, sc
118 0C3B3        953                             XOR             s3, sb
119 0C2A3        954                             XOR             s2, sa
                 955                             COMPARE         se, #0x3c               ;set carry flag for iterations <60
E: instruction not supported on the this device: COMPARE sX, kk.
11A 09D5C        956                             JUMP            nc, kt_ca62c1d6
W: value out of range: 0x15c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5c.
11B 042A1        957                             ADD             s2, #0xa1               ;add Kt=6ED9EBA1
11C 053EB        958                             ADDCY           s3, #0xeb
11D 054D9        959                             ADDCY           s4, #0xd9
11E 0556E        960                             ADDCY           s5, #0x6e
11F 08194        961                             JUMP            compute_tmp
W: value out of range: 0x194, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x94.
120 042D6        962     kt_ca62c1d6:            ADD             s2, #0xd6               ;add Kt=CA62C1D6
121 053C1        963                             ADDCY           s3, #0xc1
122 05462        964                             ADDCY           s4, #0x62
123 055CA        965                             ADDCY           s5, #0xca
124 08194        966                             JUMP            compute_tmp
W: value out of range: 0x194, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x94.
                 967     ;
                 968     ;   ft = (B and C) or ((not B) and D)
                 969     ;
                 970     ;       B and C     =        C       and       B
                 971     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                 972     ;
                 973     ;       not B       =        B       xor   FFFFFFFF
                 974     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [FF,FF,FF,FF]
                 975     ;
                 976     ;   (not B) and D   =    (not B)     and       D
                 977     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                 978     ;
                 979     ;   ;(B and C) or ((not B) and D)  =  ((not B) and D)  or   (B and C)
                 980     ;            [s5,s4,s3,s2]         =   [s5,s4,s3,s2]   or  [s9,s8,s7,s6]
                 981     ;
125 0C951        982     ft_type1:               AND             s9, s5                  ;B and C in [s9,s8,s7,s6]
126 0C841        983                             AND             s8, s4
127 0C731        984                             AND             s7, s3
128 0C621        985                             AND             s6, s2
129 035FF        986                             XOR             s5, #0xff               ;(not B) in [s5,s4,s3,s2]
12A 034FF        987                             XOR             s4, #0xff
12B 033FF        988                             XOR             s3, #0xff
12C 032FF        989                             XOR             s2, #0xff
12D 0C5D1        990                             AND             s5, sd                  ;((not B) and D) in [s5,s4,s3,s2]
12E 0C4C1        991                             AND             s4, sc
12F 0C3B1        992                             AND             s3, sb
130 0C2A1        993                             AND             s2, sa
131 0C592        994                             OR              s5, s9                  ;(B and C) or ((not B) and D) in [s5,s4,s3,s2]
132 0C482        995                             OR              s4, s8
133 0C372        996                             OR              s3, s7
134 0C262        997                             OR              s2, s6
135 04299        998                             ADD             s2, #0x99               ;add Kt=5A827999
136 05379        999                             ADDCY           s3, #0x79
137 05482       1000                             ADDCY           s4, #0x82
138 0555A       1001                             ADDCY           s5, #0x5a
139 08194       1002                             JUMP            compute_tmp
W: value out of range: 0x194, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x94.
                1003     ;
                1004     ;Routine to fetch variable 'C' into register set [s9,s8,s7,s6]
                1005     ;
  00176         1006     fetch_c:                FETCH           s9, var_c3
E: instruction not supported on the this device: FETCH sX, ss.
                1007                             FETCH           s8, var_c2
E: instruction not supported on the this device: FETCH sX, ss.
                1008                             FETCH           s7, var_c1
E: instruction not supported on the this device: FETCH sX, ss.
                1009                             FETCH           s6, var_c0
E: instruction not supported on the this device: FETCH sX, ss.
13A 08080       1010                             RETURN
                1011     ;
                1012     ;   ft = (B and C) or (B and D) or (C and D)
                1013     ;
                1014     ;       B and C     =        C       and       B
                1015     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                1016     ;
                1017     ;       B and D     =        B       and       D
                1018     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                1019     ;
                1020     ;  (B and C) or (B and D)   =    (B and D)    or    (B and C)
                1021     ;      [s5,s4,s3,s2]        =  [s5,s4,s3,s2]  or  [s9,s8,s7,s6]
                1022     ;
                1023     ;     read C again into [s9,s8,s7,s6]
                1024     ;
                1025     ;       C and D     =        C       and       D
                1026     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [sD,sC,sB,sA]
                1027     ;
                1028     ;  ((B and C) or (B and D)) or (C and D)   =    ((B and C) or (B and D)) or   (C and D)
                1029     ;               [s5,s4,s3,s2]              =           [s5,s4,s3,s2]     or  [s9,s8,s7,s6]
                1030     ;
13B 0C951       1031     ft_type3:               AND             s9, s5                  ;(B and C) in [s9,s8,s7,s6]
13C 0C841       1032                             AND             s8, s4
13D 0C731       1033                             AND             s7, s3
13E 0C621       1034                             AND             s6, s2
13F 0C5D1       1035                             AND             s5, sd                  ;(B and D) in [s5,s4,s3,s2]
140 0C4C1       1036                             AND             s4, sc
141 0C3B1       1037                             AND             s3, sb
142 0C2A1       1038                             AND             s2, sa
143 0C592       1039                             OR              s5, s9                  ;(B and C) or (B and D) in [s5,s4,s3,s2]
144 0C482       1040                             OR              s4, s8
145 0C372       1041                             OR              s3, s7
146 0C262       1042                             OR              s2, s6
147 08376       1043                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
W: value out of range: 0x176, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x76.
148 0C9D1       1044                             AND             s9, sd                  ;(C and D) in [s9,s8,s7,s6]
149 0C8C1       1045                             AND             s8, sc
14A 0C7B1       1046                             AND             s7, sb
14B 0C6A1       1047                             AND             s6, sa
14C 0C592       1048                             OR              s5, s9                  ;(B and C) or (B and D) or (C and D) in [s5,s4,s3,s2]
14D 0C482       1049                             OR              s4, s8
14E 0C372       1050                             OR              s3, s7
14F 0C262       1051                             OR              s2, s6
150 042DC       1052                             ADD             s2, #0xdc               ;add Kt=8F1BBCDC
151 053BC       1053                             ADDCY           s3, #0xbc
152 0541B       1054                             ADDCY           s4, #0x1b
153 0558F       1055                             ADDCY           s5, #0x8f
                1056     ;
                1057     ;Add variable 'E' to [s5,s4,s3,s2]
                1058     ;
  00194         1059     compute_tmp:            FETCH           s0, var_e0
E: instruction not supported on the this device: FETCH sX, ss.
154 0C204       1060                             ADD             s2, s0
                1061                             FETCH           s0, var_e1
E: instruction not supported on the this device: FETCH sX, ss.
155 0C305       1062                             ADDCY           s3, s0
                1063                             FETCH           s0, var_e2
E: instruction not supported on the this device: FETCH sX, ss.
156 0C405       1064                             ADDCY           s4, s0
                1065                             FETCH           s0, var_e3
E: instruction not supported on the this device: FETCH sX, ss.
157 0C505       1066                             ADDCY           s5, s0
                1067     ;
                1068     ;Add variable 'A' rotated left 5 places
                1069     ;
                1070                             FETCH           s9, var_a3              ;A in [s9,s8,s7,s6]
E: instruction not supported on the this device: FETCH sX, ss.
                1071                             FETCH           s8, var_a2
E: instruction not supported on the this device: FETCH sX, ss.
                1072                             FETCH           s7, var_a1
E: instruction not supported on the this device: FETCH sX, ss.
                1073                             FETCH           s6, var_a0
E: instruction not supported on the this device: FETCH sX, ss.
158 00005       1074                             LOAD            s0, #0x05               ;rotate left 5 places
159 083E7       1075                             CALL            rotate_word_left_n_places
W: value out of range: 0x1e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
15A 0C264       1076                             ADD             s2, s6                  ;add to TMP
15B 0C375       1077                             ADDCY           s3, s7
15C 0C485       1078                             ADDCY           s4, s8
15D 0C595       1079                             ADDCY           s5, s9
                1080     ;
                1081     ;
                1082     ;Compute Wt in register set [s9,s8,s7,s6]
                1083     ;  Value computed is also stored back in the external buffer for
                1084     ;  use in later iterations as well as being added to TMP.
                1085     ;
                1086     ;Iterations 0 to 15
                1087     ;  Wt = Mt
                1088     ; This only requires Wt-16 to be read and then shifted back into the buffer again.
                1089     ;
                1090     ;Iterations 0 to 15
                1091     ;  Wt = rotate_left_1_place(Wt-3 xor Wt-8 xor Wt-14 xor Wt-16)
                1092     ; This requires all data values to be read first. Then XORed and rotated before
                1093     ; shifting the new Wt word into the buffer.
                1094     ;
                1095     ;
15E 0A93F       1096                             INPUT           s9, wt_minus16_byte3_read_port ;Read Wt-16 value
15F 0A83E       1097                             INPUT           s8, wt_minus16_byte2_read_port
160 0A73D       1098                             INPUT           s7, wt_minus16_byte1_read_port
161 0A63C       1099                             INPUT           s6, wt_minus16_byte0_read_port
                1100                             COMPARE         se, #0x10               ;set carry flag for iterations 0 to 15
E: instruction not supported on the this device: COMPARE sX, kk.
162 099C5       1101                             JUMP            c, store_wt
W: value out of range: 0x1c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                1102     ;
                1103     ;Read other Wt words and perform XOR
                1104     ;
163 0A037       1105                             INPUT           s0, wt_minus14_byte3_read_port ;XOR with Wt-14 value
164 0C903       1106                             XOR             s9, s0
165 0A036       1107                             INPUT           s0, wt_minus14_byte2_read_port
166 0C803       1108                             XOR             s8, s0
167 0A035       1109                             INPUT           s0, wt_minus14_byte1_read_port
168 0C703       1110                             XOR             s7, s0
169 0A034       1111                             INPUT           s0, wt_minus14_byte0_read_port
16A 0C603       1112                             XOR             s6, s0
16B 0A01F       1113                             INPUT           s0, wt_minus8_byte3_read_port ;XOR with Wt-8 value
16C 0C903       1114                             XOR             s9, s0
16D 0A01E       1115                             INPUT           s0, wt_minus8_byte2_read_port
16E 0C803       1116                             XOR             s8, s0
16F 0A01D       1117                             INPUT           s0, wt_minus8_byte1_read_port
170 0C703       1118                             XOR             s7, s0
171 0A01C       1119                             INPUT           s0, wt_minus8_byte0_read_port
172 0C603       1120                             XOR             s6, s0
173 0A00B       1121                             INPUT           s0, wt_minus3_byte3_read_port ;XOR with Wt-3 value
174 0C903       1122                             XOR             s9, s0
175 0A00A       1123                             INPUT           s0, wt_minus3_byte2_read_port
176 0C803       1124                             XOR             s8, s0
177 0A009       1125                             INPUT           s0, wt_minus3_byte1_read_port
178 0C703       1126                             XOR             s7, s0
179 0A008       1127                             INPUT           s0, wt_minus3_byte0_read_port
17A 0C603       1128                             XOR             s6, s0
17B 083EB       1129                             CALL            rotate_word_left        ;rotate XORed word left by one place
W: value out of range: 0x1eb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xeb.
                1130     ;
                1131     ;Store new Wt value in external buffer
                1132     ;
17C 0E910       1133     store_wt:               OUTPUT          s9, w_word_write_port
17D 0E810       1134                             OUTPUT          s8, w_word_write_port
17E 0E710       1135                             OUTPUT          s7, w_word_write_port
17F 0E610       1136                             OUTPUT          s6, w_word_write_port
                1137     ;
                1138     ;Add new computed Wt value to TMP in [s5,s4,s3,s2]
                1139     ;
180 0C264       1140                             ADD             s2, s6
181 0C375       1141                             ADDCY           s3, s7
182 0C485       1142                             ADDCY           s4, s8
183 0C595       1143                             ADDCY           s5, s9
                1144     ;
                1145     ;TMP is now complete in [s5,s4,s3,s2]
                1146     ;
                1147     ;
                1148     ;copy values
                1149     ;  E <= D
                1150     ;  D <= C
                1151     ;  C <= B (this will need to be rotated 30 places afterwards)
                1152     ;  B <= A
                1153     ;
184 00D04       1154                             LOAD            sd, #0x04               ;4 bytes per word to copy
185 00C1B       1155     copy_var_loop:          LOAD            sc, #var_e3
186 00B1A       1156                             LOAD            sb, #var_e2
  001D0         1157     move_var_loop:          FETCH           sa, @sb
E: instruction not supported on the this device: FETCH sX, sY.
                1158                             STORE           sa, @sc
E: instruction not supported on the this device: STORE sX, sY.
187 06C01       1159                             SUB             sc, #0x01
188 06B01       1160                             SUB             sb, #0x01
                1161                             COMPARE         sc, #var_a0
E: instruction not supported on the this device: COMPARE sX, kk.
189 095D0       1162                             JUMP            nz, move_var_loop
W: value out of range: 0x1d0, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd0.
18A 06D01       1163                             SUB             sd, #0x01
18B 095CE       1164                             JUMP            nz, copy_var_loop
W: value out of range: 0x1ce, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xce.
                1165     ;
                1166     ;rotate 'C' (the previous 'B') left 30 places
                1167     ;
18C 08376       1168                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
W: value out of range: 0x176, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x76.
18D 0001E       1169                             LOAD            s0, #0x1e               ;rotate left 30 places
18E 083E7       1170                             CALL            rotate_word_left_n_places
W: value out of range: 0x1e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
                1171                             STORE           s9, var_c3
E: instruction not supported on the this device: STORE sX, ss.
                1172                             STORE           s8, var_c2
E: instruction not supported on the this device: STORE sX, ss.
                1173                             STORE           s7, var_c1
E: instruction not supported on the this device: STORE sX, ss.
                1174                             STORE           s6, var_c0
E: instruction not supported on the this device: STORE sX, ss.
                1175     ;
                1176     ;  A <= TMP
                1177     ;
                1178                             STORE           s5, var_a3
E: instruction not supported on the this device: STORE sX, ss.
                1179                             STORE           s4, var_a2
E: instruction not supported on the this device: STORE sX, ss.
                1180                             STORE           s3, var_a1
E: instruction not supported on the this device: STORE sX, ss.
                1181                             STORE           s2, var_a0
E: instruction not supported on the this device: STORE sX, ss.
                1182     ;
                1183     ;count iterations
                1184     ;
                1185                             COMPARE         se, #0x4f               ;test for last iteration = 79 decimal (4F hex)
E: instruction not supported on the this device: COMPARE sX, kk.
18F 09080       1186                             RETURN          z
190 04E01       1187                             ADD             se, #0x01
191 0813E       1188                             JUMP            next_sha1_iteration
W: value out of range: 0x13e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x3e.
                1189     ;
                1190     ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1191     ; by the number of places specified in register 's0'.
                1192     ;
192 083EB       1193     rotate_word_left_n_places: CALL         rotate_word_left
W: value out of range: 0x1eb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xeb.
193 06001       1194                             SUB             s0, #0x01
194 095E7       1195                             JUMP            nz, rotate_word_left_n_places
W: value out of range: 0x1e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
195 08080       1196                             RETURN
                1197     ;
                1198     ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1199     ; by one place.
                1200     ;
  001EB         1201     rotate_word_left:       TEST            s9, #0x80               ;test MSB of word
E: instruction not supported on the this device: TEST sX, kk.
196 0D600       1202                             SLA             s6
197 0D700       1203                             SLA             s7
198 0D800       1204                             SLA             s8
199 0D900       1205                             SLA             s9
19A 08080       1206                             RETURN
                1207     ;
                1208     ;**************************************************************************************
                1209     ; Compute 8-bit CRC used by DS2432.
                1210     ;**************************************************************************************
                1211     ;
                1212     ; The DS2432 computes an 8-bit CRC using the polynomial X8 + X5 + X4 + 1.
                1213     ; See the DS2432 data sheet for full details.
                1214     ;
                1215     ; Test input value of value 00 00 00 01 B8 1C 02
                1216     ; should produce CRC=A2.
                1217     ;
                1218     ; This routine computes the same CRC based on the values stored in the KCPSM3
                1219     ; scratch pad memory by the read ROM command. The result is returned in register s0.
                1220     ;
                1221     ; Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9
                1222     ;
                1223     ;
                1224     ; Start by loading family code and serial number (56-bits) into register set
                1225     ; [s9,s8,s7,s6,s5,s4,s3] so that it can be shifted out LSB first.
                1226     ;
                1227     ;
  001F1         1228     compute_crc8:           FETCH           s3, family_code
E: instruction not supported on the this device: FETCH sX, ss.
                1229                             FETCH           s4, serial_number0
E: instruction not supported on the this device: FETCH sX, ss.
                1230                             FETCH           s5, serial_number1
E: instruction not supported on the this device: FETCH sX, ss.
                1231                             FETCH           s6, serial_number2
E: instruction not supported on the this device: FETCH sX, ss.
                1232                             FETCH           s7, serial_number3
E: instruction not supported on the this device: FETCH sX, ss.
                1233                             FETCH           s8, serial_number4
E: instruction not supported on the this device: FETCH sX, ss.
                1234                             FETCH           s9, serial_number5
E: instruction not supported on the this device: FETCH sX, ss.
19B 00238       1235                             LOAD            s2, #0x38               ;56 bits to shift (38 hex)
19C 00000       1236                             LOAD            s0, #0x00               ;clear CRC value
19D 0C100       1237     crc8_loop:              LOAD            s1, s0                  ;copy current CRC value
19E 0C133       1238                             XOR             s1, s3                  ;Need to know LSB XOR next input bit
                1239                             TEST            s1, #0x01               ;test result of XOR in LSB
E: instruction not supported on the this device: TEST sX, kk.
19F 09DFF       1240                             JUMP            nc, crc8_shift
W: value out of range: 0x1ff, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xff.
1A0 03018       1241                             XOR             s0, #0x18               ;compliment bits 3 and 4 of CRC
1A1 0D10E       1242     crc8_shift:             SR0             s1                      ;Carry gets LSB XOR next input bit
1A2 0D008       1243                             SRA             s0                      ;shift Carry into MSB to form new CRC value
1A3 0D90E       1244                             SR0             s9                      ;shift input value
1A4 0D808       1245                             SRA             s8
1A5 0D708       1246                             SRA             s7
1A6 0D608       1247                             SRA             s6
1A7 0D508       1248                             SRA             s5
1A8 0D408       1249                             SRA             s4
1A9 0D308       1250                             SRA             s3
1AA 06201       1251                             SUB             s2, #0x01               ;count iterations
1AB 095FA       1252                             JUMP            nz, crc8_loop
W: value out of range: 0x1fa, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfa.
1AC 08080       1253                             RETURN
                1254     ;
                1255     ;
                1256     ;
                1257     ;**************************************************************************************
                1258     ; Clear or Compute 16-bit CRC used by DS2432.
                1259     ;**************************************************************************************
                1260     ;
                1261     ; The DS2432 computes a 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                1262     ; See the DS2432 data sheet for full details.
                1263     ;
                1264     ; Note that the value formed in the CRC shift register MUST BE INVERTED to give the
                1265     ; same value as that sent from the DS2432 during scratchpad write, scratchpad read
                1266     ; and read auth page commands.
                1267     ;
                1268     ; The 16-bit CRC is computed using a different number of bytes depending on the
                1269     ; command. This routine has been written such that the CRC can be computed one
                1270     ; byte at a time. The byte to be processed should be provided in register 's3'
                1271     ; and the contents of this register are preserved.
                1272     ;
                1273     ; This routine computes the 16-bit CRC in the register pair [sE,sD] and these
                1274     ; registers must not be disturbed between calls of this routine.
                1275     ;
                1276     ; Before starting a CRC computation the 'clear_CRC16' should be used.
                1277     ;
                1278     ; Registers used s0,s1,s3,sD,sE
                1279     ;    s3 is preserved.
                1280     ;    sD and sE should not be disturbed between calls if CRC value is required.
                1281     ;
                1282     ;
1AD 00E00       1283     clear_crc16:            LOAD            se, #0x00               ;[sE,sD]=0000
1AE 00D00       1284                             LOAD            sd, #0x00
1AF 08080       1285                             RETURN
                1286     ;
1B0 00108       1287     compute_crc16:          LOAD            s1, #0x08               ;8-bits to shift
1B1 0C0D0       1288     crc16_loop:             LOAD            s0, sd                  ;copy current CRC value
1B2 0C033       1289                             XOR             s0, s3                  ;Need to know LSB XOR next input bit
                1290                             TEST            s0, #0x01               ;test result of XOR in LSB
E: instruction not supported on the this device: TEST sX, kk.
1B3 09D15       1291                             JUMP            nc, crc16_shift
W: value out of range: 0x215, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x15.
1B4 03D02       1292                             XOR             sd, #0x02               ;compliment bit 1 of CRC
1B5 03E40       1293                             XOR             se, #0x40               ;compliment bit 14 of CRC
1B6 0D00E       1294     crc16_shift:            SR0             s0                      ;Carry gets LSB XOR next input bit
1B7 0DE08       1295                             SRA             se                      ;shift Carry into MSB to form new CRC value
1B8 0DD08       1296                             SRA             sd
1B9 0D30C       1297                             RR              s3                      ;shift input value
1BA 06101       1298                             SUB             s1, #0x01               ;count bits
1BB 0950F       1299                             JUMP            nz, crc16_loop          ;next bit
W: value out of range: 0x20f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf.
1BC 08080       1300                             RETURN
                1301     ;
                1302     ;
                1303     ;**************************************************************************************
                1304     ; Read 16-bit CRC from DS2432, send value received to UART and test result.
                1305     ;**************************************************************************************
                1306     ;
                1307     ; The computed CRC value for comparison must be in register pair [sE,sD]
                1308     ;
1BD 0836F       1309     read_send_test_crc16:   CALL            read_byte_slow          ;read 16-bit CRC into [s5,s4]
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
1BE 0C430       1310                             LOAD            s4, s3
1BF 0836F       1311                             CALL            read_byte_slow
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
1C0 0C530       1312                             LOAD            s5, s3
1C1 083E2       1313                             CALL            send_crc                ;'crc=' to display CRC value
W: value out of range: 0x3e2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe2.
1C2 0C050       1314                             LOAD            s0, s5
1C3 083C2       1315                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
1C4 0C040       1316                             LOAD            s0, s4
1C5 083C2       1317                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
1C6 083EC       1318                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
1C7 03DFF       1319                             XOR             sd, #0xff               ;1's complement the computed CRC value
1C8 03EFF       1320                             XOR             se, #0xff
                1321                             COMPARE         s4, sd                  ;test received value with computed value
E: instruction not supported on the this device: COMPARE sX, sY.
1C9 0952E       1322                             JUMP            nz, crc16_fail
W: value out of range: 0x22e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2e.
                1323                             COMPARE         s5, se
E: instruction not supported on the this device: COMPARE sX, sY.
1CA 0952E       1324                             JUMP            nz, crc16_fail
W: value out of range: 0x22e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2e.
1CB 083AD       1325                             CALL            send_pass               ;display 'Pass' with carriage return
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
1CC 08080       1326                             RETURN
1CD 083B4       1327     crc16_fail:             CALL            send_fail               ;display 'Fail' with carriage return
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
1CE 08080       1328                             RETURN
                1329     ;
                1330     ;
                1331     ;**************************************************************************************
                1332     ; Initialise the DS2432 1-wire interface.
                1333     ;**************************************************************************************
                1334     ;
                1335     ; The 1-wire interface is an open-collector communication scheme employing an external
                1336     ; pull-up resistor of 680 Ohms.
                1337     ;
                1338     ; The hardware section of this translates the one bit signal from PicoBlaze such that
                1339     ; when this signal is Low the output is driven Low, but when it is High, it turns off
                1340     ; the output buffer and the signal is pulled High externally.
                1341     ;
                1342     ; This initialisation routine simply ensures that the line is High after configuration.
                1343     ; It is vital that DS_wire is generally in the High state because it is the only way in
                1344     ; which the DS2432 device derives power to operate.
                1345     ;
                1346     ; Registers used s0
                1347     ;
1CF 00001       1348     ds_wire_init:           LOAD            s0, #ds_wire
1D0 0E008       1349                             OUTPUT          s0, ds_wire_out_port
1D1 08080       1350                             RETURN
                1351     ;
                1352     ;
                1353     ;**************************************************************************************
                1354     ; DS2432 initialisation - Regular Speed.
                1355     ;**************************************************************************************
                1356     ;
                1357     ; The initialisation sequence must be performed before any communication can be
                1358     ; made with the DS2432 device. This involves the application of an active Low master
                1359     ; reset pulse.
                1360     ;
                1361     ; The regular (slow) speed communication is established by transmitting an active
                1362     ; Low reset pulse for a duration of at least 480us. This design generates a 500us pulse.
                1363     ;
                1364     ; The DS2432 acknowledges the reset and the setting of regular mode by generating an
                1365     ; active Low 'Rx Presence Pulse'. This presence pulse can start 15 to 60us after the
                1366     ; reset pulse and will end between 120 and 300us after the reset pulse.
                1367     ;
                1368     ; To confirm that regular mode has been set, this routine confirms that the presence pulse
                1369     ; is active only after 60us have elapsed since the reset pulse. This ensures that the
                1370     ; faster presence pulse of overdrive mode can not be detected.
                1371     ;
                1372     ; The carry flag will be set if no valid presence pulse was received (wire remained High) and
                1373     ; can be used to indicate an initialisation failure or success.
                1374     ;
                1375     ; The routine only completes 300us after the presence pulse to ensure the DS2432 has
                1376     ; completed the presence pulse and is ready for the first operation.
                1377     ;
                1378     ; Registers used s0,s1,s2
                1379     ;
1D2 00000       1380     ds_init_regular_mode:   LOAD            s0, #0x00               ;transmit reset pulse
1D3 0E008       1381                             OUTPUT          s0, ds_wire_out_port
                1382     ;Delay of 500us is equivalent to 12500 instructions at 50MHz.
                1383     ;This delay loop is formed of 28 instructions requiring 446 repetitions.
1D4 00201       1384                             LOAD            s2, #0x01               ;[s3,s2]=445 decimal (01BD hex)
1D5 001BD       1385                             LOAD            s1, #0xbd
1D6 08387       1386     rm_wait_500us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
1D7 06101       1387                             SUB             s1, #0x01               ;decrement delay counter
1D8 07200       1388                             SUBCY           s2, #0x00
1D9 09D37       1389                             JUMP            nc, rm_wait_500us       ;repeat until -1
W: value out of range: 0x237, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x37.
1DA 00001       1390                             LOAD            s0, #0x01               ;end of regular reset pulse
1DB 0E008       1391                             OUTPUT          s0, ds_wire_out_port
                1392     ;Delay of 60us is equivalent to 1500 instructions at 50MHz.
                1393     ;This delay and is formed of 27 instructions requiring 56 repetitions.
1DC 00138       1394                             LOAD            s1, #0x38               ;56 (38 hex)
1DD 08387       1395     rm_wait_60us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
1DE 06101       1396                             SUB             s1, #0x01               ;decrement delay counter
1DF 0953E       1397                             JUMP            nz, rm_wait_60us        ;repeat until zero
W: value out of range: 0x23e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x3e.
                1398     ;The DS_wire is now checked at approximately 1us intervals for the next 240us looking
                1399     ;to detect an active Low presence pulse. The 240us is equivalent to 6000 instructions
                1400     ;at 50MHz and this polling loop is formed of 33 instructions requiring 182 repetitions.
1E0 00201       1401                             LOAD            s2, #0x01               ;set bit which will be reset by a presence pulse
1E1 001B6       1402                             LOAD            s1, #0xb6               ;182 (B6 hex)
1E2 08387       1403     rm_poll_240us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
1E3 0834A       1404                             CALL            read_ds_wire            ;read wire - 5 instructions including CALL
W: value out of range: 0x24a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4a.
1E4 0C201       1405                             AND             s2, s0                  ;clear flag if DS_wire was Low
1E5 06101       1406                             SUB             s1, #0x01               ;decrement delay counter
1E6 09543       1407                             JUMP            nz, rm_poll_240us       ;repeat until zero
W: value out of range: 0x243, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x43.
                1408                             TEST            s2, #0x01               ;set carry flag if no pulse detected
E: instruction not supported on the this device: TEST sX, kk.
1E7 08080       1409                             RETURN
                1410     ;
                1411     ;
                1412     ;**************************************************************************************
                1413     ; Read the DS_wire
                1414     ;**************************************************************************************
                1415     ;
                1416     ; The DS_wire signal is read and returned in bit0 of register 's0'.
                1417     ; Additionally the carry flag is set if the signal is High and reset if Low
                1418     ;
                1419     ; Registers used s0
                1420     ;
1E8 0A0C0       1421     read_ds_wire:           INPUT           s0, ds_wire_in_port
1E9 01001       1422                             AND             s0, #ds_wire            ;ensure only bit0 is active
                1423                             TEST            s0, #ds_wire            ;set carry flag if DS_wire is High
E: instruction not supported on the this device: TEST sX, kk.
1EA 08080       1424                             RETURN
                1425     ;
                1426     ;
                1427     ;
                1428     ;**************************************************************************************
                1429     ; Write a byte to DS2432 in regular speed mode.
                1430     ;**************************************************************************************
                1431     ;
                1432     ; Bytes are written to the DS2432 with LSB first.
                1433     ;
                1434     ; The byte to be written should be provided in register 's3' and this will be preserved.
                1435     ;
                1436     ; Registers used s0,s1,s2,s3
                1437     ;
1EB 00208       1438     write_byte_slow:        LOAD            s2, #0x08               ;8 bits to transmit
1EC 0D30C       1439     wbs_loop:               RR              s3                      ;test next bit LSB first
1ED 09953       1440                             JUMP            c, wbs1                 ;transmit '0' or '1'
W: value out of range: 0x253, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x53.
1EE 08357       1441                             CALL            write_low_slow
W: value out of range: 0x257, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x57.
1EF 08154       1442                             JUMP            next_slow_bit
W: value out of range: 0x254, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x54.
1F0 08362       1443     wbs1:                   CALL            write_high_slow
W: value out of range: 0x262, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x62.
1F1 06201       1444     next_slow_bit:          SUB             s2, #0x01               ;count bits
1F2 0954F       1445                             JUMP            nz, wbs_loop            ;repeat until 8-bits transmitted
W: value out of range: 0x24f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4f.
1F3 08080       1446                             RETURN
                1447     ;
                1448     ;
                1449     ;
                1450     ;**************************************************************************************
                1451     ; Write a '0' to DS_wire in regular speed mode.
                1452     ;**************************************************************************************
                1453     ;
                1454     ; To write a '0' to the DS_wire the signal must be Low for 60 to 120us. This design
                1455     ; generates a 78us active Low pulse.
                1456     ;
                1457     ; The DS2432 then requires at least 1us of recovery time for which this routine
                1458     ; provides a 2us delay such that the entire write Low process (slot time) is 80us.
                1459     ; A recovery time of 1us was also found to be marginal in practice probably due
                1460     ; to the rise time of the DS_wire via the external pull up resistor.
                1461     ;
                1462     ; Registers used s0,s1
                1463     ;
1F4 00000       1464     write_low_slow:         LOAD            s0, #0x00               ;transmit Low pulse
1F5 0E008       1465                             OUTPUT          s0, ds_wire_out_port
                1466     ;Delay of 78us is equivalent to 1950 instructions at 50MHz.
                1467     ;This delay loop is formed of 27 instructions requiring 72 repetitions.
1F6 00148       1468                             LOAD            s1, #0x48               ;72 (48 hex)
1F7 08387       1469     wls_wait_78us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
1F8 06101       1470                             SUB             s1, #0x01               ;decrement delay counter
1F9 0955A       1471                             JUMP            nz, wls_wait_78us       ;repeat until zero
W: value out of range: 0x25a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5a.
1FA 00001       1472                             LOAD            s0, #0x01               ;end of Low pulse
1FB 0E008       1473                             OUTPUT          s0, ds_wire_out_port
1FC 08387       1474                             CALL            delay_1us               ;2us recovery time
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
1FD 08387       1475                             CALL            delay_1us
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
1FE 08080       1476                             RETURN
                1477     ;
                1478     ;
                1479     ;**************************************************************************************
                1480     ; Write a '1' to DS_wire in regular speed mode.
                1481     ;**************************************************************************************
                1482     ;
                1483     ; To write a '1' to the DS_wire the signal must be Low for 1 to 15us to instigate the
                1484     ; write of the data. This design generates an 8us active Low pulse for this purpose.
                1485     ;
                1486     ; Then the output must be High for 53 to 114us to provide the '1' for the DS2432 to
                1487     ; read and then provide recovery time. This design implements a 72us delay such that
                1488     ; the entire write High process (slot time) is 80us
                1489     ;
                1490     ; Registers used s0,s1
                1491     ;
1FF 00000       1492     write_high_slow:        LOAD            s0, #0x00               ;transmit Low pulse
200 0E008       1493                             OUTPUT          s0, ds_wire_out_port
                1494     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1495     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
201 00108       1496                             LOAD            s1, #0x08               ;8 (08 hex)
202 08387       1497     whs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
203 06101       1498                             SUB             s1, #0x01               ;decrement delay counter
204 09565       1499                             JUMP            nz, whs_wait_8us        ;repeat until zero
W: value out of range: 0x265, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x65.
205 00001       1500                             LOAD            s0, #0x01               ;end of Low pulse
206 0E008       1501                             OUTPUT          s0, ds_wire_out_port
                1502     ;Delay of 72us is equivalent to 1800 instructions at 50MHz.
                1503     ;This delay loop is formed of 27 instructions requiring 67 repetitions.
207 00143       1504                             LOAD            s1, #0x43               ;67 (43 hex)
208 08387       1505     whs_wait_72us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
209 06101       1506                             SUB             s1, #0x01               ;decrement delay counter
20A 0956B       1507                             JUMP            nz, whs_wait_72us       ;repeat until zero
W: value out of range: 0x26b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6b.
20B 08080       1508                             RETURN
                1509     ;
                1510     ;
                1511     ;
                1512     ;**************************************************************************************
                1513     ; Read a byte from DS2432 in regular speed mode.
                1514     ;**************************************************************************************
                1515     ;
                1516     ; Bytes are read from the DS2432 with LSB first.
                1517     ;
                1518     ; The byte read will be returned in register 's3'.
                1519     ;
                1520     ; Registers used s0,s1,s2,s3
                1521     ;
20C 00208       1522     read_byte_slow:         LOAD            s2, #0x08               ;8 bits to receive
20D 08374       1523     rbs_loop:               CALL            read_bit_slow           ;read next bit LSB first
W: value out of range: 0x274, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x74.
20E 06201       1524                             SUB             s2, #0x01               ;count bits
20F 09570       1525                             JUMP            nz, rbs_loop            ;repeat until 8-bits received
W: value out of range: 0x270, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x70.
210 08080       1526                             RETURN
                1527     ;
                1528     ;
                1529     ;
                1530     ;
                1531     ;**************************************************************************************
                1532     ; Read a data bit sent from the DS2432 in regular speed mode.
                1533     ;**************************************************************************************
                1534     ;
                1535     ; To read a bit, PicoBlaze must initiate the processed with an active Low pulse of
                1536     ; 1 to 15us. This design generates a 4us active Low pulse for this purpose.
                1537     ;
                1538     ; Then DS2432 responds to the Low pulse by diving DS_wire in two different ways
                1539     ; depending on the logic level it is trying to send back.
                1540     ;
                1541     ; For a logic '0' the DS2432 will drive the DS-wire Low for up to 15us after
                1542     ; the start of the instigating pulse. Therefore PicoBlaze must read the DS-wire
                1543     ; before this time has elapsed but only after it has itself released the wire.
                1544     ;
                1545     ; For a logic '1' the DS2432 will do nothing and hence the DS-wire will be pulled
                1546     ; High by the external resistor after PicoBlaze has released the wire. PicoBlaze
                1547     ; will sample the wire and detect the High level.
                1548     ;
                1549     ; In this design, PicoBlaze needs to detect the logic state of the wire after
                1550     ; releasing the wire at 4us. Sampling the wire too quickly would not provide
                1551     ; adequate time for a High signal to be formed by the pull up resistor. However, it
                1552     ; must sample the wire before 15us have elapsed and any potential Low is removed.
                1553     ; This design samples the wire at 12us which is 8us after the initiation pulse ends.
                1554     ;
                1555     ; A further delay of 68us is then allowed for the DS2432 to stop transmitting and
                1556     ; to recover. This also mean that the entire read process (slot time) is 80us.
                1557     ;
                1558     ; The received data bit is SHIFTED into the MSB of register 's3'. In this way
                1559     ; the reception of 8-bits will shift the first bit into the LSB position of 's3'.
                1560     ;
                1561     ; Registers used s0,s1,s3
                1562     ;
211 00000       1563     read_bit_slow:          LOAD            s0, #0x00               ;transmit Low pulse
212 0E008       1564                             OUTPUT          s0, ds_wire_out_port
                1565     ;Delay of 4us is equivalent to 100 instructions at 50MHz.
                1566     ;This delay loop is formed of 27 instructions requiring 4 repetitions.
213 00104       1567                             LOAD            s1, #0x04               ;4 (04 hex)
214 08387       1568     rbs_wait_4us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
215 06101       1569                             SUB             s1, #0x01               ;decrement delay counter
216 09577       1570                             JUMP            nz, rbs_wait_4us        ;repeat until zero
W: value out of range: 0x277, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x77.
217 00001       1571                             LOAD            s0, #0x01               ;end of Low pulse
218 0E008       1572                             OUTPUT          s0, ds_wire_out_port
                1573     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1574     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
219 00108       1575                             LOAD            s1, #0x08               ;8 (08 hex)
21A 08387       1576     rbs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
21B 06101       1577                             SUB             s1, #0x01               ;decrement delay counter
21C 0957D       1578                             JUMP            nz, rbs_wait_8us        ;repeat until zero
W: value out of range: 0x27d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7d.
21D 0834A       1579                             CALL            read_ds_wire            ;sample wire (carry = state)
W: value out of range: 0x24a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4a.
21E 0D308       1580                             SRA             s3                      ;shift received bit into MSB of s3
                1581     ;Delay of 68us is equivalent to 1700 instructions at 50MHz.
                1582     ;This delay loop is formed of 27 instructions requiring 63 repetitions.
21F 0013F       1583                             LOAD            s1, #0x3f               ;63 (3F hex)
220 08387       1584     rbs_wait_68us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
221 06101       1585                             SUB             s1, #0x01               ;decrement delay counter
222 09583       1586                             JUMP            nz, rbs_wait_68us       ;repeat until zero
W: value out of range: 0x283, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x83.
223 08080       1587                             RETURN
                1588     ;
                1589     ;
                1590     ;**************************************************************************************
                1591     ; Software delay routines
                1592     ;**************************************************************************************
                1593     ;
                1594     ; Delay of 1us.
                1595     ;
                1596     ; Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1597     ; executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1598     ; the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1599     ;
                1600     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1601     ;
                1602     ; Register used s0
                1603     ;
224 0000B       1604     delay_1us:              LOAD            s0, #delay_1us_constant
225 06001       1605     wait_1us:               SUB             s0, #0x01
226 09588       1606                             JUMP            nz, wait_1us
W: value out of range: 0x288, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x88.
227 08080       1607                             RETURN
                1608     ;
                1609     ; Delay of 40us.
                1610     ;
                1611     ; Registers used s0, s1
                1612     ;
228 00128       1613     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
229 08387       1614     wait_40us:              CALL            delay_1us
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
22A 06101       1615                             SUB             s1, #0x01
22B 0958C       1616                             JUMP            nz, wait_40us
W: value out of range: 0x28c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8c.
22C 08080       1617                             RETURN
                1618     ;
                1619     ;
                1620     ; Delay of 1ms.
                1621     ;
                1622     ; Registers used s0, s1, s2
                1623     ;
22D 00219       1624     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
22E 0838B       1625     wait_1ms:               CALL            delay_40us
W: value out of range: 0x28b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8b.
22F 06201       1626                             SUB             s2, #0x01
230 09591       1627                             JUMP            nz, wait_1ms
W: value out of range: 0x291, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x91.
231 08080       1628                             RETURN
                1629     ;
                1630     ; Delay of 20ms.
                1631     ;
                1632     ; Registers used s0, s1, s2, s3
                1633     ;
232 00314       1634     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
233 08390       1635     wait_20ms:              CALL            delay_1ms
W: value out of range: 0x290, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x90.
234 06301       1636                             SUB             s3, #0x01
235 09596       1637                             JUMP            nz, wait_20ms
W: value out of range: 0x296, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x96.
236 08080       1638                             RETURN
                1639     ;
                1640     ; Delay of approximately 1 second.
                1641     ;
                1642     ; Registers used s0, s1, s2, s3, s4
                1643     ;
237 00414       1644     delay_1s:               LOAD            s4, #0x14               ;50 x 20ms = 1000ms
238 08395       1645     wait_1s:                CALL            delay_20ms
W: value out of range: 0x295, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x95.
239 06401       1646                             SUB             s4, #0x01
23A 0959B       1647                             JUMP            nz, wait_1s
W: value out of range: 0x29b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9b.
23B 08080       1648                             RETURN
                1649     ;
                1650     ;
                1651     ;**************************************************************************************
                1652     ; UART communication routines
                1653     ;**************************************************************************************
                1654     ;
                1655     ; Read one character from the UART
                1656     ;
                1657     ; Character read will be returned in a register called 'UART_data'.
                1658     ;
                1659     ; The routine first tests the receiver FIFO buffer to see if data is present.
                1660     ; If the FIFO is empty, the routine waits until there is a character to read.
                1661     ; As this could take any amount of time the wait loop could include a call to a
                1662     ; subroutine which performs a useful function.
                1663     ;
                1664     ;
                1665     ; Registers used s0 and UART_data
                1666     ;
23C 0A040       1667     read_from_uart:         INPUT           s0, status_port         ;test Rx_FIFO buffer
                1668                             TEST            s0, #rx_data_present    ;wait if empty
E: instruction not supported on the this device: TEST sX, kk.
23D 095A3       1669                             JUMP            nz, read_character
W: value out of range: 0x2a3, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa3.
23E 0819F       1670                             JUMP            read_from_uart
W: value out of range: 0x29f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
23F 0AF80       1671     read_character:         INPUT           uart_data, uart_read_port ;read from FIFO
240 08080       1672                             RETURN
                1673     ;
                1674     ;
                1675     ;
                1676     ; Transmit one character to the UART
                1677     ;
                1678     ; Character supplied in register called 'UART_data'.
                1679     ;
                1680     ; The routine first tests the transmit FIFO buffer to see if it is full.
                1681     ; If the FIFO is full, then the routine waits until it there is space.
                1682     ;
                1683     ; Registers used s0
                1684     ;
241 0A040       1685     send_to_uart:           INPUT           s0, status_port         ;test Tx_FIFO buffer
                1686                             TEST            s0, #tx_full            ;wait if full
E: instruction not supported on the this device: TEST sX, kk.
242 091A9       1687                             JUMP            z, uart_write
W: value out of range: 0x2a9, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa9.
243 081A5       1688                             JUMP            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
244 0EF04       1689     uart_write:             OUTPUT          uart_data, uart_write_port
245 08080       1690                             RETURN
                1691     ;
                1692     ;
                1693     ;**************************************************************************************
                1694     ; Useful ASCII conversion and handling routines
                1695     ;**************************************************************************************
                1696     ;
                1697     ;
                1698     ; Convert character to upper case
                1699     ;
                1700     ; The character supplied in register s0.
                1701     ; If the character is in the range 'a' to 'z', it is converted
                1702     ; to the equivalent upper case character in the range 'A' to 'Z'.
                1703     ; All other characters remain unchanged.
                1704     ;
                1705     ; Registers used s0.
                1706     ;
  002AB         1707     upper_case:             COMPARE         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
E: instruction not supported on the this device: COMPARE sX, kk.
246 09880       1708                             RETURN          c
                1709                             COMPARE         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
E: instruction not supported on the this device: COMPARE sX, kk.
247 09C80       1710                             RETURN          nc
248 010DF       1711                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
249 08080       1712                             RETURN
                1713     ;
                1714     ;
                1715     ; Convert hexadecimal value provided in register s0 into ASCII characters
                1716     ;
                1717     ; The value provided must can be any value in the range 00 to FF and will be converted into
                1718     ; two ASCII characters.
                1719     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1720     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1721     ;
                1722     ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1723     ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1724     ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1725     ;
                1726     ; Registers used s0, s1 and s2.
                1727     ;
24A 0C100       1728     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
24B 0D00E       1729                             SR0             s0                      ;isolate upper nibble
24C 0D00E       1730                             SR0             s0
24D 0D00E       1731                             SR0             s0
24E 0D00E       1732                             SR0             s0
24F 083BD       1733                             CALL            hex_to_ascii            ;convert
W: value out of range: 0x2bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
250 0C200       1734                             LOAD            s2, s0                  ;upper nibble value in s2
251 0C010       1735                             LOAD            s0, s1                  ;restore complete value
252 0100F       1736                             AND             s0, #0x0f               ;isolate lower nibble
253 083BD       1737                             CALL            hex_to_ascii            ;convert
W: value out of range: 0x2bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
254 0C100       1738                             LOAD            s1, s0                  ;lower nibble value in s1
255 08080       1739                             RETURN
                1740     ;
                1741     ; Convert hexadecimal value provided in register s0 into ASCII character
                1742     ;
                1743     ;Register used s0
                1744     ;
256 0600A       1745     hex_to_ascii:           SUB             s0, #0x0a               ;test if value is in range 0 to 9
257 099C0       1746                             JUMP            c, number_char
W: value out of range: 0x2c0, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc0.
258 04007       1747                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
259 0403A       1748     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
25A 08080       1749                             RETURN
                1750     ;
                1751     ;
                1752     ; Send the two character HEX value of the register contents 's0' to the UART
                1753     ;
                1754     ; Registers used s0, s1, s2
                1755     ;
25B 083B1       1756     send_hex_byte:          CALL            hex_byte_to_ascii
W: value out of range: 0x2b1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb1.
25C 0CF20       1757                             LOAD            uart_data, s2
25D 083A5       1758                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
25E 0CF10       1759                             LOAD            uart_data, s1
25F 083A5       1760                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
260 08080       1761                             RETURN
                1762     ;
                1763     ;
                1764     ;
                1765     ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                1766     ; an equivalent hexadecimal value in register 's0'.
                1767     ;     The upper nibble is represented by an ASCII character in register s3.
                1768     ;     The lower nibble is represented by an ASCII character in register s2.
                1769     ;
                1770     ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1771     ; will be set on return.
                1772     ;
                1773     ; Registers used s0, s2 and s3.
                1774     ;
261 0C030       1775     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
262 083D5       1776                             CALL            ascii_to_hex            ;convert to value
W: value out of range: 0x2d5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd5.
263 09880       1777                             RETURN          c                       ;reject if out of range
264 0C300       1778                             LOAD            s3, s0                  ;remember value
265 0D306       1779                             SL0             s3                      ;multiply value by 16 to put in upper nibble
266 0D306       1780                             SL0             s3
267 0D306       1781                             SL0             s3
268 0D306       1782                             SL0             s3
269 0C020       1783                             LOAD            s0, s2                  ;Take lower nibble
26A 083D5       1784                             CALL            ascii_to_hex            ;convert to value
W: value out of range: 0x2d5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd5.
26B 09880       1785                             RETURN          c                       ;reject if out of range
26C 0C032       1786                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
26D 08080       1787                             RETURN
                1788     ;
                1789     ;
                1790     ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1791     ;
                1792     ; If character is not valid for hex, then CARRY is set on return.
                1793     ;
                1794     ; Register used s0
                1795     ;
26E 040B9       1796     ascii_to_hex:           ADD             s0, #0xb9               ;test for above ASCII code 46 ('F')
26F 09880       1797                             RETURN          c
270 060E9       1798                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
271 09880       1799                             RETURN          c                       ;reject below ASCII code 30 ('0')
272 06011       1800                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
273 09DDF       1801                             JUMP            nc, ascii_letter
W: value out of range: 0x2df, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xdf.
274 04007       1802                             ADD             s0, #0x07               ;test for above ASCII code 46 ('F')
275 09880       1803                             RETURN          c
276 060F6       1804                             SUB             s0, #0xf6               ;convert to range 00 to 09
277 08080       1805                             RETURN
278 0400A       1806     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
279 08080       1807                             RETURN
                1808     ;
                1809     ;
                1810     ; Read one character from UART and echo.
                1811     ; Convert to upper case and return.
                1812     ;
                1813     ;
27A 0839F       1814     read_upper_case:        CALL            read_from_uart          ;read command character from UART
W: value out of range: 0x29f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
27B 083A5       1815                             CALL            send_to_uart            ;echo character
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
27C 0C0F0       1816                             LOAD            s0, uart_data           ;convert to upper case
27D 083AB       1817                             CALL            upper_case
W: value out of range: 0x2ab, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xab.
27E 08080       1818                             RETURN
                1819     ;
                1820     ;
                1821     ; Read two hex characters from UART and convert to single byte data
                1822     ;
27F 083E1       1823     obtain_8bits:           CALL            read_upper_case         ;obtain one byte from UART
W: value out of range: 0x2e1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe1.
280 0C300       1824                             LOAD            s3, s0
281 083E1       1825                             CALL            read_upper_case
W: value out of range: 0x2e1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe1.
282 0C200       1826                             LOAD            s2, s0
283 083C8       1827                             CALL            ascii_byte_to_hex
W: value out of range: 0x2c8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc8.
284 08080       1828                             RETURN
                1829     ;
                1830     ;**************************************************************************************
                1831     ; Text messages
                1832     ;**************************************************************************************
                1833     ;
                1834     ;
                1835     ; Send Carriage Return to the UART
                1836     ;
285 00F0D       1837     send_cr:                LOAD            uart_data, #character_cr
286 083A5       1838                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
287 08080       1839                             RETURN
                1840     ;
                1841     ; Send a space to the UART
                1842     ;
288 00F20       1843     send_space:             LOAD            uart_data, #character_space
289 083A5       1844                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
28A 08080       1845                             RETURN
                1846     ;
                1847     ;
                1848     ; Send a minus sign to the UART
                1849     ;
28B 00F2D       1850     send_minus:             LOAD            uart_data, #character_minus
28C 083A5       1851                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
28D 08080       1852                             RETURN
                1853     ;
                1854     ;
                1855     ; Send the letter 't' to the UART
                1856     ;
28E 00F74       1857     send_t:                 LOAD            uart_data, #character_t
28F 083A5       1858                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
290 08080       1859                             RETURN
                1860     ;
                1861     ; Send the letter 'e' to the UART
                1862     ;
291 00F65       1863     send_e:                 LOAD            uart_data, #character_e
292 083A5       1864                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
293 08080       1865                             RETURN
                1866     ;
                1867     ; Send the letter 'a' to the UART
                1868     ;
294 00F61       1869     send_a:                 LOAD            uart_data, #character_a
295 083A5       1870                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
296 08080       1871                             RETURN
                1872     ;
                1873     ;
                1874     ; Send the letter 'd' to the UART
                1875     ;
297 00F64       1876     send_d:                 LOAD            uart_data, #character_d
298 083A5       1877                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
299 08080       1878                             RETURN
                1879     ;
                1880     ;
                1881     ; Send the letter 'r' to the UART
                1882     ;
29A 00F72       1883     send_r:                 LOAD            uart_data, #character_r
29B 083A5       1884                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
29C 08080       1885                             RETURN
                1886     ;
                1887     ;
                1888     ; Send the letter 's' to the UART
                1889     ;
29D 00F73       1890     send_s:                 LOAD            uart_data, #character_s
29E 083A5       1891                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
29F 08080       1892                             RETURN
                1893     ;
                1894     ;
                1895     ; Send the letter 'c' to the UART
                1896     ;
2A0 00F63       1897     send_c:                 LOAD            uart_data, #character_c
2A1 083A5       1898                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2A2 08080       1899                             RETURN
                1900     ;
                1901     ;
                1902     ; Send 'PicoBlaze SHA-1 Algorithm v1.00' string to the UART
                1903     ;
2A3 083EC       1904     send_welcome:           CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2A4 083EC       1905                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2A5 00F50       1906                             LOAD            uart_data, #_character_p
2A6 083A5       1907                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2A7 00F69       1908                             LOAD            uart_data, #character_i
2A8 083A5       1909                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2A9 08307       1910                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
2AA 00F6F       1911                             LOAD            uart_data, #character_o
2AB 083A5       1912                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2AC 00F42       1913                             LOAD            uart_data, #_character_b
2AD 083A5       1914                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2AE 00F6C       1915                             LOAD            uart_data, #character_l
2AF 083A5       1916                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2B0 083FB       1917                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
2B1 00F7A       1918                             LOAD            uart_data, #character_z
2B2 083A5       1919                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2B3 083F8       1920                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
2B4 083EF       1921                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
2B5 00F53       1922                             LOAD            uart_data, #_character_s
2B6 083A5       1923                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2B7 00F48       1924                             LOAD            uart_data, #_character_h
2B8 083A5       1925                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2B9 00F41       1926                             LOAD            uart_data, #_character_a
2BA 083A5       1927                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2BB 083F2       1928                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
2BC 00F31       1929                             LOAD            uart_data, #character_1
2BD 083A5       1930                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2BE 083EF       1931                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
2BF 00F41       1932                             LOAD            uart_data, #_character_a
2C0 083A5       1933                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2C1 00F6C       1934                             LOAD            uart_data, #character_l
2C2 083A5       1935                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2C3 00F67       1936                             LOAD            uart_data, #character_g
2C4 083A5       1937                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2C5 00F6F       1938                             LOAD            uart_data, #character_o
2C6 083A5       1939                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2C7 08301       1940                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
2C8 00F69       1941                             LOAD            uart_data, #character_i
2C9 083A5       1942                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2CA 083F5       1943                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
2CB 00F68       1944                             LOAD            uart_data, #character_h
2CC 083A5       1945                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2CD 00F6D       1946                             LOAD            uart_data, #character_m
2CE 083A5       1947                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2CF 083EF       1948                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
2D0 00F76       1949                             LOAD            uart_data, #character_v
2D1 083A5       1950                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2D2 00F31       1951                             LOAD            uart_data, #character_1
2D3 083A5       1952                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2D4 00F2E       1953                             LOAD            uart_data, #character_fullstop
2D5 083A5       1954                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2D6 00F30       1955                             LOAD            uart_data, #character_0
2D7 083A5       1956                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2D8 00F30       1957                             LOAD            uart_data, #character_0
2D9 083A5       1958                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2DA 083EC       1959                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2DB 083EC       1960                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2DC 08080       1961                             RETURN
                1962     ;
                1963     ;
                1964     ;
                1965     ;
                1966     ;
                1967     ;
                1968     ; Send DS2432 menu to the UART
                1969     ;
2DD 083EC       1970     send_ds2432_menu:       CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2DE 083EC       1971                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2DF 00F31       1972                             LOAD            uart_data, #character_1
2E0 083A5       1973                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2E1 083F2       1974                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
2E2 083A5       1975                             CALL            send_write
W: value out of range: 0x3a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2E3 083EF       1976                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
2E4 08384       1977                             CALL            send_scratchpad
W: value out of range: 0x384, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x84.
2E5 083EC       1978                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2E6 00F32       1979                             LOAD            uart_data, #character_2
2E7 083A5       1980                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2E8 083F2       1981                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
2E9 0839F       1982                             CALL            send_read
W: value out of range: 0x39f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
2EA 083EF       1983                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
2EB 08384       1984                             CALL            send_scratchpad
W: value out of range: 0x384, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x84.
2EC 083EC       1985                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
2ED 00F33       1986                             LOAD            uart_data, #character_3
2EE 083A5       1987                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2EF 083F2       1988                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
2F0 00F4C       1989                             LOAD            uart_data, #_character_l
2F1 083A5       1990                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2F2 00F6F       1991                             LOAD            uart_data, #character_o
2F3 083A5       1992                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2F4 083FB       1993                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
2F5 083FE       1994                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
2F6 083EF       1995                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
2F7 00F66       1996                             LOAD            uart_data, #character_f
2F8 083A5       1997                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2F9 00F69       1998                             LOAD            uart_data, #character_i
2FA 083A5       1999                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2FB 08301       2000                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
2FC 08304       2001                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
2FD 083F5       2002                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
2FE 083EF       2003                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
2FF 08391       2004                             CALL            send_secret
W: value out of range: 0x391, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x91.
300 083EC       2005                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
301 00F34       2006                             LOAD            uart_data, #character_4
302 083A5       2007                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
303 083F2       2008                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
304 0839F       2009                             CALL            send_read
W: value out of range: 0x39f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
305 083EF       2010                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
306 00F61       2011                             LOAD            uart_data, #character_a
307 083A5       2012                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
308 00F75       2013                             LOAD            uart_data, #character_u
309 083A5       2014                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
30A 083F5       2015                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
30B 00F68       2016                             LOAD            uart_data, #character_h
30C 083A5       2017                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
30D 083EF       2018                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
30E 00F50       2019                             LOAD            uart_data, #_character_p
30F 083A5       2020                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
310 083FB       2021                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
311 00F67       2022                             LOAD            uart_data, #character_g
312 083A5       2023                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
313 083F8       2024                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
314 083EC       2025                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
315 08080       2026                             RETURN
                2027     ;
                2028     ;
                2029     ;
                2030     ; Send carriage return, 'OK' and carriage return to the UART
                2031     ;
316 083EC       2032     send_ok:                CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
317 00F4F       2033                             LOAD            uart_data, #_character_o
318 083A5       2034                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
319 00F4B       2035                             LOAD            uart_data, #_character_k
31A 083A5       2036                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
31B 083EC       2037                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
31C 08080       2038                             RETURN
                2039     ;
                2040     ;
                2041     ; Send 'scratchpad' to the UART
                2042     ;
31D 08304       2043     send_scratchpad:        CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
31E 08307       2044                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
31F 08301       2045                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
320 083FB       2046                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
321 083F5       2047                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
322 08307       2048                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
323 00F68       2049                             LOAD            uart_data, #character_h
324 083A5       2050                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
325 00F70       2051                             LOAD            uart_data, #character_p
326 083A5       2052                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
327 083FB       2053                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
328 083FE       2054                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
329 08080       2055                             RETURN
                2056     ;
                2057     ;
                2058     ; Send 'secret' to the UART
                2059     ;
32A 08304       2060     send_secret:            CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
32B 083F8       2061                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
32C 08307       2062                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
32D 08301       2063                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
32E 083F8       2064                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
32F 083F5       2065                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
330 08080       2066                             RETURN
                2067     ;
                2068     ;
                2069     ; Send 'Byte' to the UART
                2070     ;
331 00F42       2071     send_byte:              LOAD            uart_data, #_character_b
332 083A5       2072                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
333 00F79       2073                             LOAD            uart_data, #character_y
334 083A5       2074                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
335 083F5       2075                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
336 083F8       2076                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
337 08080       2077                             RETURN
                2078     ;
                2079     ;
                2080     ; Send 'Read' to the UART
                2081     ;
338 00F52       2082     send_read:              LOAD            uart_data, #_character_r
339 083A5       2083                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
33A 083F8       2084                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
33B 083FB       2085                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
33C 083FE       2086                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
33D 08080       2087                             RETURN
                2088     ;
                2089     ;
                2090     ; Send 'Write' to the UART
                2091     ;
33E 00F57       2092     send_write:             LOAD            uart_data, #_character_w
33F 083A5       2093                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
340 08301       2094                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
341 00F69       2095                             LOAD            uart_data, #character_i
342 083A5       2096                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
343 083F5       2097                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
344 083F8       2098                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
345 08080       2099                             RETURN
                2100     ;
                2101     ;
                2102     ; Send 'Pass' to the UART
                2103     ;
346 00F50       2104     send_pass:              LOAD            uart_data, #_character_p
347 083A5       2105                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
348 083FB       2106                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
349 08304       2107                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
34A 08304       2108                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
34B 083EC       2109                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
34C 08080       2110                             RETURN
                2111     ;
                2112     ;
                2113     ; Send 'Fail' to the UART
                2114     ;
34D 00F46       2115     send_fail:              LOAD            uart_data, #_character_f
34E 083A5       2116                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
34F 083FB       2117                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
350 00F69       2118                             LOAD            uart_data, #character_i
351 083A5       2119                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
352 00F6C       2120                             LOAD            uart_data, #character_l
353 083A5       2121                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
354 083EC       2122                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
355 08080       2123                             RETURN
                2124     ;
                2125     ;
                2126     ; Send 'address=' to the UART
                2127     ;
356 083EC       2128     send_address:           CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
357 083FB       2129                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
358 083FE       2130                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
359 083FE       2131                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
35A 08301       2132                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
35B 083F8       2133                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
35C 08304       2134                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
35D 08304       2135                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
35E 00F3D       2136     send_equals:            LOAD            uart_data, #character_equals
35F 083A5       2137                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
360 08080       2138                             RETURN
                2139     ;
                2140     ;
                2141     ; Send 'data' to the UART
                2142     ;
361 083EC       2143     send_data:              CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
362 083FE       2144                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
363 083FB       2145                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
364 083F5       2146                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
365 083FB       2147                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
366 08080       2148                             RETURN
                2149     ;
                2150     ;
                2151     ; Send 'E/S=' to the UART
                2152     ;
367 083EC       2153     send_es:                CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
368 00F45       2154                             LOAD            uart_data, #_character_e
369 083A5       2155                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
36A 00F2F       2156                             LOAD            uart_data, #character_divide
36B 083A5       2157                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
36C 00F53       2158                             LOAD            uart_data, #_character_s
36D 083A5       2159                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
36E 081C5       2160                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2161     ;
                2162     ;
                2163     ; Send 'code=' to the UART
                2164     ;
36F 08307       2165     send_code:              CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
370 00F6F       2166                             LOAD            uart_data, #character_o
371 083A5       2167                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
372 083FE       2168                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
373 083F8       2169                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
374 081C5       2170                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2171     ;
                2172     ;
                2173     ; Send 's/n=' to the UART
                2174     ;
375 08304       2175     send_sn:                CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
376 00F2F       2176                             LOAD            uart_data, #character_divide
377 083A5       2177                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
378 00F6E       2178                             LOAD            uart_data, #character_n
379 083A5       2179                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
37A 081C5       2180                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2181     ;
                2182     ;
                2183     ; Send 'crc=' to the UART
                2184     ;
37B 08307       2185     send_crc:               CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
37C 00F72       2186                             LOAD            uart_data, #character_r
37D 083A5       2187                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
37E 08307       2188                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
37F 081C5       2189                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2190     ;
                2191     ;
                2192     ;
                2193     ; Send 'mac=' to the UART
                2194     ;
380 00F6D       2195     send_mac:               LOAD            uart_data, #character_m
381 083A5       2196                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
382 083FB       2197                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
383 08307       2198                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
384 081C5       2199                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2200     ;
                2201     ;
                2202     ;**************************************************************************************
                2203     ; Interrupt Service Routine (ISR)
                2204     ;**************************************************************************************
                2205     ;
                2206     ; Interrupts are not used in this design. This is a place keeper only.
                2207     ;
  003FE         2208                             ORG             0x3fe
3FE 080F0       2209     isr:                    RETURNI         enable
                2210     ;
                2211     ;
                2212     ;**************************************************************************************
                2213     ; Interrupt Vector
                2214     ;**************************************************************************************
                2215     ;
  003FF         2216                             ORG             0x3ff
3FF 081FE       2217                             JUMP            isr
W: value out of range: 0x3fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
                2218     ;
                2219     ;
                2220
