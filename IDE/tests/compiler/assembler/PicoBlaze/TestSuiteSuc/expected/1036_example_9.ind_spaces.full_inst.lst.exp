                   1     ; KCPSM3 Program - Implementation of the SHA-1 algorithm for use with the
                   2     ;                  DS2432 secure memory on the Spartan-3E Starter Kit.
                   3     device kcpsm1
                   4     ; Ken Chapman - Xilinx Ltd
                   5     ;
                   6
                   7     ; Version v1.00 - 19th April 2006
                   8     ;
                   9     ;
                  10     ; IMPORTANT - This design builds on the reference design called "PicoBlaze
                  11     ;             DS2432 communicator". It is highly recommend that you look at that
                  12     ;             design before proceeding with this one.
                  13     ;
                  14     ;
                  15     ; This program uses a 9600 baud UART connection to allow communication with the
                  16     ; 1-wire interface of the DS2432 memory device from Dallas Semiconductor.
                  17     ;
                  18     ; The program only supports a limited number of the DS2432 commands to focus on
                  19     ; those aspects which use the SHA-1 algorithm.
                  20     ;
                  21     ; Note that the code performing the SHA-1 algorithm interacts with the hardware of
                  22     ; this complete reference design. The hardware provides a 16 word (32-bit) buffer
                  23     ; combined used in the initialisation of the algorithm and subsequent computation
                  24     ; of the Wt words.
                  25     ;
                  26     ;
                  27     ; The DS2432 should be programmed with a 64-bit secret. The following constants
                  28     ; define the secret which will be used. Obviously this would be be changed in a
                  29     ; real application and further measures taken to prevent it easily being found.
                  30     ; The secret is 64-bits formed of 8 bytes. 'secret0' would be loadd at address
                  31     ; 0080 of the DS2432 and 'secret7' at address 0087. The write buffer and load
                  32     ; first secret commands allow you to set any secret into the DS2432 device but
                  33     ; this program always uses the secret defined in these constants such that you can
                  34     ; experiment with secrets which do and do not match.
                  35     ;
                  36     ;
  00001           37     secret0                 EQU             0x01
  00023           38     secret1                 EQU             0x23
  00045           39     secret2                 EQU             0x45
  00067           40     secret3                 EQU             0x67
  00089           41     secret4                 EQU             0x89
  000AB           42     secret5                 EQU             0xab
  000CD           43     secret6                 EQU             0xcd
  000EF           44     secret7                 EQU             0xef
                  45     ;
                  46     ;
                  47     ; Bytes 4, 5 and 6 of the DS2432 scratch pad memory are used in the SHA-1 algorithm.
                  48     ; These should be set using the write scratchpad memory command before using the
                  49     ; read authenticated page command. HOWEVER, it is also important that you also use
                  50     ; the read scratchpad command BEFORE using the read authenticated page command. This
                  51     ; is because this program only copies the bytes 4, 5 and 6 during a read such that
                  52     ; they are can be used by the PicoBlaze SHA-1 algorithm. This limitation is deliberate
                  53     ; so that you can experiment and prove that the SHA-1 results will not match if
                  54     ; the same 'challenge' bytes are not used.
                  55     ;
                  56     ;
                  57     ;**************************************************************************************
                  58     ; Port definitions
                  59     ;**************************************************************************************
                  60     ;
                  61     ;
  00040           62     status_port             EQU             0x40                    ;UART status input
  00001           63     tx_half_full            EQU             0x01                    ;  Transmitter     half full - bit0
  00002           64     tx_full                 EQU             0x02                    ;    FIFO               full - bit1
  00004           65     rx_data_present         EQU             0x04                    ;  Receiver     data present - bit2
  00008           66     rx_half_full            EQU             0x08                    ;    FIFO          half full - bit3
  00010           67     rx_full                 EQU             0x10                    ;                   full - bit4
  00020           68     spare1                  EQU             0x20                    ;                  spare '0' - bit5
  00040           69     spare2                  EQU             0x40                    ;                  spare '0' - bit6
  00080           70     spare3                  EQU             0x80                    ;                  spare '0' - bit7
                  71     ;
  00080           72     uart_read_port          EQU             0x80                    ;UART Rx data input
                  73     ;
  00004           74     uart_write_port         EQU             0x04                    ;UART Tx data output
                  75     ;
                  76     ;
  000C0           77     ds_wire_in_port         EQU             0xc0                    ;Read signal from DS2432 device
  00008           78     ds_wire_out_port        EQU             0x08                    ;Drive signal to DS2432 device (open collector)
  00001           79     ds_wire                 EQU             0x01                    ;       Signal is bit0 in both cases
                  80     ;
                  81     ;
                  82     ;
                  83     ; The following ports access the 'Wt' word buffer. This buffer holds 16 words
                  84     ; of 32-bits organised as a 64-byte shiload register. Hence each word is loadd
                  85     ; by writing 4 bytes. As each byte is written, all bytes shiload along such that
                  86     ; older Wt values can be read from consistent port addresses.
                  87     ;
  00010           88     w_word_write_port       EQU             0x10                    ;Write byte to Wt buffer
                  89     ;
  00008           90     wt_minus3_byte0_read_port EQU           0x08                    ;Read of Wt-3
  00009           91     wt_minus3_byte1_read_port EQU           0x09
  0000A           92     wt_minus3_byte2_read_port EQU           0x0a
  0000B           93     wt_minus3_byte3_read_port EQU           0x0b
                  94     ;
  0001C           95     wt_minus8_byte0_read_port EQU           0x1c                    ;Read of Wt-8
  0001D           96     wt_minus8_byte1_read_port EQU           0x1d
  0001E           97     wt_minus8_byte2_read_port EQU           0x1e
  0001F           98     wt_minus8_byte3_read_port EQU           0x1f
                  99     ;
  00034          100     wt_minus14_byte0_read_port EQU          0x34                    ;Read of Wt-14
  00035          101     wt_minus14_byte1_read_port EQU          0x35
  00036          102     wt_minus14_byte2_read_port EQU          0x36
  00037          103     wt_minus14_byte3_read_port EQU          0x37
                 104     ;
  0003C          105     wt_minus16_byte0_read_port EQU          0x3c                    ;Read of Wt-16
  0003D          106     wt_minus16_byte1_read_port EQU          0x3d
  0003E          107     wt_minus16_byte2_read_port EQU          0x3e
  0003F          108     wt_minus16_byte3_read_port EQU          0x3f
                 109     ;
                 110     ;
                 111     ;**************************************************************************************
                 112     ; Special Register usage
                 113     ;**************************************************************************************
                 114     ;
  0000F          115     uart_data               REG             sf                      ;used to pass data to and from the UART
                 116     ;
                 117     ;
                 118     ;**************************************************************************************
                 119     ; Scratch Pad Memory Locations
                 120     ;**************************************************************************************
                 121     ;
                 122     ; Scratch pad memory provides 64 bytes in the address range 00 to 3F hex.
                 123     ;
                 124     ;
                 125     ; Locations for device family code, serial number and 8-bit CRC value
                 126     ;
  00000          127     family_code             EQU             0x00
  00001          128     serial_number0          EQU             0x01                    ;48-bit serial number LS-Byte first
  00002          129     serial_number1          EQU             0x02
  00003          130     serial_number2          EQU             0x03
  00004          131     serial_number3          EQU             0x04
  00005          132     serial_number4          EQU             0x05
  00006          133     serial_number5          EQU             0x06
  00007          134     read_rom_crc            EQU             0x07                    ;8-bit CRC
                 135     ;
                 136     ;
                 137     ; Locations for variables used in SHA-1 algorithm.
                 138     ; Each variable is 32-bits and requires 4 bytes to load.
                 139     ; '0' indicates the least significant byte and '3' the most significant byte.
                 140     ;
                 141     ; Note that the concatenation of 'A', 'B', 'C', 'D' and 'E' will be the 160-bit MAC.
                 142     ;
  00008          143     var_a0                  EQU             0x08                    ;Variable 'A'
  00009          144     var_a1                  EQU             0x09
  0000A          145     var_a2                  EQU             0x0a
  0000B          146     var_a3                  EQU             0x0b
                 147     ;
  0000C          148     var_b0                  EQU             0x0c                    ;Variable 'B'
  0000D          149     var_b1                  EQU             0x0d
  0000E          150     var_b2                  EQU             0x0e
  0000F          151     var_b3                  EQU             0x0f
                 152     ;
  00010          153     var_c0                  EQU             0x10                    ;Variable 'C'
  00011          154     var_c1                  EQU             0x11
  00012          155     var_c2                  EQU             0x12
  00013          156     var_c3                  EQU             0x13
                 157     ;
  00014          158     var_d0                  EQU             0x14                    ;Variable 'D'
  00015          159     var_d1                  EQU             0x15
  00016          160     var_d2                  EQU             0x16
  00017          161     var_d3                  EQU             0x17
                 162     ;
  00018          163     var_e0                  EQU             0x18                    ;Variable 'E'
  00019          164     var_e1                  EQU             0x19
  0001A          165     var_e2                  EQU             0x1a
  0001B          166     var_e3                  EQU             0x1b
                 167     ;
                 168     ;
                 169     ; Copy of data in the scratchpad memory of the DS2432.
                 170     ; This is only updated by the read scratchpad memory command.
                 171     ; '0' indicates the data in the least significant location.
                 172     ;
  0001C          173     scratchpad0             EQU             0x1c
  0001D          174     scratchpad1             EQU             0x1d
  0001E          175     scratchpad2             EQU             0x1e
  0001F          176     scratchpad3             EQU             0x1f
  00020          177     scratchpad4             EQU             0x20
  00021          178     scratchpad5             EQU             0x21
  00022          179     scratchpad6             EQU             0x22
  00023          180     scratchpad7             EQU             0x23
                 181     ;
                 182     ;
                 183     ;
                 184     ;**************************************************************************************
                 185     ; Useful data constants
                 186     ;**************************************************************************************
                 187     ;
                 188     ; Constant to define a soloadware delay of 1us. This must be adjusted to reflect the
                 189     ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 190     ; calculation highly predictable. The '6' in the following equation even allows for
                 191     ; 'CALL delay_1us' instruction in the initiating code.
                 192     ;
                 193     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 194     ;
                 195     ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 196     ; For clock rates below 10MHz the value of 1 must be used and the operation will
                 197     ; become lower than intended.
                 198     ;
  0000B          199     delay_1us_constant      EQU             0x0b
                 200     ;
                 201     ;
                 202     ;
                 203     ;ASCII table
                 204     ;
  00061          205     character_a             EQU             0x61
  00062          206     character_b             EQU             0x62
  00063          207     character_c             EQU             0x63
  00064          208     character_d             EQU             0x64
  00065          209     character_e             EQU             0x65
  00066          210     character_f             EQU             0x66
  00067          211     character_g             EQU             0x67
  00068          212     character_h             EQU             0x68
  00069          213     character_i             EQU             0x69
  0006A          214     character_j             EQU             0x6a
  0006B          215     character_k             EQU             0x6b
  0006C          216     character_l             EQU             0x6c
  0006D          217     character_m             EQU             0x6d
  0006E          218     character_n             EQU             0x6e
  0006F          219     character_o             EQU             0x6f
  00070          220     character_p             EQU             0x70
  00071          221     character_q             EQU             0x71
  00072          222     character_r             EQU             0x72
  00073          223     character_s             EQU             0x73
  00074          224     character_t             EQU             0x74
  00075          225     character_u             EQU             0x75
  00076          226     character_v             EQU             0x76
  00077          227     character_w             EQU             0x77
  00078          228     character_x             EQU             0x78
  00079          229     character_y             EQU             0x79
  0007A          230     character_z             EQU             0x7a
  00041          231     _character_a            EQU             0x41
  00042          232     _character_b            EQU             0x42
  00043          233     _character_c            EQU             0x43
  00044          234     _character_d            EQU             0x44
  00045          235     _character_e            EQU             0x45
  00046          236     _character_f            EQU             0x46
  00047          237     _character_g            EQU             0x47
  00048          238     _character_h            EQU             0x48
  00049          239     _character_i            EQU             0x49
  0004A          240     _character_j            EQU             0x4a
  0004B          241     _character_k            EQU             0x4b
  0004C          242     _character_l            EQU             0x4c
  0004D          243     _character_m            EQU             0x4d
  0004E          244     _character_n            EQU             0x4e
  0004F          245     _character_o            EQU             0x4f
  00050          246     _character_p            EQU             0x50
  00051          247     _character_q            EQU             0x51
  00052          248     _character_r            EQU             0x52
  00053          249     _character_s            EQU             0x53
  00054          250     _character_t            EQU             0x54
  00055          251     _character_u            EQU             0x55
  00056          252     _character_v            EQU             0x56
  00057          253     _character_w            EQU             0x57
  00058          254     _character_x            EQU             0x58
  00059          255     _character_y            EQU             0x59
  0005A          256     _character_z            EQU             0x5a
  00030          257     character_0             EQU             0x30
  00031          258     character_1             EQU             0x31
  00032          259     character_2             EQU             0x32
  00033          260     character_3             EQU             0x33
  00034          261     character_4             EQU             0x34
  00035          262     character_5             EQU             0x35
  00036          263     character_6             EQU             0x36
  00037          264     character_7             EQU             0x37
  00038          265     character_8             EQU             0x38
  00039          266     character_9             EQU             0x39
  0003A          267     character_colon         EQU             0x3a
  0002E          268     character_fullstop      EQU             0x2e
  0003B          269     character_semi_colon    EQU             0x3b
  0002D          270     character_minus         EQU             0x2d
  0002B          271     character_plus          EQU             0x2b
  0002C          272     character_comma         EQU             0x2c
  0003C          273     character_less_than     EQU             0x3c                    ;'<'
  0003E          274     character_greater_than  EQU             0x3e                    ;'>'
  00028          275     character_open          EQU             0x28                    ;'('
  00029          276     character_close         EQU             0x29                    ;')'
  0002F          277     character_divide        EQU             0x2f                    ;'/'
  0003D          278     character_equals        EQU             0x3d
  00020          279     character_space         EQU             0x20
  0000D          280     character_cr            EQU             0x0d                    ;carriage return
  0000A          281     character_lf            EQU             0x0a                    ;line feed
  0003F          282     character_question      EQU             0x3f                    ;'?'
  00024          283     character_dollar        EQU             0x24
  00021          284     character_exclaim       EQU             0x21                    ;'!'
  00008          285     character_bs            EQU             0x08                    ;Back Space command character
  00011          286     character_xon           EQU             0x11                    ;Flow control ON
  00013          287     character_xoff          EQU             0x13                    ;Flow control OFF
                 288     ;
                 289     ;
                 290     ;**************************************************************************************
                 291     ; Initialise the system and welcome message
                 292     ;**************************************************************************************
                 293     ;
000 08330        294     cold_start:             CALL            ds_wire_init            ;Ensure DS_wire is not driven (pulled High)
W: value out of range: 0x230, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x30.
001 0839A        295                             CALL            delay_1s                ;Allow everything to settle!
W: value out of range: 0x29a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9a.
002 0830A        296     welcome_start:          CALL            send_welcome            ;start up message and version number
W: value out of range: 0x30a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa.
                 297     ;
                 298     ;
                 299     ;**************************************************************************************
                 300     ; Reset Main menu and command selection
                 301     ;**************************************************************************************
                 302     ;
                 303     ; The main program allows you to use four of the DS2432 memory and SHA function
                 304     ; commands. A simple menu is displayed and you are guided to enter more information
                 305     ; when required. All the communication and protocol required to get the DS2432 ready
                 306     ; to receive memory and SHA function commands has been automated although information
                 307     ; is displayed to indicate the procedures being executed.
                 308     ;
                 309     ; Before any memory and function commands are available a master reset and read ROM
                 310     ; command must be issued.
                 311     ;
003 083EC        312     warm_start:             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
004 083EC        313                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
005 08333        314                             CALL            ds_init_regular_mode    ;master reset
W: value out of range: 0x233, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x33.
006 09903        315                             JUMP            c, warm_start           ;repeat reset if no presence pulse detected
007 0831D        316                             CALL            read_rom_command        ;read ROM command and display results
                 317     ;
                 318     ; Aloader a valid ROM command the DS2432 specific memory commands and SHA-1
                 319     ; functions become accessible. This program assumes that the ROM command did
                 320     ; 'Pass' so you will need to check yourself. If this program automatically
                 321     ; reset the DS2432 and tried again and there was a fault it would just cause
                 322     ; the display to roll continuously and not be very informative!
                 323     ;
                 324     ; Each of the DS2432 commands selected from the menu will require the master reset
                 325     ; and read ROM command to be repeated before being able to proceed with the next
                 326     ; memory or SHA-1 function. This is automated by the program.
                 327     ;
                 328     ;
008 08344        329     ds2432_menu:            CALL            send_ds2432_menu        ;Menu and command selection
W: value out of range: 0x344, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x44.
009 083EC        330                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
                 331     ;
00A 083EC        332     ds2432_prompt:          CALL            send_cr                 ;prompt for user input
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
00B 083EC        333                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
00C 00F3E        334                             LOAD            uart_data, #character_greater_than ;prompt for input
00D 083A5        335                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
00E 083E1        336                             CALL            read_upper_case
W: value out of range: 0x2e1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe1.
00F 00031        337                             load         s0, #character_1        ;load for commands and execute as required
010 09153        338                             JUMP            z, write_scratchpad_command
011 00032        339                             load         s0, #character_2
012 09179        340                             JUMP            z, read_scratchpad_command
013 00033        341                             load         s0, #character_3
014 09140        342                             JUMP            z, load_first_secret_command
015 00034        343                             load         s0, #character_4
016 0919D        344                             JUMP            z, read_auth_page_command
017 083EC        345                             CALL            send_cr                 ;no valid command input
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
018 00F3F        346                             LOAD            uart_data, #character_question ;display ???
019 083A5        347                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
01A 083A5        348                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
01B 083A5        349                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
01C 0810A        350                             JUMP            ds2432_prompt           ;Try again!
                 351     ;
                 352     ;
                 353     ;
                 354     ;
                 355     ;**************************************************************************************
                 356     ; DS2432 Read ROM Command.
                 357     ;**************************************************************************************
                 358     ;
                 359     ; The read ROM command (33 hex) allows the 8-bit family code, 48-bit unique serial
                 360     ; number and 8-bit CRC to be read from the DS2432 device.
                 361     ;
                 362     ; This routine reads the values and places them in KCPSM3 scratch pad memory
                 363     ; locations for future reference. These locations should be defined with constants
                 364     ; as follows and MUST be in consecutive ascending locations.
                 365     ;
                 366     ;  family_code
                 367     ;     Location to load family code which should be 33 hex
                 368     ;  serial_number0 to serial_number5
                 369     ;     6 bytes to hold 48-bit serial number (LS-byte first).
                 370     ;  read_ROM_CRC
                 371     ;     8-bit CRC value for the above data.
                 372     ;
                 373     ;
                 374     ; The routine also displays the values read and performs a verification of the
                 375     ; 8-bit CRC displaying a 'Pass' or 'Fail' message as appropriate.
                 376     ;
01D 00333        377     read_rom_command:       LOAD            s3, #0x33               ;Read ROM Command
01E 0834E        378                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
01F 00500        379                             LOAD            s5, #family_code        ;memory pointer
020 0836F        380     read_rom_loop:          CALL            read_byte_slow          ;read response into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
021 00305        381                             load           s3, #s5                 ;load value
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
022 00507        382                             load         s5, #read_rom_crc       ;8-bytes to read
023 09126        383                             JUMP            z, display_rom
024 04501        384                             ADD             s5, #0x01
025 08120        385                             JUMP            read_rom_loop
026 083EC        386     display_rom:            CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
027 083D6        387                             CALL            send_code               ;'code=' to display family code
W: value out of range: 0x3d6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd6.
028 0C000        388                             load           s0, family_code
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
029 083C2        389                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
02A 083EC        390                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
02B 083DC        391                             CALL            send_sn                 ;'s/n=' to display family code
W: value out of range: 0x3dc, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xdc.
02C 00506        392                             LOAD            s5, #serial_number5     ;memory pointer starting MS-byte first
02D 0C050        393     disp_serial_loop:       load           s0, s5
02E 083C2        394                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
02F 00501        395                             load         s5, #serial_number0
030 09133        396                             JUMP            z, end_serial
031 06501        397                             SUB             s5, #0x01
032 0812D        398                             JUMP            disp_serial_loop
033 083EC        399     end_serial:             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
034 083E2        400                             CALL            send_crc                ;'CRC=' to display CRC value
W: value out of range: 0x3e2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe2.
035 0C070        401                             load           s0, read_rom_crc
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
036 083C2        402                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
037 083EC        403                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
038 083F1        404                             CALL            compute_crc8            ;compute CRC value in s0
W: value out of range: 0x1f1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf1.
039 0C170        405                             load           s1, read_rom_crc        ;load with received value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
03A 0C010        406                             load         s0, s1
03B 0953E        407                             JUMP            nz, crc8_fail
03C 083AD        408                             CALL            send_pass
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
03D 08080        409                             RETURN
03E 083B4        410     crc8_fail:              CALL            send_fail
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
03F 08080        411                             RETURN
                 412     ;
                 413     ;
                 414     ;
                 415     ;**************************************************************************************
                 416     ; DS2432 Load First Secret Command.
                 417     ;**************************************************************************************
                 418     ;
                 419     ; This command will only be valid if the write scratchpad memory command has previously
                 420     ; been used to define the new secret to be loadd at address 0080.
                 421     ;
                 422     ; The Load First Secret Command (5A hex) will only copy the scratchpad contents into                           ;
                 423     ; the EEPROM array of the DS2432 if the address was correctly specified in the
                 424     ; write scratchpad command. This routine will assume that the address specified
                 425     ; was 0080. If everything is OK with the programming of the secret, the DS2432 responds
                 426     ; with 'AA' hex aloader the command and this routine will report 'Pass'. You can further
                 427     ; check using a read scratchpad command and look to see if E/S has changed from '5F'
                 428     ; to 'DF' which indicates the successful write.
                 429     ;
                 430     ; Note that this program defines the secret to be used by the PicoBlaze SHA-1 algorithm
                 431     ; in the constants 'secret0' through to 'secret7'. Only if you program the DS2432
                 432     ; with a matching secret will the read authenticated message command result in a
                 433     ; 'Pass' being reported for the MAC. This Load First Secret Command routine deliberately
                 434     ; does not update the secret used by the PicoBlaze SHA-1 algorithm so that you can
                 435     ; prove that only a DS2432 with the matching secret will generate matching MAC
                 436     ; responses.
                 437     ;
                 438     ;
                 439     ;
040 0035A        440     load_first_secret_command: LOAD         s3, #0x5a               ;Load First Secret Command
041 0834E        441                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
042 00380        442                             LOAD            s3, #0x80               ;TA1 value for secret = 80 hex
043 0834E        443                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
044 00300        444                             LOAD            s3, #0x00               ;TA2 value for secret = 00 hex
045 0834E        445                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
046 0035F        446                             LOAD            s3, #0x5f               ;E/S value before writing = 5F hex
047 0834E        447                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
048 08395        448                             CALL            delay_20ms              ;write takes place in 10ms
W: value out of range: 0x295, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x95.
049 083EC        449                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
04A 08391        450                             CALL            send_secret
W: value out of range: 0x391, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x91.
04B 083EF        451                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
04C 0836F        452                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
04D 003AA        453                             load         s3, #0xaa               ;load response
04E 09151        454                             JUMP            z, secret_pass
04F 083B4        455                             CALL            send_fail
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
050 08103        456                             JUMP            warm_start
051 083AD        457     secret_pass:            CALL            send_pass
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
052 08103        458                             JUMP            warm_start
                 459     ;
                 460     ;
                 461     ;**************************************************************************************
                 462     ; DS2432 Write Scratchpad Memory Command.
                 463     ;**************************************************************************************
                 464     ;
                 465     ; The write scratchpad memory command (0F hex) allows 8-bytes of data to be written
                 466     ; together with a target address for final storage in the main memory map. The
                 467     ; DS2432 scratch pad is also used to define a 3 byte 'challenge' used in the
                 468     ; SHA-1 algorithm.
                 469     ;
                 470     ; The DS2432 provides an initial confirmation of the write by returning a 16-bit CRC
                 471     ; value which KCPSM3 loads. The CRC is computed based on the command, address and
                 472     ; data transmitted (11 bytes). PicoBlaze also computes the CRC and and loads this
                 473     ; against the value received from the DS2432.
                 474     ;
                 475     ; This routine prompts the user to enter the 16-bit target address is to be loaded
                 476     ; into the target address registers TA2 and TA1 in the DS2432 device. Note that only
                 477     ; address values below 0090 hex are valid. If the address is too high, then the
                 478     ; DS2432 aborts the command and this routine will too.
                 479     ;
                 480     ; Also note that the address will be forced internally to the DS2432 to match an
                 481     ; 8-byte boundary address in which the least significant 3-bits are reset to '000'
                 482     ; regardless of the address provided. The CRC still reflects the transmitted address.
                 483     ;
                 484     ; Aloader providing a valid address, the routine then prompts the user to enter
                 485     ; 8 bytes of data which are written to the DS2432.
                 486     ;
                 487     ;
                 488     ;
053 0830B        489     write_scratchpad_command: CALL          clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
054 0030F        490                             LOAD            s3, #0x0f               ;write scratchpad memory Command
055 0834E        491                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
056 0830E        492                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
057 083BD        493     wsc_addr_loop:          CALL            send_address            ;obtain 16-bit address 0000 to FFFF in [s5,s4]
W: value out of range: 0x3bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
058 083E6        494                             CALL            obtain_8bits
W: value out of range: 0x2e6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe6.
059 09957        495                             JUMP            c, wsc_addr_loop        ;bad input address
05A 0C500        496                             LOAD            s5, s0
05B 083E6        497                             CALL            obtain_8bits
W: value out of range: 0x2e6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe6.
05C 09957        498                             JUMP            c, wsc_addr_loop        ;bad input address
05D 0C400        499                             LOAD            s4, s0
05E 0C340        500                             LOAD            s3, s4                  ;transmit target address TA1 (LS-Byte)
05F 0834E        501                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
060 0830E        502                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
061 0C350        503                             LOAD            s3, s5                  ;transmit target address TA2 (MS-Byte)
062 0834E        504                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
063 0830E        505                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
064 00500        506                             load         s5, #0x00               ;check address less than 0090 hex
065 09503        507                             JUMP            nz, warm_start          ;DS2432 aborts command and so do we!
066 00490        508                             load         s4, #0x90               ;no need to read data bytes.
067 09D03        509                             JUMP            nc, warm_start
068 00400        510                             LOAD            s4, #0x00               ;initialise byte counter
069 083C8        511     wsc_data_loop:          CALL            send_data               ;obtain a byte of data
W: value out of range: 0x3c8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc8.
06A 0CF40        512                             LOAD            uart_data, s4           ;display which byte requested
06B 04F30        513                             ADD             uart_data, #character_0 ;convert to ASCII
06C 083A5        514                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
06D 083C5        515                             CALL            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
06E 083E6        516                             CALL            obtain_8bits
W: value out of range: 0x2e6, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe6.
06F 09969        517                             JUMP            c, wsc_data_loop        ;bad input data
070 0C300        518                             LOAD            s3, s0                  ;transmit byte
071 0834E        519                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
072 0830E        520                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
073 04401        521                             ADD             s4, #0x01               ;count bytes
074 00408        522                             load         s4, #0x08
075 09569        523                             JUMP            nz, wsc_data_loop
076 083EC        524                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
077 0831C        525                             CALL            read_send_load_crc16    ;read, display and load CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
078 08103        526                             JUMP            warm_start
                 527     ;
                 528     ;
                 529     ;
                 530     ;**************************************************************************************
                 531     ; DS2432 Read Scratchpad Memory Command.
                 532     ;**************************************************************************************
                 533     ;
                 534     ; The read scratchpad memory command (AA hex) allows the 8-bytes of data previously
                 535     ; to be written into the scratchpad memory to be read back for verification together with
                 536     ; the target address, a transfer status register (E/S) and a 16-bit CRC value.
                 537     ;
                 538     ; The 16-bit CRC is formed of the command byte, address TA1 and TA2, E/S byte and 8 data
                 539     ; bytes as transmitted (12 bytes). These may not be the same as the values provided
                 540     ; during a previous write to scratchpad memory. PicoBlaze also computes the CRC and
                 541     ; and loads this against the value received from the DS2432.
                 542     ;
                 543     ; The 8 bytes of data are also copied to PicoBlaze memory at locations defined by the
                 544     ; constants 'scratchpad0' to 'scratchpad7'. Three bytes are used as a 'challenge'
                 545     ; by the SHA-1 algorithm.
                 546     ;
                 547     ;
                 548     ;
079 0830B        549     read_scratchpad_command: CALL           clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
07A 003AA        550                             LOAD            s3, #0xaa               ;read scratchpad memory Command
07B 0834E        551                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
07C 0830E        552                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
07D 083BD        553                             CALL            send_address            ;display 'Address='
W: value out of range: 0x3bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
07E 0836F        554                             CALL            read_byte_slow          ;read address into [s5,s4]
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
07F 0830E        555                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
080 0C430        556                             LOAD            s4, s3
081 0836F        557                             CALL            read_byte_slow
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
082 0830E        558                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
083 0C530        559                             LOAD            s5, s3
084 0C050        560                             LOAD            s0, s5                  ;display address
085 083C2        561                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
086 0C040        562                             LOAD            s0, s4
087 083C2        563                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
088 083CE        564                             CALL            send_es                 ;display 'E/S='
W: value out of range: 0x3ce, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xce.
089 0836F        565                             CALL            read_byte_slow          ;read E/S register
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
08A 0830E        566                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
08B 0C030        567                             LOAD            s0, s3                  ;display value
08C 083C2        568                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
08D 083C8        569                             CALL            send_data               ;display 'Data='
W: value out of range: 0x3c8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc8.
08E 083C5        570                             CALL            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
08F 0041C        571                             LOAD            s4, #scratchpad0        ;pointer to memory and byte counter
090 083EF        572     rsc_loop:               CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
091 0836F        573                             CALL            read_byte_slow          ;read data byte
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
092 0830E        574                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
093 00304        575                             load           s3, #s4                 ;load value in memory
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
094 0C030        576                             LOAD            s0, s3                  ;display value
095 083C2        577                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
096 00423        578                             load         s4, #scratchpad7        ;count bytes
097 0919A        579                             JUMP            z, end_rsc_data_loop
098 04401        580                             ADD             s4, #0x01
099 08190        581                             JUMP            rsc_loop
09A 083EC        582     end_rsc_data_loop:      CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
09B 0831C        583                             CALL            read_send_load_crc16    ;read, display and load CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
09C 08103        584                             JUMP            warm_start
                 585     ;
                 586     ;
                 587     ;
                 588     ;
                 589     ;
                 590     ;**************************************************************************************
                 591     ; DS2432 Read Authenticated Page Command.
                 592     ;**************************************************************************************
                 593     ;
                 594     ; The read authenticated page command (A5 hex) allows the 8-byte secret to be loaded
                 595     ; without it actually being read (which would obviously give away the secret!).
                 596     ;
                 597     ; This routine has been written to work with page 0 but could easily be changed and
                 598     ; is documented below. During the first part of the command, the 32 bytes
                 599     ; contained in the page are read back from the DS2432 and these are used in
                 600     ; the preparation of the table required for the for SHA-1 algorithm. Other values
                 601     ; loadd in the table are the secret, serial number of the DS2432, family code, some
                 602     ; constants, 4-bits of the page address and a 3 byte 'challenge' currently set into
                 603     ; the DS2432 scratchpad memory.
                 604     ;
                 605     ; NOTE - The read scratchpad command must be executed before this routine in order
                 606     ; that the 3 byte 'challenge' of scratchpad memory is known to PicoBlaze.
                 607     ;
                 608     ; During this command, two 16-bit CRC values are generated which PicoBlaze also
                 609     ; computes and loads. The first is formed of the command byte, address TA1 and TA2,
                 610     ; all the bytes of the page read and an 'FF' byte. The second is formed of the 20
                 611     ; bytes of the 160-but message authentication code (MAC).
                 612     ;
                 613     ;
                 614     ; Preparing the table.
                 615     ;
                 616     ; The table is loadd in the external 'Wt' buffer and must first be initialised with the
                 617     ; 16 'M' words (32-bit words each requiring 4 bytes). This is achieved by shiloading in
                 618     ; each word in sequence. Storing each word most significant byte first is a natural
                 619     ; fit with the reading of the page data from the DS2432 and the way each 'M' word
                 620     ; is organised. Notice how this causes least significant bytes to be swapped with most
                 621     ; significant bytes!
                 622     ;
                 623     ;          [31:24]      [23:16]      [15:8]       [7:0]
                 624     ;
                 625     ;   M0 = [secret0    , secret1    , secret2    , secret3    ]
                 626     ;   M1 = [page_data0 , page_data1 , page_data2 , page_data3 ]
                 627     ;   M2 = [page_data4 , page_data5 , page_data6 , page_data7 ]
                 628     ;   M3 = [page_data8 , page_data9 , page_data10, page_data11]
                 629     ;   M4 = [page_data12, page_data13, page_data14, page_data15]
                 630     ;   M5 = [page_data16, page_data17, page_data18, page_data19]
                 631     ;   M6 = [page_data20, page_data21, page_data22, page_data23]
                 632     ;   M7 = [page_data24, page_data25, page_data26, page_data27]
                 633     ;   M8 = [page_data28, page_data29, page_data30, page_data31]
                 634     ;   M9 = [   FF      ,    FF      ,    FF      ,    FF      ]
                 635     ;  M10 = [   40      ,    33      , serial_num0, serial_num1]
                 636     ;  M11 = [serial_num2, serial_num3, serial_num4, serial_num5]
                 637     ;  M12 = [secret4    , secret5    , secret6    , secret7    ]
                 638     ;  M13 = [scratchpad4, scratchpad5, scratchpad6,    80      ]
                 639     ;  M14 = [   00      ,    00      ,    00      ,    00      ]
                 640     ;  M15 = [   00      ,    00      ,    01      ,    B8      ]
                 641     ;
                 642     ; In M10, the '33' is the family code and the '40' is made up of a constant bit
                 643     ; pattern '0100' and then bits [8:5] of the page address. This gives 4 possible values
                 644     ; for this byte during a Read Authenticated Page Command, but this routine is currently
                 645     ; fixed to work with page 0 only.
                 646     ;        40 - page 0
                 647     ;        41 - page 1
                 648     ;        42 - page 2
                 649     ;        43 - page 3
                 650     ;
                 651     ; M13 contains the 3 byte challenge from the scratch pad memory. This assumes that a
                 652     ; read scratchpad command has previously been used and the bytes held in the DS2432
                 653     ; scratchpad match those held in the PicoBlaze memory.
                 654     ;
                 655     ;
                 656     ; The 160-bit Message Authentication Code (MAC) is computed from the table using the SHA-1
                 657     ; algorithm. This algorithm actually results in 5 variables 'A', 'B', 'C', 'D' and 'E'
                 658     ; which are 32-bit values each formed of 4 bytes. The MAC is the concatenation of
                 659     ; the variables. To match the same order in which the Read Authenticated Page Command
                 660     ; sends the MAC, the variables must be read in the order 'E', 'D', 'C', 'B' and 'A' and
                 661     ; with the least significant byte of each variable first.
                 662     ;
                 663     ;
                 664     ;
                 665     ;
                 666     ;
09D 00001        667     read_auth_page_command: LOAD            s0, #secret0            ;load M0 (secret 0, 1, 2 and 3) in Wt buffer.
09E 0E010        668                             OUTPUT          s0, w_word_write_port
09F 00023        669                             LOAD            s0, #secret1
0A0 0E010        670                             OUTPUT          s0, w_word_write_port
0A1 00045        671                             LOAD            s0, #secret2
0A2 0E010        672                             OUTPUT          s0, w_word_write_port
0A3 00067        673                             LOAD            s0, #secret3
0A4 0E010        674                             OUTPUT          s0, w_word_write_port
                 675     ;
                 676     ;Start of DS2432 command
                 677     ;
0A5 0830B        678                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
0A6 003A5        679                             LOAD            s3, #0xa5               ;read authenticated page command
0A7 0834E        680                             CALL            write_byte_slow         ;transmit command
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
0A8 0830E        681                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0A9 00500        682                             LOAD            s5, #0x00               ;set address for page 0
0AA 00400        683                             LOAD            s4, #0x00               ;  [TA2,TA1]=0000 hex
0AB 0C340        684                             LOAD            s3, s4                  ;transmit TA1
0AC 0834E        685                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
0AD 0830E        686                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0AE 0C350        687                             LOAD            s3, s5                  ;transmit TA2
0AF 0834E        688                             CALL            write_byte_slow
W: value out of range: 0x24e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4e.
0B0 0830E        689                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
                 690     ;
                 691     ;Read 32-bytes of data associated with page 0
                 692     ;load these as M1 through to M8
                 693     ;
0B1 083EC        694     rapc_line_loop:         CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
0B2 0C050        695                             LOAD            s0, s5                  ;display 16-bit address
0B3 083C2        696                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0B4 0C040        697                             LOAD            s0, s4
0B5 083C2        698                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0B6 083EF        699                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
0B7 083EF        700                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
0B8 083EF        701     rapc_data_loop:         CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
0B9 0836F        702                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
0BA 0830E        703                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0BB 0E310        704                             OUTPUT          s3, w_word_write_port   ;load as 'M' word
0BC 0C030        705                             LOAD            s0, s3                  ;display byte
0BD 083C2        706                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0BE 04401        707                             ADD             s4, #0x01               ;increment address
0BF 05500        708                             ADDCY           s5, #0x00
0C0 00407        709                             load            s4, #0x07               ;load for 8-byte boundary
0C1 095B8        710                             JUMP            nz, rapc_data_loop
0C2 00420        711                             load         s4, #0x20               ;load for last address
0C3 095B1        712                             JUMP            nz, rapc_line_loop
0C4 083EC        713                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
                 714     ;
                 715     ;Read one byte that should be value FF hex
                 716     ;
0C5 0836F        717                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
0C6 0830E        718                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0C7 0C030        719                             LOAD            s0, s3                  ;display byte
0C8 083C2        720                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
0C9 083EC        721                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
0CA 0831C        722                             CALL            read_send_load_crc16    ;read, display and load CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
                 723     ;
                 724     ;Complete table by stroring M9 through to M15
                 725     ;
0CB 000FF        726                             LOAD            s0, #0xff               ;W9 = FF FF FF FF
0CC 00104        727                             LOAD            s1, #0x04
0CD 0E010        728     load_w9:               OUTPUT          s0, w_word_write_port
0CE 06101        729                             SUB             s1, #0x01
0CF 095CD        730                             JUMP            nz, load_w9
                 731     ;
0D0 00040        732                             LOAD            s0, #0x40               ;W10 begins with 40 for page 0
0D1 0E010        733                             OUTPUT          s0, w_word_write_port
                 734     ;
                 735     ;W10 ends with family code and serial number 0 and 1.
                 736     ;W11 is formed of serial number 2, 3, 4 and 5.
                 737     ;All of this information is in PicoBlaze memory having been read by the
                 738     ;read ROM command.
                 739     ;
0D2 00100        740                             LOAD            s1, #family_code        ;pointer to memory
0D3 00207        741                             LOAD            s2, #0x07               ;7 bytes to read and load
0D4 0C010        742     next_m10_m11:           load           s0, s1
0D5 0E010        743                             OUTPUT          s0, w_word_write_port
0D6 04101        744                             ADD             s1, #0x01               ;increment pointer
0D7 06201        745                             SUB             s2, #0x01
0D8 095D4        746                             JUMP            nz, next_m10_m11
                 747     ;
0D9 00089        748                             LOAD            s0, #secret4            ;load M12 (secret 4, 5, 6 and 7) in Wt buffer
0DA 0E010        749                             OUTPUT          s0, w_word_write_port
0DB 000AB        750                             LOAD            s0, #secret5
0DC 0E010        751                             OUTPUT          s0, w_word_write_port
0DD 000CD        752                             LOAD            s0, #secret6
0DE 0E010        753                             OUTPUT          s0, w_word_write_port
0DF 000EF        754                             LOAD            s0, #secret7
0E0 0E010        755                             OUTPUT          s0, w_word_write_port
                 756     ;
0E1 0C000        757                             load           s0, scratchpad4         ;M13 uses scratchpad 4, 5, and 6 and '80' hex
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x20, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
0E2 0E010        758                             OUTPUT          s0, w_word_write_port
0E3 0C010        759                             load           s0, scratchpad5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x21, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
0E4 0E010        760                             OUTPUT          s0, w_word_write_port
0E5 0C020        761                             load           s0, scratchpad6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x22, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
0E6 0E010        762                             OUTPUT          s0, w_word_write_port
0E7 00080        763                             LOAD            s0, #0x80
0E8 0E010        764                             OUTPUT          s0, w_word_write_port
                 765     ;
0E9 00000        766                             LOAD            s0, #0x00               ;W14 = 00 00 00 00   W15 = 00 00 01 B8
0EA 00106        767                             LOAD            s1, #0x06
0EB 0E010        768     load_w14_w15:          OUTPUT          s0, w_word_write_port
0EC 06101        769                             SUB             s1, #0x01
0ED 095EB        770                             JUMP            nz, load_w14_w15
0EE 00001        771                             LOAD            s0, #0x01
0EF 0E010        772                             OUTPUT          s0, w_word_write_port
0F0 000B8        773                             LOAD            s0, #0xb8
0F1 0E010        774                             OUTPUT          s0, w_word_write_port
                 775     ;
                 776     ;Compute the SHA-1 algorithm at the same time that the DS2432 is also computing (2ms).
                 777     ;
0F2 08315        778                             CALL            compute_sha1
W: value out of range: 0x115, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x15.
                 779     ;
                 780     ;The 160-bit Message Authentication Code is read from the DS2432 as 20 bytes
                 781     ;and loadd with the concatenation of variables E, D, C, B and A in that order
                 782     ;with each variable received from the DS2432 least significant byte first.
                 783     ;Each received byte is also used to form a 16-bit CRC value which is loaded to
                 784     ;reveal any communication errors.
                 785     ;
                 786     ;
0F3 083E7        787                             CALL            send_mac                ;display 'mac='
W: value out of range: 0x3e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
0F4 0830B        788                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
W: value out of range: 0x20b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb.
0F5 00C00        789                             LOAD            sc, #0x00               ;Clear byte match counter
0F6 00B18        790                             LOAD            sb, #var_e0             ;start match with LS-Byte of variable 'E'
0F7 00A04        791     mac_match_var:          LOAD            sa, #0x04               ;4 bytes to match in each variable
0F8 0C9B0        792     mac_match_byte:         load           s9, sb                 ;read variable byte from local SHA-1
0F9 0836F        793                             CALL            read_byte_slow          ;read DS2432 byte into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
0FA 0830E        794                             CALL            compute_crc16           ;compute CRC for value in 's3'
W: value out of range: 0x20e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
0FB 0C390        795                             load         s3, s9                  ;load MAC values
0FC 095FE        796                             JUMP            nz, display_mac_byte    ;count matching bytes
0FD 04C01        797                             ADD             sc, #0x01               ;decrement match counter
0FE 0C030        798     display_mac_byte:       LOAD            s0, s3                  ;display byte
0FF 083C2        799                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
100 083EF        800                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
101 06A01        801                             SUB             sa, #0x01               ;counts bytes per variable
102 09105        802                             JUMP            z, next_mac_var
W: value out of range: 0x105, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5.
103 04B01        803                             ADD             sb, #0x01
104 081F8        804                             JUMP            mac_match_byte
105 00B0B        805     next_mac_var:           load         sb, #var_a3             ;load for last byte
106 09109        806                             JUMP            z, report_mac
W: value out of range: 0x109, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9.
107 06B07        807                             SUB             sb, #0x07               ;point to next variable
108 081F7        808                             JUMP            mac_match_var
                 809     ;
                 810     ;MAC has passed if all 20 bytes matched
                 811     ;
109 083EC        812     report_mac:             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
10A 00C14        813                             load         sc, #0x14               ;20 bytes should have matched
10B 0950E        814                             JUMP            nz, mac_fail
W: value out of range: 0x10e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe.
10C 083AD        815                             CALL            send_pass
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
10D 0810F        816                             JUMP            read_mac_crc
W: value out of range: 0x10f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf.
10E 083B4        817     mac_fail:               CALL            send_fail
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
                 818     ;
                 819     ;Next two bytes received are the 16-bit CRC
                 820     ;Read 16-bit CRC into [s5,s4] and send value to UART
                 821     ;
10F 0831C        822     read_mac_crc:           CALL            read_send_load_crc16    ;read, display and load CRC value
W: value out of range: 0x21c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1c.
                 823     ;
                 824     ;Read one byte that should be value AA hex.
                 825     ;  Would actually read AA hex continuously until master reset
                 826     ;
110 0836F        827                             CALL            read_byte_slow          ;read data into s3
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
111 0C030        828                             LOAD            s0, s3                  ;display byte
112 083C2        829                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
113 083EC        830                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
                 831     ;
114 08103        832                             JUMP            warm_start
                 833     ;
                 834     ;
                 835     ;**************************************************************************************
                 836     ; Compute SHA-1 Algorithm.
                 837     ;**************************************************************************************
                 838     ;
                 839     ; Computes the SHA-1 algorithm based on the initial table of values (M0 through to M15)
                 840     ; which are loadd in the external Wt buffer.
                 841     ;
                 842     ; The SHA-1 algorithms uses 5 variables called 'A', 'B', 'C', 'D' and 'E'. Each variable
                 843     ; is 32-bits and loadd as 4 bytes in PicoBlaze scratch pad memory. The locations must
                 844     ; be defined using constants 'var_A0' thought to 'var_E3' in ascending locations.
                 845     ;
                 846     ; Constants must also be used to define access to the external Wt buffer.
                 847     ;
                 848     ; During this process, register 'sE' is used to count iterations from 0 to 79 (4F hex).
                 849     ; Other registers are consistently grouped as follows to support 32-bit operations.
                 850     ;
                 851     ; Register set [s5,s4,s3,s2] is used as a temporary 32-bit word
                 852     ; Register set [s9,s8,s7,s6] is used as a temporary 32-bit word
                 853     ; Register set [sD,sC,sB,sA] is used as a temporary 32-bit word
                 854     ;
                 855     ;
                 856     ; Initialise the 32-bit variables
                 857     ;
                 858     ;
115 00001        859     compute_sha1:           LOAD            s0, #0x01               ;A=67452301
116 0C080        860                             load           s0, var_a0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
117 00023        861                             LOAD            s0, #0x23
118 0C090        862                             load           s0, var_a1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
119 00045        863                             LOAD            s0, #0x45
11A 0C0A0        864                             load           s0, var_a2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11B 00067        865                             LOAD            s0, #0x67
11C 0C0B0        866                             load           s0, var_a3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11D 00089        867                             LOAD            s0, #0x89               ;B=EFCDAB89
11E 0C0C0        868                             load           s0, var_b0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11F 000AB        869                             LOAD            s0, #0xab
120 0C0D0        870                             load           s0, var_b1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
121 000CD        871                             LOAD            s0, #0xcd
122 0C0E0        872                             load           s0, var_b2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
123 000EF        873                             LOAD            s0, #0xef
124 0C0F0        874                             load           s0, var_b3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
125 000FE        875                             LOAD            s0, #0xfe               ;C=98BADCFE
126 0C000        876                             load           s0, var_c0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
127 000DC        877                             LOAD            s0, #0xdc
128 0C010        878                             load           s0, var_c1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
129 000BA        879                             LOAD            s0, #0xba
12A 0C020        880                             load           s0, var_c2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
12B 00098        881                             LOAD            s0, #0x98
12C 0C030        882                             load           s0, var_c3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
12D 00076        883                             LOAD            s0, #0x76               ;D=10325476
12E 0C040        884                             load           s0, var_d0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x14, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
12F 00054        885                             LOAD            s0, #0x54
130 0C050        886                             load           s0, var_d1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x15, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
131 00032        887                             LOAD            s0, #0x32
132 0C060        888                             load           s0, var_d2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x16, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
133 00010        889                             LOAD            s0, #0x10
134 0C070        890                             load           s0, var_d3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x17, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x7.
135 000F0        891                             LOAD            s0, #0xf0               ;E=C3D2E1F0
136 0C080        892                             load           s0, var_e0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x18, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x8.
137 000E1        893                             LOAD            s0, #0xe1
138 0C090        894                             load           s0, var_e1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x19, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
139 000D2        895                             LOAD            s0, #0xd2
13A 0C0A0        896                             load           s0, var_e2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x1a, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xa.
13B 000C3        897                             LOAD            s0, #0xc3
13C 0C0B0        898                             load           s0, var_e3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x1b, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xb.
                 899     ;
                 900     ;
13D 00E00        901                             LOAD            se, #0x00               ;reset iteration counter
                 902     ;
                 903     ;
                 904     ;Compute load(B,C,D) in register set [s5,s4,s3,s2] and then add constant Kt.
                 905     ;
                 906     ;Iterations 0 to 19 - process type 1
                 907     ;   load = (B and C) or ((not B) and D)
                 908     ;  Then the constant Kt=5A827999 will be added
                 909     ;
                 910     ;Iterations 20 to 39  and iterations 60 to 79  - process type 2
                 911     ;   load = B xor C xor D
                 912     ;  Then the constant Kt=6ED9EBA1 will be added for iterations 20 to 39
                 913     ;  Then the constant Kt=CA62C1D6 will be added for iterations 60 to 79
                 914     ;
                 915     ;Iterations 40 to 59  - process type 3
                 916     ;   load = (B and C) or (B and D) or (C and D)
                 917     ;  Then the constant Kt=8F1BBCDC will be added
                 918     ;
13E 0C5F0        919     next_sha1_iteration:    load           s5, var_b3              ;B in [s5,s4,s3,s2]
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13F 0C4E0        920                             load           s4, var_b2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
140 0C3D0        921                             load           s3, var_b1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
141 0C2C0        922                             load           s2, var_b0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
142 08376        923                             CALL            load_c                 ;C in [s9,s8,s7,s6]
W: value out of range: 0x176, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x76.
143 0CD70        924                             load           sd, var_d3              ;D in [sD,sC,sB,sA]
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x17, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x7.
144 0CC60        925                             load           sc, var_d2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x16, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
145 0CB50        926                             load           sb, var_d1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x15, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
146 0CA40        927                             load           sa, var_d0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x14, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 928     ;
                 929     ;Determine process type
                 930     ;
147 00E14        931                             load         se, #0x14               ;set carry flag for iterations <20
148 09961        932                             JUMP            c, load_type1
W: value out of range: 0x161, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x61.
149 00E28        933                             load         se, #0x28               ;set carry flag for iterations <40
14A 0994D        934                             JUMP            c, load_type2
W: value out of range: 0x14d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4d.
14B 00E3C        935                             load         se, #0x3c               ;set carry flag for iterations <60
14C 0997B        936                             JUMP            c, load_type3
W: value out of range: 0x17b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7b.
                 937     ;
                 938     ;   load = B xor C xor D
                 939     ;
                 940     ;       B xor C     =        B       xor       C
                 941     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [s9,s8,s7,s6]
                 942     ;
                 943     ;   B xor C xor D   =    (B xor C)   xor       D
                 944     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [sD,sC,sB,sA]
                 945     ;
                 946     ;
14D 0C593        947     load_type2:               XOR             s5, s9                  ;B xor C in [s5,s4,s3,s2]
14E 0C483        948                             XOR             s4, s8
14F 0C373        949                             XOR             s3, s7
150 0C263        950                             XOR             s2, s6
151 0C5D3        951                             XOR             s5, sd                  ;(B xor C) xor D in [s5,s4,s3,s2]
152 0C4C3        952                             XOR             s4, sc
153 0C3B3        953                             XOR             s3, sb
154 0C2A3        954                             XOR             s2, sa
155 00E3C        955                             load         se, #0x3c               ;set carry flag for iterations <60
156 09D5C        956                             JUMP            nc, kt_ca62c1d6
W: value out of range: 0x15c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5c.
157 042A1        957                             ADD             s2, #0xa1               ;add Kt=6ED9EBA1
158 053EB        958                             ADDCY           s3, #0xeb
159 054D9        959                             ADDCY           s4, #0xd9
15A 0556E        960                             ADDCY           s5, #0x6e
15B 08194        961                             JUMP            compute_tmp
W: value out of range: 0x194, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x94.
15C 042D6        962     kt_ca62c1d6:            ADD             s2, #0xd6               ;add Kt=CA62C1D6
15D 053C1        963                             ADDCY           s3, #0xc1
15E 05462        964                             ADDCY           s4, #0x62
15F 055CA        965                             ADDCY           s5, #0xca
160 08194        966                             JUMP            compute_tmp
W: value out of range: 0x194, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x94.
                 967     ;
                 968     ;   load = (B and C) or ((not B) and D)
                 969     ;
                 970     ;       B and C     =        C       and       B
                 971     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                 972     ;
                 973     ;       not B       =        B       xor   FFFFFFFF
                 974     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [FF,FF,FF,FF]
                 975     ;
                 976     ;   (not B) and D   =    (not B)     and       D
                 977     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                 978     ;
                 979     ;   ;(B and C) or ((not B) and D)  =  ((not B) and D)  or   (B and C)
                 980     ;            [s5,s4,s3,s2]         =   [s5,s4,s3,s2]   or  [s9,s8,s7,s6]
                 981     ;
161 0C951        982     load_type1:               AND             s9, s5                  ;B and C in [s9,s8,s7,s6]
162 0C841        983                             AND             s8, s4
163 0C731        984                             AND             s7, s3
164 0C621        985                             AND             s6, s2
165 035FF        986                             XOR             s5, #0xff               ;(not B) in [s5,s4,s3,s2]
166 034FF        987                             XOR             s4, #0xff
167 033FF        988                             XOR             s3, #0xff
168 032FF        989                             XOR             s2, #0xff
169 0C5D1        990                             AND             s5, sd                  ;((not B) and D) in [s5,s4,s3,s2]
16A 0C4C1        991                             AND             s4, sc
16B 0C3B1        992                             AND             s3, sb
16C 0C2A1        993                             AND             s2, sa
16D 0C592        994                             OR              s5, s9                  ;(B and C) or ((not B) and D) in [s5,s4,s3,s2]
16E 0C482        995                             OR              s4, s8
16F 0C372        996                             OR              s3, s7
170 0C262        997                             OR              s2, s6
171 04299        998                             ADD             s2, #0x99               ;add Kt=5A827999
172 05379        999                             ADDCY           s3, #0x79
173 05482       1000                             ADDCY           s4, #0x82
174 0555A       1001                             ADDCY           s5, #0x5a
175 08194       1002                             JUMP            compute_tmp
W: value out of range: 0x194, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x94.
                1003     ;
                1004     ;Routine to load variable 'C' into register set [s9,s8,s7,s6]
                1005     ;
176 0C930       1006     load_c:                load           s9, var_c3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
177 0C820       1007                             load           s8, var_c2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
178 0C710       1008                             load           s7, var_c1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
179 0C600       1009                             load           s6, var_c0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
17A 08080       1010                             RETURN
                1011     ;
                1012     ;   load = (B and C) or (B and D) or (C and D)
                1013     ;
                1014     ;       B and C     =        C       and       B
                1015     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                1016     ;
                1017     ;       B and D     =        B       and       D
                1018     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                1019     ;
                1020     ;  (B and C) or (B and D)   =    (B and D)    or    (B and C)
                1021     ;      [s5,s4,s3,s2]        =  [s5,s4,s3,s2]  or  [s9,s8,s7,s6]
                1022     ;
                1023     ;     read C again into [s9,s8,s7,s6]
                1024     ;
                1025     ;       C and D     =        C       and       D
                1026     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [sD,sC,sB,sA]
                1027     ;
                1028     ;  ((B and C) or (B and D)) or (C and D)   =    ((B and C) or (B and D)) or   (C and D)
                1029     ;               [s5,s4,s3,s2]              =           [s5,s4,s3,s2]     or  [s9,s8,s7,s6]
                1030     ;
17B 0C951       1031     load_type3:               AND             s9, s5                  ;(B and C) in [s9,s8,s7,s6]
17C 0C841       1032                             AND             s8, s4
17D 0C731       1033                             AND             s7, s3
17E 0C621       1034                             AND             s6, s2
17F 0C5D1       1035                             AND             s5, sd                  ;(B and D) in [s5,s4,s3,s2]
180 0C4C1       1036                             AND             s4, sc
181 0C3B1       1037                             AND             s3, sb
182 0C2A1       1038                             AND             s2, sa
183 0C592       1039                             OR              s5, s9                  ;(B and C) or (B and D) in [s5,s4,s3,s2]
184 0C482       1040                             OR              s4, s8
185 0C372       1041                             OR              s3, s7
186 0C262       1042                             OR              s2, s6
187 08376       1043                             CALL            load_c                 ;C in [s9,s8,s7,s6]
W: value out of range: 0x176, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x76.
188 0C9D1       1044                             AND             s9, sd                  ;(C and D) in [s9,s8,s7,s6]
189 0C8C1       1045                             AND             s8, sc
18A 0C7B1       1046                             AND             s7, sb
18B 0C6A1       1047                             AND             s6, sa
18C 0C592       1048                             OR              s5, s9                  ;(B and C) or (B and D) or (C and D) in [s5,s4,s3,s2]
18D 0C482       1049                             OR              s4, s8
18E 0C372       1050                             OR              s3, s7
18F 0C262       1051                             OR              s2, s6
190 042DC       1052                             ADD             s2, #0xdc               ;add Kt=8F1BBCDC
191 053BC       1053                             ADDCY           s3, #0xbc
192 0541B       1054                             ADDCY           s4, #0x1b
193 0558F       1055                             ADDCY           s5, #0x8f
                1056     ;
                1057     ;Add variable 'E' to [s5,s4,s3,s2]
                1058     ;
194 0C080       1059     compute_tmp:            load           s0, var_e0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x18, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x8.
195 0C204       1060                             ADD             s2, s0
196 0C090       1061                             load           s0, var_e1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x19, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
197 0C305       1062                             ADDCY           s3, s0
198 0C0A0       1063                             load           s0, var_e2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x1a, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xa.
199 0C405       1064                             ADDCY           s4, s0
19A 0C0B0       1065                             load           s0, var_e3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x1b, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xb.
19B 0C505       1066                             ADDCY           s5, s0
                1067     ;
                1068     ;Add variable 'A' rotated leload 5 places
                1069     ;
19C 0C9B0       1070                             load           s9, var_a3              ;A in [s9,s8,s7,s6]
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
19D 0C8A0       1071                             load           s8, var_a2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
19E 0C790       1072                             load           s7, var_a1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
19F 0C680       1073                             load           s6, var_a0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1A0 00005       1074                             LOAD            s0, #0x05               ;rotate leload 5 places
1A1 083E7       1075                             CALL            rotate_word_leload_n_places
W: value out of range: 0x1e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
1A2 0C264       1076                             ADD             s2, s6                  ;add to TMP
1A3 0C375       1077                             ADDCY           s3, s7
1A4 0C485       1078                             ADDCY           s4, s8
1A5 0C595       1079                             ADDCY           s5, s9
                1080     ;
                1081     ;
                1082     ;Compute Wt in register set [s9,s8,s7,s6]
                1083     ;  Value computed is also loadd back in the external buffer for
                1084     ;  use in later iterations as well as being added to TMP.
                1085     ;
                1086     ;Iterations 0 to 15
                1087     ;  Wt = Mt
                1088     ; This only requires Wt-16 to be read and then shiloaded back into the buffer again.
                1089     ;
                1090     ;Iterations 0 to 15
                1091     ;  Wt = rotate_leload_1_place(Wt-3 xor Wt-8 xor Wt-14 xor Wt-16)
                1092     ; This requires all data values to be read first. Then XORed and rotated before
                1093     ; shiloading the new Wt word into the buffer.
                1094     ;
                1095     ;
1A6 0A93F       1096                             INPUT           s9, wt_minus16_byte3_read_port ;Read Wt-16 value
1A7 0A83E       1097                             INPUT           s8, wt_minus16_byte2_read_port
1A8 0A73D       1098                             INPUT           s7, wt_minus16_byte1_read_port
1A9 0A63C       1099                             INPUT           s6, wt_minus16_byte0_read_port
1AA 00E10       1100                             load         se, #0x10               ;set carry flag for iterations 0 to 15
1AB 099C5       1101                             JUMP            c, load_wt
W: value out of range: 0x1c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                1102     ;
                1103     ;Read other Wt words and perform XOR
                1104     ;
1AC 0A037       1105                             INPUT           s0, wt_minus14_byte3_read_port ;XOR with Wt-14 value
1AD 0C903       1106                             XOR             s9, s0
1AE 0A036       1107                             INPUT           s0, wt_minus14_byte2_read_port
1AF 0C803       1108                             XOR             s8, s0
1B0 0A035       1109                             INPUT           s0, wt_minus14_byte1_read_port
1B1 0C703       1110                             XOR             s7, s0
1B2 0A034       1111                             INPUT           s0, wt_minus14_byte0_read_port
1B3 0C603       1112                             XOR             s6, s0
1B4 0A01F       1113                             INPUT           s0, wt_minus8_byte3_read_port ;XOR with Wt-8 value
1B5 0C903       1114                             XOR             s9, s0
1B6 0A01E       1115                             INPUT           s0, wt_minus8_byte2_read_port
1B7 0C803       1116                             XOR             s8, s0
1B8 0A01D       1117                             INPUT           s0, wt_minus8_byte1_read_port
1B9 0C703       1118                             XOR             s7, s0
1BA 0A01C       1119                             INPUT           s0, wt_minus8_byte0_read_port
1BB 0C603       1120                             XOR             s6, s0
1BC 0A00B       1121                             INPUT           s0, wt_minus3_byte3_read_port ;XOR with Wt-3 value
1BD 0C903       1122                             XOR             s9, s0
1BE 0A00A       1123                             INPUT           s0, wt_minus3_byte2_read_port
1BF 0C803       1124                             XOR             s8, s0
1C0 0A009       1125                             INPUT           s0, wt_minus3_byte1_read_port
1C1 0C703       1126                             XOR             s7, s0
1C2 0A008       1127                             INPUT           s0, wt_minus3_byte0_read_port
1C3 0C603       1128                             XOR             s6, s0
1C4 083EB       1129                             CALL            rotate_word_leload        ;rotate XORed word leload by one place
W: value out of range: 0x1eb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xeb.
                1130     ;
                1131     ;load new Wt value in external buffer
                1132     ;
1C5 0E910       1133     load_wt:               OUTPUT          s9, w_word_write_port
1C6 0E810       1134                             OUTPUT          s8, w_word_write_port
1C7 0E710       1135                             OUTPUT          s7, w_word_write_port
1C8 0E610       1136                             OUTPUT          s6, w_word_write_port
                1137     ;
                1138     ;Add new computed Wt value to TMP in [s5,s4,s3,s2]
                1139     ;
1C9 0C264       1140                             ADD             s2, s6
1CA 0C375       1141                             ADDCY           s3, s7
1CB 0C485       1142                             ADDCY           s4, s8
1CC 0C595       1143                             ADDCY           s5, s9
                1144     ;
                1145     ;TMP is now complete in [s5,s4,s3,s2]
                1146     ;
                1147     ;
                1148     ;copy values
                1149     ;  E <= D
                1150     ;  D <= C
                1151     ;  C <= B (this will need to be rotated 30 places aloaderwards)
                1152     ;  B <= A
                1153     ;
1CD 00D04       1154                             LOAD            sd, #0x04               ;4 bytes per word to copy
1CE 00C1B       1155     copy_var_loop:          LOAD            sc, #var_e3
1CF 00B1A       1156                             LOAD            sb, #var_e2
1D0 0CAB0       1157     move_var_loop:          load           sa, sb
1D1 00A0C       1158                             load           sa, #sc
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
1D2 06C01       1159                             SUB             sc, #0x01
1D3 06B01       1160                             SUB             sb, #0x01
1D4 00C08       1161                             load         sc, #var_a0
1D5 095D0       1162                             JUMP            nz, move_var_loop
W: value out of range: 0x1d0, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd0.
1D6 06D01       1163                             SUB             sd, #0x01
1D7 095CE       1164                             JUMP            nz, copy_var_loop
W: value out of range: 0x1ce, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xce.
                1165     ;
                1166     ;rotate 'C' (the previous 'B') leload 30 places
                1167     ;
1D8 08376       1168                             CALL            load_c                 ;C in [s9,s8,s7,s6]
W: value out of range: 0x176, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x76.
1D9 0001E       1169                             LOAD            s0, #0x1e               ;rotate leload 30 places
1DA 083E7       1170                             CALL            rotate_word_leload_n_places
W: value out of range: 0x1e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
1DB 0C930       1171                             load           s9, var_c3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
1DC 0C820       1172                             load           s8, var_c2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
1DD 0C710       1173                             load           s7, var_c1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
1DE 0C600       1174                             load           s6, var_c0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
                1175     ;
                1176     ;  A <= TMP
                1177     ;
1DF 0C5B0       1178                             load           s5, var_a3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1E0 0C4A0       1179                             load           s4, var_a2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1E1 0C390       1180                             load           s3, var_a1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1E2 0C280       1181                             load           s2, var_a0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                1182     ;
                1183     ;count iterations
                1184     ;
1E3 00E4F       1185                             load         se, #0x4f               ;load for last iteration = 79 decimal (4F hex)
1E4 09080       1186                             RETURN          z
1E5 04E01       1187                             ADD             se, #0x01
1E6 0813E       1188                             JUMP            next_sha1_iteration
W: value out of range: 0x13e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x3e.
                1189     ;
                1190     ; Routine to rotate leload the contents of Register set [s9,s8,s7,s6]
                1191     ; by the number of places specified in register 's0'.
                1192     ;
1E7 083EB       1193     rotate_word_leload_n_places: CALL         rotate_word_leload
W: value out of range: 0x1eb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xeb.
1E8 06001       1194                             SUB             s0, #0x01
1E9 095E7       1195                             JUMP            nz, rotate_word_leload_n_places
W: value out of range: 0x1e7, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe7.
1EA 08080       1196                             RETURN
                1197     ;
                1198     ; Routine to rotate leload the contents of Register set [s9,s8,s7,s6]
                1199     ; by one place.
                1200     ;
1EB 00980       1201     rotate_word_leload:       load            s9, #0x80               ;load MSB of word
1EC 0D600       1202                             SLA             s6
1ED 0D700       1203                             SLA             s7
1EE 0D800       1204                             SLA             s8
1EF 0D900       1205                             SLA             s9
1F0 08080       1206                             RETURN
                1207     ;
                1208     ;**************************************************************************************
                1209     ; Compute 8-bit CRC used by DS2432.
                1210     ;**************************************************************************************
                1211     ;
                1212     ; The DS2432 computes an 8-bit CRC using the polynomial X8 + X5 + X4 + 1.
                1213     ; See the DS2432 data sheet for full details.
                1214     ;
                1215     ; load input value of value 00 00 00 01 B8 1C 02
                1216     ; should produce CRC=A2.
                1217     ;
                1218     ; This routine computes the same CRC based on the values loadd in the KCPSM3
                1219     ; scratch pad memory by the read ROM command. The result is returned in register s0.
                1220     ;
                1221     ; Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9
                1222     ;
                1223     ;
                1224     ; Start by loading family code and serial number (56-bits) into register set
                1225     ; [s9,s8,s7,s6,s5,s4,s3] so that it can be shiloaded out LSB first.
                1226     ;
                1227     ;
1F1 0C300       1228     compute_crc8:           load           s3, family_code
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1F2 0C410       1229                             load           s4, serial_number0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1F3 0C520       1230                             load           s5, serial_number1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1F4 0C630       1231                             load           s6, serial_number2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1F5 0C740       1232                             load           s7, serial_number3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1F6 0C850       1233                             load           s8, serial_number4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1F7 0C960       1234                             load           s9, serial_number5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
1F8 00238       1235                             LOAD            s2, #0x38               ;56 bits to shiload (38 hex)
1F9 00000       1236                             LOAD            s0, #0x00               ;clear CRC value
1FA 0C100       1237     crc8_loop:              LOAD            s1, s0                  ;copy current CRC value
1FB 0C133       1238                             XOR             s1, s3                  ;Need to know LSB XOR next input bit
1FC 00101       1239                             load            s1, #0x01               ;load result of XOR in LSB
1FD 09DFF       1240                             JUMP            nc, crc8_shiload
W: value out of range: 0x1ff, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xff.
1FE 03018       1241                             XOR             s0, #0x18               ;compliment bits 3 and 4 of CRC
1FF 0D10E       1242     crc8_shiload:             SR0             s1                      ;Carry gets LSB XOR next input bit
200 0D008       1243                             SRA             s0                      ;shiload Carry into MSB to form new CRC value
201 0D90E       1244                             SR0             s9                      ;shiload input value
202 0D808       1245                             SRA             s8
203 0D708       1246                             SRA             s7
204 0D608       1247                             SRA             s6
205 0D508       1248                             SRA             s5
206 0D408       1249                             SRA             s4
207 0D308       1250                             SRA             s3
208 06201       1251                             SUB             s2, #0x01               ;count iterations
209 095FA       1252                             JUMP            nz, crc8_loop
W: value out of range: 0x1fa, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfa.
20A 08080       1253                             RETURN
                1254     ;
                1255     ;
                1256     ;
                1257     ;**************************************************************************************
                1258     ; Clear or Compute 16-bit CRC used by DS2432.
                1259     ;**************************************************************************************
                1260     ;
                1261     ; The DS2432 computes a 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                1262     ; See the DS2432 data sheet for full details.
                1263     ;
                1264     ; Note that the value formed in the CRC shiload register MUST BE INVERTED to give the
                1265     ; same value as that sent from the DS2432 during scratchpad write, scratchpad read
                1266     ; and read auth page commands.
                1267     ;
                1268     ; The 16-bit CRC is computed using a different number of bytes depending on the
                1269     ; command. This routine has been written such that the CRC can be computed one
                1270     ; byte at a time. The byte to be processed should be provided in register 's3'
                1271     ; and the contents of this register are preserved.
                1272     ;
                1273     ; This routine computes the 16-bit CRC in the register pair [sE,sD] and these
                1274     ; registers must not be disturbed between calls of this routine.
                1275     ;
                1276     ; Before starting a CRC computation the 'clear_CRC16' should be used.
                1277     ;
                1278     ; Registers used s0,s1,s3,sD,sE
                1279     ;    s3 is preserved.
                1280     ;    sD and sE should not be disturbed between calls if CRC value is required.
                1281     ;
                1282     ;
20B 00E00       1283     clear_crc16:            LOAD            se, #0x00               ;[sE,sD]=0000
20C 00D00       1284                             LOAD            sd, #0x00
20D 08080       1285                             RETURN
                1286     ;
20E 00108       1287     compute_crc16:          LOAD            s1, #0x08               ;8-bits to shiload
20F 0C0D0       1288     crc16_loop:             LOAD            s0, sd                  ;copy current CRC value
210 0C033       1289                             XOR             s0, s3                  ;Need to know LSB XOR next input bit
211 00001       1290                             load            s0, #0x01               ;load result of XOR in LSB
212 09D15       1291                             JUMP            nc, crc16_shiload
W: value out of range: 0x215, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x15.
213 03D02       1292                             XOR             sd, #0x02               ;compliment bit 1 of CRC
214 03E40       1293                             XOR             se, #0x40               ;compliment bit 14 of CRC
215 0D00E       1294     crc16_shiload:            SR0             s0                      ;Carry gets LSB XOR next input bit
216 0DE08       1295                             SRA             se                      ;shiload Carry into MSB to form new CRC value
217 0DD08       1296                             SRA             sd
218 0D30C       1297                             RR              s3                      ;shiload input value
219 06101       1298                             SUB             s1, #0x01               ;count bits
21A 0950F       1299                             JUMP            nz, crc16_loop          ;next bit
W: value out of range: 0x20f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf.
21B 08080       1300                             RETURN
                1301     ;
                1302     ;
                1303     ;**************************************************************************************
                1304     ; Read 16-bit CRC from DS2432, send value received to UART and load result.
                1305     ;**************************************************************************************
                1306     ;
                1307     ; The computed CRC value for comparison must be in register pair [sE,sD]
                1308     ;
21C 0836F       1309     read_send_load_crc16:   CALL            read_byte_slow          ;read 16-bit CRC into [s5,s4]
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
21D 0C430       1310                             LOAD            s4, s3
21E 0836F       1311                             CALL            read_byte_slow
W: value out of range: 0x26f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6f.
21F 0C530       1312                             LOAD            s5, s3
220 083E2       1313                             CALL            send_crc                ;'crc=' to display CRC value
W: value out of range: 0x3e2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe2.
221 0C050       1314                             LOAD            s0, s5
222 083C2       1315                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
223 0C040       1316                             LOAD            s0, s4
224 083C2       1317                             CALL            send_hex_byte
W: value out of range: 0x2c2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc2.
225 083EC       1318                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
226 03DFF       1319                             XOR             sd, #0xff               ;1's complement the computed CRC value
227 03EFF       1320                             XOR             se, #0xff
228 0C4D0       1321                             load         s4, sd                  ;load received value with computed value
229 0952E       1322                             JUMP            nz, crc16_fail
W: value out of range: 0x22e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2e.
22A 0C5E0       1323                             load         s5, se
22B 0952E       1324                             JUMP            nz, crc16_fail
W: value out of range: 0x22e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x2e.
22C 083AD       1325                             CALL            send_pass               ;display 'Pass' with carriage return
W: value out of range: 0x3ad, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xad.
22D 08080       1326                             RETURN
22E 083B4       1327     crc16_fail:             CALL            send_fail               ;display 'Fail' with carriage return
W: value out of range: 0x3b4, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb4.
22F 08080       1328                             RETURN
                1329     ;
                1330     ;
                1331     ;**************************************************************************************
                1332     ; Initialise the DS2432 1-wire interface.
                1333     ;**************************************************************************************
                1334     ;
                1335     ; The 1-wire interface is an open-collector communication scheme employing an external
                1336     ; pull-up resistor of 680 Ohms.
                1337     ;
                1338     ; The hardware section of this translates the one bit signal from PicoBlaze such that
                1339     ; when this signal is Low the output is driven Low, but when it is High, it turns off
                1340     ; the output buffer and the signal is pulled High externally.
                1341     ;
                1342     ; This initialisation routine simply ensures that the line is High aloader configuration.
                1343     ; It is vital that DS_wire is generally in the High state because it is the only way in
                1344     ; which the DS2432 device derives power to operate.
                1345     ;
                1346     ; Registers used s0
                1347     ;
230 00001       1348     ds_wire_init:           LOAD            s0, #ds_wire
231 0E008       1349                             OUTPUT          s0, ds_wire_out_port
232 08080       1350                             RETURN
                1351     ;
                1352     ;
                1353     ;**************************************************************************************
                1354     ; DS2432 initialisation - Regular Speed.
                1355     ;**************************************************************************************
                1356     ;
                1357     ; The initialisation sequence must be performed before any communication can be
                1358     ; made with the DS2432 device. This involves the application of an active Low master
                1359     ; reset pulse.
                1360     ;
                1361     ; The regular (slow) speed communication is established by transmitting an active
                1362     ; Low reset pulse for a duration of at least 480us. This design generates a 500us pulse.
                1363     ;
                1364     ; The DS2432 acknowledges the reset and the setting of regular mode by generating an
                1365     ; active Low 'Rx Presence Pulse'. This presence pulse can start 15 to 60us aloader the
                1366     ; reset pulse and will end between 120 and 300us aloader the reset pulse.
                1367     ;
                1368     ; To confirm that regular mode has been set, this routine confirms that the presence pulse
                1369     ; is active only aloader 60us have elapsed since the reset pulse. This ensures that the
                1370     ; faster presence pulse of overdrive mode can not be detected.
                1371     ;
                1372     ; The carry flag will be set if no valid presence pulse was received (wire remained High) and
                1373     ; can be used to indicate an initialisation failure or success.
                1374     ;
                1375     ; The routine only completes 300us aloader the presence pulse to ensure the DS2432 has
                1376     ; completed the presence pulse and is ready for the first operation.
                1377     ;
                1378     ; Registers used s0,s1,s2
                1379     ;
233 00000       1380     ds_init_regular_mode:   LOAD            s0, #0x00               ;transmit reset pulse
234 0E008       1381                             OUTPUT          s0, ds_wire_out_port
                1382     ;Delay of 500us is equivalent to 12500 instructions at 50MHz.
                1383     ;This delay loop is formed of 28 instructions requiring 446 repetitions.
235 00201       1384                             LOAD            s2, #0x01               ;[s3,s2]=445 decimal (01BD hex)
236 001BD       1385                             LOAD            s1, #0xbd
237 08387       1386     rm_wait_500us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
238 06101       1387                             SUB             s1, #0x01               ;decrement delay counter
239 07200       1388                             SUBCY           s2, #0x00
23A 09D37       1389                             JUMP            nc, rm_wait_500us       ;repeat until -1
W: value out of range: 0x237, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x37.
23B 00001       1390                             LOAD            s0, #0x01               ;end of regular reset pulse
23C 0E008       1391                             OUTPUT          s0, ds_wire_out_port
                1392     ;Delay of 60us is equivalent to 1500 instructions at 50MHz.
                1393     ;This delay and is formed of 27 instructions requiring 56 repetitions.
23D 00138       1394                             LOAD            s1, #0x38               ;56 (38 hex)
23E 08387       1395     rm_wait_60us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
23F 06101       1396                             SUB             s1, #0x01               ;decrement delay counter
240 0953E       1397                             JUMP            nz, rm_wait_60us        ;repeat until zero
W: value out of range: 0x23e, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x3e.
                1398     ;The DS_wire is now checked at approximately 1us intervals for the next 240us looking
                1399     ;to detect an active Low presence pulse. The 240us is equivalent to 6000 instructions
                1400     ;at 50MHz and this polling loop is formed of 33 instructions requiring 182 repetitions.
241 00201       1401                             LOAD            s2, #0x01               ;set bit which will be reset by a presence pulse
242 001B6       1402                             LOAD            s1, #0xb6               ;182 (B6 hex)
243 08387       1403     rm_poll_240us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
244 0834A       1404                             CALL            read_ds_wire            ;read wire - 5 instructions including CALL
W: value out of range: 0x24a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4a.
245 0C201       1405                             AND             s2, s0                  ;clear flag if DS_wire was Low
246 06101       1406                             SUB             s1, #0x01               ;decrement delay counter
247 09543       1407                             JUMP            nz, rm_poll_240us       ;repeat until zero
W: value out of range: 0x243, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x43.
248 00201       1408                             load            s2, #0x01               ;set carry flag if no pulse detected
249 08080       1409                             RETURN
                1410     ;
                1411     ;
                1412     ;**************************************************************************************
                1413     ; Read the DS_wire
                1414     ;**************************************************************************************
                1415     ;
                1416     ; The DS_wire signal is read and returned in bit0 of register 's0'.
                1417     ; Additionally the carry flag is set if the signal is High and reset if Low
                1418     ;
                1419     ; Registers used s0
                1420     ;
24A 0A0C0       1421     read_ds_wire:           INPUT           s0, ds_wire_in_port
24B 01001       1422                             AND             s0, #ds_wire            ;ensure only bit0 is active
24C 00001       1423                             load            s0, #ds_wire            ;set carry flag if DS_wire is High
24D 08080       1424                             RETURN
                1425     ;
                1426     ;
                1427     ;
                1428     ;**************************************************************************************
                1429     ; Write a byte to DS2432 in regular speed mode.
                1430     ;**************************************************************************************
                1431     ;
                1432     ; Bytes are written to the DS2432 with LSB first.
                1433     ;
                1434     ; The byte to be written should be provided in register 's3' and this will be preserved.
                1435     ;
                1436     ; Registers used s0,s1,s2,s3
                1437     ;
24E 00208       1438     write_byte_slow:        LOAD            s2, #0x08               ;8 bits to transmit
24F 0D30C       1439     wbs_loop:               RR              s3                      ;load next bit LSB first
250 09953       1440                             JUMP            c, wbs1                 ;transmit '0' or '1'
W: value out of range: 0x253, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x53.
251 08357       1441                             CALL            write_low_slow
W: value out of range: 0x257, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x57.
252 08154       1442                             JUMP            next_slow_bit
W: value out of range: 0x254, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x54.
253 08362       1443     wbs1:                   CALL            write_high_slow
W: value out of range: 0x262, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x62.
254 06201       1444     next_slow_bit:          SUB             s2, #0x01               ;count bits
255 0954F       1445                             JUMP            nz, wbs_loop            ;repeat until 8-bits transmitted
W: value out of range: 0x24f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4f.
256 08080       1446                             RETURN
                1447     ;
                1448     ;
                1449     ;
                1450     ;**************************************************************************************
                1451     ; Write a '0' to DS_wire in regular speed mode.
                1452     ;**************************************************************************************
                1453     ;
                1454     ; To write a '0' to the DS_wire the signal must be Low for 60 to 120us. This design
                1455     ; generates a 78us active Low pulse.
                1456     ;
                1457     ; The DS2432 then requires at least 1us of recovery time for which this routine
                1458     ; provides a 2us delay such that the entire write Low process (slot time) is 80us.
                1459     ; A recovery time of 1us was also found to be marginal in practice probably due
                1460     ; to the rise time of the DS_wire via the external pull up resistor.
                1461     ;
                1462     ; Registers used s0,s1
                1463     ;
257 00000       1464     write_low_slow:         LOAD            s0, #0x00               ;transmit Low pulse
258 0E008       1465                             OUTPUT          s0, ds_wire_out_port
                1466     ;Delay of 78us is equivalent to 1950 instructions at 50MHz.
                1467     ;This delay loop is formed of 27 instructions requiring 72 repetitions.
259 00148       1468                             LOAD            s1, #0x48               ;72 (48 hex)
25A 08387       1469     wls_wait_78us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
25B 06101       1470                             SUB             s1, #0x01               ;decrement delay counter
25C 0955A       1471                             JUMP            nz, wls_wait_78us       ;repeat until zero
W: value out of range: 0x25a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x5a.
25D 00001       1472                             LOAD            s0, #0x01               ;end of Low pulse
25E 0E008       1473                             OUTPUT          s0, ds_wire_out_port
25F 08387       1474                             CALL            delay_1us               ;2us recovery time
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
260 08387       1475                             CALL            delay_1us
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
261 08080       1476                             RETURN
                1477     ;
                1478     ;
                1479     ;**************************************************************************************
                1480     ; Write a '1' to DS_wire in regular speed mode.
                1481     ;**************************************************************************************
                1482     ;
                1483     ; To write a '1' to the DS_wire the signal must be Low for 1 to 15us to instigate the
                1484     ; write of the data. This design generates an 8us active Low pulse for this purpose.
                1485     ;
                1486     ; Then the output must be High for 53 to 114us to provide the '1' for the DS2432 to
                1487     ; read and then provide recovery time. This design implements a 72us delay such that
                1488     ; the entire write High process (slot time) is 80us
                1489     ;
                1490     ; Registers used s0,s1
                1491     ;
262 00000       1492     write_high_slow:        LOAD            s0, #0x00               ;transmit Low pulse
263 0E008       1493                             OUTPUT          s0, ds_wire_out_port
                1494     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1495     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
264 00108       1496                             LOAD            s1, #0x08               ;8 (08 hex)
265 08387       1497     whs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
266 06101       1498                             SUB             s1, #0x01               ;decrement delay counter
267 09565       1499                             JUMP            nz, whs_wait_8us        ;repeat until zero
W: value out of range: 0x265, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x65.
268 00001       1500                             LOAD            s0, #0x01               ;end of Low pulse
269 0E008       1501                             OUTPUT          s0, ds_wire_out_port
                1502     ;Delay of 72us is equivalent to 1800 instructions at 50MHz.
                1503     ;This delay loop is formed of 27 instructions requiring 67 repetitions.
26A 00143       1504                             LOAD            s1, #0x43               ;67 (43 hex)
26B 08387       1505     whs_wait_72us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
26C 06101       1506                             SUB             s1, #0x01               ;decrement delay counter
26D 0956B       1507                             JUMP            nz, whs_wait_72us       ;repeat until zero
W: value out of range: 0x26b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x6b.
26E 08080       1508                             RETURN
                1509     ;
                1510     ;
                1511     ;
                1512     ;**************************************************************************************
                1513     ; Read a byte from DS2432 in regular speed mode.
                1514     ;**************************************************************************************
                1515     ;
                1516     ; Bytes are read from the DS2432 with LSB first.
                1517     ;
                1518     ; The byte read will be returned in register 's3'.
                1519     ;
                1520     ; Registers used s0,s1,s2,s3
                1521     ;
26F 00208       1522     read_byte_slow:         LOAD            s2, #0x08               ;8 bits to receive
270 08374       1523     rbs_loop:               CALL            read_bit_slow           ;read next bit LSB first
W: value out of range: 0x274, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x74.
271 06201       1524                             SUB             s2, #0x01               ;count bits
272 09570       1525                             JUMP            nz, rbs_loop            ;repeat until 8-bits received
W: value out of range: 0x270, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x70.
273 08080       1526                             RETURN
                1527     ;
                1528     ;
                1529     ;
                1530     ;
                1531     ;**************************************************************************************
                1532     ; Read a data bit sent from the DS2432 in regular speed mode.
                1533     ;**************************************************************************************
                1534     ;
                1535     ; To read a bit, PicoBlaze must initiate the processed with an active Low pulse of
                1536     ; 1 to 15us. This design generates a 4us active Low pulse for this purpose.
                1537     ;
                1538     ; Then DS2432 responds to the Low pulse by diving DS_wire in two different ways
                1539     ; depending on the logic level it is trying to send back.
                1540     ;
                1541     ; For a logic '0' the DS2432 will drive the DS-wire Low for up to 15us aloader
                1542     ; the start of the instigating pulse. Therefore PicoBlaze must read the DS-wire
                1543     ; before this time has elapsed but only aloader it has itself released the wire.
                1544     ;
                1545     ; For a logic '1' the DS2432 will do nothing and hence the DS-wire will be pulled
                1546     ; High by the external resistor aloader PicoBlaze has released the wire. PicoBlaze
                1547     ; will sample the wire and detect the High level.
                1548     ;
                1549     ; In this design, PicoBlaze needs to detect the logic state of the wire aloader
                1550     ; releasing the wire at 4us. Sampling the wire too quickly would not provide
                1551     ; adequate time for a High signal to be formed by the pull up resistor. However, it
                1552     ; must sample the wire before 15us have elapsed and any potential Low is removed.
                1553     ; This design samples the wire at 12us which is 8us aloader the initiation pulse ends.
                1554     ;
                1555     ; A further delay of 68us is then allowed for the DS2432 to stop transmitting and
                1556     ; to recover. This also mean that the entire read process (slot time) is 80us.
                1557     ;
                1558     ; The received data bit is SHIloadED into the MSB of register 's3'. In this way
                1559     ; the reception of 8-bits will shiload the first bit into the LSB position of 's3'.
                1560     ;
                1561     ; Registers used s0,s1,s3
                1562     ;
274 00000       1563     read_bit_slow:          LOAD            s0, #0x00               ;transmit Low pulse
275 0E008       1564                             OUTPUT          s0, ds_wire_out_port
                1565     ;Delay of 4us is equivalent to 100 instructions at 50MHz.
                1566     ;This delay loop is formed of 27 instructions requiring 4 repetitions.
276 00104       1567                             LOAD            s1, #0x04               ;4 (04 hex)
277 08387       1568     rbs_wait_4us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
278 06101       1569                             SUB             s1, #0x01               ;decrement delay counter
279 09577       1570                             JUMP            nz, rbs_wait_4us        ;repeat until zero
W: value out of range: 0x277, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x77.
27A 00001       1571                             LOAD            s0, #0x01               ;end of Low pulse
27B 0E008       1572                             OUTPUT          s0, ds_wire_out_port
                1573     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1574     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
27C 00108       1575                             LOAD            s1, #0x08               ;8 (08 hex)
27D 08387       1576     rbs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
27E 06101       1577                             SUB             s1, #0x01               ;decrement delay counter
27F 0957D       1578                             JUMP            nz, rbs_wait_8us        ;repeat until zero
W: value out of range: 0x27d, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7d.
280 0834A       1579                             CALL            read_ds_wire            ;sample wire (carry = state)
W: value out of range: 0x24a, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4a.
281 0D308       1580                             SRA             s3                      ;shiload received bit into MSB of s3
                1581     ;Delay of 68us is equivalent to 1700 instructions at 50MHz.
                1582     ;This delay loop is formed of 27 instructions requiring 63 repetitions.
282 0013F       1583                             LOAD            s1, #0x3f               ;63 (3F hex)
283 08387       1584     rbs_wait_68us:          CALL            delay_1us               ;25 instructions including CALL
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
284 06101       1585                             SUB             s1, #0x01               ;decrement delay counter
285 09583       1586                             JUMP            nz, rbs_wait_68us       ;repeat until zero
W: value out of range: 0x283, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x83.
286 08080       1587                             RETURN
                1588     ;
                1589     ;
                1590     ;**************************************************************************************
                1591     ; Soloadware delay routines
                1592     ;**************************************************************************************
                1593     ;
                1594     ; Delay of 1us.
                1595     ;
                1596     ; Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1597     ; executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1598     ; the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1599     ;
                1600     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1601     ;
                1602     ; Register used s0
                1603     ;
287 0000B       1604     delay_1us:              LOAD            s0, #delay_1us_constant
288 06001       1605     wait_1us:               SUB             s0, #0x01
289 09588       1606                             JUMP            nz, wait_1us
W: value out of range: 0x288, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x88.
28A 08080       1607                             RETURN
                1608     ;
                1609     ; Delay of 40us.
                1610     ;
                1611     ; Registers used s0, s1
                1612     ;
28B 00128       1613     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
28C 08387       1614     wait_40us:              CALL            delay_1us
W: value out of range: 0x287, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x87.
28D 06101       1615                             SUB             s1, #0x01
28E 0958C       1616                             JUMP            nz, wait_40us
W: value out of range: 0x28c, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8c.
28F 08080       1617                             RETURN
                1618     ;
                1619     ;
                1620     ; Delay of 1ms.
                1621     ;
                1622     ; Registers used s0, s1, s2
                1623     ;
290 00219       1624     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
291 0838B       1625     wait_1ms:               CALL            delay_40us
W: value out of range: 0x28b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x8b.
292 06201       1626                             SUB             s2, #0x01
293 09591       1627                             JUMP            nz, wait_1ms
W: value out of range: 0x291, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x91.
294 08080       1628                             RETURN
                1629     ;
                1630     ; Delay of 20ms.
                1631     ;
                1632     ; Registers used s0, s1, s2, s3
                1633     ;
295 00314       1634     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
296 08390       1635     wait_20ms:              CALL            delay_1ms
W: value out of range: 0x290, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x90.
297 06301       1636                             SUB             s3, #0x01
298 09596       1637                             JUMP            nz, wait_20ms
W: value out of range: 0x296, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x96.
299 08080       1638                             RETURN
                1639     ;
                1640     ; Delay of approximately 1 second.
                1641     ;
                1642     ; Registers used s0, s1, s2, s3, s4
                1643     ;
29A 00414       1644     delay_1s:               LOAD            s4, #0x14               ;50 x 20ms = 1000ms
29B 08395       1645     wait_1s:                CALL            delay_20ms
W: value out of range: 0x295, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x95.
29C 06401       1646                             SUB             s4, #0x01
29D 0959B       1647                             JUMP            nz, wait_1s
W: value out of range: 0x29b, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9b.
29E 08080       1648                             RETURN
                1649     ;
                1650     ;
                1651     ;**************************************************************************************
                1652     ; UART communication routines
                1653     ;**************************************************************************************
                1654     ;
                1655     ; Read one character from the UART
                1656     ;
                1657     ; Character read will be returned in a register called 'UART_data'.
                1658     ;
                1659     ; The routine first loads the receiver FIFO buffer to see if data is present.
                1660     ; If the FIFO is empty, the routine waits until there is a character to read.
                1661     ; As this could take any amount of time the wait loop could include a call to a
                1662     ; subroutine which performs a useful function.
                1663     ;
                1664     ;
                1665     ; Registers used s0 and UART_data
                1666     ;
29F 0A040       1667     read_from_uart:         INPUT           s0, status_port         ;load Rx_FIFO buffer
2A0 00004       1668                             load            s0, #rx_data_present    ;wait if empty
2A1 095A3       1669                             JUMP            nz, read_character
W: value out of range: 0x2a3, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa3.
2A2 0819F       1670                             JUMP            read_from_uart
W: value out of range: 0x29f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
2A3 0AF80       1671     read_character:         INPUT           uart_data, uart_read_port ;read from FIFO
2A4 08080       1672                             RETURN
                1673     ;
                1674     ;
                1675     ;
                1676     ; Transmit one character to the UART
                1677     ;
                1678     ; Character supplied in register called 'UART_data'.
                1679     ;
                1680     ; The routine first loads the transmit FIFO buffer to see if it is full.
                1681     ; If the FIFO is full, then the routine waits until it there is space.
                1682     ;
                1683     ; Registers used s0
                1684     ;
2A5 0A040       1685     send_to_uart:           INPUT           s0, status_port         ;load Tx_FIFO buffer
2A6 00002       1686                             load            s0, #tx_full            ;wait if full
2A7 091A9       1687                             JUMP            z, uart_write
W: value out of range: 0x2a9, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa9.
2A8 081A5       1688                             JUMP            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2A9 0EF04       1689     uart_write:             OUTPUT          uart_data, uart_write_port
2AA 08080       1690                             RETURN
                1691     ;
                1692     ;
                1693     ;**************************************************************************************
                1694     ; Useful ASCII conversion and handling routines
                1695     ;**************************************************************************************
                1696     ;
                1697     ;
                1698     ; Convert character to upper case
                1699     ;
                1700     ; The character supplied in register s0.
                1701     ; If the character is in the range 'a' to 'z', it is converted
                1702     ; to the equivalent upper case character in the range 'A' to 'Z'.
                1703     ; All other characters remain unchanged.
                1704     ;
                1705     ; Registers used s0.
                1706     ;
2AB 00061       1707     upper_case:             load         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
2AC 09880       1708                             RETURN          c
2AD 0007B       1709                             load         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
2AE 09C80       1710                             RETURN          nc
2AF 010DF       1711                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
2B0 08080       1712                             RETURN
                1713     ;
                1714     ;
                1715     ; Convert hexadecimal value provided in register s0 into ASCII characters
                1716     ;
                1717     ; The value provided must can be any value in the range 00 to FF and will be converted into
                1718     ; two ASCII characters.
                1719     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1720     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1721     ;
                1722     ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1723     ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1724     ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1725     ;
                1726     ; Registers used s0, s1 and s2.
                1727     ;
2B1 0C100       1728     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
2B2 0D00E       1729                             SR0             s0                      ;isolate upper nibble
2B3 0D00E       1730                             SR0             s0
2B4 0D00E       1731                             SR0             s0
2B5 0D00E       1732                             SR0             s0
2B6 083BD       1733                             CALL            hex_to_ascii            ;convert
W: value out of range: 0x2bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
2B7 0C200       1734                             LOAD            s2, s0                  ;upper nibble value in s2
2B8 0C010       1735                             LOAD            s0, s1                  ;reload complete value
2B9 0100F       1736                             AND             s0, #0x0f               ;isolate lower nibble
2BA 083BD       1737                             CALL            hex_to_ascii            ;convert
W: value out of range: 0x2bd, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xbd.
2BB 0C100       1738                             LOAD            s1, s0                  ;lower nibble value in s1
2BC 08080       1739                             RETURN
                1740     ;
                1741     ; Convert hexadecimal value provided in register s0 into ASCII character
                1742     ;
                1743     ;Register used s0
                1744     ;
2BD 0600A       1745     hex_to_ascii:           SUB             s0, #0x0a               ;load if value is in range 0 to 9
2BE 099C0       1746                             JUMP            c, number_char
W: value out of range: 0x2c0, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc0.
2BF 04007       1747                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
2C0 0403A       1748     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
2C1 08080       1749                             RETURN
                1750     ;
                1751     ;
                1752     ; Send the two character HEX value of the register contents 's0' to the UART
                1753     ;
                1754     ; Registers used s0, s1, s2
                1755     ;
2C2 083B1       1756     send_hex_byte:          CALL            hex_byte_to_ascii
W: value out of range: 0x2b1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xb1.
2C3 0CF20       1757                             LOAD            uart_data, s2
2C4 083A5       1758                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2C5 0CF10       1759                             LOAD            uart_data, s1
2C6 083A5       1760                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2C7 08080       1761                             RETURN
                1762     ;
                1763     ;
                1764     ;
                1765     ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                1766     ; an equivalent hexadecimal value in register 's0'.
                1767     ;     The upper nibble is represented by an ASCII character in register s3.
                1768     ;     The lower nibble is represented by an ASCII character in register s2.
                1769     ;
                1770     ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1771     ; will be set on return.
                1772     ;
                1773     ; Registers used s0, s2 and s3.
                1774     ;
2C8 0C030       1775     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
2C9 083D5       1776                             CALL            ascii_to_hex            ;convert to value
W: value out of range: 0x2d5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd5.
2CA 09880       1777                             RETURN          c                       ;reject if out of range
2CB 0C300       1778                             LOAD            s3, s0                  ;remember value
2CC 0D306       1779                             SL0             s3                      ;multiply value by 16 to put in upper nibble
2CD 0D306       1780                             SL0             s3
2CE 0D306       1781                             SL0             s3
2CF 0D306       1782                             SL0             s3
2D0 0C020       1783                             LOAD            s0, s2                  ;Take lower nibble
2D1 083D5       1784                             CALL            ascii_to_hex            ;convert to value
W: value out of range: 0x2d5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xd5.
2D2 09880       1785                             RETURN          c                       ;reject if out of range
2D3 0C032       1786                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
2D4 08080       1787                             RETURN
                1788     ;
                1789     ;
                1790     ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1791     ;
                1792     ; If character is not valid for hex, then CARRY is set on return.
                1793     ;
                1794     ; Register used s0
                1795     ;
2D5 040B9       1796     ascii_to_hex:           ADD             s0, #0xb9               ;load for above ASCII code 46 ('F')
2D6 09880       1797                             RETURN          c
2D7 060E9       1798                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
2D8 09880       1799                             RETURN          c                       ;reject below ASCII code 30 ('0')
2D9 06011       1800                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
2DA 09DDF       1801                             JUMP            nc, ascii_letter
W: value out of range: 0x2df, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xdf.
2DB 04007       1802                             ADD             s0, #0x07               ;load for above ASCII code 46 ('F')
2DC 09880       1803                             RETURN          c
2DD 060F6       1804                             SUB             s0, #0xf6               ;convert to range 00 to 09
2DE 08080       1805                             RETURN
2DF 0400A       1806     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
2E0 08080       1807                             RETURN
                1808     ;
                1809     ;
                1810     ; Read one character from UART and echo.
                1811     ; Convert to upper case and return.
                1812     ;
                1813     ;
2E1 0839F       1814     read_upper_case:        CALL            read_from_uart          ;read command character from UART
W: value out of range: 0x29f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
2E2 083A5       1815                             CALL            send_to_uart            ;echo character
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2E3 0C0F0       1816                             LOAD            s0, uart_data           ;convert to upper case
2E4 083AB       1817                             CALL            upper_case
W: value out of range: 0x2ab, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xab.
2E5 08080       1818                             RETURN
                1819     ;
                1820     ;
                1821     ; Read two hex characters from UART and convert to single byte data
                1822     ;
2E6 083E1       1823     obtain_8bits:           CALL            read_upper_case         ;obtain one byte from UART
W: value out of range: 0x2e1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe1.
2E7 0C300       1824                             LOAD            s3, s0
2E8 083E1       1825                             CALL            read_upper_case
W: value out of range: 0x2e1, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xe1.
2E9 0C200       1826                             LOAD            s2, s0
2EA 083C8       1827                             CALL            ascii_byte_to_hex
W: value out of range: 0x2c8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc8.
2EB 08080       1828                             RETURN
                1829     ;
                1830     ;**************************************************************************************
                1831     ; Text messages
                1832     ;**************************************************************************************
                1833     ;
                1834     ;
                1835     ; Send Carriage Return to the UART
                1836     ;
2EC 00F0D       1837     send_cr:                LOAD            uart_data, #character_cr
2ED 083A5       1838                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2EE 08080       1839                             RETURN
                1840     ;
                1841     ; Send a space to the UART
                1842     ;
2EF 00F20       1843     send_space:             LOAD            uart_data, #character_space
2F0 083A5       1844                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2F1 08080       1845                             RETURN
                1846     ;
                1847     ;
                1848     ; Send a minus sign to the UART
                1849     ;
2F2 00F2D       1850     send_minus:             LOAD            uart_data, #character_minus
2F3 083A5       1851                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2F4 08080       1852                             RETURN
                1853     ;
                1854     ;
                1855     ; Send the letter 't' to the UART
                1856     ;
2F5 00F74       1857     send_t:                 LOAD            uart_data, #character_t
2F6 083A5       1858                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2F7 08080       1859                             RETURN
                1860     ;
                1861     ; Send the letter 'e' to the UART
                1862     ;
2F8 00F65       1863     send_e:                 LOAD            uart_data, #character_e
2F9 083A5       1864                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2FA 08080       1865                             RETURN
                1866     ;
                1867     ; Send the letter 'a' to the UART
                1868     ;
2FB 00F61       1869     send_a:                 LOAD            uart_data, #character_a
2FC 083A5       1870                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
2FD 08080       1871                             RETURN
                1872     ;
                1873     ;
                1874     ; Send the letter 'd' to the UART
                1875     ;
2FE 00F64       1876     send_d:                 LOAD            uart_data, #character_d
2FF 083A5       1877                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
300 08080       1878                             RETURN
                1879     ;
                1880     ;
                1881     ; Send the letter 'r' to the UART
                1882     ;
301 00F72       1883     send_r:                 LOAD            uart_data, #character_r
302 083A5       1884                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
303 08080       1885                             RETURN
                1886     ;
                1887     ;
                1888     ; Send the letter 's' to the UART
                1889     ;
304 00F73       1890     send_s:                 LOAD            uart_data, #character_s
305 083A5       1891                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
306 08080       1892                             RETURN
                1893     ;
                1894     ;
                1895     ; Send the letter 'c' to the UART
                1896     ;
307 00F63       1897     send_c:                 LOAD            uart_data, #character_c
308 083A5       1898                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
309 08080       1899                             RETURN
                1900     ;
                1901     ;
                1902     ; Send 'PicoBlaze SHA-1 Algorithm v1.00' string to the UART
                1903     ;
30A 083EC       1904     send_welcome:           CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
30B 083EC       1905                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
30C 00F50       1906                             LOAD            uart_data, #_character_p
30D 083A5       1907                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
30E 00F69       1908                             LOAD            uart_data, #character_i
30F 083A5       1909                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
310 08307       1910                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
311 00F6F       1911                             LOAD            uart_data, #character_o
312 083A5       1912                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
313 00F42       1913                             LOAD            uart_data, #_character_b
314 083A5       1914                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
315 00F6C       1915                             LOAD            uart_data, #character_l
316 083A5       1916                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
317 083FB       1917                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
318 00F7A       1918                             LOAD            uart_data, #character_z
319 083A5       1919                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
31A 083F8       1920                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
31B 083EF       1921                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
31C 00F53       1922                             LOAD            uart_data, #_character_s
31D 083A5       1923                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
31E 00F48       1924                             LOAD            uart_data, #_character_h
31F 083A5       1925                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
320 00F41       1926                             LOAD            uart_data, #_character_a
321 083A5       1927                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
322 083F2       1928                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
323 00F31       1929                             LOAD            uart_data, #character_1
324 083A5       1930                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
325 083EF       1931                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
326 00F41       1932                             LOAD            uart_data, #_character_a
327 083A5       1933                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
328 00F6C       1934                             LOAD            uart_data, #character_l
329 083A5       1935                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
32A 00F67       1936                             LOAD            uart_data, #character_g
32B 083A5       1937                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
32C 00F6F       1938                             LOAD            uart_data, #character_o
32D 083A5       1939                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
32E 08301       1940                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
32F 00F69       1941                             LOAD            uart_data, #character_i
330 083A5       1942                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
331 083F5       1943                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
332 00F68       1944                             LOAD            uart_data, #character_h
333 083A5       1945                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
334 00F6D       1946                             LOAD            uart_data, #character_m
335 083A5       1947                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
336 083EF       1948                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
337 00F76       1949                             LOAD            uart_data, #character_v
338 083A5       1950                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
339 00F31       1951                             LOAD            uart_data, #character_1
33A 083A5       1952                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
33B 00F2E       1953                             LOAD            uart_data, #character_fullstop
33C 083A5       1954                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
33D 00F30       1955                             LOAD            uart_data, #character_0
33E 083A5       1956                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
33F 00F30       1957                             LOAD            uart_data, #character_0
340 083A5       1958                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
341 083EC       1959                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
342 083EC       1960                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
343 08080       1961                             RETURN
                1962     ;
                1963     ;
                1964     ;
                1965     ;
                1966     ;
                1967     ;
                1968     ; Send DS2432 menu to the UART
                1969     ;
344 083EC       1970     send_ds2432_menu:       CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
345 083EC       1971                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
346 00F31       1972                             LOAD            uart_data, #character_1
347 083A5       1973                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
348 083F2       1974                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
349 083A5       1975                             CALL            send_write
W: value out of range: 0x3a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
34A 083EF       1976                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
34B 08384       1977                             CALL            send_scratchpad
W: value out of range: 0x384, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x84.
34C 083EC       1978                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
34D 00F32       1979                             LOAD            uart_data, #character_2
34E 083A5       1980                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
34F 083F2       1981                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
350 0839F       1982                             CALL            send_read
W: value out of range: 0x39f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
351 083EF       1983                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
352 08384       1984                             CALL            send_scratchpad
W: value out of range: 0x384, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x84.
353 083EC       1985                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
354 00F33       1986                             LOAD            uart_data, #character_3
355 083A5       1987                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
356 083F2       1988                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
357 00F4C       1989                             LOAD            uart_data, #_character_l
358 083A5       1990                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
359 00F6F       1991                             LOAD            uart_data, #character_o
35A 083A5       1992                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
35B 083FB       1993                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
35C 083FE       1994                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
35D 083EF       1995                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
35E 00F66       1996                             LOAD            uart_data, #character_f
35F 083A5       1997                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
360 00F69       1998                             LOAD            uart_data, #character_i
361 083A5       1999                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
362 08301       2000                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
363 08304       2001                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
364 083F5       2002                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
365 083EF       2003                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
366 08391       2004                             CALL            send_secret
W: value out of range: 0x391, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x91.
367 083EC       2005                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
368 00F34       2006                             LOAD            uart_data, #character_4
369 083A5       2007                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
36A 083F2       2008                             CALL            send_minus
W: value out of range: 0x2f2, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf2.
36B 0839F       2009                             CALL            send_read
W: value out of range: 0x39f, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x9f.
36C 083EF       2010                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
36D 00F61       2011                             LOAD            uart_data, #character_a
36E 083A5       2012                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
36F 00F75       2013                             LOAD            uart_data, #character_u
370 083A5       2014                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
371 083F5       2015                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
372 00F68       2016                             LOAD            uart_data, #character_h
373 083A5       2017                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
374 083EF       2018                             CALL            send_space
W: value out of range: 0x2ef, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xef.
375 00F50       2019                             LOAD            uart_data, #_character_p
376 083A5       2020                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
377 083FB       2021                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
378 00F67       2022                             LOAD            uart_data, #character_g
379 083A5       2023                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
37A 083F8       2024                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
37B 083EC       2025                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
37C 08080       2026                             RETURN
                2027     ;
                2028     ;
                2029     ;
                2030     ; Send carriage return, 'OK' and carriage return to the UART
                2031     ;
37D 083EC       2032     send_ok:                CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
37E 00F4F       2033                             LOAD            uart_data, #_character_o
37F 083A5       2034                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
380 00F4B       2035                             LOAD            uart_data, #_character_k
381 083A5       2036                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
382 083EC       2037                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
383 08080       2038                             RETURN
                2039     ;
                2040     ;
                2041     ; Send 'scratchpad' to the UART
                2042     ;
384 08304       2043     send_scratchpad:        CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
385 08307       2044                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
386 08301       2045                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
387 083FB       2046                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
388 083F5       2047                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
389 08307       2048                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
38A 00F68       2049                             LOAD            uart_data, #character_h
38B 083A5       2050                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
38C 00F70       2051                             LOAD            uart_data, #character_p
38D 083A5       2052                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
38E 083FB       2053                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
38F 083FE       2054                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
390 08080       2055                             RETURN
                2056     ;
                2057     ;
                2058     ; Send 'secret' to the UART
                2059     ;
391 08304       2060     send_secret:            CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
392 083F8       2061                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
393 08307       2062                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
394 08301       2063                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
395 083F8       2064                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
396 083F5       2065                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
397 08080       2066                             RETURN
                2067     ;
                2068     ;
                2069     ; Send 'Byte' to the UART
                2070     ;
398 00F42       2071     send_byte:              LOAD            uart_data, #_character_b
399 083A5       2072                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
39A 00F79       2073                             LOAD            uart_data, #character_y
39B 083A5       2074                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
39C 083F5       2075                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
39D 083F8       2076                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
39E 08080       2077                             RETURN
                2078     ;
                2079     ;
                2080     ; Send 'Read' to the UART
                2081     ;
39F 00F52       2082     send_read:              LOAD            uart_data, #_character_r
3A0 083A5       2083                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3A1 083F8       2084                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
3A2 083FB       2085                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3A3 083FE       2086                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
3A4 08080       2087                             RETURN
                2088     ;
                2089     ;
                2090     ; Send 'Write' to the UART
                2091     ;
3A5 00F57       2092     send_write:             LOAD            uart_data, #_character_w
3A6 083A5       2093                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3A7 08301       2094                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
3A8 00F69       2095                             LOAD            uart_data, #character_i
3A9 083A5       2096                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3AA 083F5       2097                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
3AB 083F8       2098                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
3AC 08080       2099                             RETURN
                2100     ;
                2101     ;
                2102     ; Send 'Pass' to the UART
                2103     ;
3AD 00F50       2104     send_pass:              LOAD            uart_data, #_character_p
3AE 083A5       2105                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3AF 083FB       2106                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3B0 08304       2107                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
3B1 08304       2108                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
3B2 083EC       2109                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
3B3 08080       2110                             RETURN
                2111     ;
                2112     ;
                2113     ; Send 'Fail' to the UART
                2114     ;
3B4 00F46       2115     send_fail:              LOAD            uart_data, #_character_f
3B5 083A5       2116                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3B6 083FB       2117                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3B7 00F69       2118                             LOAD            uart_data, #character_i
3B8 083A5       2119                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3B9 00F6C       2120                             LOAD            uart_data, #character_l
3BA 083A5       2121                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3BB 083EC       2122                             CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
3BC 08080       2123                             RETURN
                2124     ;
                2125     ;
                2126     ; Send 'address=' to the UART
                2127     ;
3BD 083EC       2128     send_address:           CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
3BE 083FB       2129                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3BF 083FE       2130                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
3C0 083FE       2131                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
3C1 08301       2132                             CALL            send_r
W: value out of range: 0x301, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
3C2 083F8       2133                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
3C3 08304       2134                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
3C4 08304       2135                             CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
3C5 00F3D       2136     send_equals:            LOAD            uart_data, #character_equals
3C6 083A5       2137                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3C7 08080       2138                             RETURN
                2139     ;
                2140     ;
                2141     ; Send 'data' to the UART
                2142     ;
3C8 083EC       2143     send_data:              CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
3C9 083FE       2144                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
3CA 083FB       2145                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3CB 083F5       2146                             CALL            send_t
W: value out of range: 0x2f5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf5.
3CC 083FB       2147                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3CD 08080       2148                             RETURN
                2149     ;
                2150     ;
                2151     ; Send 'E/S=' to the UART
                2152     ;
3CE 083EC       2153     send_es:                CALL            send_cr
W: value out of range: 0x2ec, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xec.
3CF 00F45       2154                             LOAD            uart_data, #_character_e
3D0 083A5       2155                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3D1 00F2F       2156                             LOAD            uart_data, #character_divide
3D2 083A5       2157                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3D3 00F53       2158                             LOAD            uart_data, #_character_s
3D4 083A5       2159                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3D5 081C5       2160                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2161     ;
                2162     ;
                2163     ; Send 'code=' to the UART
                2164     ;
3D6 08307       2165     send_code:              CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
3D7 00F6F       2166                             LOAD            uart_data, #character_o
3D8 083A5       2167                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3D9 083FE       2168                             CALL            send_d
W: value out of range: 0x2fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
3DA 083F8       2169                             CALL            send_e
W: value out of range: 0x2f8, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xf8.
3DB 081C5       2170                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2171     ;
                2172     ;
                2173     ; Send 's/n=' to the UART
                2174     ;
3DC 08304       2175     send_sn:                CALL            send_s
W: value out of range: 0x304, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x4.
3DD 00F2F       2176                             LOAD            uart_data, #character_divide
3DE 083A5       2177                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3DF 00F6E       2178                             LOAD            uart_data, #character_n
3E0 083A5       2179                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3E1 081C5       2180                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2181     ;
                2182     ;
                2183     ; Send 'crc=' to the UART
                2184     ;
3E2 08307       2185     send_crc:               CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
3E3 00F72       2186                             LOAD            uart_data, #character_r
3E4 083A5       2187                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3E5 08307       2188                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
3E6 081C5       2189                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2190     ;
                2191     ;
                2192     ;
                2193     ; Send 'mac=' to the UART
                2194     ;
3E7 00F6D       2195     send_mac:               LOAD            uart_data, #character_m
3E8 083A5       2196                             CALL            send_to_uart
W: value out of range: 0x2a5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xa5.
3E9 083FB       2197                             CALL            send_a
W: value out of range: 0x2fb, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfb.
3EA 08307       2198                             CALL            send_c
W: value out of range: 0x307, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x7.
3EB 081C5       2199                             JUMP            send_equals
W: value out of range: 0x3c5, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xc5.
                2200     ;
                2201     ;
                2202     ;**************************************************************************************
                2203     ; Interrupt Service Routine (ISR)
                2204     ;**************************************************************************************
                2205     ;
                2206     ; Interrupts are not used in this design. This is a place keeper only.
                2207     ;
  003FE         2208                             ORG             0x3fe
3FE 080F0       2209     isr:                    RETURNI         enable
                2210     ;
                2211     ;
                2212     ;**************************************************************************************
                2213     ; Interrupt Vector
                2214     ;**************************************************************************************
                2215     ;
  003FF         2216                             ORG             0x3ff
3FF 081FE       2217                             JUMP            isr
W: value out of range: 0x3fe, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0xfe.
                2218     ;
                2219     ;
                2220
