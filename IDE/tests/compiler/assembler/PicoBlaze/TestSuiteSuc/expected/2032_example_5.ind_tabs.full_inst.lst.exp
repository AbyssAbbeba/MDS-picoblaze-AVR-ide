                   1     ; KCPSM3 Program - Control and calculation for Frequency Generator design using the
                   2     ;                 Spartan-3E Starter Kit.
                   3     ; Interfaces with the rotary encoder and LCD display to enable a frequency to be set.
                   4     ; Converts the BCD frequency value into a binary integer and then performs the high
                   5     ; precision calculation necessary to derive the control numbers required by the high
                   6     ; performance Direct Digital Synthesis (DDS) circuit implemented in hardware.
                   7     ;
                   8     ; LEDs are connected and used as edit mode indicators.
                   9     device kcpsm2
                  10     ; Substantial comments are included in line with the code below and should be used
                  11     ; in conjunction with the documentation provided with the complete reference design.
                  12     ;
                  13     ;
                  14     ;
                  15     ; Ken Chapman - Xilinx Ltd
                  16     ;
                  17     ; Version v1.00 - 13th July 2006
                  18     ;
                  19     ;**************************************************************************************
                  20     ;Port definitions
                  21     ;**************************************************************************************
                  22     ;
                  23     ;
                  24     ;
  00080           25     led_port		EQU		0x80			;8 simple LEDs
  00001           26     led0			EQU		0x01			;     LED 0 - bit0
  00002           27     led1			EQU		0x02			;         1 - bit1
  00004           28     led2			EQU		0x04			;         2 - bit2
  00008           29     led3			EQU		0x08			;         3 - bit3
  00010           30     led4			EQU		0x10			;         4 - bit4
  00020           31     led5			EQU		0x20			;         5 - bit5
  00040           32     led6			EQU		0x40			;         6 - bit6
  00080           33     led7			EQU		0x80			;         7 - bit7
                  34     ;
                  35     ;
  00000           36     rotary_port		EQU		0x00			;Read status of rotary encoder
  00001           37     rotary_left		EQU		0x01			; Direction of last move Left=1 Right=0  - bit0
  00002           38     rotary_press		EQU		0x02			;     Centre press contact (active High) - bit1
                  39     ;
                  40     ;
                  41     ;LCD interface ports
                  42     ;
                  43     ;The master enable signal is not used by the LCD display itself
                  44     ;but may be required to confirm that LCD communication is active.
                  45     ;This is required on the Spartan-3E Starter Kit if the StrataFLASH
                  46     ;is used because it shares the same EQU pins and conflicts must be avoided.
                  47     ;
  00040           48     lcd_output_port		EQU		0x40			;LCD character module output EQU and control
  00001           49     lcd_e			EQU		0x01			;   active High Enable        E - bit0
  00002           50     lcd_rw			EQU		0x02			;   Read=1 Write=0           RW - bit1
  00004           51     lcd_rs			EQU		0x04			;   Instruction=0 EQU=1     RS - bit2
  00008           52     lcd_drive		EQU		0x08			;   Master enable (active High) - bit3
  00010           53     lcd_db4			EQU		0x10			;   4-bit              EQU DB4 - bit4
  00020           54     lcd_db5			EQU		0x20			;   interface          EQU DB5 - bit5
  00040           55     lcd_db6			EQU		0x40			;                      EQU DB6 - bit6
  00080           56     lcd_db7			EQU		0x80			;                      EQU DB7 - bit7
                  57     ;
                  58     ;
  00001           59     lcd_input_port		EQU		0x01			;LCD character module input EQU
  00010           60     lcd_read_db4		EQU		0x10			;    4-bit           EQU DB4 - bit4
  00020           61     lcd_read_db5		EQU		0x20			;    interface       EQU DB5 - bit5
  00040           62     lcd_read_db6		EQU		0x40			;                    EQU DB6 - bit6
  00080           63     lcd_read_db7		EQU		0x80			;                    EQU DB7 - bit7
                  64     ;
                  65     ;
                  66     ;
                  67     ;DDS control ports
                  68     ;
                  69     ;DDS control word is 32-bits
                  70     ;
  00002           71     dds_control0_port	EQU		0x02			; dds_control_word(7:0)
  00004           72     dds_control1_port	EQU		0x04			; dds_control_word(15:8)
  00008           73     dds_control2_port	EQU		0x08			; dds_control_word(23:16)
  00010           74     dds_control3_port	EQU		0x10			; dds_control_word(31:24)
                  75     ;
                  76     ;Frequency scaling control word is 5-bits
                  77     ;
  00020           78     dds_scaling_port	EQU		0x20			; dds_scaling_word(4:0)
                  79     ;
                  80     ;
                  81     ;**************************************************************************************
                  82     ;Special Register usage
                  83     ;**************************************************************************************
                  84     ;
                  85     ;**************************************************************************************
                  86     ;Scratch Pad Memory Locations
                  87     ;**************************************************************************************
                  88     ;
  00000           89     rotary_status		EQU		0x00			;Status of rotary encoder
  00080           90     rotary_event		EQU		0x80			;  flag set by interrupt in 'rotary_status' - bit7
                  91     ;
  00001           92     isr_preserve_s0		EQU		0x01			;Preserve s0 contents during ISR
                  93     ;
  00002           94     led_pattern		EQU		0x02			;LED pattern used in rotation mode
                  95     ;
                  96     ;
                  97     ;BCD digits representing selected and displayed frequency
                  98     ;
  00003           99     bcd_digit0		EQU		0x03			; value           1
  00004          100     bcd_digit1		EQU		0x04			;                10
  00005          101     bcd_digit2		EQU		0x05			;               100
  00006          102     bcd_digit3		EQU		0x06			;             1,000
  00007          103     bcd_digit4		EQU		0x07			;            10,000
  00008          104     bcd_digit5		EQU		0x08			;           100,000
  00009          105     bcd_digit6		EQU		0x09			;         1,000,000
  0000A          106     bcd_digit7		EQU		0x0a			;        10,000,000
  0000B          107     bcd_digit8		EQU		0x0b			;       100,000,000
                 108     ;
                 109     ;
                 110     ;Binary integer representation of BCD value
                 111     ;
  0000C          112     frequency0		EQU		0x0c			;LS byte
  0000D          113     frequency1		EQU		0x0d
  0000E          114     frequency2		EQU		0x0e
  0000F          115     frequency3		EQU		0x0f			;MS byte
                 116     ;
                 117     ;
                 118     ;Control of frequency selection values
                 119     ;
  00010          120     cursor_position		EQU		0x10			; Pointer to edit position on LCD
  00011          121     edit_digit_pointer	EQU		0x11			; BCD digit to be changed
                 122     ;
                 123     ;
                 124     ;
                 125     ;80-bit product resulting from 32-bit frequency x 48-bit scaling constant
                 126     ;
  00012          127     product0		EQU		0x12			;LS byte
  00013          128     product1		EQU		0x13
  00014          129     product2		EQU		0x14
  00015          130     product3		EQU		0x15
  00016          131     product4		EQU		0x16
  00017          132     product5		EQU		0x17
  00018          133     product6		EQU		0x18
  00019          134     product7		EQU		0x19
  0001A          135     product8		EQU		0x1a
  0001B          136     product9		EQU		0x1b			;MS byte
                 137     ;
                 138     ;Local copies of the DDS control word and DDS scaling word
                 139     ;
  0001C          140     dds_control0		EQU		0x1c			; dds_control_word(7:0)
  0001D          141     dds_control1		EQU		0x1d			; dds_control_word(15:8)
  0001E          142     dds_control2		EQU		0x1e			; dds_control_word(23:16)
  0001F          143     dds_control3		EQU		0x1f			; dds_control_word(31:24)
  00020          144     dds_scaling		EQU		0x20			; dds_scaling_word(4:0)
                 145     ;
                 146     ;**************************************************************************************
                 147     ; Useful EQU constants
                 148     ;**************************************************************************************
                 149     ;
                 150     ; To convert the frequency into a DDS control value a high precision scaling
                 151     ; factor is used. This is a 48-bit number which converts the frequency presented
                 152     ; as an 32-bit integer into the 32-bit value required by the phase accumulator
                 153     ; to synthesize the desired frequency. The scaling factor is derived using the
                 154     ; following method. First I will consider the scaling factor which results in the
                 155     ; desired frequency being generated directly at the output of the phase accumulator
                 156     ; which is suitable for low frequencies in which a few ns of jitter is acceptable.
                 157     ;
                 158     ; 'Fpa' is frequency generated by the MSB of the phase accumulator.
                 159     ; 'p' is number of phase accumulator which in this case is 32 bits.
                 160     ; 'clk' is the input clock frequency to the phase accumulator which is 200MHz.
                 161     ; 'N' is the DDS control word value which is also 'p' bits (32 in this case).
                 162     ;
                 163     ; Frequency at MSB of phase accumulator is then
                 164     ;
                 165     ;       Fpa = clk x N / (2^p)
                 166     ;
                 167     ; Note that the maximum value allowed for 'N' is (2^p)/2 which results in Fpa=clk/2.
                 168     ;  for 'N' greater than that value 'Fpa' would decrease in frequency (aliasing).
                 169     ;
                 170     ;
                 171     ; By simple reorganisation of the equation we can compute 'N'
                 172     ;
                 173     ;       N = Fpa x (2^p) / clk
                 174     ;
                 175     ;
                 176     ; Now it is easier to approach the next step using specific example.
                 177     ;
                 178     ; So for a frequency of Fpa = 1MHz then
                 179     ;       N = 1MHz x (2^32)/200MHz = 21474836.48
                 180     ;
                 181     ; We must use the nearest 32-bit integer value 21474836 and this in turn
                 182     ; is best viewed as the 32-bit hexadecimal value 0147AE14.
                 183     ;
                 184     ; In this case the value we have to work with is a 32-bit integer frequency
                 185     ; value of 1 million which is 000F4240.
                 186     ;
                 187     ; So now we need to translate the value 000F4240 into 0147AE14. This is
                 188     ; where a 48-bit scaling value is used together with a full precision multiplier
                 189     ; as this ensures adequate accuracy of the final frequency.
                 190     ;
                 191     ;        32-bit frequency value                  ffffffff
                 192     ;        48-bit scaling value              x ssssssssssss
                 193     ;                                    --------------------
                 194     ;        80-bit product              nnnnnnnnnnnnnnnnnnnn
                 195     ;
                 196     ; The art is to organise the scaling factor into the range where the most is made of
                 197     ; the 48-bit resolution available but which will result in the correct 32-bit output.
                 198     ; The way this is achieved is the select an appropriate 32-bits from the available 80-bit
                 199     ; product for use as 'N' and truncate 'y' least significant bits.
                 200     ;
                 201     ; From this we can deduce that for a target frequency 'Ft' at the input then the
                 202     ; scaling value 'S' is given by
                 203     ;
                 204     ;    S = N x (2^y) / Ft    with the condition that S < 2^48 but as large as possible
                 205     ;
                 206     ; For best accuracy we calculate 'S' using the full precision value of 'N' divided
                 207     ; by Ft and then multiply continuously by 2 until we reach the biggest value less
                 208     ; that 2^48. The number of multiplications by 2 indicating the value of 'y'.
                 209     ;
                 210     ; In this case we find that 'y' is 43.....
                 211     ;       S = 21474836.48 x (2^43) / 1000000 = 21.47483648 x (2^43)
                 212     ;                                          = 188894659314785.80854784
                 213     ;
                 214     ;  ...round to nearest integer and convert to hexadecimal S = ABCC77118462
                 215     ;
                 216     ; N will be taken from the 80 bit product by removing the 43 LSBs and the 5 MSBs
                 217     ; to leave the 32 active bits required. This is best achieved by shifting left
                 218     ; by 5 places (multiply by 2^5=32) and keeping the upper 32-bits.
                 219     ;
                 220     ;
                 221     ; Sanity check....
                 222     ;   Note that most calculators do not support >64 bit values to you will either
                 223     ;   need to decompose your calculation and perform some of it manually or trust
                 224     ;   the PicoBlaze implementation :-)
                 225     ;
                 226     ;     Ft = 1MHz =                         000F4240
                 227     ;             S =                  x  ABCC77118462
                 228     ;                             --------------------
                 229     ;                             000A3D70A3D70A405C80
                 230     ;
                 231     ;     shift left 5 places                     x 20
                 232     ;                             --------------------
                 233     ;                             0147AE147AE1480B9000
                 234     ;
                 235     ; As expected, the most significant 32-bit (4 bytes) are 0147AE14 hex which is
                 236     ; the DDS control word for 1MHz calculated previously.
                 237     ;
                 238     ; ***
                 239     ;
                 240     ; Now I will consider how this needs to be modified for the circuit presented
                 241     ; which has a second DCM connected to the output of the phase accumulator to
                 242     ; multiply the synthesized frequency and reduce cycle to cycle jitter at
                 243     ; the same time. There is then a clock divider circuit connected to the output
                 244     ; of the DCM which allows lower frequencies to be formed a different way (more of
                 245     ; that later). As a minimum that divider circuit will divide by 2 which ensures that
                 246     ; a square wave is presented to the clocked put pin. So in this circuit the fundamental
                 247     ; multiplication factor is 8 formed by a 16 times multiplication by the DCM (256/16) and
                 248     ; then a divide by 2.
                 249     ;
                 250     ; The overall multiplication factor of this sebsequent circuit means that for final
                 251     ; output from the DCM to be the desired frequency, the output from the phase accumulator
                 252     ; needs to be the same number of times smaller. This is not a bad thing because the
                 253     ; percentage jitter of waveforms produced by the phase accumulator is better for lower
                 254     ; frequencies made from more clock cycles.
                 255     ;
                 256     ; So we modify the basic equation to
                 257     ;
                 258     ;    Fout = Frequency at output of DCM
                 259     ;       M = Multiplying factor of DCM
                 260     ;
                 261     ;    Fout = M x Fpa = M x clk x N / (2^p)
                 262     ;
                 263     ;
                 264     ; By simple reorganisation of the equation we can compute 'N'
                 265     ;
                 266     ;       N = Fout x (2^p) / (clk x M)
                 267     ;
                 268     ;
                 269     ; In this design M=8, p=32, clk=200MHz
                 270     ;
                 271     ; So now consider generating a nominal maximum frequency of 100MHz which will require
                 272     ; the frequency synthesized by the phase accumulator to be 12.5MHz.
                 273     ;
                 274     ;       N = 100MHz x (2^32) / (200MHz x 8) = 268435456 = 10000000 Hex
                 275     ;
                 276     ; This all seems like a very convenient number but it simply reflects that 12.5MHz
                 277     ; is a perfect division of the 200MHz clock and that that output from the phase
                 278     ; accumulator will be formed perfectly of 16 of the 200MHz clock periods every time
                 279     ; (8 Low and 8 High) with no additional jitter.
                 280     ;
                 281     ; So now we work out the scaling factor with the same rules as used previously that
                 282     ; the scaling factor should be as large as possible within the 48-bits allocated.
                 283     ;
                 284     ;    S = N x (2^y) / Ft    with the condition that S < 2^48 but as large as possible
                 285     ;
                 286     ; In this case Ft = 100MHz = 055FE100 and the biggest value for S is found when using
                 287     ; y=46
                 288     ;
                 289     ;    S = 268435456 x (2^46) / 100000000 = 2.68435456 x (2^46)
                 290     ;                                       = 188894659314785.80854784
                 291     ;
                 292     ;      round to 188894659314786  = ABCC77118462
                 293     ;
                 294     ; Actually this is the exact same scaling constant as previously because the
                 295     ; frequency to be synthesized by the phase accumulator is 8 times smaller but the
                 296     ; value of 'S' is deliberate scaled to be as large as possible. In fact, 'S' in this
                 297     ; case has been scaled up by a factor of 8 to arrive at the same value. So after
                 298     ; using the scaling constant to form the 80 bit product, this time we will remove
                 299     ; the 46 LSBs and the 2 MSBs to leave the 32 active bits required. This is best
                 300     ; achieved by shifting left by 2 places (multiply by 2^2=4) and keeping the upper
                 301     ; 32-bits (last time we multiplied by 32 which was 8 times more).
                 302     ;
                 303     ;
                 304     ; Sanity check....
                 305     ;
                 306     ;     Ft = 100MHz =                         055FE100
                 307     ;               S =                  x  ABCC77118462
                 308     ;                               --------------------
                 309     ;                               04000000000001242200
                 310     ;
                 311     ;       shift left 5 places                     x 20
                 312     ;                               --------------------
                 313     ;                               1000000000001C908800
                 314     ;
                 315     ; As expected, the most significant 32-bit (4 bytes) are 10000000 hex which is
                 316     ; the DDS control word for 12.5MHz at the phase accumulator output calculated
                 317     ; previously.
                 318     ;
                 319     ;
                 320     ; ********
                 321     ;
                 322     ;
                 323     ; 48-bit Scaling factor constant to generate the phase accumulator control word
                 324     ; from the integer frequency value.
                 325     ;
                 326     ;   S = AB CC 77 11 84 62
                 327     ;
                 328     ; Notes
                 329     ;
                 330     ; The 80-bit product must be shifted left 5 times and then most significant 32-bits
                 331     ; used to provide DDS control word if the frequency required is to be synthesized
                 332     ; directly at the output of the phase accumulator.
                 333     ;
                 334     ; The 80-bit product must be shifted left 2 times and then most significant 32-bits
                 335     ; used to provide DDS control word if the frequency required is to be synthesized
                 336     ; by the phase accumulator followed by a multiplying DCM and divider with overall
                 337     ; frequency gain of 8 times.
                 338     ;
  00062          339     scale_constant0		EQU		0x62			;LS byte
  00084          340     scale_constant1		EQU		0x84
  00011          341     scale_constant2		EQU		0x11
  00077          342     scale_constant3		EQU		0x77
  000CC          343     scale_constant4		EQU		0xcc
  000AB          344     scale_constant5		EQU		0xab			;MS byte
                 345     ;
                 346     ;
                 347     ;
                 348     ; ************************
                 349     ;
                 350     ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                 351     ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 352     ;calculation highly predictable. The '6' in the following equation even allows for
                 353     ;'CALL delay_1us' instruction in the initiating code.
                 354     ;
                 355     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 356     ;
                 357     ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 358     ;For clock rates below 10MHz the value of 1 must be used and the operation will
                 359     ;become lower than intended.
                 360     ;
  0000B          361     delay_1us_constant	EQU		0x0b
                 362     ;
                 363     ;
                 364     ;
                 365     ;ASCII table
                 366     ;
  00061          367     character_a		EQU		0x61
  00062          368     character_b		EQU		0x62
  00063          369     character_c		EQU		0x63
  00064          370     character_d		EQU		0x64
  00065          371     character_e		EQU		0x65
  00066          372     character_f		EQU		0x66
  00067          373     character_g		EQU		0x67
  00068          374     character_h		EQU		0x68
  00069          375     character_i		EQU		0x69
  0006A          376     character_j		EQU		0x6a
  0006B          377     character_k		EQU		0x6b
  0006C          378     character_l		EQU		0x6c
  0006D          379     character_m		EQU		0x6d
  0006E          380     character_n		EQU		0x6e
  0006F          381     character_o		EQU		0x6f
  00070          382     character_p		EQU		0x70
  00071          383     character_q		EQU		0x71
  00072          384     character_r		EQU		0x72
  00073          385     character_s		EQU		0x73
  00074          386     character_t		EQU		0x74
  00075          387     character_u		EQU		0x75
  00076          388     character_v		EQU		0x76
  00077          389     character_w		EQU		0x77
  00078          390     character_x		EQU		0x78
  00079          391     character_y		EQU		0x79
  0007A          392     character_z		EQU		0x7a
  00041          393     _character_a		EQU		0x41
  00042          394     _character_b		EQU		0x42
  00043          395     _character_c		EQU		0x43
  00044          396     _character_d		EQU		0x44
  00045          397     _character_e		EQU		0x45
  00046          398     _character_f		EQU		0x46
  00047          399     _character_g		EQU		0x47
  00048          400     _character_h		EQU		0x48
  00049          401     _character_i		EQU		0x49
  0004A          402     _character_j		EQU		0x4a
  0004B          403     _character_k		EQU		0x4b
  0004C          404     _character_l		EQU		0x4c
  0004D          405     _character_m		EQU		0x4d
  0004E          406     _character_n		EQU		0x4e
  0004F          407     _character_o		EQU		0x4f
  00050          408     _character_p		EQU		0x50
  00051          409     _character_q		EQU		0x51
  00052          410     _character_r		EQU		0x52
  00053          411     _character_s		EQU		0x53
  00054          412     _character_t		EQU		0x54
  00055          413     _character_u		EQU		0x55
  00056          414     _character_v		EQU		0x56
  00057          415     _character_w		EQU		0x57
  00058          416     _character_x		EQU		0x58
  00059          417     _character_y		EQU		0x59
  0005A          418     _character_z		EQU		0x5a
  00030          419     character_0		EQU		0x30
  00031          420     character_1		EQU		0x31
  00032          421     character_2		EQU		0x32
  00033          422     character_3		EQU		0x33
  00034          423     character_4		EQU		0x34
  00035          424     character_5		EQU		0x35
  00036          425     character_6		EQU		0x36
  00037          426     character_7		EQU		0x37
  00038          427     character_8		EQU		0x38
  00039          428     character_9		EQU		0x39
  0003A          429     character_colon		EQU		0x3a
  0002E          430     character_stop		EQU		0x2e
  0003B          431     character_semi_colon	EQU		0x3b
  0002D          432     character_minus		EQU		0x2d
  0002F          433     character_divide	EQU		0x2f			;'/'
  0002B          434     character_plus		EQU		0x2b
  0002C          435     character_comma		EQU		0x2c
  0003C          436     character_less_than	EQU		0x3c
  0003E          437     character_greater_than	EQU		0x3e
  0003D          438     character_equals	EQU		0x3d
  00020          439     character_space		EQU		0x20
  0000D          440     character_cr		EQU		0x0d			;carriage return
  0003F          441     character_question	EQU		0x3f			;'?'
  00024          442     character_dollar	EQU		0x24
  00021          443     character_exclaim	EQU		0x21			;'!'
  00008          444     character_bs		EQU		0x08			;Back Space command character
                 445     ;
                 446     ;
                 447     ;
                 448     ;
                 449     ;
                 450     ;**************************************************************************************
                 451     ;Initialise the system
                 452     ;**************************************************************************************
                 453     ;
000 36215        454     cold_start:		CALL		lcd_reset		;initialise LCD display
                 455     ;
                 456     ;Write 'Frequency Generator' to LCD display and display for 4 seconds
                 457     ;
001 00510        458     			LOAD		s5, #0x10		;Line 1 position 0
002 3622B        459     			CALL		lcd_cursor
003 3618B        460     			CALL		disp_frequency
004 00522        461     			LOAD		s5, #0x22		;Line 2 position 2
005 3622B        462     			CALL		lcd_cursor
006 3619E        463     			CALL		disp_generator
007 361CD        464     			CALL		delay_1s		;wait 4 seconds
008 361CD        465     			CALL		delay_1s
009 361CD        466     			CALL		delay_1s
00A 361CD        467     			CALL		delay_1s
00B 36226        468     			CALL		lcd_clear		;clear screen
                 469     ;
                 470     ;
                 471     ;Initial frequency of 100MHz
                 472     ;
00C 00000        473     			LOAD		s0, #0x00
00D 00101        474     			LOAD		s1, #0x01
00E 10018        475     			load		s0, bcd_digit0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00F 10020        476     			load		s0, bcd_digit1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
010 10028        477     			load		s0, bcd_digit2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
011 10030        478     			load		s0, bcd_digit3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
012 10038        479     			load		s0, bcd_digit4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
013 10040        480     			load		s0, bcd_digit5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
014 10048        481     			load		s0, bcd_digit6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
015 10050        482     			load		s0, bcd_digit7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
016 10158        483     			load		s1, bcd_digit8
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 484     ;
017 00004        485     			LOAD		s0, #0x04		;Start position for editing frequency is 1MHz digit
018 10080        486     			load		s0, cursor_position
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
019 00009        487     			LOAD		s0, #bcd_digit6
01A 10088        488     			load		s0, edit_digit_pointer
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 489     ;
                 490     ;
01B 3C001        491     			ENABLE		interrupt		;interrupts are used to detect rotary controller
01C 361C3        492     			CALL		delay_1ms
01D 00000        493     			LOAD		s0, #0x00		;clear the status of any spurious rotary events
01E 10000        494     			load		s0, rotary_status	;   as a result of system turning on.
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 495     ;
                 496     ;**************************************************************************************
                 497     ; Main program
                 498     ;**************************************************************************************
                 499     ;
                 500     ; The main program is centred on the task of editing the frequency. It waits until the
                 501     ; rotary control is used and then makes the appropriate changes. If the actual digit
                 502     ; digit value is changed then the calculation to drive the DDS is performed each time.
                 503     ;
                 504     ; The start state is that of allowing the edit cursor position to be moved. Rotary
                 505     ; inputs are detected by the interrupt service routine and set a flag bit which the
                 506     ; main program then uses to adjust the cursor position and pointer to the corresponding
                 507     ; BCD digit in memory.
                 508     ;
                 509     ; A press of the rotary control is detected by polling and used to change to the digit
                 510     ; editing mode.
                 511     ;
                 512     ;
01F 36084        513     move_mode:		CALL		compute_dds_words	;compute DDS control values
020 360B4        514     			CALL		display_freq		;refresh display with cursor position shown
021 00001        515     			LOAD		s0, #led0		;indicate move mode on LEDs
022 22080        516     			OUTPUT		s0, led_port
023 20000        517     move_wait:		INPUT		s0, rotary_port		;read rotary encoder
024 00002        518     			load		s0, #rotary_press	;load for press of button which changes mode
025 35445        519     			JUMP		nz, edit_mode
026 10000        520     			load		s0, rotary_status	;check for any rotation of rotary control
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
027 00080        521     			load		s0, #rotary_event
028 35023        522     			JUMP		z, move_wait
                 523     ;
029 0207F        524     			AND		s0, #0x7f		;clear flag now that action it is being processed
02A 10000        525     			load		s0, rotary_status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
02B 10A80        526     			load		sa, cursor_position	;read current position
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
02C 10B88        527     			load		sb, edit_digit_pointer
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
02D 00001        528     			load		s0, #rotary_left	;determine direction to move cursor
02E 35039        529     			JUMP		z, move_right
                 530     ;
02F 00B0B        531     move_left:		load		sb, #bcd_digit8		;can not move left of 100MHz digit
030 3501F        532     			JUMP		z, move_mode
031 08B01        533     			ADD		sb, #0x01		;move to next higher BCD digit
032 0CA01        534     			SUB		sa, #0x01		;move cursor to match digit to be edited
033 00A09        535     			load		sa, #0x09		;must skip over space separator
034 35037        536     			JUMP		z, skip_left
035 00A05        537     			load		sa, #0x05		;must skip over decimal point
036 35442        538     			JUMP		nz, edit_point_update
037 0CA01        539     skip_left:		SUB		sa, #0x01		;move cursor further left
038 34042        540     			JUMP		edit_point_update
                 541     ;
039 00B03        542     move_right:		load		sb, #bcd_digit0		;can not move right of 1Hz digit
03A 3501F        543     			JUMP		z, move_mode
03B 0CB01        544     			SUB		sb, #0x01		;move to next lower BCD digit
03C 08A01        545     			ADD		sa, #0x01		;move cursor to match digit to be edited
03D 00A09        546     			load		sa, #0x09		;must skip over space separator
03E 35041        547     			JUMP		z, skip_right
03F 00A05        548     			load		sa, #0x05		;must skip over decimal point
040 35442        549     			JUMP		nz, edit_point_update
041 08A01        550     skip_right:		ADD		sa, #0x01		;move cursor further right
                 551     ;
042 10A80        552     edit_point_update:	load		sa, cursor_position	;update edit value in memory
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
043 10B88        553     			load		sb, edit_digit_pointer
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
044 3401F        554     			JUMP		move_mode
                 555     ;
                 556     ;
                 557     ; The edit mode is reached by pressing the rotary control. Since this is a simple switch
                 558     ; a software de-bounce delay is used to wait for the knob to be released fully before
                 559     ; entering the digit editing mode fully.
                 560     ;
                 561     ; In this mode rotations of the detected by the interrupt service routine are used to
                 562     ; increment or decrement the digit value at the cursor position with carry/borrow to
                 563     ; the left.
                 564     ;
                 565     ; A new press of the rotary control is detected by polling and used to change back to the
                 566     ; cursor moving mode.
                 567     ;
                 568     ;
045 3607D        569     edit_mode:		CALL		wait_switch_release	;wait for switch press to end
046 36084        570     edit_display:		CALL		compute_dds_words	;compute DDS control values
047 360B4        571     			CALL		display_freq		;refresh display with new values
048 00002        572     			LOAD		s0, #led1		;indicate edit mode on LEDs
049 22080        573     			OUTPUT		s0, led_port
04A 20000        574     edit_wait:		INPUT		s0, rotary_port		;read rotary encoder
04B 00002        575     			load		s0, #rotary_press	;load for press of button which changes mode
04C 3547B        576     			JUMP		nz, end_edit_mode
04D 10000        577     			load		s0, rotary_status	;check for any rotation of rotary control
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
04E 00080        578     			load		s0, #rotary_event
04F 3504A        579     			JUMP		z, edit_wait
                 580     ;
050 0207F        581     			AND		s0, #0x7f		;clear flag now that action it is being processed
051 10000        582     			load		s0, rotary_status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
052 10B88        583     			load		sb, edit_digit_pointer	;read pointer to BCD digit for initial change
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
053 00001        584     			load		s0, #rotary_left	;determine direction to increment or decrement
054 35068        585     			JUMP		z, inc_digit
                 586     ;
                 587     ; Decrement the value starting at the current position and borrowing from the left.
                 588     ; However the value needs to bottom out at all 0's from the editing position.
                 589     ;
                 590     ;
055 00A0B        591     dec_digit:		load		sa, #sb			;read digit value at pointer position
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
056 0CA01        592     			SUB		sa, #0x01		;decrement digit
057 00AFF        593     			load		sa, #0xff		;load for borrow from next digit
058 3505B        594     			JUMP		z, dec_borrow
059 00A0B        595     			load		sa, #sb			;load decremented digit value
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
05A 34046        596     			JUMP		edit_display		;decrement task complete
05B 00A09        597     dec_borrow:		LOAD		sa, #0x09		;current digit rolls over to nine
05C 00A0B        598     			load		sa, #sb			;load '9' digit value
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
05D 00B0B        599     			load		sb, #bcd_digit8		;check if working on 100MHz digit
05E 35061        600     			JUMP		z, set_min_value
05F 08B01        601     			ADD		sb, #0x01		;increment pointer to next most significant digit
060 34055        602     			JUMP		dec_digit		;decrement next digit up.
                 603     ;
061 10B88        604     set_min_value:		load		sb, edit_digit_pointer	;Must fill digits from insert to MS-Digit with 000...
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
062 00A00        605     			LOAD		sa, #0x00
063 00A0B        606     fill_min:		load		sa, #sb
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
064 00B0B        607     			load		sb, #bcd_digit8		;check if filled to 100MHz digit
065 35046        608     			JUMP		z, edit_display
066 08B01        609     			ADD		sb, #0x01		;fill next higher digit
067 34063        610     			JUMP		fill_min
                 611     ;
                 612     ; Increment the value starting at the current position and carrying to the left.
                 613     ; However the value needs to saturate to all 9's from the editing position.
                 614     ;
068 00A0B        615     inc_digit:		load		sa, #sb			;read digit value at pointer position
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
069 08A01        616     			ADD		sa, #0x01		;increment digit
06A 00A0A        617     			load		sa, #0x0a		;load for carry to next digit
06B 3506E        618     			JUMP		z, inc_carry
06C 00A0B        619     			load		sa, #sb			;load incremented digit value
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
06D 34046        620     			JUMP		edit_display		;increment task complete
06E 00A00        621     inc_carry:		LOAD		sa, #0x00		;current digit rolls over to zero
06F 00A0B        622     			load		sa, #sb			;load zero digit value
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
070 00B0B        623     			load		sb, #bcd_digit8		;check if working on 100MHz digit
071 35074        624     			JUMP		z, set_max_value
072 08B01        625     			ADD		sb, #0x01		;increment pointer to next most significant digit
073 34068        626     			JUMP		inc_digit		;increment next digit up.
                 627     ;
074 10B88        628     set_max_value:		load		sb, edit_digit_pointer	;Must fill digits from insert to MS-Digit with 999...
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
075 00A09        629     			LOAD		sa, #0x09
076 00A0B        630     fill_max:		load		sa, #sb
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
077 00B0B        631     			load		sb, #bcd_digit8		;check if filled to 100MHz digit
078 35046        632     			JUMP		z, edit_display
079 08B01        633     			ADD		sb, #0x01		;fill next higher digit
07A 34076        634     			JUMP		fill_max
                 635     ;
07B 3607D        636     end_edit_mode:		CALL		wait_switch_release	;wait for end of switch press
07C 3401F        637     			JUMP		move_mode		;then go to move cursor mode
                 638     ;
                 639     ;
                 640     ; Routine to poll the press switch with de-bounce delay and wait for it to be
                 641     ; released. Any rotation inputs detected by the interrupt
                 642     ; service routine are cleared before returning.
                 643     ;
07D 361C8        644     wait_switch_release:	CALL		delay_20ms		;delay to aid switch de-bounce
07E 20000        645     			INPUT		s0, rotary_port		;read rotary encoder
07F 00002        646     			load		s0, #rotary_press	;load if button is still being pressed
080 3547D        647     			JUMP		nz, wait_switch_release
081 00000        648     			LOAD		s0, #0x00		;clear flag indicating any rotary events
082 10000        649     			load		s0, rotary_status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
083 24000        650     			RETURN
                 651     ;
                 652     ;**************************************************************************************
                 653     ; Compute DDS control words from currently display frequency value
                 654     ;**************************************************************************************
                 655     ;
                 656     ; This routine reads the current BCD value and converts it into a 32-bit binary
                 657     ; integer. It then multiplies it by a 48-bit scaling factor (see notes in the
                 658     ; constants section above) to form a full precision 80-bit product.
                 659     ;
                 660     ; From this product the 32-bit DDS control word must be extracted. For frequencies of
                 661     ; 50MHz or above the DDS control word is formed by shifting the product left by 2 places
                 662     ; (multiply by 4) and then keeping only the most significant 32-bits (4 bytes).
                 663     ;
                 664     ; Also for frequencies of 50MHz and above, there is no additional division performed
                 665     ; after the DCM which multiplies frequency and reduces the jitter. Therefore the DDS_scaling
                 666     ; word will be set to zero and the output of the DCM will divide by 2.
                 667     ;
                 668     ;   Freq     DDS control word    DDS Scaling      Synthesized Frequency
                 669     ;                                                  of Phase Accumulator
                 670     ;
                 671     ;  50MHz      08000000              00                   6.25MHz
                 672     ; 100MHz      10000000              00                  12.50MHz
                 673     ;
                 674     ; You will notice that for frequencies of 50MHz and above, the upper byte of the
                 675     ; DDS control word is 08 hex or greater. In other words, bit3 and/or bit4 of that byte
                 676     ; are High (bits 27 and/or 28 of the full 32-bit word). This is the indication that
                 677     ; the control words are complete.
                 678     ;
                 679     ; For frequencies below 50MHz an additional process is required. The reason for this
                 680     ; becomes clear if we think about the lowest frequency of 1Hz. In that case the 80-bit
                 681     ; product is the same as the 48-bit scaling constant 00000000ABCC77118462. Once this
                 682     ; has been multiplied by 4 (shifted left 2 places) it becomes 00000002AF31DC461188 and the
                 683     ; most significant 32-bits are only 00000002 hex. If we put this back into the basic
                 684     ; equations for the phase accumulator we find that the output frequency of the phase
                 685     ; accumulator would be
                 686     ;
                 687     ;    Fout = M x clk x N / (2^p)
                 688     ;
                 689     ;         = 8 x 200MHz x 2 / (2^32) = 0.745 Hz
                 690     ;
                 691     ; There are two important observations we can make. Firstly we have lost accuracy because
                 692     ; the resolution of the DDS control word has become too granular at low amplitudes.
                 693     ; Secondly this would never even work because the frequency synthesized by the phase
                 694     ; accumulator would be 0.745/8 = 0.0931 Hz which is seriously slow and a way below the
                 695     ; frequency at which the DCM can even work.
                 696     ;
                 697     ; The solution to both of these issues is to ensure that the DDS control word is always
                 698     ; formed to be in the range that would result in an output of 50MHz or above. In other
                 699     ; words to keep the phase accumulator output in the range 6.25MHz to 12.5MHz such that
                 700     ; the DCM is able to work and only has to deal with one octave of input variation. This
                 701     ; can be achieved by shifting the 80-bit product left more times until bits 27 and 28
                 702     ; of the most significant 32-bits are not zero.
                 703     ;
                 704     ; For each shift left the synthesized frequency is being doubled and therefore the final
                 705     ; output from the DCM must be divided by a further factor of 2. This is achieved using
                 706     ; a multiplexer which is guided to select the appropriate output from a simple binary
                 707     ; counter.
                 708     ;
                 709     ; Returning to the example of 1Hz, the 80-bit product will be shifted left by the default
                 710     ; 2 places (multiplied by 4), but will then need to be shifted left by a further 26 places
                 711     ; which is like multiplying by 67108864 (04000000 hex).
                 712     ;
                 713     ;                            00000000ABCC77118462
                 714     ;                          x                    4
                 715     ;                            --------------------
                 716     ;                            00000002AF31DC461188
                 717     ;
                 718     ;
                 719     ;                          x             04000000
                 720     ;                            --------------------
                 721     ;                            0ABCC771184620000000
                 722     ;
                 723     ; So now the DDS control word is 0ABCC771 (180143985 decimal)and the frequency synthesized
                 724     ; by the phase accumulator will be....
                 725     ;
                 726     ;   Fpa = clk x N / (2^p) = 200MHz x 180143985 / (2^32) = 8388608Hz
                 727     ;
                 728     ; The DCM will multiply this by a factor of 16 to give 134217728Hz and this will then
                 729     ; be divided by the counter of which the 26th bit selected (26 decimal = 1A hex).
                 730     ;
                 731     ;   Fout = Fpa x 16 / (2^(D+1)) =  8388608Hz x 16 / (2^(26+1)) = 0.99999999947 Hz
                 732     ;
                 733     ;     'D' is the DDS Scaling factor
                 734     ;         Note that bit0 of a counter is a clock division by 2 and hence the 'D+1'
                 735     ;
                 736     ; Clearly this implementation style has provided much greater accuracy and enables
                 737     ; the DCM to work for all desired frequencies.
                 738     ;
                 739     ;
                 740     ;   Freq     DDS control word    DDS Scaling      Synthesized Frequency
                 741     ;                                                  of Phase Accumulator
                 742     ;
                 743     ; 100 MHz      10000000              00                  12.50MHz
                 744     ;  50 MHz      08000000              00                   6.25MHz
                 745     ;  25 MHz      08000000              01                   6.25MHz
                 746     ;  12.5 MHz    08000000              02                   6.25MHz
                 747     ;
                 748     ;    1Hz       0ABCC771              1A                   8.388608 MHz
                 749     ;
                 750     ;
                 751     ;
                 752     ; In order to ensure the DCM is always provided with a frequency in an acceptable
                 753     ; range, the value of absolute zero is never implemented and instead just a very low
                 754     ; frequency is produced.
                 755     ;   6.25MHz x 16 / (2^31+1) = 0.0233 Hz
                 756     ;       which is 1 cycle every 43 seconds and that is pretty slow  :-)
                 757     ;
                 758     ;
                 759     ;
                 760     ;
084 360E5        761     compute_dds_words:	CALL		bcd_to_integer		;convert BCD display value to 32-bit value
085 36119        762     			CALL		scale_frequency		;80-bit product of 32-bit frequency x 48-bit scaling value
086 10AD8        763     			load		sa, product9		;read the upper part of the 80-bit product into [sA,s9,s8,s7,s6,s5,s4]
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
087 109D0        764     			load		s9, product8		; The least significant 24-bits of the 80-bit product will never
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
088 108C8        765     			load		s8, product7		; be used for frequencies above 1Hz.
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
089 107C0        766     			load		s7, product6		;The final 32-bit DDS control word will be formed in
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
08A 106B8        767     			load		s6, product5		; [sA,s9,s8,s7]
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
08B 105B0        768     			load		s5, product4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
08C 104A8        769     			load		s4, product3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
08D 360A1        770     			CALL		shift80_left		;multiply DDS control word by 4 to achieve default value
08E 360A1        771     			CALL		shift80_left
08F 00B00        772     			LOAD		sb, #0x00		;default scaling factor is 2 (select counter bit0)
090 00A18        773     normalise_loop:		load		sa, #0x18		;load bits 27 and 28 of 32-bit DDS control word
091 3549A        774     			JUMP		nz, load_dds_words	;DDS control word is normalised to above 50MHz output
092 360A1        775     			CALL		shift80_left		;multiply DDS control word by 2
093 08B01        776     			ADD		sb, #0x01		;Divide final value by 2 to compensate
094 00B1F        777     			load		sb, #0x1f		;load for maximum division factor
095 35490        778     			JUMP		nz, normalise_loop
096 00A08        779     			LOAD		sa, #0x08		;Set for minimum frequency
097 00900        780     			LOAD		s9, #0x00		; with phase accumulator set to generate 6.25MHz
098 00800        781     			LOAD		s8, #0x00
099 00700        782     			LOAD		s7, #0x00
09A 107E0        783     load_dds_words:	load		s7, dds_control0	;load local copy of control word
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
09B 108E8        784     			load		s8, dds_control1	;load local copy of control word
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
09C 109F0        785     			load		s9, dds_control2	;load local copy of control word
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
09D 10AF8        786     			load		sa, dds_control3	;load local copy of control word
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
09E 10B00        787     			load		sb, dds_scaling
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x20, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x0.
09F 360A9        788     			CALL		drive_dds_words		;output control words to DDS circuit
0A0 24000        789     			RETURN
                 790     ;
0A1 28406        791     shift80_left:		SL0		s4			;shift (most of the) 80-bit value in
0A2 28500        792     			SLA		s5			;  [sA,s9,s8,s7,s6,s5,s4] left 1 place
0A3 28600        793     			SLA		s6
0A4 28700        794     			SLA		s7
0A5 28800        795     			SLA		s8
0A6 28900        796     			SLA		s9
0A7 28A00        797     			SLA		sa
0A8 24000        798     			RETURN
                 799     ;
                 800     ;**************************************************************************************
                 801     ; Set DDS control words
                 802     ;**************************************************************************************
                 803     ;
                 804     ; Because multiple ports are used, the idea is to update all of them in
                 805     ; rapid succession to avoid too much disturbance in the frequency synthesis.
                 806     ;
                 807     ; dds_control_word should be supplied in register set [sA,s9,s8,s7]
                 808     ; dds_scaling_word should be supplied in register s6.
                 809     ;
0A9 107E0        810     drive_dds_words:	load		s7, dds_control0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0AA 108E8        811     			load		s8, dds_control1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0AB 109F0        812     			load		s9, dds_control2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0AC 10AF8        813     			load		sa, dds_control3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0AD 10600        814     			load		s6, dds_scaling
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x20, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x0.
0AE 22702        815     			OUTPUT		s7, dds_control0_port
0AF 22804        816     			OUTPUT		s8, dds_control1_port
0B0 22908        817     			OUTPUT		s9, dds_control2_port
0B1 22A10        818     			OUTPUT		sa, dds_control3_port
0B2 22620        819     			OUTPUT		s6, dds_scaling_port
0B3 24000        820     			RETURN
                 821     ;
                 822     ;
                 823     ;**************************************************************************************
                 824     ; Display frequency on top line of the LCD and DDS EQU on the lower line
                 825     ;**************************************************************************************
                 826     ;
                 827     ; The BCD value should be loadd in scratch pad memory in 9 ascending locations
                 828     ; called BCD_digit0 to BCD_digit8.
                 829     ;
                 830     ; The value is displayed in the format      xxx.xxx xxxMHz
                 831     ;
                 832     ; However, the most significant 2 digits will be blanked if zero.
                 833     ;
                 834     ; registers used s0,s1,s2,s3,s4,s5,s6,s7
                 835     ;
                 836     ;
0B4 3615D        837     display_freq:		CALL		display_dds_EQU	;display DDS information on lower line
0B5 00512        838     			LOAD		s5, #0x12		;Line 1 position 2
0B6 3622B        839     			CALL		lcd_cursor
0B7 10558        840     			load		s5, bcd_digit8		;read 100MHz digit
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0B8 00500        841     			load		s5, #0x00		;load for blanking
0B9 350BE        842     			JUMP		z, blank_100m_digit
0BA 360DF        843     			CALL		display_digit		;display non zero digit
0BB 10550        844     			load		s5, bcd_digit7		;read 10MHz digit and display
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0BC 360DF        845     			CALL		display_digit
0BD 340C5        846     			JUMP		disp_1m_digit
                 847     ;
0BE 360E2        848     blank_100m_digit:	CALL		display_space		;blank 100MHz digit
0BF 10550        849     			load		s5, bcd_digit7		;read 10MHz digit
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0C0 00500        850     			load		s5, #0x00		;load for blanking
0C1 350C4        851     			JUMP		z, blank_10m_digit
0C2 360DF        852     			CALL		display_digit		;display non zero digit
0C3 340C5        853     			JUMP		disp_1m_digit
                 854     ;
0C4 360E2        855     blank_10m_digit:	CALL		display_space		;blank 10MHz digit
                 856     ;
0C5 10548        857     disp_1m_digit:		load		s5, bcd_digit6		;read 1MHz digit and display
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0C6 360DF        858     			CALL		display_digit
0C7 0052E        859     			LOAD		s5, #character_stop	;display decimal point
0C8 361EB        860     			CALL		lcd_write_EQU
                 861     ;
0C9 00208        862     			LOAD		s2, #bcd_digit5		;set pointer to 100KHz digit
0CA 360D8        863     			CALL		display_3_digits
0CB 360E2        864     			CALL		display_space
0CC 00205        865     			LOAD		s2, #bcd_digit2		;set pointer to 100Hz digit
0CD 360D8        866     			CALL		display_3_digits
0CE 0054D        867     			LOAD		s5, #_character_m	;display 'MHz'
0CF 361EB        868     			CALL		lcd_write_EQU
0D0 00548        869     			LOAD		s5, #_character_h
0D1 361EB        870     			CALL		lcd_write_EQU
0D2 0057A        871     			LOAD		s5, #character_z
0D3 361EB        872     			CALL		lcd_write_EQU
                 873     ;
0D4 10580        874     			load		s5, cursor_position	;reposition edit cursor on display
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0D5 08510        875     			ADD		s5, #0x10		;on line 1
0D6 3622B        876     			CALL		lcd_cursor
0D7 24000        877     			RETURN
                 878     ;
0D8 00303        879     display_3_digits:	LOAD		s3, #0x03		;3 digits to display
0D9 00502        880     _3digit_loop:		load		s5, #s2
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0DA 360DF        881     			CALL		display_digit
0DB 0C201        882     			SUB		s2, #0x01		;decrement digit pointer
0DC 0C301        883     			SUB		s3, #0x01		;count digits displayed
0DD 354D9        884     			JUMP		nz, _3digit_loop
0DE 24000        885     			RETURN
                 886     ;
0DF 08530        887     display_digit:		ADD		s5, #0x30		;convert BCD to ASCII character
0E0 361EB        888     			CALL		lcd_write_EQU
0E1 24000        889     			RETURN
                 890     ;
0E2 00520        891     display_space:		LOAD		s5, #character_space
0E3 361EB        892     			CALL		lcd_write_EQU
0E4 24000        893     			RETURN
                 894     ;
                 895     ;
                 896     ;**************************************************************************************
                 897     ; Convert 9 digit BCD frequency into 32-bit binary integer
                 898     ;**************************************************************************************
                 899     ;
                 900     ;Both values are loadd in scratch pad memory
                 901     ;    BCD values in ascending locations BCD_digit0 to BCD_digit8
                 902     ;    Binary frequency in ascending locations frequency0 to frequency3
                 903     ;
                 904     ;Each digit is read in turn and its value is determined by repeated
                 905     ;decrement until reaching zero. Each decrement causes a value to be added
                 906     ;to the memory locations forming the frequency value as binary integer.
                 907     ;The process requires approximately 1600 instructions to convert the highest
                 908     ;value 999,999,999 which is approximately 64us at 50MHz clock rate.
                 909     ;
                 910     ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sA,sB
                 911     ;
0E5 00209        912     bcd_to_integer:		LOAD		s2, #0x09		;9 digits to convert
0E6 00000        913     			LOAD		s0, #0x00		;clear frequency value ready to accumulate result
0E7 10060        914     			load		s0, frequency0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0E8 10068        915     			load		s0, frequency1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0E9 10070        916     			load		s0, frequency2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0EA 10078        917     			load		s0, frequency3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0EB 00B00        918     			LOAD		sb, #0x00		;initialise BCD digit weighting [sB,sA,s9,s8] to 1
0EC 00A00        919     			LOAD		sa, #0x00
0ED 00900        920     			LOAD		s9, #0x00
0EE 00801        921     			LOAD		s8, #0x01
0EF 00303        922     			LOAD		s3, #bcd_digit0		;locate LS-digit
0F0 00103        923     next_bcd_to_int_digit:	load		s1, #s3
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0F1 00100        924     bcd_digit_convert:	load		s1, #0x00		;load for zero
0F2 35101        925     			JUMP		z, next_digit_value
0F3 10060        926     			load		s0, frequency0		;add 32-bit digit weighting to memory value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0F4 18040        927     			ADD		s0, s8
0F5 10060        928     			load		s0, frequency0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0F6 10068        929     			load		s0, frequency1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0F7 1A048        930     			ADDCY		s0, s9
0F8 10068        931     			load		s0, frequency1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0F9 10070        932     			load		s0, frequency2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0FA 1A050        933     			ADDCY		s0, sa
0FB 10070        934     			load		s0, frequency2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0FC 10078        935     			load		s0, frequency3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0FD 1A058        936     			ADDCY		s0, sb
0FE 10078        937     			load		s0, frequency3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0FF 0C101        938     			SUB		s1, #0x01		;decrement digit value
100 340F1        939     			JUMP		bcd_digit_convert
                 940     ;Increase weighting by 10x
101 10758        941     next_digit_value:	LOAD		s7, sb			;copy existing weighting
102 10650        942     			LOAD		s6, sa
103 10548        943     			LOAD		s5, s9
104 10440        944     			LOAD		s4, s8
105 28806        945     			SL0		s8			;multiply weight by 4x (shift left 2 places)
106 28900        946     			SLA		s9
107 28A00        947     			SLA		sa
108 28B00        948     			SLA		sb
109 28806        949     			SL0		s8
10A 28900        950     			SLA		s9
10B 28A00        951     			SLA		sa
10C 28B00        952     			SLA		sb
10D 18820        953     			ADD		s8, s4			;add previous weight to form 5x multiplication
10E 1A928        954     			ADDCY		s9, s5
10F 1AA30        955     			ADDCY		sa, s6
110 1AB38        956     			ADDCY		sb, s7
111 28806        957     			SL0		s8			;multiply weight by 2x (shift left 1 places)
112 28900        958     			SLA		s9
113 28A00        959     			SLA		sa
114 28B00        960     			SLA		sb			;weight value is now 10x previous value
115 08301        961     			ADD		s3, #0x01		;move to next digit for conversion
116 0C201        962     			SUB		s2, #0x01
117 354F0        963     			JUMP		nz, next_bcd_to_int_digit
118 24000        964     			RETURN
                 965     ;
                 966     ;
                 967     ;**************************************************************************************
                 968     ; 32-bit x 48-bit multiply to scale the integer frequency
                 969     ;**************************************************************************************
                 970     ;
                 971     ;Multiply the 32-bit frequency binary integer by the 48-bit scaling factor
                 972     ;to form a full precision 80-bit product.
                 973     ;
                 974     ;The frequency binary integer is loadd in scratch pad memory using ascending
                 975     ;locations frequency0 to frequency3
                 976     ;
                 977     ;The product will be loadd in scratch pad memory using ascending
                 978     ;locations product0 to product9
                 979     ;
                 980     ;The scaling factor is provided directly as constants
                 981     ; scale_constant0 to scale_constant5
                 982     ;
                 983     ;The multiplication is performed as a 32-bit 'shift and add' process in which the
                 984     ;integer frequency is examined LSB first using a register set [sB,sA,s9,s8] and
                 985     ;a scaling accumulator is formed directly in the 'product' memory locations.
                 986     ;
                 987     ;The process requires up to 1772 instructions which is 3544 clock cycle or
                 988     ;approximately 71us at 50MHz clock rate.
                 989     ;
                 990     ;Registers used s0,s1,s8,s9,sA,sB (s1,s8,s9,sA,sB clear on return)
                 991     ;
119 00000        992     scale_frequency:	LOAD		s0, #0x00		;clear accumulator section of 'product'
11A 100D8        993     			load		s0, product9
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11B 100D0        994     			load		s0, product8
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11C 100C8        995     			load		s0, product7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11D 100C0        996     			load		s0, product6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11E 100B8        997     			load		s0, product5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11F 100B0        998     			load		s0, product4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
120 10B78        999     			load		sb, frequency3		;read frequency integer value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
121 10A70       1000     			load		sa, frequency2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
122 10968       1001     			load		s9, frequency1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
123 10860       1002     			load		s8, frequency0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
124 00120       1003     			LOAD		s1, #0x20		;32-bit multiply
125 28B0E       1004     scale_mult_bit:		SR0		sb			;shift right frequency integer
126 28A08       1005     			SRA		sa
127 28908       1006     			SRA		s9
128 28808       1007     			SRA		s8
129 35D3C       1008     			JUMP		nc, product_shift	;no add if bit is zero (note carry is zero)
12A 100B0       1009     			load		s0, product4		;addition of scaling factor to most significant bits of product
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
12B 08062       1010     			ADD		s0, #scale_constant0
12C 100B0       1011     			load		s0, product4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
12D 100B8       1012     			load		s0, product5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
12E 0A084       1013     			ADDCY		s0, #scale_constant1
12F 100B8       1014     			load		s0, product5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
130 100C0       1015     			load		s0, product6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
131 0A011       1016     			ADDCY		s0, #scale_constant2
132 100C0       1017     			load		s0, product6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
133 100C8       1018     			load		s0, product7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
134 0A077       1019     			ADDCY		s0, #scale_constant3
135 100C8       1020     			load		s0, product7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
136 100D0       1021     			load		s0, product8
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
137 0A0CC       1022     			ADDCY		s0, #scale_constant4
138 100D0       1023     			load		s0, product8
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
139 100D8       1024     			load		s0, product9
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13A 0A0AB       1025     			ADDCY		s0, #scale_constant5
13B 100D8       1026     			load		s0, product9		;carry holds any overflow of addition
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13C 100D8       1027     product_shift:		load		s0, product9		;Divide product by 2 (shift right by 1)
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13D 28008       1028     			SRA		s0			;overflow of addition included in shift
13E 100D8       1029     			load		s0, product9
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13F 100D0       1030     			load		s0, product8
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
140 28008       1031     			SRA		s0
141 100D0       1032     			load		s0, product8
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
142 100C8       1033     			load		s0, product7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
143 28008       1034     			SRA		s0
144 100C8       1035     			load		s0, product7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
145 100C0       1036     			load		s0, product6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
146 28008       1037     			SRA		s0
147 100C0       1038     			load		s0, product6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
148 100B8       1039     			load		s0, product5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
149 28008       1040     			SRA		s0
14A 100B8       1041     			load		s0, product5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
14B 100B0       1042     			load		s0, product4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
14C 28008       1043     			SRA		s0
14D 100B0       1044     			load		s0, product4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
14E 100A8       1045     			load		s0, product3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
14F 28008       1046     			SRA		s0
150 100A8       1047     			load		s0, product3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
151 100A0       1048     			load		s0, product2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
152 28008       1049     			SRA		s0
153 100A0       1050     			load		s0, product2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
154 10098       1051     			load		s0, product1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
155 28008       1052     			SRA		s0
156 10098       1053     			load		s0, product1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
157 10090       1054     			load		s0, product0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
158 28008       1055     			SRA		s0
159 10090       1056     			load		s0, product0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
15A 0C101       1057     			SUB		s1, #0x01		;move to next bit
15B 35525       1058     			JUMP		nz, scale_mult_bit
15C 24000       1059     			RETURN
                1060     ;
                1061     ;**************************************************************************************
                1062     ; Display DDS control information on the lower line of the LCD display.
                1063     ;**************************************************************************************
                1064     ;
                1065     ;Display the 32-bit DDS control word and 8-bit DDS scaling word.
                1066     ;
15D 00520       1067     display_dds_EQU:	LOAD		s5, #0x20		;Line 2 position 0
15E 3622B       1068     			CALL		lcd_cursor
15F 0054E       1069     			LOAD		s5, #_character_n
160 361EB       1070     			CALL		lcd_write_EQU
161 0053D       1071     			LOAD		s5, #character_equals
162 361EB       1072     			CALL		lcd_write_EQU
163 0071F       1073     			LOAD		s7, #dds_control3	;pointer to most significant byte in memory
164 36184       1074     			CALL		display_hex_32_bit
165 360E2       1075     			CALL		display_space
166 00544       1076     			LOAD		s5, #_character_d
167 361EB       1077     			CALL		lcd_write_EQU
168 0053D       1078     			LOAD		s5, #character_equals
169 361EB       1079     			CALL		lcd_write_EQU
16A 10000       1080     			load		s0, dds_scaling
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x20, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x0.
16B 3617E       1081     			CALL		display_hex_byte
16C 24000       1082     			RETURN
                1083     ;
                1084     ;**************************************************************************************
                1085     ; Routines to display hexadecimal values on LCD display
                1086     ;**************************************************************************************
                1087     ;
                1088     ;
                1089     ; Convert hexadecimal value provided in register s0 into ASCII characters
                1090     ;
                1091     ; The value provided must can be any value in the range 00 to FF and will be converted into
                1092     ; two ASCII characters.
                1093     ;     The upper nibble will be represented by an ASCII character returned in register s3.
                1094     ;     The lower nibble will be represented by an ASCII character returned in register s2.
                1095     ;
                1096     ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1097     ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1098     ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1099     ;
                1100     ; Registers used s0, s2 and s3.
                1101     ;
16D 10200       1102     hex_byte_to_ascii:	LOAD		s2, s0			;remember value supplied
16E 2800E       1103     			SR0		s0			;isolate upper nibble
16F 2800E       1104     			SR0		s0
170 2800E       1105     			SR0		s0
171 2800E       1106     			SR0		s0
172 36179       1107     			CALL		hex_to_ascii		;convert
173 10300       1108     			LOAD		s3, s0			;upper nibble value in s3
174 10010       1109     			LOAD		s0, s2			;reload complete value
175 0200F       1110     			AND		s0, #0x0f		;isolate lower nibble
176 36179       1111     			CALL		hex_to_ascii		;convert
177 10200       1112     			LOAD		s2, s0			;lower nibble value in s2
178 24000       1113     			RETURN
                1114     ;
                1115     ; Convert hexadecimal value provided in register s0 into ASCII character
                1116     ;
                1117     ;Register used s0
                1118     ;
179 0C00A       1119     hex_to_ascii:		SUB		s0, #0x0a		;load if value is in range 0 to 9
17A 3597C       1120     			JUMP		c, number_char
17B 08007       1121     			ADD		s0, #0x07		;ASCII char A to F in range 41 to 46
17C 0803A       1122     number_char:		ADD		s0, #0x3a		;ASCII char 0 to 9 in range 30 to 40
17D 24000       1123     			RETURN
                1124     ;
                1125     ;
                1126     ; Display the two character HEX value of the register contents 's0' on the LCD
                1127     ; at the current cursor position.
                1128     ;
                1129     ; Registers used s0, s1, s2, s3, s4, s5
                1130     ;
17E 3616D       1131     display_hex_byte:	CALL		hex_byte_to_ascii
17F 10518       1132     			LOAD		s5, s3
180 361EB       1133     			CALL		lcd_write_EQU
181 10510       1134     			LOAD		s5, s2
182 361EB       1135     			CALL		lcd_write_EQU
183 24000       1136     			RETURN
                1137     ;
                1138     ;
                1139     ;
                1140     ; Display the 32-bit value loadd in 4 ascending memory locations as an 8 character
                1141     ; HEX value at the current cursor position. Register s7 must contain the memory
                1142     ; location of the most significant byte (which is also the highest address).
                1143     ;
                1144     ; Registers used s0, s1, s2, s3, s4, s5, s6, s7
                1145     ;
184 00604       1146     display_hex_32_bit:	LOAD		s6, #0x04		;4 bytes to display
185 00007       1147     disp32_loop:		load		s0, #s7			;read byte
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
186 3617E       1148     			CALL		display_hex_byte	;display byte
187 0C701       1149     			SUB		s7, #0x01		;decrement pointer
188 0C601       1150     			SUB		s6, #0x01		;count bytes displayed
189 25000       1151     			RETURN		z
18A 34185       1152     			JUMP		disp32_loop
                1153     ;
                1154     ;
                1155     ;**************************************************************************************
                1156     ;LCD text messages
                1157     ;**************************************************************************************
                1158     ;
                1159     ;
                1160     ;Display 'Frequency' on LCD at current cursor position
                1161     ;
18B 00546       1162     disp_frequency:		LOAD		s5, #_character_f
18C 361EB       1163     			CALL		lcd_write_EQU
18D 00572       1164     			LOAD		s5, #character_r
18E 361EB       1165     			CALL		lcd_write_EQU
18F 00565       1166     			LOAD		s5, #character_e
190 361EB       1167     			CALL		lcd_write_EQU
191 00571       1168     			LOAD		s5, #character_q
192 361EB       1169     			CALL		lcd_write_EQU
193 00575       1170     			LOAD		s5, #character_u
194 361EB       1171     			CALL		lcd_write_EQU
195 00565       1172     			LOAD		s5, #character_e
196 361EB       1173     			CALL		lcd_write_EQU
197 0056E       1174     			LOAD		s5, #character_n
198 361EB       1175     			CALL		lcd_write_EQU
199 00563       1176     			LOAD		s5, #character_c
19A 361EB       1177     			CALL		lcd_write_EQU
19B 00579       1178     			LOAD		s5, #character_y
19C 361EB       1179     			CALL		lcd_write_EQU
19D 24000       1180     			RETURN
                1181     ;
                1182     ;Display 'Generator' on LCD at current cursor position
                1183     ;
19E 00547       1184     disp_generator:		LOAD		s5, #_character_g
19F 361EB       1185     			CALL		lcd_write_EQU
1A0 00565       1186     			LOAD		s5, #character_e
1A1 361EB       1187     			CALL		lcd_write_EQU
1A2 0056E       1188     			LOAD		s5, #character_n
1A3 361EB       1189     			CALL		lcd_write_EQU
1A4 00565       1190     			LOAD		s5, #character_e
1A5 361EB       1191     			CALL		lcd_write_EQU
1A6 00572       1192     			LOAD		s5, #character_r
1A7 361EB       1193     			CALL		lcd_write_EQU
1A8 00561       1194     			LOAD		s5, #character_a
1A9 361EB       1195     			CALL		lcd_write_EQU
1AA 00574       1196     			LOAD		s5, #character_t
1AB 361EB       1197     			CALL		lcd_write_EQU
1AC 0056F       1198     			LOAD		s5, #character_o
1AD 361EB       1199     			CALL		lcd_write_EQU
1AE 00572       1200     			LOAD		s5, #character_r
1AF 361EB       1201     			CALL		lcd_write_EQU
1B0 360E2       1202     			CALL		display_space
1B1 00576       1203     			LOAD		s5, #character_v
1B2 361EB       1204     			CALL		lcd_write_EQU
1B3 00531       1205     			LOAD		s5, #character_1
1B4 361EB       1206     			CALL		lcd_write_EQU
1B5 0052E       1207     			LOAD		s5, #character_stop
1B6 361EB       1208     			CALL		lcd_write_EQU
1B7 00532       1209     			LOAD		s5, #character_2
1B8 361EB       1210     			CALL		lcd_write_EQU
1B9 24000       1211     			RETURN
                1212     ;
                1213     ;
                1214     ;
                1215     ;
                1216     ;**************************************************************************************
                1217     ;Software delay routines
                1218     ;**************************************************************************************
                1219     ;
                1220     ;
                1221     ;
                1222     ;Delay of 1us.
                1223     ;
                1224     ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1225     ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1226     ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1227     ;
                1228     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1229     ;
                1230     ;Registers used s0
                1231     ;
1BA 0000B       1232     delay_1us:		LOAD		s0, #delay_1us_constant
1BB 0C001       1233     wait_1us:		SUB		s0, #0x01
1BC 355BB       1234     			JUMP		nz, wait_1us
1BD 24000       1235     			RETURN
                1236     ;
                1237     ;Delay of 40us.
                1238     ;
                1239     ;Registers used s0, s1
                1240     ;
1BE 00128       1241     delay_40us:		LOAD		s1, #0x28		;40 x 1us = 40us
1BF 361BA       1242     wait_40us:		CALL		delay_1us
1C0 0C101       1243     			SUB		s1, #0x01
1C1 355BF       1244     			JUMP		nz, wait_40us
1C2 24000       1245     			RETURN
                1246     ;
                1247     ;
                1248     ;Delay of 1ms.
                1249     ;
                1250     ;Registers used s0, s1, s2
                1251     ;
1C3 00219       1252     delay_1ms:		LOAD		s2, #0x19		;25 x 40us = 1ms
1C4 361BE       1253     wait_1ms:		CALL		delay_40us
1C5 0C201       1254     			SUB		s2, #0x01
1C6 355C4       1255     			JUMP		nz, wait_1ms
1C7 24000       1256     			RETURN
                1257     ;
                1258     ;Delay of 20ms.
                1259     ;
                1260     ;Delay of 20ms used during initialisation.
                1261     ;
                1262     ;Registers used s0, s1, s2, s3
                1263     ;
1C8 00314       1264     delay_20ms:		LOAD		s3, #0x14		;20 x 1ms = 20ms
1C9 361C3       1265     wait_20ms:		CALL		delay_1ms
1CA 0C301       1266     			SUB		s3, #0x01
1CB 355C9       1267     			JUMP		nz, wait_20ms
1CC 24000       1268     			RETURN
                1269     ;
                1270     ;Delay of approximately 1 second.
                1271     ;
                1272     ;Registers used s0, s1, s2, s3, s4
                1273     ;
1CD 00432       1274     delay_1s:		LOAD		s4, #0x32		;50 x 20ms = 1000ms
1CE 361C8       1275     wait_1s:		CALL		delay_20ms
1CF 0C401       1276     			SUB		s4, #0x01
1D0 355CE       1277     			JUMP		nz, wait_1s
1D1 24000       1278     			RETURN
                1279     ;
                1280     ;
                1281     ;
                1282     ;**************************************************************************************
                1283     ;LCD Character Module Routines
                1284     ;**************************************************************************************
                1285     ;
                1286     ;LCD module is a 16 character by 2 line display but all displays are very similar
                1287     ;The 4-wire EQU interface will be used (DB4 to DB7).
                1288     ;
                1289     ;The LCD modules are relatively slow and software delay loops are used to slow down
                1290     ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
                1291     ;a different section (see above in this case).
                1292     ;
                1293     ;
                1294     ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
                1295     ;
                1296     ;Register s4 should define the current state of the LCD output port.
                1297     ;
                1298     ;Registers used s0, s4
                1299     ;
1D2 06401       1300     lcd_pulse_e:		XOR		s4, #lcd_e		;E=1
1D3 22440       1301     			OUTPUT		s4, lcd_output_port
1D4 361BA       1302     			CALL		delay_1us
1D5 06401       1303     			XOR		s4, #lcd_e		;E=0
1D6 22440       1304     			OUTPUT		s4, lcd_output_port
1D7 24000       1305     			RETURN
                1306     ;
                1307     ;Write 4-bit instruction to LCD display.
                1308     ;
                1309     ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
                1310     ;Note that this routine does not release the master enable but as it is only
                1311     ;used during initialisation and as part of the 8-bit instruction write it
                1312     ;should be acceptable.
                1313     ;
                1314     ;Registers used s4
                1315     ;
1D8 024F8       1316     lcd_write_inst4:	AND		s4, #0xf8		;Enable=1 RS=0 Instruction, RW=0 Write, E=0
1D9 22440       1317     			OUTPUT		s4, lcd_output_port	;set up RS and RW >40ns before enable pulse
1DA 361D2       1318     			CALL		lcd_pulse_e
1DB 24000       1319     			RETURN
                1320     ;
                1321     ;
                1322     ;Write 8-bit instruction to LCD display.
                1323     ;
                1324     ;The 8-bit instruction should be provided in register s5.
                1325     ;Instructions are written using the following sequence
                1326     ; Upper nibble
                1327     ; wait >1us
                1328     ; Lower nibble
                1329     ; wait >40us
                1330     ;
                1331     ;Registers used s0, s1, s4, s5
                1332     ;
1DC 10428       1333     lcd_write_inst8:	LOAD		s4, s5
1DD 024F0       1334     			AND		s4, #0xf0		;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1DE 04408       1335     			OR		s4, #lcd_drive		;Enable=1
1DF 361D8       1336     			CALL		lcd_write_inst4		;write upper nibble
1E0 361BA       1337     			CALL		delay_1us		;wait >1us
1E1 10428       1338     			LOAD		s4, s5			;select lower nibble with
1E2 28407       1339     			SL1		s4			;Enable=1
1E3 28406       1340     			SL0		s4			;RS=0 Instruction
1E4 28406       1341     			SL0		s4			;RW=0 Write
1E5 28406       1342     			SL0		s4			;E=0
1E6 361D8       1343     			CALL		lcd_write_inst4		;write lower nibble
1E7 361BE       1344     			CALL		delay_40us		;wait >40us
1E8 004F0       1345     			LOAD		s4, #0xf0		;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1E9 22440       1346     			OUTPUT		s4, lcd_output_port	;Release master enable
1EA 24000       1347     			RETURN
                1348     ;
                1349     ;
                1350     ;
                1351     ;Write 8-bit EQU to LCD display.
                1352     ;
                1353     ;The 8-bit EQU should be provided in register s5.
                1354     ;EQU bytes are written using the following sequence
                1355     ; Upper nibble
                1356     ; wait >1us
                1357     ; Lower nibble
                1358     ; wait >40us
                1359     ;
                1360     ;Registers used s0, s1, s4, s5
                1361     ;
1EB 10428       1362     lcd_write_EQU:		LOAD		s4, s5
1EC 024F0       1363     			AND		s4, #0xf0		;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1ED 0440C       1364     			OR		s4, #0x0c		;Enable=1 RS=1 EQU, RW=0 Write, E=0
1EE 22440       1365     			OUTPUT		s4, lcd_output_port	;set up RS and RW >40ns before enable pulse
1EF 361D2       1366     			CALL		lcd_pulse_e		;write upper nibble
1F0 361BA       1367     			CALL		delay_1us		;wait >1us
1F1 10428       1368     			LOAD		s4, s5			;select lower nibble with
1F2 28407       1369     			SL1		s4			;Enable=1
1F3 28407       1370     			SL1		s4			;RS=1 EQU
1F4 28406       1371     			SL0		s4			;RW=0 Write
1F5 28406       1372     			SL0		s4			;E=0
1F6 22440       1373     			OUTPUT		s4, lcd_output_port	;set up RS and RW >40ns before enable pulse
1F7 361D2       1374     			CALL		lcd_pulse_e		;write lower nibble
1F8 361BE       1375     			CALL		delay_40us		;wait >40us
1F9 004F0       1376     			LOAD		s4, #0xf0		;Enable=0 RS=0 Instruction, RW=0 Write, E=0
1FA 22440       1377     			OUTPUT		s4, lcd_output_port	;Release master enable
1FB 24000       1378     			RETURN
                1379     ;
                1380     ;
                1381     ;
                1382     ;
                1383     ;Read 8-bit EQU from LCD display.
                1384     ;
                1385     ;The 8-bit EQU will be read from the current LCD memory address
                1386     ;and will be returned in register s5.
                1387     ;It is advisable to set the LCD address (cursor position) before
                1388     ;using the EQU read for the first time otherwise the display may
                1389     ;generate invalid EQU on the first read.
                1390     ;
                1391     ;EQU bytes are read using the following sequence
                1392     ; Upper nibble
                1393     ; wait >1us
                1394     ; Lower nibble
                1395     ; wait >40us
                1396     ;
                1397     ;Registers used s0, s1, s4, s5
                1398     ;
1FC 0040E       1399     lcd_read_EQU8:		LOAD		s4, #0x0e		;Enable=1 RS=1 EQU, RW=1 Read, E=0
1FD 22440       1400     			OUTPUT		s4, lcd_output_port	;set up RS and RW >40ns before enable pulse
1FE 06401       1401     			XOR		s4, #lcd_e		;E=1
1FF 22440       1402     			OUTPUT		s4, lcd_output_port
200 361BA       1403     			CALL		delay_1us		;wait >260ns to access EQU
201 20501       1404     			INPUT		s5, lcd_input_port	;read upper nibble
202 06401       1405     			XOR		s4, #lcd_e		;E=0
203 22440       1406     			OUTPUT		s4, lcd_output_port
204 361BA       1407     			CALL		delay_1us		;wait >1us
205 06401       1408     			XOR		s4, #lcd_e		;E=1
206 22440       1409     			OUTPUT		s4, lcd_output_port
207 361BA       1410     			CALL		delay_1us		;wait >260ns to access EQU
208 20001       1411     			INPUT		s0, lcd_input_port	;read lower nibble
209 06401       1412     			XOR		s4, #lcd_e		;E=0
20A 22440       1413     			OUTPUT		s4, lcd_output_port
20B 025F0       1414     			AND		s5, #0xf0		;merge upper and lower nibbles
20C 2800E       1415     			SR0		s0
20D 2800E       1416     			SR0		s0
20E 2800E       1417     			SR0		s0
20F 2800E       1418     			SR0		s0
210 14500       1419     			OR		s5, s0
211 00404       1420     			LOAD		s4, #0x04		;Enable=0 RS=1 EQU, RW=0 Write, E=0
212 22440       1421     			OUTPUT		s4, lcd_output_port	;Stop reading 5V device and release master enable
213 361BE       1422     			CALL		delay_40us		;wait >40us
214 24000       1423     			RETURN
                1424     ;
                1425     ;
                1426     ;Reset and initialise display to communicate using 4-bit EQU mode
                1427     ;Includes routine to clear the display.
                1428     ;
                1429     ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
                1430     ;following by the 8-bit instructions to set up the display.
                1431     ;
                1432     ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
                1433     ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
                1434     ;  0E = '00001' Display control, '1' display on, '1' cursor off, '0' cursor blink off
                1435     ;  01 = '00000001' Display clear
                1436     ;
                1437     ;Registers used s0, s1, s2, s3, s4
                1438     ;
215 361C8       1439     lcd_reset:		CALL		delay_20ms		;wait more that 15ms for display to be ready
216 00430       1440     			LOAD		s4, #0x30
217 361D8       1441     			CALL		lcd_write_inst4		;send '3'
218 361C8       1442     			CALL		delay_20ms		;wait >4.1ms
219 361D8       1443     			CALL		lcd_write_inst4		;send '3'
21A 361C3       1444     			CALL		delay_1ms		;wait >100us
21B 361D8       1445     			CALL		lcd_write_inst4		;send '3'
21C 361BE       1446     			CALL		delay_40us		;wait >40us
21D 00420       1447     			LOAD		s4, #0x20
21E 361D8       1448     			CALL		lcd_write_inst4		;send '2'
21F 361BE       1449     			CALL		delay_40us		;wait >40us
220 00528       1450     			LOAD		s5, #0x28		;Function set
221 361DC       1451     			CALL		lcd_write_inst8
222 00506       1452     			LOAD		s5, #0x06		;Entry mode
223 361DC       1453     			CALL		lcd_write_inst8
224 0050E       1454     			LOAD		s5, #0x0e		;Display control
225 361DC       1455     			CALL		lcd_write_inst8
226 00501       1456     lcd_clear:		LOAD		s5, #0x01		;Display clear
227 361DC       1457     			CALL		lcd_write_inst8
228 361C3       1458     			CALL		delay_1ms		;wait >1.64ms for display to clear
229 361C3       1459     			CALL		delay_1ms
22A 24000       1460     			RETURN
                1461     ;
                1462     ;Position the cursor ready for characters to be written.
                1463     ;The display is formed of 2 lines of 16 characters and each
                1464     ;position has a corresponding address as indicated below.
                1465     ;
                1466     ;                   Character position
                1467     ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
                1468     ;
                1469     ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
                1470     ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
                1471     ;
                1472     ;This routine will set the cursor position using the value provided
                1473     ;in register s5. The upper nibble will define the line and the lower
                1474     ;nibble the character position on the line.
                1475     ; Example s5 = 2B will position the cursor on line 2 position 11
                1476     ;
                1477     ;Registers used s0, s1, s2, s3, s4
                1478     ;
22B 00510       1479     lcd_cursor:		load		s5, #0x10		;load for line 1
22C 35231       1480     			JUMP		z, set_line2
22D 0250F       1481     			AND		s5, #0x0f		;make address in range 80 to 8F for line 1
22E 04580       1482     			OR		s5, #0x80
22F 361DC       1483     			CALL		lcd_write_inst8		;instruction write to set cursor
230 24000       1484     			RETURN
231 0250F       1485     set_line2:		AND		s5, #0x0f		;make address in range C0 to CF for line 2
232 045C0       1486     			OR		s5, #0xc0
233 361DC       1487     			CALL		lcd_write_inst8		;instruction write to set cursor
234 24000       1488     			RETURN
                1489     ;
                1490     ;This routine will shift the complete display one position to the left.
                1491     ;The cursor position and LCD memory contents will not change.
                1492     ;
                1493     ;
                1494     ;Registers used s0, s1, s2, s3, s4, s5
                1495     ;
235 00518       1496     lcd_shift_left:		LOAD		s5, #0x18		;shift display left
236 361DC       1497     			CALL		lcd_write_inst8
237 24000       1498     			RETURN
                1499     ;
                1500     ;**************************************************************************************
                1501     ;Interrupt Service Routine (ISR)
                1502     ;**************************************************************************************
                1503     ;
                1504     ;Interrupts occur when the rotary control has been moved.
                1505     ;
                1506     ;The ISR captures the state of the direction which it writes to scratch pad memory (SPM).
                1507     ;The most significant bit is also set at this location to provide a 'flag' to the
                1508     ;main body of the program.
                1509     ;
                1510     ;
238 10008       1511     isr:			load		s0, isr_preserve_s0	;preserve s0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
239 20000       1512     			INPUT		s0, rotary_port		;read rotary encoder
23A 04080       1513     			OR		s0, #rotary_event	;set flag
23B 10000       1514     			load		s0, rotary_status	;put result in SCM
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
23C 10008       1515     			load		s0, isr_preserve_s0	;reload s0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
23D 2C001       1516     			RETURNI		enable
                1517     ;
                1518     ;
                1519     ;**************************************************************************************
                1520     ;Interrupt Vector
                1521     ;**************************************************************************************
                1522     ;
  003FF         1523     			ORG		0x3ff
3FF 34238       1524     			JUMP		isr
                1525     ;
                1526     ;
                1527
