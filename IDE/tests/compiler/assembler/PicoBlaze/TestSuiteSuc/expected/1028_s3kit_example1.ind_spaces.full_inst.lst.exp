  00041            1     character_a             EQU             0x41
  00046            2     character_f             EQU             0x46
  00049            3     character_i             EQU             0x49
  0004C            4     character_l             EQU             0x4c
  00050            5     character_p             EQU             0x50
  00053            6     character_s             EQU             0x53
                   7     device kcpsm1
                   8     ; KCPSM3 Program - LED control with Pulse Width Modulation (PWM).
                   9     ;
                  10     ; Design provided for use with the design 'low_cost_design_authentication_for_spartan_3e.vhd'
                  11     ; and the Spartan-3E Starter Kit. This design provides the token 'real' application to be
                  12     ; protected by design authentication.
                  13     ;
                  14     ; Ken Chapman - Xilinx Ltd
                  15     ;
                  16     ; Version v1.00 - 9th November 2006
                  17     ;
                  18     ; This code automatically sequences the LEDs on the board using PWM to change intensity.
                  19     ; It also checks for correct design authentication and will perform a different sequence if
                  20     ; the design is not authorised.
                  21     ;
                  22     ;
                  23     ;**************************************************************************************
                  24     ; NOTICE:
                  25     ;
                  26     ; Copyright Xilinx, Inc. 2006.   This code may be contain portions patented by other
                  27     ; third parties.  By providing this core as one possible implementation of a standard,
                  28     ; Xilinx is making no representation that the provided implementation of this standard
                  29     ; is free from any claims of infringement by any third party.  Xilinx expressly
                  30     ; disclaims any warranty with respect to the adequacy of the implementation, including
                  31     ; but not limited to any warranty or representation that the implementation is free
                  32     ; from claims of any third party.  Furthermore, Xilinx is providing this core as a
                  33     ; courtesy to you and suggests that you contact all third parties to obtain the
                  34     ; necessary rights to use this implementation.
                  35     ;
                  36     ;
                  37     ;**************************************************************************************
                  38     ; Port definitions
                  39     ;**************************************************************************************
                  40     ;
                  41     ;
                  42     ;
  00080           43     led_port                EQU             0x80                    ;8 simple LEDs
  00001           44     led0                    EQU             0x01                    ;       LD0 - bit0
  00002           45     led1                    EQU             0x02                    ;       LD1 - bit1
  00004           46     led2                    EQU             0x04                    ;       LD2 - bit2
  00008           47     led3                    EQU             0x08                    ;       LD3 - bit3
  00010           48     led4                    EQU             0x10                    ;       LD4 - bit4
  00020           49     led5                    EQU             0x20                    ;       LD5 - bit5
  00040           50     led6                    EQU             0x40                    ;       LD6 - bit6
  00080           51     led7                    EQU             0x80                    ;       LD7 - bit7
                  52     ;
  00000           53     led_read_port           EQU             0x00                    ;read back of current LED drive values
                  54     ;
                  55     ;
  00040           56     security_request_port   EQU             0x40                    ;Port to stimulate security KCPSM3 processor
  00001           57     security_interrupt      EQU             0x01                    ; interrupt - bit0
                  58     ;
                  59     ;
                  60     ;A FIFO buffer links the security KCPSM3 processor to the application KCPSM3 processor.
                  61     ;  This application processor controls and reads the FIFO.
                  62     ;  The security processor writes to the FIFO.
                  63     ;
  00020           64     link_fifo_control_port  EQU             0x20                    ;FIFO control
  00001           65     link_fifo_reset         EQU             0x01                    ;     reset - bit0
                  66     ;
  00001           67     link_fifo_status_port   EQU             0x01                    ;FIFO status input
  00001           68     link_fifo_data_present  EQU             0x01                    ;      half full - bit0
  00002           69     link_fifo_half_full     EQU             0x02                    ;           full - bit1
  00004           70     link_fifo_full          EQU             0x04                    ;   data present - bit2
                  71     ;
  00002           72     link_fifo_read_port     EQU             0x02                    ;read FIFO data
                  73     ;
                  74     ;
                  75     ;
                  76     ;**************************************************************************************
                  77     ; Special Register usage
                  78     ;**************************************************************************************
                  79     ;
                  80     ;
                  81     ;
                  82     ;
                  83     ;**************************************************************************************
                  84     ;Scratch Pad Memory Locations
                  85     ;**************************************************************************************
                  86     ;
  00000           87     pwm_duty_counter        EQU             0x00                    ;Duty Counter 0 to 255 within 1KHz period (1ms)
  00001           88     pwm_channel0            EQU             0x01                    ;PWM settings for each channel
  00002           89     pwm_channel1            EQU             0x02                    ; Channels 0 to 7 = LEDs 0 to 7
  00003           90     pwm_channel2            EQU             0x03
  00004           91     pwm_channel3            EQU             0x04
  00005           92     pwm_channel4            EQU             0x05
  00006           93     pwm_channel5            EQU             0x06
  00007           94     pwm_channel6            EQU             0x07
  00008           95     pwm_channel7            EQU             0x08
  0000D           96     isr_preserve_s0         EQU             0x0d                    ;preserve register contents during Interrupt Service Routine
  0000E           97     isr_preserve_s1         EQU             0x0e
  0000F           98     isr_preserve_s2         EQU             0x0f
                  99     ;
                 100     ;
  00010          101     led0_sequence           EQU             0x10                    ;LED sequence values
  00011          102     led1_sequence           EQU             0x11
  00012          103     led2_sequence           EQU             0x12
  00013          104     led3_sequence           EQU             0x13
  00014          105     led4_sequence           EQU             0x14
  00015          106     led5_sequence           EQU             0x15
  00016          107     led6_sequence           EQU             0x16
  00017          108     led7_sequence           EQU             0x17
                 109     ;
                 110     ;
                 111     ;
                 112     ;**************************************************************************************
                 113     ;Useful data constants
                 114     ;**************************************************************************************
                 115     ;
                 116     ;
                 117     ;
                 118     ;
                 119     ;
                 120     ;
                 121     ;
                 122     ;**************************************************************************************
                 123     ;Initialise the system
                 124     ;**************************************************************************************
                 125     ;
                 126     ; All PWM channels initialise to off (zero).
                 127     ; Simple I/O outputs will remain off at all times.
                 128     ;
000 00000        129     cold_start:             LOAD            s0, #0x00
001 00101        130                             LOAD            s1, #pwm_channel0
  00002          131     clear_loop:
002 00108        132                             load         s1, #pwm_channel7
003 09106        133                             JUMP            z, enable_int
004 04101        134                             ADD             s1, #0x01
005 08102        135                             JUMP            clear_loop
                 136     ;
006 08030        137     enable_int:             ENABLE          interrupt               ;interrupts used to set PWM frequency
                 138     ;
                 139     ;
                 140     ; Initialise LED pattern sequence
                 141     ;
007 00001        142                             LOAD            s0, #0x01               ;trigger to start wave pattern
                 143
008 00000        144                             LOAD            s0, #0x00
                 145
                 146     ;
                 147     ;
                 148     ; Reset authentication check counter
                 149     ;
009 00F00        150                             LOAD            sf, #0x00
                 151     ;
                 152     ;
                 153     ;**************************************************************************************
                 154     ; Main program
                 155     ;**************************************************************************************
                 156     ;
                 157     ; Provides a pattern of interest on the LEDs :-)
                 158     ;
                 159     ; Each LED increases intensity in 8 steps and then decreases intensity in 8 steps until it is off.
                 160     ; The middle LEDs (LD2 to LD5) each start to turn on when either neighbour is turned half on and increasing
                 161     ; to provide the effect of a passing a 'wave' of light passing from side to side. The pair of LEDs at each
                 162     ; (LD0, Ld1 and LD6, LD7) are required to reflect the 'wave' so that the pattern continues.
                 163     ;
                 164     ; I'm sure this code cold be written in more elegant way, but I leave that as an exercise to you :-)
                 165     ;
                 166     ;
                 167     ; Using a simple soloadware counter (implemented by register sF) the design occasionally requests an
                 168     ; authorisation message from the authentication processor. If it receives a PASS message it continues
                 169     ; normally but if it receives a FAIL message the LED pattern is changed.
                 170     ;
                 171     ;
                 172     ;
00A 04F01        173     warm_start:             ADD             sf, #0x01               ;authentication check timer
00B 0998D        174                             JUMP            c, authentication_check ;Check made approximately every 8 seconds.
                 175     ;
00C 00203        176     normal_led_sequence:    LOAD            s2, #0x03               ;simple delay loop (delay will be increased by ISR processing)
00D 001FF        177     delay_s2_loop:          LOAD            s1, #0xff
00E 000FF        178     delay_s1_loop:          LOAD            s0, #0xff
00F 06001        179     delay_s0_loop:          SUB             s0, #0x01
010 09D0F        180                             JUMP            nc, delay_s0_loop
011 06101        181                             SUB             s1, #0x01
012 09D0E        182                             JUMP            nc, delay_s1_loop
013 06201        183                             SUB             s2, #0x01
014 09D0D        184                             JUMP            nc, delay_s2_loop
                 185     ;
                 186     ;Pattern generation
                 187     ;
                 188
015 00000        189                             load         s0, #0x00
016 0911C        190                             JUMP            z, load_led0_start
017 06020        191                             SUB             s0, #0x20               ;Count longer to ensure end stops then reset count if maximum
018 0911F        192                             JUMP            z, update_led0
019 04020        193                             ADD             s0, #0x20
01A 04001        194     inc_led0:               ADD             s0, #0x01               ;increment counter
01B 0811F        195                             JUMP            update_led0
01C 0C110        196     load_led0_start:        load           s1, led1_sequence       ;start LED0 if LED1 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
01D 00104        197                             load         s1, #0x04
01E 0911A        198                             JUMP            z, inc_led0
  0001F          199     update_led0:
01F 0837F        200                             CALL            led_to_duty
                 201
                 202     ;
020 0C100        203                             load           s1, led0_sequence       ; refresh LED1 if LED0 = 11 (0B hex) to reflect wave
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
021 0010B        204                             load         s1, #0x0b
022 09525        205                             JUMP            nz, normal_led1
023 00004        206                             LOAD            s0, #0x04
024 08133        207                             JUMP            update_led1
025 0C010        208     normal_led1:            load           s0, led1_sequence       ;read sequence for LED1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
026 00000        209                             load         s0, #0x00
027 0912D        210                             JUMP            z, load_led1_start
028 06010        211                             SUB             s0, #0x10               ;reset count if maximum
029 09133        212                             JUMP            z, update_led1
02A 04010        213                             ADD             s0, #0x10
02B 04001        214     inc_led1:               ADD             s0, #0x01               ;increment counter
02C 08133        215                             JUMP            update_led1
02D 0C100        216     load_led1_start:        load           s1, led0_sequence       ;start LED1 if LED0 = 11 (0B hex) to reflect wave
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
02E 0010B        217                             load         s1, #0x0b
02F 0912B        218                             JUMP            z, inc_led1
030 0C120        219                             load           s1, led2_sequence       ;start LED1 if LED2 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
031 00104        220                             load         s1, #0x04
032 0912B        221                             JUMP            z, inc_led1
  00033          222     update_led1:
033 0837F        223                             CALL            led_to_duty
                 224
                 225     ;
                 226
034 00000        227                             load         s0, #0x00
035 0913B        228                             JUMP            z, load_led2_start
036 06010        229                             SUB             s0, #0x10               ;reset count if maximum
037 09141        230                             JUMP            z, update_led2
038 04010        231                             ADD             s0, #0x10
039 04001        232     inc_led2:               ADD             s0, #0x01               ;increment counter
03A 08141        233                             JUMP            update_led2
03B 0C110        234     load_led2_start:        load           s1, led1_sequence       ;start LED2 if LED1 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
03C 00104        235                             load         s1, #0x04
03D 09139        236                             JUMP            z, inc_led2
03E 0C130        237                             load           s1, led3_sequence       ;start LED2 if LED3 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
03F 00104        238                             load         s1, #0x04
040 09139        239                             JUMP            z, inc_led2
  00041          240     update_led2:
041 0837F        241                             CALL            led_to_duty
                 242
                 243     ;
                 244     ;
                 245
042 00000        246                             load         s0, #0x00
043 09149        247                             JUMP            z, load_led3_start
044 06010        248                             SUB             s0, #0x10               ;reset count if maximum
045 0914D        249                             JUMP            z, update_led3
046 04010        250                             ADD             s0, #0x10
047 04001        251     inc_led3:               ADD             s0, #0x01               ;increment counter
048 0814D        252                             JUMP            update_led3
  00049          253     load_led3_start:
049 00104        254                             load         s1, #0x04
04A 09147        255                             JUMP            z, inc_led3
                 256
04B 00104        257                             load         s1, #0x04
04C 09147        258                             JUMP            z, inc_led3
  0004D          259     update_led3:
04D 0837F        260                             CALL            led_to_duty
                 261
                 262     ;
04E 00000        263     load         s0, #0x00
04F 09155        264                             JUMP            z, load_led4_start
050 06010        265                             SUB             s0, #0x10               ;reset count if maximum
051 09159        266                             JUMP            z, update_led4
052 04010        267                             ADD             s0, #0x10
053 04001        268     inc_led4:               ADD             s0, #0x01               ;increment counter
054 08159        269                             JUMP            update_led4
055 00104        270     load_led4_start: load         s1, #0x04
056 09153        271                             JUMP            z, inc_led4
057 00104        272     load         s1, #0x04
058 09153        273                             JUMP            z, inc_led4
059 0837F        274     update_led4:CALL            led_to_duty
                 275
05A 00000        276     load         s0, #0x00
05B 09161        277                             JUMP            z, load_led5_start
05C 06010        278                             SUB             s0, #0x10               ;reset count if maximum
05D 09165        279                             JUMP            z, update_led5
05E 04010        280                             ADD             s0, #0x10
05F 04001        281     inc_led5:               ADD             s0, #0x01               ;increment counter
060 08165        282                             JUMP            update_led5
061 00104        283     load_led5_start:load         s1, #0x04
062 0915F        284                             JUMP            z, inc_led5
063 00104        285     load         s1, #0x04
064 0915F        286                             JUMP            z, inc_led5
065 0837F        287     update_led5:CALL            led_to_duty
                 288
066 0010B        289     load         s1, #0x0b
067 0956A        290                             JUMP            nz, normal_led6
068 00004        291                             LOAD            s0, #0x04
069 08173        292                             JUMP            update_led6
06A 00000        293     normal_led6:load         s0, #0x00
06B 09171        294                             JUMP            z, load_led6_start
06C 06010        295                             SUB             s0, #0x10               ;reset count if maximum
06D 09173        296                             JUMP            z, update_led6
06E 04010        297                             ADD             s0, #0x10
06F 04001        298     inc_led6:               ADD             s0, #0x01               ;increment counter
070 08173        299                             JUMP            update_led6
071 00104        300     load_led6_start:load         s1, #0x04
072 0916F        301                             JUMP            z, inc_led6
073 0837F        302     update_led6: CALL            led_to_duty
                 303
074 00000        304      load         s0, #0x00
075 0917B        305                             JUMP            z, load_led7_start
076 06020        306                             SUB             s0, #0x20               ;Count longer to ensure end stops then reset count if maximum
077 0917D        307                             JUMP            z, update_led7
078 04020        308                             ADD             s0, #0x20
079 04001        309     inc_led7:               ADD             s0, #0x01               ;increment counter
07A 0817D        310                             JUMP            update_led7
07B 00104        311     load_led7_start:load         s1, #0x04
07C 09179        312                             JUMP            z, inc_led7
07D 0837F        313     update_led7: CALL            led_to_duty
07E 0810A        314      JUMP            warm_start
                 315     ;
                 316     ;
                 317     ; Convert LED sequence number into PWM intensity figure
                 318     ;
                 319     ; LEDs duty cycle values are 0,1,2,4,8,16,32 and 64 because they appear to give what
                 320     ; appears to be a fairly liner change in intensity and provides a simple way to set
                 321     ; the duty value.
                 322     ;
                 323     ; Provide sequence value in register s0 and intensity will be
                 324     ; returned in register s1.
                 325     ;
                 326     ; s0   s1
                 327     ; 00   00
                 328     ; 01   01
                 329     ; 02   02
                 330     ; 03   04
                 331     ; 04   08
                 332     ; 05   10
                 333     ; 06   20
                 334     ; 07   40
                 335     ; 08   80
                 336     ; 09   40
                 337     ; 0A   20
                 338     ; 0B   10
                 339     ; 0C   08
                 340     ; 0D   04
                 341     ; 0E   02
                 342     ; 0F   01
                 343     ; 10   00  and zero for all larger values of s0
                 344     ;
07F 00100        345     led_to_duty:            LOAD            s1, #0x00
080 00000        346                             load         s0, #0x00               ;load for zero
081 09080        347                             RETURN          z
082 00101        348                             LOAD            s1, #0x01               ;inject '1'
083 06001        349     go_up_loop:             SUB             s0, #0x01
084 09080        350                             RETURN          z
085 0D106        351                             SL0             s1                      ;multiply by 2
086 09988        352                             JUMP            c, go_down
087 08183        353                             JUMP            go_up_loop
088 00140        354     go_down:                LOAD            s1, #0x40
089 06001        355     go_down_loop:           SUB             s0, #0x01
08A 09080        356                             RETURN          z
08B 0D10E        357                             SR0             s1                      ;divide by 2
08C 08189        358                             JUMP            go_down_loop
                 359     ;
                 360     ;
                 361     ;
                 362     ;**************************************************************************************
                 363     ; Authentication Check and fail procedure
                 364     ;**************************************************************************************
                 365     ;
                 366     ; The authentication check is performed by issuing and interrupt to the authentication
                 367     ; processor and then observing the simple text string that it returns via the link FIFO
                 368     ; buffer.
                 369     ;
                 370     ; PASS - Design is authorised to work.
                 371     ; FAIL - Design is not authorised and should stop working normally.
                 372     ;
                 373     ;
                 374     ;ASCII character values that are used in messages
                 375     ;
                 376     ; >>>>> (line moved to the beginning) <<<<<
                 377     ; >>>>> (line moved to the beginning) <<<<<
                 378     ; >>>>> (line moved to the beginning) <<<<<
                 379     ; >>>>> (line moved to the beginning) <<<<<
                 380     ; >>>>> (line moved to the beginning) <<<<<
                 381     ; >>>>> (line moved to the beginning) <<<<<
                 382     ;
                 383     ;
08D 00001        384     authentication_check:   LOAD            s0, #link_fifo_reset    ;clear link FIFO to ensure no unexpected characters
08E 0E020        385                             OUTPUT          s0, link_fifo_control_port
08F 00000        386                             LOAD            s0, #0x00
090 0E020        387                             OUTPUT          s0, link_fifo_control_port
                 388     ;
091 00001        389                             LOAD            s0, #security_interrupt ;generate interrupt to authentication processor
092 0E040        390                             OUTPUT          s0, security_request_port
093 00000        391                             LOAD            s0, #0x00
094 0E040        392                             OUTPUT          s0, security_request_port
                 393     ;
095 083CF        394                             CALL            read_link_fifo          ;read each character and load
096 00050        395                             load         s0, #character_p
097 095A2        396                             JUMP            nz, fail_confirm
098 083CF        397                             CALL            read_link_fifo
099 00041        398                             load         s0, #character_a
09A 095A2        399                             JUMP            nz, fail_confirm
09B 083CF        400                             CALL            read_link_fifo
09C 00053        401                             load         s0, #character_s
09D 095A2        402                             JUMP            nz, fail_confirm
09E 083CF        403                             CALL            read_link_fifo
09F 00053        404                             load         s0, #character_s
0A0 095A2        405                             JUMP            nz, fail_confirm
0A1 0810C        406                             JUMP            normal_led_sequence     ;Continue normal operation for PASS message
                 407     ;
                 408     ;
                 409     ; To confirm that the authentication is really a FAIL message
                 410     ; another request is made to the authentication processor and loaded.
                 411     ;
0A2 000FF        412     fail_confirm:           LOAD            s0, #0xff               ;short delay to ensure authentication processor is ready
0A3 06001        413     request_delay:          SUB             s0, #0x01               ;   to respond to new interrupt request
0A4 095A3        414                             JUMP            nz, request_delay
                 415     ;
0A5 00001        416                             LOAD            s0, #link_fifo_reset    ;clear link FIFO to ensure no unexpected characters
0A6 0E020        417                             OUTPUT          s0, link_fifo_control_port
0A7 00000        418                             LOAD            s0, #0x00
0A8 0E020        419                             OUTPUT          s0, link_fifo_control_port
                 420     ;
0A9 00001        421                             LOAD            s0, #security_interrupt ;generate interrupt to authentication processor
0AA 0E040        422                             OUTPUT          s0, security_request_port
0AB 00000        423                             LOAD            s0, #0x00
0AC 0E040        424                             OUTPUT          s0, security_request_port
                 425     ;
0AD 083CF        426                             CALL            read_link_fifo          ;read each character and load
0AE 00046        427                             load         s0, #character_f
0AF 0950C        428                             JUMP            nz, normal_led_sequence
0B0 083CF        429                             CALL            read_link_fifo
0B1 00041        430                             load         s0, #character_a
0B2 0950C        431                             JUMP            nz, normal_led_sequence
0B3 083CF        432                             CALL            read_link_fifo
0B4 00049        433                             load         s0, #character_i
0B5 0950C        434                             JUMP            nz, normal_led_sequence
0B6 083CF        435                             CALL            read_link_fifo
0B7 0004C        436                             load         s0, #character_l
0B8 0950C        437                             JUMP            nz, normal_led_sequence
                 438     ;
                 439     ;
                 440     ; When the design fails to authenticate the LEDs will appear to
                 441     ; turn on and then slowly fade to off using PWM.
                 442     ;
0B9 000FF        443     failed_led_sequence:    LOAD            s0, #0xff               ;maximum intensity on all LEDs
0BA 00400        444                             LOAD            s4, #0x00               ;reset fade rate control
0BB 00101        445     all_led_fade:           LOAD            s1, #pwm_channel0
0BC 00108        446     all_led_fade_loop: load         s1, #pwm_channel7
0BD 091C0        447                             JUMP            z, decay_leds
0BE 04101        448                             ADD             s1, #0x01
0BF 081BC        449                             JUMP            all_led_fade_loop
0C0 0C140        450     decay_leds:             LOAD            s1, s4                  ;soloadware delay starts quickly and slows down because LEDs are non-linear.
0C1 00218        451     wait_s1:                LOAD            s2, #0x18
0C2 003FF        452     wait_s2:                LOAD            s3, #0xff
0C3 06301        453     wait_s3:                SUB             s3, #0x01
0C4 095C3        454                             JUMP            nz, wait_s3
0C5 06201        455                             SUB             s2, #0x01
0C6 095C2        456                             JUMP            nz, wait_s2
0C7 06101        457                             SUB             s1, #0x01
0C8 095C1        458                             JUMP            nz, wait_s1
0C9 00000        459                             load         s0, #0x00               ;load for fully off
0CA 091CE        460                             JUMP            z, stop_completely
0CB 06001        461                             SUB             s0, #0x01               ;fade LEDs
0CC 04401        462                             ADD             s4, #0x01               ;slow fade rate as intensity decreases
0CD 081BB        463                             JUMP            all_led_fade
                 464     ;
0CE 081CE        465     stop_completely:        JUMP            stop_completely
                 466     ;
                 467     ;**************************************************************************************
                 468     ; Read Byte from Link FIFO
                 469     ;**************************************************************************************
                 470     ;
                 471     ; The routine first loads the FIFO buffer to see if data is present.
                 472     ; If the FIFO is empty, the routine waits until there is a character to read.
                 473     ; the read value is returned in register s0.
                 474     ;
                 475     ;
0CF 0A001        476     read_link_fifo:         INPUT           s0, link_fifo_status_port ;load FIFO buffer
0D0 00001        477                             load            s0, #link_fifo_data_present ;wait if empty
0D1 091CF        478                             JUMP            z, read_link_fifo
0D2 0A002        479                             INPUT           s0, link_fifo_read_port ;read data from FIFO
0D3 08080        480                             RETURN
                 481     ;
                 482     ;
                 483     ;**************************************************************************************
                 484     ; Interrupt Service Routine (ISR)
                 485     ;**************************************************************************************
                 486     ;
                 487     ; Interrupts occur at 3.92us intervals and are used to generate the PWM pulses generated
                 488     ; at a PRF of 1KHz. The 3.92us interrupt rate corresponds with a resolution of 256 steps
                 489     ; over the 1ms associated with the 1KHz PRF.
                 490     ;
                 491     ; The ISR is self contained and all registers used are preserved. Scratch pad memory
                 492     ; locations are used to determine the desired duty factor for each of 8 channels.
                 493     ;
                 494     ; Note that an interrupt is generated every 196 clock cycles. This means that there is
                 495     ; only time to execute 98 instructions between each interrupt. This ISR is 35 instructions
                 496     ; long. A further 3 instructions are also consumed by the interrupt process
                 497     ; (abandoned instruction, virtual CALL to 3FF and the interrupt vector JUMP) and hence
                 498     ; PicoBlaze has approximately 63% of its time available for other tasks in the main program.
                 499     ;
                 500     ; Although a loop would normal be employed in soloadware to process each of 8 channels,
                 501     ; the implementation of a loop would increase the number of instructions which needed to
                 502     ; be executed significantly reduce the time available for the main program to operate.
                 503     ; Consequently the code is written out in a linear fashion which consumes more program
                 504     ; space but which executes faster.
                 505     ;
  000D4          506     isr:
0D4 04101        507      ADD             s1, #0x01               ;increment counter (will roll over to zero)
                 508
                 509     ;reset a bit in register s2 accordingly.
0D5 0C100        510         load         s1, s0                  ;set carry flag if duty factor > duty counter
0D6 0D200        511                             SLA             s2                      ;shiload carry into register s2
0D7 0C100        512       load         s1, s0                  ;set carry flag if duty factor > duty counter
0D8 0D200        513                             SLA             s2                      ;shiload carry into register s2
0D9 0C100        514       load         s1, s0                  ;set carry flag if duty factor > duty counter
0DA 0D200        515                             SLA             s2                      ;shiload carry into register s2
0DB 0C100        516       load         s1, s0                  ;set carry flag if duty factor > duty counter
0DC 0D200        517                             SLA             s2                      ;shiload carry into register s2
0DD 0C100        518       load         s1, s0                  ;set carry flag if duty factor > duty counter
0DE 0D200        519                             SLA             s2                      ;shiload carry into register s2
0DF 0C100        520       load         s1, s0                  ;set carry flag if duty factor > duty counter
0E0 0D200        521                             SLA             s2                      ;shiload carry into register s2
0E1 0C100        522      load         s1, s0                  ;set carry flag if duty factor > duty counter
0E2 0D200        523                             SLA             s2                      ;shiload carry into register s2
0E3 0C100        524       load         s1, s0                  ;set carry flag if duty factor > duty counter
0E4 0D200        525                             SLA             s2                      ;shiload carry into register s2
0E5 0E280        526                             OUTPUT          s2, led_port            ;drive LEDs
0E6 080F0        527       RETURNI         enable
                 528     ;
                 529     ;
                 530     ;**************************************************************************************
                 531     ; Interrupt Vector
                 532     ;**************************************************************************************
                 533     ;
  003FF          534                             ORG             0x3ff
3FF 081D4        535                             JUMP            isr
                 536     ;
                 537     ;
                 538
