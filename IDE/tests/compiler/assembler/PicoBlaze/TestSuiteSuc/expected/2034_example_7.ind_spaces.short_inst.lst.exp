                   1     ;KCPSM3 Program - SPI Control of D/A converter on Spartan-3E Starter Kit.
                   2     ;
                   3     ;
                   4     ;Ken Chapman - Xilinx Ltd
                   5     ;
                   6     ;Version v1.00 - 24th November 2005
                   7     device kcpsm2
                   8     ;This program uses an 8KHz interrupt to generate load waveforms on the
                   9     ;4 analogue outputs provided by the Linear Technology LTC2624 device.
                  10     ;
                  11     ;As well as the port connections vital to communication with the UART and the SPI
                  12     ;FLASH memory, there are additional port connections used to disable the other
                  13     ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
                  14     ;controlled at the hardware level, they are included in this code to aid
                  15     ;future investigations of communication with the other SPI devices using PicoBlaze.
                  16     ;
                  17     ;Connections to the LEDs, switches and press buttons are provided to aid
                  18     ;development and enable further experiments. Otherwise know as having fun!
                  19     ;
                  20     ;Port definitions
                  21     ;
                  22     ;
  00008           23     spi_control_port        EQU     0x08                    ;SPI clock and chip selects
  00001           24     spi_sck                 EQU     0x01                    ;                  SCK - bit0
  00002           25     spi_rom_cs              EQU     0x02                    ;    serial rom select - bit1
  00004           26     spi_spare_control       EQU     0x04                    ;                spare - bit2
  00008           27     spi_amp_cs              EQU     0x08                    ;     amplifier select - bit3
  00010           28     spi_adc_conv            EQU     0x10                    ;          A/D convert - bit4
  00020           29     spi_dac_cs              EQU     0x20                    ;           D/A select - bit5
  00040           30     spi_amp_shdn            EQU     0x40                    ;       amplifier SHDN - bit6
  00080           31     spi_dac_clr             EQU     0x80                    ;            D/A clear - bit7
                  32     ;
  00004           33     spi_output_port         EQU     0x04                    ;SPI EQU output
  00080           34     spi_sdo                 EQU     0x80                    ;   SDO - bit7
                  35     ;
  00001           36     spi_input_port          EQU     0x01                    ;SPI EQU input
  00080           37     spi_sdi                 EQU     0x80                    ;             SDI - bit7
  00040           38     spi_amp_sdi             EQU     0x40                    ;   amplifier SDI - bit6
                  39     ;
                  40     ;
  00080           41     led_port                EQU     0x80                    ;8 simple LEDs
  00001           42     led0                    EQU     0x01                    ;     LED 0 - bit0
  00002           43     led1                    EQU     0x02                    ;         1 - bit1
  00004           44     led2                    EQU     0x04                    ;         2 - bit2
  00008           45     led3                    EQU     0x08                    ;         3 - bit3
  00010           46     led4                    EQU     0x10                    ;         4 - bit4
  00020           47     led5                    EQU     0x20                    ;         5 - bit5
  00040           48     led6                    EQU     0x40                    ;         6 - bit6
  00080           49     led7                    EQU     0x80                    ;         7 - bit7
                  50     ;
                  51     ;
  00000           52     switch_port             EQU     0x00                    ;Read switches and press buttons
  00001           53     btn_north               EQU     0x01                    ;  Buttons     North - bit0
  00002           54     btn_east                EQU     0x02                    ;               East - bit1
  00004           55     btn_south               EQU     0x04                    ;              South - bit2
  00008           56     btn_west                EQU     0x08                    ;               West - bit3
  00010           57     switch0                 EQU     0x10                    ;  Switches        0 - bit4
  00020           58     switch1                 EQU     0x20                    ;                  1 - bit5
  00040           59     switch2                 EQU     0x40                    ;                  2 - bit6
  00080           60     switch3                 EQU     0x80                    ;                  3 - bit7
                  61     ;
                  62     ;
                  63     ;
                  64     ;
                  65     ;Special Register usage
                  66     ;
                  67     ;
                  68     ;Useful EQU constants
                  69     ;
                  70     ;
                  71     ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                  72     ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                  73     ;calculation highly predictable. The '6' in the following equation even allows for
                  74     ;'CALL delay_1us' instruction in the initiating code.
                  75     ;
                  76     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                  77     ;
                  78     ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                  79     ;For clock rates below 10MHz the value of 1 must be used and the operation will
                  80     ;become lower than intended.
                  81     ;
  0000B           82     delay_1us_constant      EQU     0x0b
                  83     ;
                  84     ;
                  85     ;
                  86     ;
                  87     ;
                  88     ;
                  89     ;Scratch Pad Memory Locations
                  90     ;
                  91     ;Values to be written to the D/A converter
                  92     ;
                  93     ;
  00000           94     chan_a_lsb              EQU     0x00                    ;Channel A value LS-Byte
  00001           95     chan_a_msb              EQU     0x01                    ;                MS-Byte
                  96     ;
  00002           97     chan_b_lsb              EQU     0x02                    ;Channel B value LS-Byte
  00003           98     chan_b_msb              EQU     0x03                    ;                MS-Byte
                  99     ;
  00004          100     chan_c_lsb              EQU     0x04                    ;Channel C value LS-Byte
  00005          101     chan_c_msb              EQU     0x05                    ;                MS-Byte
                 102     ;
  00006          103     chan_d_lsb              EQU     0x06                    ;Channel D value LS-Byte
  00007          104     chan_d_msb              EQU     0x07                    ;                MS-Byte
                 105     ;
                 106     ;
                 107     ;Value used to synthesise a triangle wave
                 108     ;
  00008          109     triangle_up_down        EQU     0x08                    ;Determines up or down slope
                 110     ;
                 111     ;Value used to synthesise a square wave
                 112     ;
  00009          113     square_count            EQU     0x09                    ;Counts samples in square wave
                 114     ;
                 115     ;
                 116     ;Values used to synthesise a sine wave
                 117     ;
  00010          118     sine_y_lsb              EQU     0x10                    ;Sine wave value LS-Byte
  00011          119     sine_y_msb              EQU     0x11                    ;                 MS-Byte
  00012          120     sine_y1_lsb             EQU     0x12                    ;Sine wave delayed LS-Byte
  00013          121     sine_y1_msb             EQU     0x13                    ;                  MS-Byte
  00014          122     sine_k_lsb              EQU     0x14                    ;Sine constant LS-Byte
  00015          123     sine_k_msb              EQU     0x15                    ;              MS-Byte
                 124     ;
                 125     ;
                 126     ;Sample counter used to give activity indication on LEDs
                 127     ;
  00020          128     sample_count_lsb        EQU     0x20                    ;16-bit counter LS-Byte
  00021          129     sample_count_msb        EQU     0x21                    ;               MS-Byte
                 130     ;
                 131     ;Initialise the system
                 132     ;
                 133     ;
000 36077        134     cold_start:             CALL    spi_init                ;initialise SPI bus ports
001 36052        135                             CALL    init_sine_wave          ;initialise sine wave synthesis values
002 360BB        136                             CALL    delay_1s                ;bus settling delay
003 00000        137                             LD      s0, #0x00               ;clear all internal D/A values
004 10000        138                             load      s0, chan_a_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
005 10008        139                             load      s0, chan_a_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
006 10010        140                             load      s0, chan_b_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
007 10018        141                             load      s0, chan_b_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
008 10020        142                             load      s0, chan_c_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
009 10028        143                             load      s0, chan_c_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00A 10030        144                             load      s0, chan_d_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00B 10038        145                             load      s0, chan_d_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00C 10040        146                             load      s0, triangle_up_down    ;initial slope is up
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00D 360A2        147                             CALL    dac_reset               ;reset D/A converter on all channels
00E 3C001        148                             ENA                             ;Interrupts define 8KHz sample rate
                 149     ;
                 150     ;
                 151     ;The program is interrupt driven to maintain an 8KHz sample rate. The main body
                 152     ;of the program waits for an interrupt to occur. The interrupt updates all four
                 153     ;analogue outputs with values loadd in scratch pad memory. This takes approximately
                 154     ;58us of the 125us available between interrupts. The main program then prepares
                 155     ;new values for the analogue outputs (in less than 67us) before waiting for the
                 156     ;next interrupt.
                 157     ;
                 158     ;
00F 00FFF        159     warm_start:             LD      sf, #0xff               ;flag set and wait for interrupt to be serviced
010 00FFF        160     wait_int:               load     sf, #0xff
011 35010        161                             JUMP    z, wait_int             ;interrupt clears the flag
                 162     ;
                 163     ;
                 164     ;Channel A is a square wave of 2KHz.
                 165     ;
                 166     ;This is formed from the 2KHz square wave on channel C and demonstrates that the
                 167     ;D/A converter echoes the previously sent 32-bit command word.
                 168     ;
                 169     ;Following the interrupt service routine (ISR), the register set [s9,s8,s7,s6]
                 170     ;will contain the command which was last sent for the setting of channel C. The
                 171     ;12-bit sample value is extracted from this word and loadd in the location for
                 172     ;channel A. This should mean that channel A is one sample behind channel C. In this
                 173     ;version that does not mean a lag of 90 degrees because each output is updated
                 174     ;sequentially and that takes approximatly 14.5us per channel.
                 175     ;
                 176     ;This will also demonstrate that the reference voltage on channels A and B is 3.3v
                 177     ;loadd with 2.5v on channels C and D. So whilst the square wave on channel C is
                 178     ;set for 0.50v to 2.00v, it should be 0.66v to 2.64v on channel A.
                 179     ;
012 2870E        180                             SR0     s7                      ; shift 12-bit value right 4 places
013 28608        181                             SRA     s6
014 2870E        182                             SR0     s7
015 28608        183                             SRA     s6
016 2870E        184                             SR0     s7
017 28608        185                             SRA     s6
018 2870E        186                             SR0     s7
019 28608        187                             SRA     s6
01A 10708        188                             load      s7, chan_a_msb          ;load value for D/A output
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
01B 10600        189                             load      s6, chan_a_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 190     ;
                 191     ;
                 192     ;
                 193     ;
                 194     ;Channel B is a triangle waveform of 200Hz.
                 195     ;
                 196     ;Given the sample rate of 8KHz, there are 40 samples per waveform period.
                 197     ;To achieve close to full scale deflection, the waveform needs to increase or
                 198     ;decrease by 204 each sample so that over the first 20 samples it rises from
                 199     ;0 to 4080 and then over the next 20 samples it reduces back to zero.
                 200     ;
01C 10010        201                             load      s0, chan_b_lsb          ;load current value into [s1,s0]
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
01D 10118        202                             load      s1, chan_b_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
01E 10240        203                             load      s2, triangle_up_down    ;read current slope direction
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
01F 00200        204                             load     s2, #0x00               ;determine current direction
020 3542A        205                             JUMP    nz, slope_down
021 080CC        206                             ADD     s0, #0xcc               ;add 204 (00CC hex) to current value
022 0A100        207                             ADDCY   s1, #0x00
023 0010F        208                             load     s1, #0x0f               ;load for peak value of 4080 (0FF0 hex)
024 35432        209                             JUMP    nz, load_channel_b
025 000F0        210                             load     s0, #0xf0
026 35432        211                             JUMP    nz, load_channel_b
027 00201        212                             LD      s2, #0x01               ;change to slope down next time
028 10240        213                             load      s2, triangle_up_down
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
029 34032        214                             JUMP    load_channel_b
02A 0C0CC        215     slope_down:             SUB     s0, #0xcc               ;subtract 204 (00CC hex) from current value
02B 0E100        216                             SUBCY   s1, #0x00
02C 00100        217                             load     s1, #0x00               ;load for zero (0000 hex)
02D 35432        218                             JUMP    nz, load_channel_b
02E 00000        219                             load     s0, #0x00
02F 35432        220                             JUMP    nz, load_channel_b
030 00200        221                             LD      s2, #0x00               ;change to slope up next time
031 10240        222                             load      s2, triangle_up_down
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
032 10010        223     load_channel_b:        load      s0, chan_b_lsb          ;load value for D/A output
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
033 10118        224                             load      s1, chan_b_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 225     ;
                 226     ;
                 227     ;Channel C is a square wave of 2KHz.
                 228     ;
                 229     ;Since the sample rate is 8KHz, this square wave is formed of two samples at a
                 230     ;low level and two samples at a high level. This is used to demonstrate when the
                 231     ;D/A converter output actually changes and how to determine the voltage levels.
                 232     ;It is also used indirectly to form the signal for channel A.
                 233     ;
                 234     ;The low level voltage is 0.50v.
                 235     ;   The 12-bit value is therefore 4096 x 0.5 / 2.5 = 819 (333 hex)
                 236     ;
                 237     ;The high level voltage is 2.00v.
                 238     ;   The 12-bit value is therefore 4096 x 2.0 / 2.5 = 3277 (CCD hex)
                 239     ;
                 240     ;
034 10248        241                             load      s2, square_count        ;read sample counter
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
035 00202        242                             load    s2, #0x02               ;bit 1 has correct frequency
036 3543A        243                             JUMP    nz, square_high
037 00103        244                             LD      s1, #0x03               ;Set low level
038 00033        245                             LD      s0, #0x33
039 3403C        246                             JUMP    load_channel_c
03A 0010C        247     square_high:            LD      s1, #0x0c               ;Set high level
03B 000CD        248                             LD      s0, #0xcd
03C 10020        249     load_channel_c:        load      s0, chan_c_lsb          ;load value for D/A output
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
03D 10128        250                             load      s1, chan_c_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
03E 08201        251                             ADD     s2, #0x01               ;increment sampel count
03F 10248        252                             load      s2, square_count        ;load new sample count
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 253     ;
                 254     ;Sine wave for channel D
                 255     ;
                 256     ;A synthesis algorithm is used to generate a stable 770Hz sine wave
                 257     ;which is one of the 8 tines used in DTMF telephone dialing.
                 258     ;
040 3605E        259                             CALL    calc_next_sine
041 2890E        260                             SR0     s9                      ;reduce value to 12-bits
042 28808        261                             SRA     s8
043 2890E        262                             SR0     s9
044 28808        263                             SRA     s8
045 2890E        264                             SR0     s9
046 28808        265                             SRA     s8
047 08908        266                             ADD     s9, #0x08               ;Scale signed number to mid-rail of unsigned output
048 10938        267                             load      s9, chan_d_msb          ;load value for D/A output
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
049 10830        268                             load      s8, chan_d_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 269     ;
                 270     ;
                 271     ;Drive LEDs with simple binary count of the samples to indicate
                 272     ;that the design is active.
                 273     ;
04A 10000        274                             load      s0, sample_count_lsb    ;read sample counter
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x20, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x0.
04B 10108        275                             load      s1, sample_count_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x21, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x1.
04C 08001        276                             ADD     s0, #0x01               ;increment counter
04D 0A100        277                             ADDCY   s1, #0x00
04E 10000        278                             load      s0, sample_count_lsb    ;load new value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x20, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x0.
04F 10108        279                             load      s1, sample_count_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x21, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x1.
050 22180        280                             OUT     s1, led_port            ;upper bits are 31.25Hz and lower
                 281     ;
051 3400F        282                             JUMP    warm_start              ;wait for next interrupt
                 283     ;
                 284     ;**************************************************************************************
                 285     ;Sine wave synthesis algorithm
                 286     ;**************************************************************************************
                 287     ;
                 288     ;This example is set to generate 770Hz at a sample rate of 8KHz. 770Hz is one of
                 289     ;the eight DTMF frequences. Please see design documentation for more details.
                 290     ;
052 00024        291     init_sine_wave:         LD      s0, #0x24               ;initial value 9216 (2400 hex)
053 10088        292                             load      s0, sine_y_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
054 00000        293                             LD      s0, #0x00
055 10080        294                             load      s0, sine_y_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
056 00000        295                             LD      s0, #0x00               ;initial delayed value 0 (0000 hex)
057 10098        296                             load      s0, sine_y1_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
058 10090        297                             load      s0, sine_y1_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
059 000D2        298                             LD      s0, #0xd2               ;Coefficient for 770Hz is UFIX_16_15 value 53913/32768 = 1.64529
05A 100A8        299                             load      s0, sine_k_msb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
05B 00099        300                             LD      s0, #0x99
05C 100A0        301                             load      s0, sine_k_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
05D 24000        302                             RET
                 303     ;
                 304     ;
                 305     ;Calculate a new output sample for a single tone.
                 306     ;
                 307     ;The tone sample is generated as a 16-bit signed integer.
                 308     ;The waveform is virtually full scale deflection for a 15-bit integer
                 309     ;such that the addition of two tones for DTMF will not exceed the 16-bits
                 310     ;provided by two registers.
                 311     ;
                 312     ;Obtain current values from wscratch pad memory
                 313     ;
05E 10F88        314     calc_next_sine:         load      sf, sine_y_msb          ;[sF,sE] is Y
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
05F 10E80        315                             load      se, sine_y_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
060 10D98        316                             load      sd, sine_y1_msb         ;[sD,sC] is Y1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
061 10C90        317                             load      sc, sine_y1_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
062 10BA8        318                             load      sb, sine_k_msb          ;[sB,sA] is K
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
063 10AA0        319                             load      sa, sine_k_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 320     ;
                 321     ;16-bit signed by 16-bit unsigned multiplication. [s9,s8]=[sB,sA]x[sF,sE]
                 322     ;
                 323     ;The unsigned number is of format UFIX_16_15 resulting
                 324     ;in a FIX_32_15 product. Since only the integer part of the
                 325     ;product is to be retained as a 16-bit value, their is no
                 326     ;shift of the result on the last cycle of the multiplication.
                 327     ;Execution requires a maximum of 145 instructions.
                 328     ;
064 00900        329                             LD      s9, #0x00               ;clear temporary result registers [s9,s8]
065 00800        330                             LD      s8, #0x00
066 00010        331                             LD      s0, #0x10               ;16 bit multiply
067 2890A        332     mult_loop:              SRX     s9                      ;signed divide result by 2
068 28808        333                             SRA     s8
069 28B0E        334                             SR0     sb                      ;shift coefficient
06A 28A08        335                             SRA     sa
06B 35C6E        336                             JUMP    nc, no_mult_add         ;load for active bit
06C 18870        337                             ADD     s8, se                  ;16-bit signed addition
06D 1A978        338                             ADDCY   s9, sf
06E 0C001        339     no_mult_add:            SUB     s0, #0x01               ;load for 16 cycles
06F 35467        340                             JUMP    nz, mult_loop
                 341     ;
                 342     ;Subtract of delayed sample
                 343     ;
070 1C860        344                             SUB     s8, sc                  ;16-bit signed subtract
071 1E968        345                             SUBCY   s9, sd
                 346     ;
                 347     ;Update scratch pad memory with new sample values
                 348     ;
072 10F98        349                             load      sf, sine_y1_msb         ;delayed sample gets previous output
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
073 10E90        350                             load      se, sine_y1_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
074 10988        351                             load      s9, sine_y_msb          ;new current sample
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
075 10880        352                             load      s8, sine_y_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
076 24000        353                             RET
                 354     ;
                 355     ;
                 356     ;**************************************************************************************
                 357     ;SPI communication routines for D/A Converter
                 358     ;**************************************************************************************
                 359     ;
                 360     ;These routines will work with two output ports and one input port which should be
                 361     ;defined as follows using CONloadANT directives.
                 362     ;   (replace 'pp' with appropriate port address in each case)
                 363     ;In the list of CONloadANT directives, only the ones marked with a * are really required
                 364     ;for the D/A Converter system. The other directives are to control (disable) or
                 365     ;communicate with the other SPI components on the same SPI bus of the Spartan-3E Starter Kit.
                 366     ;
                 367     ;
                 368     ;
                 369     ;CONloadANT SPI_control_port, pp       ;SPI clock and chip selects     *
                 370     ;CONloadANT SPI_sck, 01                ;                  SCK - bit0   *
                 371     ;CONloadANT SPI_rom_cs, 02             ;    serial rom select - bit1
                 372     ;CONloadANT SPI_spare_control, 04      ;                spare - bit2
                 373     ;CONloadANT SPI_amp_cs, 08             ;     amplifier select - bit3
                 374     ;CONloadANT SPI_adc_conv, 10           ;          A/D convert - bit4
                 375     ;CONloadANT SPI_dac_cs, 20             ;           D/A select - bit5   *
                 376     ;CONloadANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
                 377     ;CONloadANT SPI_dac_clr, 80            ;            D/A clear - bit7   *
                 378     ;
                 379     ;CONloadANT SPI_output_port, pp        ;SPI EQU output                *
                 380     ;CONloadANT SPI_sdo, 80                ;   SDO - bit7                  *
                 381     ;
                 382     ;CONloadANT SPI_input_port, pp         ;SPI EQU input                 *
                 383     ;CONloadANT SPI_sdi, 80                ;             SDI - bit7        *
                 384     ;CONloadANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
                 385     ;
                 386     ;
                 387     ;
                 388     ;
                 389     ;Initialise SPI bus
                 390     ;
                 391     ;This routine should be used to initialise the SPI bus.
                 392     ;The SCK clock is made low.
                 393     ;Device selections are made inactive as follows
                 394     ;   SPI_sck      = 0      Clock is Low (required)
                 395     ;   SPI_rom_cs   = 1      Deselect ROM
                 396     ;   spare        = 1      spare control bit
                 397     ;   SPI_amp_cs   = 1      Deselect amplifier
                 398     ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
                 399     ;   SPI_dac_cs   = 1      Deselect D/A
                 400     ;   SPI_amp_shdn = 0      Amplifier active and available
                 401     ;   SPI_dac_clr  = 1      D/A clear off
                 402     ;
077 000AE        403     spi_init:               LD      s0, #0xae               ;normally AE
078 22008        404                             OUT     s0, spi_control_port
079 24000        405                             RET
                 406     ;
                 407     ;
                 408     ;
                 409     ;Send and receive one byte to and from the SPI D/A converter.
                 410     ;
                 411     ;The EQU supplied in register 's2' is transmitted to the SPI bus and
                 412     ;at the same time the received byte is used to replace the value in 's2'.
                 413     ;The SCK clock is generated by software and results in a communication rate of
                 414     ;2.5Mbit/s with a 50MHz clock.
                 415     ;
                 416     ;Note that you must have previously selected the required device on the bus
                 417     ;before attempting communication and you must subsequently deselect the device
                 418     ;when appropriate.
                 419     ;
                 420     ;Entry to this routine assumes that register s0 defines the state of the SPI
                 421     ;control signals including SCK which should be Low. The easiest way to achieve this is
                 422     ;to use the SPI_init routine before calling this one for the first time.
                 423     ;
                 424     ;As a 'master' the signal sequence is as follows..
                 425     ;   Transmit EQU bit on SDO line
                 426     ;   Drive SCK transition from low to high
                 427     ;   Receive EQU bit from SDI line (D/A transmits on previous falling edge)
                 428     ;   Drive SCK transition from high to low.
                 429     ;
                 430     ;Important note
                 431     ;   The received EQU bit must be captured some time before SCK goes low.
                 432     ;   However the combination of relatively slow clock to output time of the
                 433     ;   LTC2624 combined with the low drive strength of its SDO output means that
                 434     ;   the received bit needs maximum time to settle. Therefore this routine
                 435     ;   schedules the read as late as it can.
                 436     ;
07A 00108        437     spi_dac_tx_rx:          LD      s1, #0x08               ;8-bits to transmit and receive
07B 22204        438     next_spi_dac_bit:       OUT     s2, spi_output_port     ;output EQU bit ready to be used on rising edge
07C 06001        439                             XOR     s0, #spi_sck            ;clock High (bit0)
07D 22008        440                             OUT     s0, spi_control_port    ;drive clock High
07E 06001        441                             XOR     s0, #spi_sck            ;prepare clock Low (bit0)
07F 20301        442                             IN      s3, spi_input_port      ;read input bit
080 00380        443                             load    s3, #spi_sdi            ;detect state of received bit
081 28200        444                             SLA     s2                      ;shift new EQU into result and move to next transmit bit
082 22008        445                             OUT     s0, spi_control_port    ;drive clock Low
083 0C101        446                             SUB     s1, #0x01               ;count bits
084 3547B        447                             JUMP    nz, next_spi_dac_bit    ;repeat until finished
085 24000        448                             RET
                 449     ;
                 450     ;
                 451     ;
                 452     ;Set a voltage on one of the LTC2624 D/A converter outputs
                 453     ;
                 454     ;The D/A converter has 4 channels. Specify which channel is to be set using
                 455     ;register sC as follows....
                 456     ;   sC     Channel                 Nominal Voltage Range
                 457     ;   00        A                       0 to 3.30v (or VREFAB)
                 458     ;   01        B                       0 to 3.30v (or VREFAB)
                 459     ;   02        C                       0 to 2.50v (or VREFCD)
                 460     ;   03        D                       0 to 2.50v (or VREFCD)
                 461     ;   0F        All channels            various as above.
                 462     ;
                 463     ;The analogue level is a 12-bit value to be supplied in lower 12-bits of register
                 464     ;pair [sB,sA]. If this value is called 'k' and is in the range 0 to 4095 (000 to FFF)
                 465     ;then
                 466     ;      Vout = (k/4096) * VREFx
                 467     ;Hence it is not possible to reach the absolute level of the reference.
                 468     ;
                 469     ;Here are some useful values..
                 470     ;    Voltage    A or B    C or D
                 471     ;      0.0       000       000
                 472     ;      0.5       26D       333
                 473     ;      0.65      327               A/D reference -1.00v
                 474     ;      1.0       4D9       666
                 475     ;      1.5       746       99A
                 476     ;      1.65      800       A8F     converter reference = 3.3/2 = 1.65v
                 477     ;      2.0       9B2       CCD
                 478     ;      2.5       C1F       FFF
                 479     ;      2.65      CD9               A/D reference +1.00v
                 480     ;      3.0       E8C       n/a
                 481     ;      3.3       FFF       n/a
                 482     ;
                 483     ;Note that the full scale deflection of FFF will result in different output
                 484     ;voltages due to different reference voltages for each pair of channels.
                 485     ;
                 486     ;SPI communication with the DAC only requires a 24-bit word to be transmitted.
                 487     ;However, the device internally contains a 32-bit shift register. When writing
                 488     ;a command word, the previous contents are shifted out and can be observed by
                 489     ;the master (Spartan-3E in this case). If you do not use a 32-bit format, then
                 490     ;the read back is confusing. Hence this routine uses a 32-bit format by transmitting
                 491     ;a dummy byte first.
                 492     ;
                 493     ;  Byte 1 = 00   8 dummy bits
                 494     ;  Byte 2 = 3c   Command nibble (3=write and update) and channel selection
                 495     ;  Byte 3 = dd   Upper 8-bits of the 12-bit voltage value
                 496     ;  Byte 4 = d0   lower 4-bits of the 12-bit voltage value and 4 dummy bits.
                 497     ;
                 498     ;At the end of this communication, the register set [s9,s8,s7,s6] will contain the
                 499     ;EQU received back from the D/A converter which should be the previous command.
                 500     ;
086 36077        501     set_dac:                CALL    spi_init                ;ensure known state of bus and s0 register
087 06020        502                             XOR     s0, #spi_dac_cs         ;select low on D/A converter
088 22008        503                             OUT     s0, spi_control_port
089 00200        504                             LD      s2, #0x00               ;Write dummy byte to DAC
08A 3607A        505                             CALL    spi_dac_tx_rx
08B 10910        506                             LD      s9, s2                  ;capture response
08C 10260        507                             LD      s2, sc                  ;Select channel for update
08D 0220F        508                             AND     s2, #0x0f               ;isolate channel bits to be certain of correct command
08E 04230        509                             OR      s2, #0x30               ;Use immediate Write and Update command is "0011"
08F 3607A        510                             CALL    spi_dac_tx_rx
090 10810        511                             LD      s8, s2                  ;capture response
091 28A06        512                             SL0     sa                      ;EQU shift bits into correct position
092 28B00        513                             SLA     sb                      ;with 4 dummy bits ('0') in the least significant bits.
093 28A06        514                             SL0     sa
094 28B00        515                             SLA     sb
095 28A06        516                             SL0     sa
096 28B00        517                             SLA     sb
097 28A06        518                             SL0     sa
098 28B00        519                             SLA     sb
099 10258        520                             LD      s2, sb                  ;Write 12 bit value followed by 4 dummy bits
09A 3607A        521                             CALL    spi_dac_tx_rx
09B 10710        522                             LD      s7, s2                  ;capture response
09C 10250        523                             LD      s2, sa
09D 3607A        524                             CALL    spi_dac_tx_rx
09E 10610        525                             LD      s6, s2                  ;capture response
09F 06020        526                             XOR     s0, #spi_dac_cs         ;deselect the D/A converter to execute
0A0 22008        527                             OUT     s0, spi_control_port
0A1 24000        528                             RET
                 529     ;
                 530     ;Perform a hard reset of the D/A converter
                 531     ;
0A2 36077        532     dac_reset:              CALL    spi_init                ;ensure known state of bus and s0 register
0A3 06080        533                             XOR     s0, #spi_dac_clr        ;pulse the clear signal.
0A4 22008        534                             OUT     s0, spi_control_port
0A5 06080        535                             XOR     s0, #spi_dac_clr
0A6 22008        536                             OUT     s0, spi_control_port
0A7 24000        537                             RET
                 538     ;
                 539     ;
                 540     ;**************************************************************************************
                 541     ;Software delay routines
                 542     ;**************************************************************************************
                 543     ;
                 544     ;
                 545     ;
                 546     ;Delay of 1us.
                 547     ;
                 548     ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                 549     ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                 550     ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                 551     ;
                 552     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 553     ;
                 554     ;Registers used s0
                 555     ;
0A8 0000B        556     delay_1us:              LD      s0, #delay_1us_constant
0A9 0C001        557     wait_1us:               SUB     s0, #0x01
0AA 354A9        558                             JUMP    nz, wait_1us
0AB 24000        559                             RET
                 560     ;
                 561     ;Delay of 40us.
                 562     ;
                 563     ;Registers used s0, s1
                 564     ;
0AC 00128        565     delay_40us:             LD      s1, #0x28               ;40 x 1us = 40us
0AD 360A8        566     wait_40us:              CALL    delay_1us
0AE 0C101        567                             SUB     s1, #0x01
0AF 354AD        568                             JUMP    nz, wait_40us
0B0 24000        569                             RET
                 570     ;
                 571     ;
                 572     ;Delay of 1ms.
                 573     ;
                 574     ;Registers used s0, s1, s2
                 575     ;
0B1 00219        576     delay_1ms:              LD      s2, #0x19               ;25 x 40us = 1ms
0B2 360AC        577     wait_1ms:               CALL    delay_40us
0B3 0C201        578                             SUB     s2, #0x01
0B4 354B2        579                             JUMP    nz, wait_1ms
0B5 24000        580                             RET
                 581     ;
                 582     ;Delay of 20ms.
                 583     ;
                 584     ;Delay of 20ms used during initialisation.
                 585     ;
                 586     ;Registers used s0, s1, s2, s3
                 587     ;
0B6 00314        588     delay_20ms:             LD      s3, #0x14               ;20 x 1ms = 20ms
0B7 360B1        589     wait_20ms:              CALL    delay_1ms
0B8 0C301        590                             SUB     s3, #0x01
0B9 354B7        591                             JUMP    nz, wait_20ms
0BA 24000        592                             RET
                 593     ;
                 594     ;Delay of approximately 1 second.
                 595     ;
                 596     ;Registers used s0, s1, s2, s3, s4
                 597     ;
0BB 00414        598     delay_1s:               LD      s4, #0x14               ;50 x 20ms = 1000ms
0BC 360B6        599     wait_1s:                CALL    delay_20ms
0BD 0C401        600                             SUB     s4, #0x01
0BE 354BC        601                             JUMP    nz, wait_1s
0BF 24000        602                             RET
                 603     ;
                 604     ;
                 605     ;
                 606     ;**************************************************************************************
                 607     ;Interrupt Service Routine (ISR)
                 608     ;**************************************************************************************
                 609     ;
                 610     ;Interrupts occur at a rate of 8KHz.
                 611     ;
                 612     ;Each interrupt is the fundamental timing trigger used to set the sample rate and
                 613     ;it is therefore use to set the D/A outputs by copying the values loadd in
                 614     ;scratch pad memory and outputting them to the D/A converter using the SPI bus.
                 615     ;
                 616     ;Because the SPI communication is in itself a predictable process, the sample rate
                 617     ;is preserved without sample jitter. All variable activities are left to the main
                 618     ;program.
                 619     ;
                 620     ;Each time PicoBlaze transmits a 32-bit command word to the D/A converter, the
                 621     ;D/A responds with the last command it was sent. So as the end of this service routine
                 622     ;the register set [s9,s8,s7,s6] will contain the command which has just been sent
                 623     ;for the setting of channel C.
                 624     ;
                 625     ;Set channel A
                 626     ;
0C0 00C00        627     isr:                    LD      sc, #0x00               ;channel A
0C1 10B08        628                             load      sb, chan_a_msb          ;12-bit value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0C2 10A00        629                             load      sa, chan_a_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0C3 36086        630                             CALL    set_dac
                 631     ;
                 632     ;Set channel B
                 633     ;
0C4 00C01        634                             LD      sc, #0x01               ;channel B
0C5 10B18        635                             load      sb, chan_b_msb          ;12-bit value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0C6 10A10        636                             load      sa, chan_b_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0C7 36086        637                             CALL    set_dac
                 638     ;
                 639     ;Set channel C
                 640     ;
0C8 00C02        641                             LD      sc, #0x02               ;channel C
0C9 10B28        642                             load      sb, chan_c_msb          ;12-bit value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0CA 10A20        643                             load      sa, chan_c_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0CB 36086        644                             CALL    set_dac
                 645     ;
                 646     ;Set channel A
                 647     ;
0CC 00C03        648                             LD      sc, #0x03               ;channel D
0CD 10B38        649                             load      sb, chan_d_msb          ;12-bit value
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0CE 10A30        650                             load      sa, chan_d_lsb
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0CF 36086        651                             CALL    set_dac
                 652     ;
0D0 00F00        653                             LD      sf, #0x00               ;clear flag
0D1 2C001        654                             RETIE
                 655     ;
                 656     ;
                 657     ;**************************************************************************************
                 658     ;Interrupt Vector
                 659     ;**************************************************************************************
                 660     ;
  003FF          661                             ORG     0x3ff
3FF 340C0        662                             JUMP    isr
                 663     ;
                 664     ;
                 665
