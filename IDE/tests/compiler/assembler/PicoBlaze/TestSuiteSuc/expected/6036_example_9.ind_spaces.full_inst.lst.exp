                   1     ; KCPSM3 Program - Implementation of the SHA-1 algorithm for use with the
                   2     ;                  DS2432 secure memory on the Spartan-3E Starter Kit.
                   3     ;
                   4     ; Ken Chapman - Xilinx Ltd
                   5     ;
                   6
                   7     ; Version v1.00 - 19th April 2006
                   8     device kcpsm6
                   9     ;
                  10     ; IMPORTANT - This design builds on the reference design called "PicoBlaze
                  11     ;             DS2432 communicator". It is highly recommend that you look at that
                  12     ;             design before proceeding with this one.
                  13     ;
                  14     ;
                  15     ; This program uses a 9600 baud UART connection to allow communication with the
                  16     ; 1-wire interface of the DS2432 memory device from Dallas Semiconductor.
                  17     ;
                  18     ; The program only supports a limited number of the DS2432 commands to focus on
                  19     ; those aspects which use the SHA-1 algorithm.
                  20     ;
                  21     ; Note that the code performing the SHA-1 algorithm interacts with the hardware of
                  22     ; this complete reference design. The hardware provides a 16 word (32-bit) buffer
                  23     ; combined used in the initialisation of the algorithm and subsequent computation
                  24     ; of the Wt words.
                  25     ;
                  26     ;
                  27     ; The DS2432 should be programmed with a 64-bit secret. The following constants
                  28     ; define the secret which will be used. Obviously this would be be changed in a
                  29     ; real application and further measures taken to prevent it easily being found.
                  30     ; The secret is 64-bits formed of 8 bytes. 'secret0' would be stored at address
                  31     ; 0080 of the DS2432 and 'secret7' at address 0087. The write buffer and load
                  32     ; first secret commands allow you to set any secret into the DS2432 device but
                  33     ; this program always uses the secret defined in these constants such that you can
                  34     ; experiment with secrets which do and do not match.
                  35     ;
                  36     ;
  00001           37     secret0                 EQU             0x01
  00023           38     secret1                 EQU             0x23
  00045           39     secret2                 EQU             0x45
  00067           40     secret3                 EQU             0x67
  00089           41     secret4                 EQU             0x89
  000AB           42     secret5                 EQU             0xab
  000CD           43     secret6                 EQU             0xcd
  000EF           44     secret7                 EQU             0xef
                  45     ;
                  46     ;
                  47     ; Bytes 4, 5 and 6 of the DS2432 scratch pad memory are used in the SHA-1 algorithm.
                  48     ; These should be set using the write scratchpad memory command before using the
                  49     ; read authenticated page command. HOWEVER, it is also important that you also use
                  50     ; the read scratchpad command BEFORE using the read authenticated page command. This
                  51     ; is because this program only copies the bytes 4, 5 and 6 during a read such that
                  52     ; they are can be used by the PicoBlaze SHA-1 algorithm. This limitation is deliberate
                  53     ; so that you can experiment and prove that the SHA-1 results will not match if
                  54     ; the same 'challenge' bytes are not used.
                  55     ;
                  56     ;
                  57     ;**************************************************************************************
                  58     ; Port definitions
                  59     ;**************************************************************************************
                  60     ;
                  61     ;
  00040           62     status_port             EQU             0x40                    ;UART status input
  00001           63     tx_half_full            EQU             0x01                    ;  Transmitter     half full - bit0
  00002           64     tx_full                 EQU             0x02                    ;    FIFO               full - bit1
  00004           65     rx_data_present         EQU             0x04                    ;  Receiver     data present - bit2
  00008           66     rx_half_full            EQU             0x08                    ;    FIFO          half full - bit3
  00010           67     rx_full                 EQU             0x10                    ;                   full - bit4
  00020           68     spare1                  EQU             0x20                    ;                  spare '0' - bit5
  00040           69     spare2                  EQU             0x40                    ;                  spare '0' - bit6
  00080           70     spare3                  EQU             0x80                    ;                  spare '0' - bit7
                  71     ;
  00080           72     uart_read_port          EQU             0x80                    ;UART Rx data input
                  73     ;
  00004           74     uart_write_port         EQU             0x04                    ;UART Tx data output
                  75     ;
                  76     ;
  000C0           77     ds_wire_in_port         EQU             0xc0                    ;Read signal from DS2432 device
  00008           78     ds_wire_out_port        EQU             0x08                    ;Drive signal to DS2432 device (open collector)
  00001           79     ds_wire                 EQU             0x01                    ;       Signal is bit0 in both cases
                  80     ;
                  81     ;
                  82     ;
                  83     ; The following ports access the 'Wt' word buffer. This buffer holds 16 words
                  84     ; of 32-bits organised as a 64-byte shift register. Hence each word is stored
                  85     ; by writing 4 bytes. As each byte is written, all bytes shift along such that
                  86     ; older Wt values can be read from consistent port addresses.
                  87     ;
  00010           88     w_word_write_port       EQU             0x10                    ;Write byte to Wt buffer
                  89     ;
  00008           90     wt_minus3_byte0_read_port EQU           0x08                    ;Read of Wt-3
  00009           91     wt_minus3_byte1_read_port EQU           0x09
  0000A           92     wt_minus3_byte2_read_port EQU           0x0a
  0000B           93     wt_minus3_byte3_read_port EQU           0x0b
                  94     ;
  0001C           95     wt_minus8_byte0_read_port EQU           0x1c                    ;Read of Wt-8
  0001D           96     wt_minus8_byte1_read_port EQU           0x1d
  0001E           97     wt_minus8_byte2_read_port EQU           0x1e
  0001F           98     wt_minus8_byte3_read_port EQU           0x1f
                  99     ;
  00034          100     wt_minus14_byte0_read_port EQU          0x34                    ;Read of Wt-14
  00035          101     wt_minus14_byte1_read_port EQU          0x35
  00036          102     wt_minus14_byte2_read_port EQU          0x36
  00037          103     wt_minus14_byte3_read_port EQU          0x37
                 104     ;
  0003C          105     wt_minus16_byte0_read_port EQU          0x3c                    ;Read of Wt-16
  0003D          106     wt_minus16_byte1_read_port EQU          0x3d
  0003E          107     wt_minus16_byte2_read_port EQU          0x3e
  0003F          108     wt_minus16_byte3_read_port EQU          0x3f
                 109     ;
                 110     ;
                 111     ;**************************************************************************************
                 112     ; Special Register usage
                 113     ;**************************************************************************************
                 114     ;
  0000F          115     uart_data               REG             sf                      ;used to pass data to and from the UART
                 116     ;
                 117     ;
                 118     ;**************************************************************************************
                 119     ; Scratch Pad Memory Locations
                 120     ;**************************************************************************************
                 121     ;
                 122     ; Scratch pad memory provides 64 bytes in the address range 00 to 3F hex.
                 123     ;
                 124     ;
                 125     ; Locations for device family code, serial number and 8-bit CRC value
                 126     ;
  00000          127     family_code             EQU             0x00
  00001          128     serial_number0          EQU             0x01                    ;48-bit serial number LS-Byte first
  00002          129     serial_number1          EQU             0x02
  00003          130     serial_number2          EQU             0x03
  00004          131     serial_number3          EQU             0x04
  00005          132     serial_number4          EQU             0x05
  00006          133     serial_number5          EQU             0x06
  00007          134     read_rom_crc            EQU             0x07                    ;8-bit CRC
                 135     ;
                 136     ;
                 137     ; Locations for variables used in SHA-1 algorithm.
                 138     ; Each variable is 32-bits and requires 4 bytes to store.
                 139     ; '0' indicates the least significant byte and '3' the most significant byte.
                 140     ;
                 141     ; Note that the concatenation of 'A', 'B', 'C', 'D' and 'E' will be the 160-bit MAC.
                 142     ;
  00008          143     var_a0                  EQU             0x08                    ;Variable 'A'
  00009          144     var_a1                  EQU             0x09
  0000A          145     var_a2                  EQU             0x0a
  0000B          146     var_a3                  EQU             0x0b
                 147     ;
  0000C          148     var_b0                  EQU             0x0c                    ;Variable 'B'
  0000D          149     var_b1                  EQU             0x0d
  0000E          150     var_b2                  EQU             0x0e
  0000F          151     var_b3                  EQU             0x0f
                 152     ;
  00010          153     var_c0                  EQU             0x10                    ;Variable 'C'
  00011          154     var_c1                  EQU             0x11
  00012          155     var_c2                  EQU             0x12
  00013          156     var_c3                  EQU             0x13
                 157     ;
  00014          158     var_d0                  EQU             0x14                    ;Variable 'D'
  00015          159     var_d1                  EQU             0x15
  00016          160     var_d2                  EQU             0x16
  00017          161     var_d3                  EQU             0x17
                 162     ;
  00018          163     var_e0                  EQU             0x18                    ;Variable 'E'
  00019          164     var_e1                  EQU             0x19
  0001A          165     var_e2                  EQU             0x1a
  0001B          166     var_e3                  EQU             0x1b
                 167     ;
                 168     ;
                 169     ; Copy of data in the scratchpad memory of the DS2432.
                 170     ; This is only updated by the read scratchpad memory command.
                 171     ; '0' indicates the data in the least significant location.
                 172     ;
  0001C          173     scratchpad0             EQU             0x1c
  0001D          174     scratchpad1             EQU             0x1d
  0001E          175     scratchpad2             EQU             0x1e
  0001F          176     scratchpad3             EQU             0x1f
  00020          177     scratchpad4             EQU             0x20
  00021          178     scratchpad5             EQU             0x21
  00022          179     scratchpad6             EQU             0x22
  00023          180     scratchpad7             EQU             0x23
                 181     ;
                 182     ;
                 183     ;
                 184     ;**************************************************************************************
                 185     ; Useful data constants
                 186     ;**************************************************************************************
                 187     ;
                 188     ; Constant to define a software delay of 1us. This must be adjusted to reflect the
                 189     ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 190     ; calculation highly predictable. The '6' in the following equation even allows for
                 191     ; 'CALL delay_1us' instruction in the initiating code.
                 192     ;
                 193     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 194     ;
                 195     ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 196     ; For clock rates below 10MHz the value of 1 must be used and the operation will
                 197     ; become lower than intended.
                 198     ;
  0000B          199     delay_1us_constant      EQU             0x0b
                 200     ;
                 201     ;
                 202     ;
                 203     ;ASCII table
                 204     ;
  00061          205     character_a             EQU             0x61
  00062          206     character_b             EQU             0x62
  00063          207     character_c             EQU             0x63
  00064          208     character_d             EQU             0x64
  00065          209     character_e             EQU             0x65
  00066          210     character_f             EQU             0x66
  00067          211     character_g             EQU             0x67
  00068          212     character_h             EQU             0x68
  00069          213     character_i             EQU             0x69
  0006A          214     character_j             EQU             0x6a
  0006B          215     character_k             EQU             0x6b
  0006C          216     character_l             EQU             0x6c
  0006D          217     character_m             EQU             0x6d
  0006E          218     character_n             EQU             0x6e
  0006F          219     character_o             EQU             0x6f
  00070          220     character_p             EQU             0x70
  00071          221     character_q             EQU             0x71
  00072          222     character_r             EQU             0x72
  00073          223     character_s             EQU             0x73
  00074          224     character_t             EQU             0x74
  00075          225     character_u             EQU             0x75
  00076          226     character_v             EQU             0x76
  00077          227     character_w             EQU             0x77
  00078          228     character_x             EQU             0x78
  00079          229     character_y             EQU             0x79
  0007A          230     character_z             EQU             0x7a
  00041          231     _character_a            EQU             0x41
  00042          232     _character_b            EQU             0x42
  00043          233     _character_c            EQU             0x43
  00044          234     _character_d            EQU             0x44
  00045          235     _character_e            EQU             0x45
  00046          236     _character_f            EQU             0x46
  00047          237     _character_g            EQU             0x47
  00048          238     _character_h            EQU             0x48
  00049          239     _character_i            EQU             0x49
  0004A          240     _character_j            EQU             0x4a
  0004B          241     _character_k            EQU             0x4b
  0004C          242     _character_l            EQU             0x4c
  0004D          243     _character_m            EQU             0x4d
  0004E          244     _character_n            EQU             0x4e
  0004F          245     _character_o            EQU             0x4f
  00050          246     _character_p            EQU             0x50
  00051          247     _character_q            EQU             0x51
  00052          248     _character_r            EQU             0x52
  00053          249     _character_s            EQU             0x53
  00054          250     _character_t            EQU             0x54
  00055          251     _character_u            EQU             0x55
  00056          252     _character_v            EQU             0x56
  00057          253     _character_w            EQU             0x57
  00058          254     _character_x            EQU             0x58
  00059          255     _character_y            EQU             0x59
  0005A          256     _character_z            EQU             0x5a
  00030          257     character_0             EQU             0x30
  00031          258     character_1             EQU             0x31
  00032          259     character_2             EQU             0x32
  00033          260     character_3             EQU             0x33
  00034          261     character_4             EQU             0x34
  00035          262     character_5             EQU             0x35
  00036          263     character_6             EQU             0x36
  00037          264     character_7             EQU             0x37
  00038          265     character_8             EQU             0x38
  00039          266     character_9             EQU             0x39
  0003A          267     character_colon         EQU             0x3a
  0002E          268     character_fullstop      EQU             0x2e
  0003B          269     character_semi_colon    EQU             0x3b
  0002D          270     character_minus         EQU             0x2d
  0002B          271     character_plus          EQU             0x2b
  0002C          272     character_comma         EQU             0x2c
  0003C          273     character_less_than     EQU             0x3c                    ;'<'
  0003E          274     character_greater_than  EQU             0x3e                    ;'>'
  00028          275     character_open          EQU             0x28                    ;'('
  00029          276     character_close         EQU             0x29                    ;')'
  0002F          277     character_divide        EQU             0x2f                    ;'/'
  0003D          278     character_equals        EQU             0x3d
  00020          279     character_space         EQU             0x20
  0000D          280     character_cr            EQU             0x0d                    ;carriage return
  0000A          281     character_lf            EQU             0x0a                    ;line feed
  0003F          282     character_question      EQU             0x3f                    ;'?'
  00024          283     character_dollar        EQU             0x24
  00021          284     character_exclaim       EQU             0x21                    ;'!'
  00008          285     character_bs            EQU             0x08                    ;Back Space command character
  00011          286     character_xon           EQU             0x11                    ;Flow control ON
  00013          287     character_xoff          EQU             0x13                    ;Flow control OFF
                 288     ;
                 289     ;
                 290     ;**************************************************************************************
                 291     ; Initialise the system and welcome message
                 292     ;**************************************************************************************
                 293     ;
000 20230        294     cold_start:             CALL            ds_wire_init            ;Ensure DS_wire is not driven (pulled High)
001 2029A        295                             CALL            delay_1s                ;Allow everything to settle!
002 2030A        296     welcome_start:          CALL            send_welcome            ;start up message and version number
                 297     ;
                 298     ;
                 299     ;**************************************************************************************
                 300     ; Reset Main menu and command selection
                 301     ;**************************************************************************************
                 302     ;
                 303     ; The main program allows you to use four of the DS2432 memory and SHA function
                 304     ; commands. A simple menu is displayed and you are guided to enter more information
                 305     ; when required. All the communication and protocol required to get the DS2432 ready
                 306     ; to receive memory and SHA function commands has been automated although information
                 307     ; is displayed to indicate the procedures being executed.
                 308     ;
                 309     ; Before any memory and function commands are available a master reset and read ROM
                 310     ; command must be issued.
                 311     ;
003 202EC        312     warm_start:             CALL            send_cr
004 202EC        313                             CALL            send_cr
005 20233        314                             CALL            ds_init_regular_mode    ;master reset
006 3A003        315                             JUMP            c, warm_start           ;repeat reset if no presence pulse detected
007 2001D        316                             CALL            read_rom_command        ;read ROM command and display results
                 317     ;
                 318     ; After a valid ROM command the DS2432 specific memory commands and SHA-1
                 319     ; functions become accessible. This program assumes that the ROM command did
                 320     ; 'Pass' so you will need to check yourself. If this program automatically
                 321     ; reset the DS2432 and tried again and there was a fault it would just cause
                 322     ; the display to roll continuously and not be very informative!
                 323     ;
                 324     ; Each of the DS2432 commands selected from the menu will require the master reset
                 325     ; and read ROM command to be repeated before being able to proceed with the next
                 326     ; memory or SHA-1 function. This is automated by the program.
                 327     ;
                 328     ;
008 20344        329     ds2432_menu:            CALL            send_ds2432_menu        ;Menu and command selection
009 202EC        330                             CALL            send_cr
                 331     ;
00A 202EC        332     ds2432_prompt:          CALL            send_cr                 ;prompt for user input
00B 202EC        333                             CALL            send_cr
00C 01F3E        334                             LOAD            uart_data, #character_greater_than ;prompt for input
00D 202A5        335                             CALL            send_to_uart
00E 202E1        336                             CALL            read_upper_case
00F 1D031        337                             COMPARE         s0, #character_1        ;test for commands and execute as required
010 32053        338                             JUMP            z, write_scratchpad_command
011 1D032        339                             COMPARE         s0, #character_2
012 32079        340                             JUMP            z, read_scratchpad_command
013 1D033        341                             COMPARE         s0, #character_3
014 32040        342                             JUMP            z, load_first_secret_command
015 1D034        343                             COMPARE         s0, #character_4
016 3209D        344                             JUMP            z, read_auth_page_command
017 202EC        345                             CALL            send_cr                 ;no valid command input
018 01F3F        346                             LOAD            uart_data, #character_question ;display ???
019 202A5        347                             CALL            send_to_uart
01A 202A5        348                             CALL            send_to_uart
01B 202A5        349                             CALL            send_to_uart
01C 2200A        350                             JUMP            ds2432_prompt           ;Try again!
                 351     ;
                 352     ;
                 353     ;
                 354     ;
                 355     ;**************************************************************************************
                 356     ; DS2432 Read ROM Command.
                 357     ;**************************************************************************************
                 358     ;
                 359     ; The read ROM command (33 hex) allows the 8-bit family code, 48-bit unique serial
                 360     ; number and 8-bit CRC to be read from the DS2432 device.
                 361     ;
                 362     ; This routine reads the values and places them in KCPSM3 scratch pad memory
                 363     ; locations for future reference. These locations should be defined with constants
                 364     ; as follows and MUST be in consecutive ascending locations.
                 365     ;
                 366     ;  family_code
                 367     ;     Location to store family code which should be 33 hex
                 368     ;  serial_number0 to serial_number5
                 369     ;     6 bytes to hold 48-bit serial number (LS-byte first).
                 370     ;  read_ROM_CRC
                 371     ;     8-bit CRC value for the above data.
                 372     ;
                 373     ;
                 374     ; The routine also displays the values read and performs a verification of the
                 375     ; 8-bit CRC displaying a 'Pass' or 'Fail' message as appropriate.
                 376     ;
01D 01333        377     read_rom_command:       LOAD            s3, #0x33               ;Read ROM Command
01E 2024E        378                             CALL            write_byte_slow         ;transmit command
01F 01500        379                             LOAD            s5, #family_code        ;memory pointer
020 2026F        380     read_rom_loop:          CALL            read_byte_slow          ;read response into s3
021 2E350        381                             STORE           s3, @s5                 ;store value
022 1D507        382                             COMPARE         s5, #read_rom_crc       ;8-bytes to read
023 32026        383                             JUMP            z, display_rom
024 11501        384                             ADD             s5, #0x01
025 22020        385                             JUMP            read_rom_loop
026 202EC        386     display_rom:            CALL            send_cr
027 203D6        387                             CALL            send_code               ;'code=' to display family code
028 0B000        388                             FETCH           s0, family_code
029 202C2        389                             CALL            send_hex_byte
02A 202EC        390                             CALL            send_cr
02B 203DC        391                             CALL            send_sn                 ;'s/n=' to display family code
02C 01506        392                             LOAD            s5, #serial_number5     ;memory pointer starting MS-byte first
02D 0A050        393     disp_serial_loop:       FETCH           s0, @s5
02E 202C2        394                             CALL            send_hex_byte
02F 1D501        395                             COMPARE         s5, #serial_number0
030 32033        396                             JUMP            z, end_serial
031 19501        397                             SUB             s5, #0x01
032 2202D        398                             JUMP            disp_serial_loop
033 202EC        399     end_serial:             CALL            send_cr
034 203E2        400                             CALL            send_crc                ;'CRC=' to display CRC value
035 0B007        401                             FETCH           s0, read_rom_crc
036 202C2        402                             CALL            send_hex_byte
037 202EC        403                             CALL            send_cr
038 201F1        404                             CALL            compute_crc8            ;compute CRC value in s0
039 0B107        405                             FETCH           s1, read_rom_crc        ;compare with received value
03A 1C010        406                             COMPARE         s0, s1
03B 3603E        407                             JUMP            nz, crc8_fail
03C 203AD        408                             CALL            send_pass
03D 25000        409                             RETURN
03E 203B4        410     crc8_fail:              CALL            send_fail
03F 25000        411                             RETURN
                 412     ;
                 413     ;
                 414     ;
                 415     ;**************************************************************************************
                 416     ; DS2432 Load First Secret Command.
                 417     ;**************************************************************************************
                 418     ;
                 419     ; This command will only be valid if the write scratchpad memory command has previously
                 420     ; been used to define the new secret to be stored at address 0080.
                 421     ;
                 422     ; The Load First Secret Command (5A hex) will only copy the scratchpad contents into                           ;
                 423     ; the EEPROM array of the DS2432 if the address was correctly specified in the
                 424     ; write scratchpad command. This routine will assume that the address specified
                 425     ; was 0080. If everything is OK with the programming of the secret, the DS2432 responds
                 426     ; with 'AA' hex after the command and this routine will report 'Pass'. You can further
                 427     ; check using a read scratchpad command and look to see if E/S has changed from '5F'
                 428     ; to 'DF' which indicates the successful write.
                 429     ;
                 430     ; Note that this program defines the secret to be used by the PicoBlaze SHA-1 algorithm
                 431     ; in the constants 'secret0' through to 'secret7'. Only if you program the DS2432
                 432     ; with a matching secret will the read authenticated message command result in a
                 433     ; 'Pass' being reported for the MAC. This Load First Secret Command routine deliberately
                 434     ; does not update the secret used by the PicoBlaze SHA-1 algorithm so that you can
                 435     ; prove that only a DS2432 with the matching secret will generate matching MAC
                 436     ; responses.
                 437     ;
                 438     ;
                 439     ;
040 0135A        440     load_first_secret_command: LOAD         s3, #0x5a               ;Load First Secret Command
041 2024E        441                             CALL            write_byte_slow         ;transmit command
042 01380        442                             LOAD            s3, #0x80               ;TA1 value for secret = 80 hex
043 2024E        443                             CALL            write_byte_slow
044 01300        444                             LOAD            s3, #0x00               ;TA2 value for secret = 00 hex
045 2024E        445                             CALL            write_byte_slow
046 0135F        446                             LOAD            s3, #0x5f               ;E/S value before writing = 5F hex
047 2024E        447                             CALL            write_byte_slow
048 20295        448                             CALL            delay_20ms              ;write takes place in 10ms
049 202EC        449                             CALL            send_cr
04A 20391        450                             CALL            send_secret
04B 202EF        451                             CALL            send_space
04C 2026F        452                             CALL            read_byte_slow          ;read data into s3
04D 1D3AA        453                             COMPARE         s3, #0xaa               ;test response
04E 32051        454                             JUMP            z, secret_pass
04F 203B4        455                             CALL            send_fail
050 22003        456                             JUMP            warm_start
051 203AD        457     secret_pass:            CALL            send_pass
052 22003        458                             JUMP            warm_start
                 459     ;
                 460     ;
                 461     ;**************************************************************************************
                 462     ; DS2432 Write Scratchpad Memory Command.
                 463     ;**************************************************************************************
                 464     ;
                 465     ; The write scratchpad memory command (0F hex) allows 8-bytes of data to be written
                 466     ; together with a target address for final storage in the main memory map. The
                 467     ; DS2432 scratch pad is also used to define a 3 byte 'challenge' used in the
                 468     ; SHA-1 algorithm.
                 469     ;
                 470     ; The DS2432 provides an initial confirmation of the write by returning a 16-bit CRC
                 471     ; value which KCPSM3 tests. The CRC is computed based on the command, address and
                 472     ; data transmitted (11 bytes). PicoBlaze also computes the CRC and and tests this
                 473     ; against the value received from the DS2432.
                 474     ;
                 475     ; This routine prompts the user to enter the 16-bit target address is to be loaded
                 476     ; into the target address registers TA2 and TA1 in the DS2432 device. Note that only
                 477     ; address values below 0090 hex are valid. If the address is too high, then the
                 478     ; DS2432 aborts the command and this routine will too.
                 479     ;
                 480     ; Also note that the address will be forced internally to the DS2432 to match an
                 481     ; 8-byte boundary address in which the least significant 3-bits are reset to '000'
                 482     ; regardless of the address provided. The CRC still reflects the transmitted address.
                 483     ;
                 484     ; After providing a valid address, the routine then prompts the user to enter
                 485     ; 8 bytes of data which are written to the DS2432.
                 486     ;
                 487     ;
                 488     ;
053 2020B        489     write_scratchpad_command: CALL          clear_crc16             ;prepare CRC registers [sE,sD]
054 0130F        490                             LOAD            s3, #0x0f               ;write scratchpad memory Command
055 2024E        491                             CALL            write_byte_slow         ;transmit command
056 2020E        492                             CALL            compute_crc16           ;compute CRC for value in 's3'
057 203BD        493     wsc_addr_loop:          CALL            send_address            ;obtain 16-bit address 0000 to FFFF in [s5,s4]
058 202E6        494                             CALL            obtain_8bits
059 3A057        495                             JUMP            c, wsc_addr_loop        ;bad input address
05A 00500        496                             LOAD            s5, s0
05B 202E6        497                             CALL            obtain_8bits
05C 3A057        498                             JUMP            c, wsc_addr_loop        ;bad input address
05D 00400        499                             LOAD            s4, s0
05E 00340        500                             LOAD            s3, s4                  ;transmit target address TA1 (LS-Byte)
05F 2024E        501                             CALL            write_byte_slow
060 2020E        502                             CALL            compute_crc16           ;compute CRC for value in 's3'
061 00350        503                             LOAD            s3, s5                  ;transmit target address TA2 (MS-Byte)
062 2024E        504                             CALL            write_byte_slow
063 2020E        505                             CALL            compute_crc16           ;compute CRC for value in 's3'
064 1D500        506                             COMPARE         s5, #0x00               ;check address less than 0090 hex
065 36003        507                             JUMP            nz, warm_start          ;DS2432 aborts command and so do we!
066 1D490        508                             COMPARE         s4, #0x90               ;no need to read data bytes.
067 3E003        509                             JUMP            nc, warm_start
068 01400        510                             LOAD            s4, #0x00               ;initialise byte counter
069 203C8        511     wsc_data_loop:          CALL            send_data               ;obtain a byte of data
06A 00F40        512                             LOAD            uart_data, s4           ;display which byte requested
06B 11F30        513                             ADD             uart_data, #character_0 ;convert to ASCII
06C 202A5        514                             CALL            send_to_uart
06D 203C5        515                             CALL            send_equals
06E 202E6        516                             CALL            obtain_8bits
06F 3A069        517                             JUMP            c, wsc_data_loop        ;bad input data
070 00300        518                             LOAD            s3, s0                  ;transmit byte
071 2024E        519                             CALL            write_byte_slow
072 2020E        520                             CALL            compute_crc16           ;compute CRC for value in 's3'
073 11401        521                             ADD             s4, #0x01               ;count bytes
074 1D408        522                             COMPARE         s4, #0x08
075 36069        523                             JUMP            nz, wsc_data_loop
076 202EC        524                             CALL            send_cr
077 2021C        525                             CALL            read_send_test_crc16    ;read, display and test CRC value
078 22003        526                             JUMP            warm_start
                 527     ;
                 528     ;
                 529     ;
                 530     ;**************************************************************************************
                 531     ; DS2432 Read Scratchpad Memory Command.
                 532     ;**************************************************************************************
                 533     ;
                 534     ; The read scratchpad memory command (AA hex) allows the 8-bytes of data previously
                 535     ; to be written into the scratchpad memory to be read back for verification together with
                 536     ; the target address, a transfer status register (E/S) and a 16-bit CRC value.
                 537     ;
                 538     ; The 16-bit CRC is formed of the command byte, address TA1 and TA2, E/S byte and 8 data
                 539     ; bytes as transmitted (12 bytes). These may not be the same as the values provided
                 540     ; during a previous write to scratchpad memory. PicoBlaze also computes the CRC and
                 541     ; and tests this against the value received from the DS2432.
                 542     ;
                 543     ; The 8 bytes of data are also copied to PicoBlaze memory at locations defined by the
                 544     ; constants 'scratchpad0' to 'scratchpad7'. Three bytes are used as a 'challenge'
                 545     ; by the SHA-1 algorithm.
                 546     ;
                 547     ;
                 548     ;
079 2020B        549     read_scratchpad_command: CALL           clear_crc16             ;prepare CRC registers [sE,sD]
07A 013AA        550                             LOAD            s3, #0xaa               ;read scratchpad memory Command
07B 2024E        551                             CALL            write_byte_slow         ;transmit command
07C 2020E        552                             CALL            compute_crc16           ;compute CRC for value in 's3'
07D 203BD        553                             CALL            send_address            ;display 'Address='
07E 2026F        554                             CALL            read_byte_slow          ;read address into [s5,s4]
07F 2020E        555                             CALL            compute_crc16           ;compute CRC for value in 's3'
080 00430        556                             LOAD            s4, s3
081 2026F        557                             CALL            read_byte_slow
082 2020E        558                             CALL            compute_crc16           ;compute CRC for value in 's3'
083 00530        559                             LOAD            s5, s3
084 00050        560                             LOAD            s0, s5                  ;display address
085 202C2        561                             CALL            send_hex_byte
086 00040        562                             LOAD            s0, s4
087 202C2        563                             CALL            send_hex_byte
088 203CE        564                             CALL            send_es                 ;display 'E/S='
089 2026F        565                             CALL            read_byte_slow          ;read E/S register
08A 2020E        566                             CALL            compute_crc16           ;compute CRC for value in 's3'
08B 00030        567                             LOAD            s0, s3                  ;display value
08C 202C2        568                             CALL            send_hex_byte
08D 203C8        569                             CALL            send_data               ;display 'Data='
08E 203C5        570                             CALL            send_equals
08F 0141C        571                             LOAD            s4, #scratchpad0        ;pointer to memory and byte counter
090 202EF        572     rsc_loop:               CALL            send_space
091 2026F        573                             CALL            read_byte_slow          ;read data byte
092 2020E        574                             CALL            compute_crc16           ;compute CRC for value in 's3'
093 2E340        575                             STORE           s3, @s4                 ;store value in memory
094 00030        576                             LOAD            s0, s3                  ;display value
095 202C2        577                             CALL            send_hex_byte
096 1D423        578                             COMPARE         s4, #scratchpad7        ;count bytes
097 3209A        579                             JUMP            z, end_rsc_data_loop
098 11401        580                             ADD             s4, #0x01
099 22090        581                             JUMP            rsc_loop
09A 202EC        582     end_rsc_data_loop:      CALL            send_cr
09B 2021C        583                             CALL            read_send_test_crc16    ;read, display and test CRC value
09C 22003        584                             JUMP            warm_start
                 585     ;
                 586     ;
                 587     ;
                 588     ;
                 589     ;
                 590     ;**************************************************************************************
                 591     ; DS2432 Read Authenticated Page Command.
                 592     ;**************************************************************************************
                 593     ;
                 594     ; The read authenticated page command (A5 hex) allows the 8-byte secret to be tested
                 595     ; without it actually being read (which would obviously give away the secret!).
                 596     ;
                 597     ; This routine has been written to work with page 0 but could easily be changed and
                 598     ; is documented below. During the first part of the command, the 32 bytes
                 599     ; contained in the page are read back from the DS2432 and these are used in
                 600     ; the preparation of the table required for the for SHA-1 algorithm. Other values
                 601     ; stored in the table are the secret, serial number of the DS2432, family code, some
                 602     ; constants, 4-bits of the page address and a 3 byte 'challenge' currently set into
                 603     ; the DS2432 scratchpad memory.
                 604     ;
                 605     ; NOTE - The read scratchpad command must be executed before this routine in order
                 606     ; that the 3 byte 'challenge' of scratchpad memory is known to PicoBlaze.
                 607     ;
                 608     ; During this command, two 16-bit CRC values are generated which PicoBlaze also
                 609     ; computes and tests. The first is formed of the command byte, address TA1 and TA2,
                 610     ; all the bytes of the page read and an 'FF' byte. The second is formed of the 20
                 611     ; bytes of the 160-but message authentication code (MAC).
                 612     ;
                 613     ;
                 614     ; Preparing the table.
                 615     ;
                 616     ; The table is stored in the external 'Wt' buffer and must first be initialised with the
                 617     ; 16 'M' words (32-bit words each requiring 4 bytes). This is achieved by shifting in
                 618     ; each word in sequence. Storing each word most significant byte first is a natural
                 619     ; fit with the reading of the page data from the DS2432 and the way each 'M' word
                 620     ; is organised. Notice how this causes least significant bytes to be swapped with most
                 621     ; significant bytes!
                 622     ;
                 623     ;          [31:24]      [23:16]      [15:8]       [7:0]
                 624     ;
                 625     ;   M0 = [secret0    , secret1    , secret2    , secret3    ]
                 626     ;   M1 = [page_data0 , page_data1 , page_data2 , page_data3 ]
                 627     ;   M2 = [page_data4 , page_data5 , page_data6 , page_data7 ]
                 628     ;   M3 = [page_data8 , page_data9 , page_data10, page_data11]
                 629     ;   M4 = [page_data12, page_data13, page_data14, page_data15]
                 630     ;   M5 = [page_data16, page_data17, page_data18, page_data19]
                 631     ;   M6 = [page_data20, page_data21, page_data22, page_data23]
                 632     ;   M7 = [page_data24, page_data25, page_data26, page_data27]
                 633     ;   M8 = [page_data28, page_data29, page_data30, page_data31]
                 634     ;   M9 = [   FF      ,    FF      ,    FF      ,    FF      ]
                 635     ;  M10 = [   40      ,    33      , serial_num0, serial_num1]
                 636     ;  M11 = [serial_num2, serial_num3, serial_num4, serial_num5]
                 637     ;  M12 = [secret4    , secret5    , secret6    , secret7    ]
                 638     ;  M13 = [scratchpad4, scratchpad5, scratchpad6,    80      ]
                 639     ;  M14 = [   00      ,    00      ,    00      ,    00      ]
                 640     ;  M15 = [   00      ,    00      ,    01      ,    B8      ]
                 641     ;
                 642     ; In M10, the '33' is the family code and the '40' is made up of a constant bit
                 643     ; pattern '0100' and then bits [8:5] of the page address. This gives 4 possible values
                 644     ; for this byte during a Read Authenticated Page Command, but this routine is currently
                 645     ; fixed to work with page 0 only.
                 646     ;        40 - page 0
                 647     ;        41 - page 1
                 648     ;        42 - page 2
                 649     ;        43 - page 3
                 650     ;
                 651     ; M13 contains the 3 byte challenge from the scratch pad memory. This assumes that a
                 652     ; read scratchpad command has previously been used and the bytes held in the DS2432
                 653     ; scratchpad match those held in the PicoBlaze memory.
                 654     ;
                 655     ;
                 656     ; The 160-bit Message Authentication Code (MAC) is computed from the table using the SHA-1
                 657     ; algorithm. This algorithm actually results in 5 variables 'A', 'B', 'C', 'D' and 'E'
                 658     ; which are 32-bit values each formed of 4 bytes. The MAC is the concatenation of
                 659     ; the variables. To match the same order in which the Read Authenticated Page Command
                 660     ; sends the MAC, the variables must be read in the order 'E', 'D', 'C', 'B' and 'A' and
                 661     ; with the least significant byte of each variable first.
                 662     ;
                 663     ;
                 664     ;
                 665     ;
                 666     ;
09D 01001        667     read_auth_page_command: LOAD            s0, #secret0            ;store M0 (secret 0, 1, 2 and 3) in Wt buffer.
09E 2D010        668                             OUTPUT          s0, w_word_write_port
09F 01023        669                             LOAD            s0, #secret1
0A0 2D010        670                             OUTPUT          s0, w_word_write_port
0A1 01045        671                             LOAD            s0, #secret2
0A2 2D010        672                             OUTPUT          s0, w_word_write_port
0A3 01067        673                             LOAD            s0, #secret3
0A4 2D010        674                             OUTPUT          s0, w_word_write_port
                 675     ;
                 676     ;Start of DS2432 command
                 677     ;
0A5 2020B        678                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
0A6 013A5        679                             LOAD            s3, #0xa5               ;read authenticated page command
0A7 2024E        680                             CALL            write_byte_slow         ;transmit command
0A8 2020E        681                             CALL            compute_crc16           ;compute CRC for value in 's3'
0A9 01500        682                             LOAD            s5, #0x00               ;set address for page 0
0AA 01400        683                             LOAD            s4, #0x00               ;  [TA2,TA1]=0000 hex
0AB 00340        684                             LOAD            s3, s4                  ;transmit TA1
0AC 2024E        685                             CALL            write_byte_slow
0AD 2020E        686                             CALL            compute_crc16           ;compute CRC for value in 's3'
0AE 00350        687                             LOAD            s3, s5                  ;transmit TA2
0AF 2024E        688                             CALL            write_byte_slow
0B0 2020E        689                             CALL            compute_crc16           ;compute CRC for value in 's3'
                 690     ;
                 691     ;Read 32-bytes of data associated with page 0
                 692     ;Store these as M1 through to M8
                 693     ;
0B1 202EC        694     rapc_line_loop:         CALL            send_cr
0B2 00050        695                             LOAD            s0, s5                  ;display 16-bit address
0B3 202C2        696                             CALL            send_hex_byte
0B4 00040        697                             LOAD            s0, s4
0B5 202C2        698                             CALL            send_hex_byte
0B6 202EF        699                             CALL            send_space
0B7 202EF        700                             CALL            send_space
0B8 202EF        701     rapc_data_loop:         CALL            send_space
0B9 2026F        702                             CALL            read_byte_slow          ;read data into s3
0BA 2020E        703                             CALL            compute_crc16           ;compute CRC for value in 's3'
0BB 2D310        704                             OUTPUT          s3, w_word_write_port   ;store as 'M' word
0BC 00030        705                             LOAD            s0, s3                  ;display byte
0BD 202C2        706                             CALL            send_hex_byte
0BE 11401        707                             ADD             s4, #0x01               ;increment address
0BF 13500        708                             ADDCY           s5, #0x00
0C0 0D407        709                             TEST            s4, #0x07               ;test for 8-byte boundary
0C1 360B8        710                             JUMP            nz, rapc_data_loop
0C2 1D420        711                             COMPARE         s4, #0x20               ;test for last address
0C3 360B1        712                             JUMP            nz, rapc_line_loop
0C4 202EC        713                             CALL            send_cr
                 714     ;
                 715     ;Read one byte that should be value FF hex
                 716     ;
0C5 2026F        717                             CALL            read_byte_slow          ;read data into s3
0C6 2020E        718                             CALL            compute_crc16           ;compute CRC for value in 's3'
0C7 00030        719                             LOAD            s0, s3                  ;display byte
0C8 202C2        720                             CALL            send_hex_byte
0C9 202EC        721                             CALL            send_cr
0CA 2021C        722                             CALL            read_send_test_crc16    ;read, display and test CRC value
                 723     ;
                 724     ;Complete table by stroring M9 through to M15
                 725     ;
0CB 010FF        726                             LOAD            s0, #0xff               ;W9 = FF FF FF FF
0CC 01104        727                             LOAD            s1, #0x04
0CD 2D010        728     store_w9:               OUTPUT          s0, w_word_write_port
0CE 19101        729                             SUB             s1, #0x01
0CF 360CD        730                             JUMP            nz, store_w9
                 731     ;
0D0 01040        732                             LOAD            s0, #0x40               ;W10 begins with 40 for page 0
0D1 2D010        733                             OUTPUT          s0, w_word_write_port
                 734     ;
                 735     ;W10 ends with family code and serial number 0 and 1.
                 736     ;W11 is formed of serial number 2, 3, 4 and 5.
                 737     ;All of this information is in PicoBlaze memory having been read by the
                 738     ;read ROM command.
                 739     ;
0D2 01100        740                             LOAD            s1, #family_code        ;pointer to memory
0D3 01207        741                             LOAD            s2, #0x07               ;7 bytes to read and store
0D4 0A010        742     next_m10_m11:           FETCH           s0, @s1
0D5 2D010        743                             OUTPUT          s0, w_word_write_port
0D6 11101        744                             ADD             s1, #0x01               ;increment pointer
0D7 19201        745                             SUB             s2, #0x01
0D8 360D4        746                             JUMP            nz, next_m10_m11
                 747     ;
0D9 01089        748                             LOAD            s0, #secret4            ;store M12 (secret 4, 5, 6 and 7) in Wt buffer
0DA 2D010        749                             OUTPUT          s0, w_word_write_port
0DB 010AB        750                             LOAD            s0, #secret5
0DC 2D010        751                             OUTPUT          s0, w_word_write_port
0DD 010CD        752                             LOAD            s0, #secret6
0DE 2D010        753                             OUTPUT          s0, w_word_write_port
0DF 010EF        754                             LOAD            s0, #secret7
0E0 2D010        755                             OUTPUT          s0, w_word_write_port
                 756     ;
0E1 0B020        757                             FETCH           s0, scratchpad4         ;M13 uses scratchpad 4, 5, and 6 and '80' hex
0E2 2D010        758                             OUTPUT          s0, w_word_write_port
0E3 0B021        759                             FETCH           s0, scratchpad5
0E4 2D010        760                             OUTPUT          s0, w_word_write_port
0E5 0B022        761                             FETCH           s0, scratchpad6
0E6 2D010        762                             OUTPUT          s0, w_word_write_port
0E7 01080        763                             LOAD            s0, #0x80
0E8 2D010        764                             OUTPUT          s0, w_word_write_port
                 765     ;
0E9 01000        766                             LOAD            s0, #0x00               ;W14 = 00 00 00 00   W15 = 00 00 01 B8
0EA 01106        767                             LOAD            s1, #0x06
0EB 2D010        768     store_w14_w15:          OUTPUT          s0, w_word_write_port
0EC 19101        769                             SUB             s1, #0x01
0ED 360EB        770                             JUMP            nz, store_w14_w15
0EE 01001        771                             LOAD            s0, #0x01
0EF 2D010        772                             OUTPUT          s0, w_word_write_port
0F0 010B8        773                             LOAD            s0, #0xb8
0F1 2D010        774                             OUTPUT          s0, w_word_write_port
                 775     ;
                 776     ;Compute the SHA-1 algorithm at the same time that the DS2432 is also computing (2ms).
                 777     ;
0F2 20115        778                             CALL            compute_sha1
                 779     ;
                 780     ;The 160-bit Message Authentication Code is read from the DS2432 as 20 bytes
                 781     ;and compared with the concatenation of variables E, D, C, B and A in that order
                 782     ;with each variable received from the DS2432 least significant byte first.
                 783     ;Each received byte is also used to form a 16-bit CRC value which is tested to
                 784     ;reveal any communication errors.
                 785     ;
                 786     ;
0F3 203E7        787                             CALL            send_mac                ;display 'mac='
0F4 2020B        788                             CALL            clear_crc16             ;prepare CRC registers [sE,sD]
0F5 01C00        789                             LOAD            sc, #0x00               ;Clear byte match counter
0F6 01B18        790                             LOAD            sb, #var_e0             ;start match with LS-Byte of variable 'E'
0F7 01A04        791     mac_match_var:          LOAD            sa, #0x04               ;4 bytes to match in each variable
0F8 0A9B0        792     mac_match_byte:         FETCH           s9, @sb                 ;read variable byte from local SHA-1
0F9 2026F        793                             CALL            read_byte_slow          ;read DS2432 byte into s3
0FA 2020E        794                             CALL            compute_crc16           ;compute CRC for value in 's3'
0FB 1C390        795                             COMPARE         s3, s9                  ;compare MAC values
0FC 360FE        796                             JUMP            nz, display_mac_byte    ;count matching bytes
0FD 11C01        797                             ADD             sc, #0x01               ;decrement match counter
0FE 00030        798     display_mac_byte:       LOAD            s0, s3                  ;display byte
0FF 202C2        799                             CALL            send_hex_byte
100 202EF        800                             CALL            send_space
101 19A01        801                             SUB             sa, #0x01               ;counts bytes per variable
102 32105        802                             JUMP            z, next_mac_var
103 11B01        803                             ADD             sb, #0x01
104 220F8        804                             JUMP            mac_match_byte
105 1DB0B        805     next_mac_var:           COMPARE         sb, #var_a3             ;test for last byte
106 32109        806                             JUMP            z, report_mac
107 19B07        807                             SUB             sb, #0x07               ;point to next variable
108 220F7        808                             JUMP            mac_match_var
                 809     ;
                 810     ;MAC has passed if all 20 bytes matched
                 811     ;
109 202EC        812     report_mac:             CALL            send_cr
10A 1DC14        813                             COMPARE         sc, #0x14               ;20 bytes should have matched
10B 3610E        814                             JUMP            nz, mac_fail
10C 203AD        815                             CALL            send_pass
10D 2210F        816                             JUMP            read_mac_crc
10E 203B4        817     mac_fail:               CALL            send_fail
                 818     ;
                 819     ;Next two bytes received are the 16-bit CRC
                 820     ;Read 16-bit CRC into [s5,s4] and send value to UART
                 821     ;
10F 2021C        822     read_mac_crc:           CALL            read_send_test_crc16    ;read, display and test CRC value
                 823     ;
                 824     ;Read one byte that should be value AA hex.
                 825     ;  Would actually read AA hex continuously until master reset
                 826     ;
110 2026F        827                             CALL            read_byte_slow          ;read data into s3
111 00030        828                             LOAD            s0, s3                  ;display byte
112 202C2        829                             CALL            send_hex_byte
113 202EC        830                             CALL            send_cr
                 831     ;
114 22003        832                             JUMP            warm_start
                 833     ;
                 834     ;
                 835     ;**************************************************************************************
                 836     ; Compute SHA-1 Algorithm.
                 837     ;**************************************************************************************
                 838     ;
                 839     ; Computes the SHA-1 algorithm based on the initial table of values (M0 through to M15)
                 840     ; which are stored in the external Wt buffer.
                 841     ;
                 842     ; The SHA-1 algorithms uses 5 variables called 'A', 'B', 'C', 'D' and 'E'. Each variable
                 843     ; is 32-bits and stored as 4 bytes in PicoBlaze scratch pad memory. The locations must
                 844     ; be defined using constants 'var_A0' thought to 'var_E3' in ascending locations.
                 845     ;
                 846     ; Constants must also be used to define access to the external Wt buffer.
                 847     ;
                 848     ; During this process, register 'sE' is used to count iterations from 0 to 79 (4F hex).
                 849     ; Other registers are consistently grouped as follows to support 32-bit operations.
                 850     ;
                 851     ; Register set [s5,s4,s3,s2] is used as a temporary 32-bit word
                 852     ; Register set [s9,s8,s7,s6] is used as a temporary 32-bit word
                 853     ; Register set [sD,sC,sB,sA] is used as a temporary 32-bit word
                 854     ;
                 855     ;
                 856     ; Initialise the 32-bit variables
                 857     ;
                 858     ;
115 01001        859     compute_sha1:           LOAD            s0, #0x01               ;A=67452301
116 2F008        860                             STORE           s0, var_a0
117 01023        861                             LOAD            s0, #0x23
118 2F009        862                             STORE           s0, var_a1
119 01045        863                             LOAD            s0, #0x45
11A 2F00A        864                             STORE           s0, var_a2
11B 01067        865                             LOAD            s0, #0x67
11C 2F00B        866                             STORE           s0, var_a3
11D 01089        867                             LOAD            s0, #0x89               ;B=EFCDAB89
11E 2F00C        868                             STORE           s0, var_b0
11F 010AB        869                             LOAD            s0, #0xab
120 2F00D        870                             STORE           s0, var_b1
121 010CD        871                             LOAD            s0, #0xcd
122 2F00E        872                             STORE           s0, var_b2
123 010EF        873                             LOAD            s0, #0xef
124 2F00F        874                             STORE           s0, var_b3
125 010FE        875                             LOAD            s0, #0xfe               ;C=98BADCFE
126 2F010        876                             STORE           s0, var_c0
127 010DC        877                             LOAD            s0, #0xdc
128 2F011        878                             STORE           s0, var_c1
129 010BA        879                             LOAD            s0, #0xba
12A 2F012        880                             STORE           s0, var_c2
12B 01098        881                             LOAD            s0, #0x98
12C 2F013        882                             STORE           s0, var_c3
12D 01076        883                             LOAD            s0, #0x76               ;D=10325476
12E 2F014        884                             STORE           s0, var_d0
12F 01054        885                             LOAD            s0, #0x54
130 2F015        886                             STORE           s0, var_d1
131 01032        887                             LOAD            s0, #0x32
132 2F016        888                             STORE           s0, var_d2
133 01010        889                             LOAD            s0, #0x10
134 2F017        890                             STORE           s0, var_d3
135 010F0        891                             LOAD            s0, #0xf0               ;E=C3D2E1F0
136 2F018        892                             STORE           s0, var_e0
137 010E1        893                             LOAD            s0, #0xe1
138 2F019        894                             STORE           s0, var_e1
139 010D2        895                             LOAD            s0, #0xd2
13A 2F01A        896                             STORE           s0, var_e2
13B 010C3        897                             LOAD            s0, #0xc3
13C 2F01B        898                             STORE           s0, var_e3
                 899     ;
                 900     ;
13D 01E00        901                             LOAD            se, #0x00               ;reset iteration counter
                 902     ;
                 903     ;
                 904     ;Compute ft(B,C,D) in register set [s5,s4,s3,s2] and then add constant Kt.
                 905     ;
                 906     ;Iterations 0 to 19 - process type 1
                 907     ;   ft = (B and C) or ((not B) and D)
                 908     ;  Then the constant Kt=5A827999 will be added
                 909     ;
                 910     ;Iterations 20 to 39  and iterations 60 to 79  - process type 2
                 911     ;   ft = B xor C xor D
                 912     ;  Then the constant Kt=6ED9EBA1 will be added for iterations 20 to 39
                 913     ;  Then the constant Kt=CA62C1D6 will be added for iterations 60 to 79
                 914     ;
                 915     ;Iterations 40 to 59  - process type 3
                 916     ;   ft = (B and C) or (B and D) or (C and D)
                 917     ;  Then the constant Kt=8F1BBCDC will be added
                 918     ;
13E 0B50F        919     next_sha1_iteration:    FETCH           s5, var_b3              ;B in [s5,s4,s3,s2]
13F 0B40E        920                             FETCH           s4, var_b2
140 0B30D        921                             FETCH           s3, var_b1
141 0B20C        922                             FETCH           s2, var_b0
142 20176        923                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
143 0BD17        924                             FETCH           sd, var_d3              ;D in [sD,sC,sB,sA]
144 0BC16        925                             FETCH           sc, var_d2
145 0BB15        926                             FETCH           sb, var_d1
146 0BA14        927                             FETCH           sa, var_d0
                 928     ;
                 929     ;Determine process type
                 930     ;
147 1DE14        931                             COMPARE         se, #0x14               ;set carry flag for iterations <20
148 3A161        932                             JUMP            c, ft_type1
149 1DE28        933                             COMPARE         se, #0x28               ;set carry flag for iterations <40
14A 3A14D        934                             JUMP            c, ft_type2
14B 1DE3C        935                             COMPARE         se, #0x3c               ;set carry flag for iterations <60
14C 3A17B        936                             JUMP            c, ft_type3
                 937     ;
                 938     ;   ft = B xor C xor D
                 939     ;
                 940     ;       B xor C     =        B       xor       C
                 941     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [s9,s8,s7,s6]
                 942     ;
                 943     ;   B xor C xor D   =    (B xor C)   xor       D
                 944     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [sD,sC,sB,sA]
                 945     ;
                 946     ;
14D 06590        947     ft_type2:               XOR             s5, s9                  ;B xor C in [s5,s4,s3,s2]
14E 06480        948                             XOR             s4, s8
14F 06370        949                             XOR             s3, s7
150 06260        950                             XOR             s2, s6
151 065D0        951                             XOR             s5, sd                  ;(B xor C) xor D in [s5,s4,s3,s2]
152 064C0        952                             XOR             s4, sc
153 063B0        953                             XOR             s3, sb
154 062A0        954                             XOR             s2, sa
155 1DE3C        955                             COMPARE         se, #0x3c               ;set carry flag for iterations <60
156 3E15C        956                             JUMP            nc, kt_ca62c1d6
157 112A1        957                             ADD             s2, #0xa1               ;add Kt=6ED9EBA1
158 133EB        958                             ADDCY           s3, #0xeb
159 134D9        959                             ADDCY           s4, #0xd9
15A 1356E        960                             ADDCY           s5, #0x6e
15B 22194        961                             JUMP            compute_tmp
15C 112D6        962     kt_ca62c1d6:            ADD             s2, #0xd6               ;add Kt=CA62C1D6
15D 133C1        963                             ADDCY           s3, #0xc1
15E 13462        964                             ADDCY           s4, #0x62
15F 135CA        965                             ADDCY           s5, #0xca
160 22194        966                             JUMP            compute_tmp
                 967     ;
                 968     ;   ft = (B and C) or ((not B) and D)
                 969     ;
                 970     ;       B and C     =        C       and       B
                 971     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                 972     ;
                 973     ;       not B       =        B       xor   FFFFFFFF
                 974     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [FF,FF,FF,FF]
                 975     ;
                 976     ;   (not B) and D   =    (not B)     and       D
                 977     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                 978     ;
                 979     ;   ;(B and C) or ((not B) and D)  =  ((not B) and D)  or   (B and C)
                 980     ;            [s5,s4,s3,s2]         =   [s5,s4,s3,s2]   or  [s9,s8,s7,s6]
                 981     ;
161 02950        982     ft_type1:               AND             s9, s5                  ;B and C in [s9,s8,s7,s6]
162 02840        983                             AND             s8, s4
163 02730        984                             AND             s7, s3
164 02620        985                             AND             s6, s2
165 075FF        986                             XOR             s5, #0xff               ;(not B) in [s5,s4,s3,s2]
166 074FF        987                             XOR             s4, #0xff
167 073FF        988                             XOR             s3, #0xff
168 072FF        989                             XOR             s2, #0xff
169 025D0        990                             AND             s5, sd                  ;((not B) and D) in [s5,s4,s3,s2]
16A 024C0        991                             AND             s4, sc
16B 023B0        992                             AND             s3, sb
16C 022A0        993                             AND             s2, sa
16D 04590        994                             OR              s5, s9                  ;(B and C) or ((not B) and D) in [s5,s4,s3,s2]
16E 04480        995                             OR              s4, s8
16F 04370        996                             OR              s3, s7
170 04260        997                             OR              s2, s6
171 11299        998                             ADD             s2, #0x99               ;add Kt=5A827999
172 13379        999                             ADDCY           s3, #0x79
173 13482       1000                             ADDCY           s4, #0x82
174 1355A       1001                             ADDCY           s5, #0x5a
175 22194       1002                             JUMP            compute_tmp
                1003     ;
                1004     ;Routine to fetch variable 'C' into register set [s9,s8,s7,s6]
                1005     ;
176 0B913       1006     fetch_c:                FETCH           s9, var_c3
177 0B812       1007                             FETCH           s8, var_c2
178 0B711       1008                             FETCH           s7, var_c1
179 0B610       1009                             FETCH           s6, var_c0
17A 25000       1010                             RETURN
                1011     ;
                1012     ;   ft = (B and C) or (B and D) or (C and D)
                1013     ;
                1014     ;       B and C     =        C       and       B
                1015     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                1016     ;
                1017     ;       B and D     =        B       and       D
                1018     ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                1019     ;
                1020     ;  (B and C) or (B and D)   =    (B and D)    or    (B and C)
                1021     ;      [s5,s4,s3,s2]        =  [s5,s4,s3,s2]  or  [s9,s8,s7,s6]
                1022     ;
                1023     ;     read C again into [s9,s8,s7,s6]
                1024     ;
                1025     ;       C and D     =        C       and       D
                1026     ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [sD,sC,sB,sA]
                1027     ;
                1028     ;  ((B and C) or (B and D)) or (C and D)   =    ((B and C) or (B and D)) or   (C and D)
                1029     ;               [s5,s4,s3,s2]              =           [s5,s4,s3,s2]     or  [s9,s8,s7,s6]
                1030     ;
17B 02950       1031     ft_type3:               AND             s9, s5                  ;(B and C) in [s9,s8,s7,s6]
17C 02840       1032                             AND             s8, s4
17D 02730       1033                             AND             s7, s3
17E 02620       1034                             AND             s6, s2
17F 025D0       1035                             AND             s5, sd                  ;(B and D) in [s5,s4,s3,s2]
180 024C0       1036                             AND             s4, sc
181 023B0       1037                             AND             s3, sb
182 022A0       1038                             AND             s2, sa
183 04590       1039                             OR              s5, s9                  ;(B and C) or (B and D) in [s5,s4,s3,s2]
184 04480       1040                             OR              s4, s8
185 04370       1041                             OR              s3, s7
186 04260       1042                             OR              s2, s6
187 20176       1043                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
188 029D0       1044                             AND             s9, sd                  ;(C and D) in [s9,s8,s7,s6]
189 028C0       1045                             AND             s8, sc
18A 027B0       1046                             AND             s7, sb
18B 026A0       1047                             AND             s6, sa
18C 04590       1048                             OR              s5, s9                  ;(B and C) or (B and D) or (C and D) in [s5,s4,s3,s2]
18D 04480       1049                             OR              s4, s8
18E 04370       1050                             OR              s3, s7
18F 04260       1051                             OR              s2, s6
190 112DC       1052                             ADD             s2, #0xdc               ;add Kt=8F1BBCDC
191 133BC       1053                             ADDCY           s3, #0xbc
192 1341B       1054                             ADDCY           s4, #0x1b
193 1358F       1055                             ADDCY           s5, #0x8f
                1056     ;
                1057     ;Add variable 'E' to [s5,s4,s3,s2]
                1058     ;
194 0B018       1059     compute_tmp:            FETCH           s0, var_e0
195 10200       1060                             ADD             s2, s0
196 0B019       1061                             FETCH           s0, var_e1
197 12300       1062                             ADDCY           s3, s0
198 0B01A       1063                             FETCH           s0, var_e2
199 12400       1064                             ADDCY           s4, s0
19A 0B01B       1065                             FETCH           s0, var_e3
19B 12500       1066                             ADDCY           s5, s0
                1067     ;
                1068     ;Add variable 'A' rotated left 5 places
                1069     ;
19C 0B90B       1070                             FETCH           s9, var_a3              ;A in [s9,s8,s7,s6]
19D 0B80A       1071                             FETCH           s8, var_a2
19E 0B709       1072                             FETCH           s7, var_a1
19F 0B608       1073                             FETCH           s6, var_a0
1A0 01005       1074                             LOAD            s0, #0x05               ;rotate left 5 places
1A1 201E7       1075                             CALL            rotate_word_left_n_places
1A2 10260       1076                             ADD             s2, s6                  ;add to TMP
1A3 12370       1077                             ADDCY           s3, s7
1A4 12480       1078                             ADDCY           s4, s8
1A5 12590       1079                             ADDCY           s5, s9
                1080     ;
                1081     ;
                1082     ;Compute Wt in register set [s9,s8,s7,s6]
                1083     ;  Value computed is also stored back in the external buffer for
                1084     ;  use in later iterations as well as being added to TMP.
                1085     ;
                1086     ;Iterations 0 to 15
                1087     ;  Wt = Mt
                1088     ; This only requires Wt-16 to be read and then shifted back into the buffer again.
                1089     ;
                1090     ;Iterations 0 to 15
                1091     ;  Wt = rotate_left_1_place(Wt-3 xor Wt-8 xor Wt-14 xor Wt-16)
                1092     ; This requires all data values to be read first. Then XORed and rotated before
                1093     ; shifting the new Wt word into the buffer.
                1094     ;
                1095     ;
1A6 0993F       1096                             INPUT           s9, wt_minus16_byte3_read_port ;Read Wt-16 value
1A7 0983E       1097                             INPUT           s8, wt_minus16_byte2_read_port
1A8 0973D       1098                             INPUT           s7, wt_minus16_byte1_read_port
1A9 0963C       1099                             INPUT           s6, wt_minus16_byte0_read_port
1AA 1DE10       1100                             COMPARE         se, #0x10               ;set carry flag for iterations 0 to 15
1AB 3A1C5       1101                             JUMP            c, store_wt
                1102     ;
                1103     ;Read other Wt words and perform XOR
                1104     ;
1AC 09037       1105                             INPUT           s0, wt_minus14_byte3_read_port ;XOR with Wt-14 value
1AD 06900       1106                             XOR             s9, s0
1AE 09036       1107                             INPUT           s0, wt_minus14_byte2_read_port
1AF 06800       1108                             XOR             s8, s0
1B0 09035       1109                             INPUT           s0, wt_minus14_byte1_read_port
1B1 06700       1110                             XOR             s7, s0
1B2 09034       1111                             INPUT           s0, wt_minus14_byte0_read_port
1B3 06600       1112                             XOR             s6, s0
1B4 0901F       1113                             INPUT           s0, wt_minus8_byte3_read_port ;XOR with Wt-8 value
1B5 06900       1114                             XOR             s9, s0
1B6 0901E       1115                             INPUT           s0, wt_minus8_byte2_read_port
1B7 06800       1116                             XOR             s8, s0
1B8 0901D       1117                             INPUT           s0, wt_minus8_byte1_read_port
1B9 06700       1118                             XOR             s7, s0
1BA 0901C       1119                             INPUT           s0, wt_minus8_byte0_read_port
1BB 06600       1120                             XOR             s6, s0
1BC 0900B       1121                             INPUT           s0, wt_minus3_byte3_read_port ;XOR with Wt-3 value
1BD 06900       1122                             XOR             s9, s0
1BE 0900A       1123                             INPUT           s0, wt_minus3_byte2_read_port
1BF 06800       1124                             XOR             s8, s0
1C0 09009       1125                             INPUT           s0, wt_minus3_byte1_read_port
1C1 06700       1126                             XOR             s7, s0
1C2 09008       1127                             INPUT           s0, wt_minus3_byte0_read_port
1C3 06600       1128                             XOR             s6, s0
1C4 201EB       1129                             CALL            rotate_word_left        ;rotate XORed word left by one place
                1130     ;
                1131     ;Store new Wt value in external buffer
                1132     ;
1C5 2D910       1133     store_wt:               OUTPUT          s9, w_word_write_port
1C6 2D810       1134                             OUTPUT          s8, w_word_write_port
1C7 2D710       1135                             OUTPUT          s7, w_word_write_port
1C8 2D610       1136                             OUTPUT          s6, w_word_write_port
                1137     ;
                1138     ;Add new computed Wt value to TMP in [s5,s4,s3,s2]
                1139     ;
1C9 10260       1140                             ADD             s2, s6
1CA 12370       1141                             ADDCY           s3, s7
1CB 12480       1142                             ADDCY           s4, s8
1CC 12590       1143                             ADDCY           s5, s9
                1144     ;
                1145     ;TMP is now complete in [s5,s4,s3,s2]
                1146     ;
                1147     ;
                1148     ;copy values
                1149     ;  E <= D
                1150     ;  D <= C
                1151     ;  C <= B (this will need to be rotated 30 places afterwards)
                1152     ;  B <= A
                1153     ;
1CD 01D04       1154                             LOAD            sd, #0x04               ;4 bytes per word to copy
1CE 01C1B       1155     copy_var_loop:          LOAD            sc, #var_e3
1CF 01B1A       1156                             LOAD            sb, #var_e2
1D0 0AAB0       1157     move_var_loop:          FETCH           sa, @sb
1D1 2EAC0       1158                             STORE           sa, @sc
1D2 19C01       1159                             SUB             sc, #0x01
1D3 19B01       1160                             SUB             sb, #0x01
1D4 1DC08       1161                             COMPARE         sc, #var_a0
1D5 361D0       1162                             JUMP            nz, move_var_loop
1D6 19D01       1163                             SUB             sd, #0x01
1D7 361CE       1164                             JUMP            nz, copy_var_loop
                1165     ;
                1166     ;rotate 'C' (the previous 'B') left 30 places
                1167     ;
1D8 20176       1168                             CALL            fetch_c                 ;C in [s9,s8,s7,s6]
1D9 0101E       1169                             LOAD            s0, #0x1e               ;rotate left 30 places
1DA 201E7       1170                             CALL            rotate_word_left_n_places
1DB 2F913       1171                             STORE           s9, var_c3
1DC 2F812       1172                             STORE           s8, var_c2
1DD 2F711       1173                             STORE           s7, var_c1
1DE 2F610       1174                             STORE           s6, var_c0
                1175     ;
                1176     ;  A <= TMP
                1177     ;
1DF 2F50B       1178                             STORE           s5, var_a3
1E0 2F40A       1179                             STORE           s4, var_a2
1E1 2F309       1180                             STORE           s3, var_a1
1E2 2F208       1181                             STORE           s2, var_a0
                1182     ;
                1183     ;count iterations
                1184     ;
1E3 1DE4F       1185                             COMPARE         se, #0x4f               ;test for last iteration = 79 decimal (4F hex)
1E4 31000       1186                             RETURN          z
1E5 11E01       1187                             ADD             se, #0x01
1E6 2213E       1188                             JUMP            next_sha1_iteration
                1189     ;
                1190     ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1191     ; by the number of places specified in register 's0'.
                1192     ;
1E7 201EB       1193     rotate_word_left_n_places: CALL         rotate_word_left
1E8 19001       1194                             SUB             s0, #0x01
1E9 361E7       1195                             JUMP            nz, rotate_word_left_n_places
1EA 25000       1196                             RETURN
                1197     ;
                1198     ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1199     ; by one place.
                1200     ;
1EB 0D980       1201     rotate_word_left:       TEST            s9, #0x80               ;test MSB of word
1EC 14600       1202                             SLA             s6
1ED 14700       1203                             SLA             s7
1EE 14800       1204                             SLA             s8
1EF 14900       1205                             SLA             s9
1F0 25000       1206                             RETURN
                1207     ;
                1208     ;**************************************************************************************
                1209     ; Compute 8-bit CRC used by DS2432.
                1210     ;**************************************************************************************
                1211     ;
                1212     ; The DS2432 computes an 8-bit CRC using the polynomial X8 + X5 + X4 + 1.
                1213     ; See the DS2432 data sheet for full details.
                1214     ;
                1215     ; Test input value of value 00 00 00 01 B8 1C 02
                1216     ; should produce CRC=A2.
                1217     ;
                1218     ; This routine computes the same CRC based on the values stored in the KCPSM3
                1219     ; scratch pad memory by the read ROM command. The result is returned in register s0.
                1220     ;
                1221     ; Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9
                1222     ;
                1223     ;
                1224     ; Start by loading family code and serial number (56-bits) into register set
                1225     ; [s9,s8,s7,s6,s5,s4,s3] so that it can be shifted out LSB first.
                1226     ;
                1227     ;
1F1 0B300       1228     compute_crc8:           FETCH           s3, family_code
1F2 0B401       1229                             FETCH           s4, serial_number0
1F3 0B502       1230                             FETCH           s5, serial_number1
1F4 0B603       1231                             FETCH           s6, serial_number2
1F5 0B704       1232                             FETCH           s7, serial_number3
1F6 0B805       1233                             FETCH           s8, serial_number4
1F7 0B906       1234                             FETCH           s9, serial_number5
1F8 01238       1235                             LOAD            s2, #0x38               ;56 bits to shift (38 hex)
1F9 01000       1236                             LOAD            s0, #0x00               ;clear CRC value
1FA 00100       1237     crc8_loop:              LOAD            s1, s0                  ;copy current CRC value
1FB 06130       1238                             XOR             s1, s3                  ;Need to know LSB XOR next input bit
1FC 0D101       1239                             TEST            s1, #0x01               ;test result of XOR in LSB
1FD 3E1FF       1240                             JUMP            nc, crc8_shift
1FE 07018       1241                             XOR             s0, #0x18               ;compliment bits 3 and 4 of CRC
1FF 1410E       1242     crc8_shift:             SR0             s1                      ;Carry gets LSB XOR next input bit
200 14008       1243                             SRA             s0                      ;shift Carry into MSB to form new CRC value
201 1490E       1244                             SR0             s9                      ;shift input value
202 14808       1245                             SRA             s8
203 14708       1246                             SRA             s7
204 14608       1247                             SRA             s6
205 14508       1248                             SRA             s5
206 14408       1249                             SRA             s4
207 14308       1250                             SRA             s3
208 19201       1251                             SUB             s2, #0x01               ;count iterations
209 361FA       1252                             JUMP            nz, crc8_loop
20A 25000       1253                             RETURN
                1254     ;
                1255     ;
                1256     ;
                1257     ;**************************************************************************************
                1258     ; Clear or Compute 16-bit CRC used by DS2432.
                1259     ;**************************************************************************************
                1260     ;
                1261     ; The DS2432 computes a 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                1262     ; See the DS2432 data sheet for full details.
                1263     ;
                1264     ; Note that the value formed in the CRC shift register MUST BE INVERTED to give the
                1265     ; same value as that sent from the DS2432 during scratchpad write, scratchpad read
                1266     ; and read auth page commands.
                1267     ;
                1268     ; The 16-bit CRC is computed using a different number of bytes depending on the
                1269     ; command. This routine has been written such that the CRC can be computed one
                1270     ; byte at a time. The byte to be processed should be provided in register 's3'
                1271     ; and the contents of this register are preserved.
                1272     ;
                1273     ; This routine computes the 16-bit CRC in the register pair [sE,sD] and these
                1274     ; registers must not be disturbed between calls of this routine.
                1275     ;
                1276     ; Before starting a CRC computation the 'clear_CRC16' should be used.
                1277     ;
                1278     ; Registers used s0,s1,s3,sD,sE
                1279     ;    s3 is preserved.
                1280     ;    sD and sE should not be disturbed between calls if CRC value is required.
                1281     ;
                1282     ;
20B 01E00       1283     clear_crc16:            LOAD            se, #0x00               ;[sE,sD]=0000
20C 01D00       1284                             LOAD            sd, #0x00
20D 25000       1285                             RETURN
                1286     ;
20E 01108       1287     compute_crc16:          LOAD            s1, #0x08               ;8-bits to shift
20F 000D0       1288     crc16_loop:             LOAD            s0, sd                  ;copy current CRC value
210 06030       1289                             XOR             s0, s3                  ;Need to know LSB XOR next input bit
211 0D001       1290                             TEST            s0, #0x01               ;test result of XOR in LSB
212 3E215       1291                             JUMP            nc, crc16_shift
213 07D02       1292                             XOR             sd, #0x02               ;compliment bit 1 of CRC
214 07E40       1293                             XOR             se, #0x40               ;compliment bit 14 of CRC
215 1400E       1294     crc16_shift:            SR0             s0                      ;Carry gets LSB XOR next input bit
216 14E08       1295                             SRA             se                      ;shift Carry into MSB to form new CRC value
217 14D08       1296                             SRA             sd
218 1430C       1297                             RR              s3                      ;shift input value
219 19101       1298                             SUB             s1, #0x01               ;count bits
21A 3620F       1299                             JUMP            nz, crc16_loop          ;next bit
21B 25000       1300                             RETURN
                1301     ;
                1302     ;
                1303     ;**************************************************************************************
                1304     ; Read 16-bit CRC from DS2432, send value received to UART and test result.
                1305     ;**************************************************************************************
                1306     ;
                1307     ; The computed CRC value for comparison must be in register pair [sE,sD]
                1308     ;
21C 2026F       1309     read_send_test_crc16:   CALL            read_byte_slow          ;read 16-bit CRC into [s5,s4]
21D 00430       1310                             LOAD            s4, s3
21E 2026F       1311                             CALL            read_byte_slow
21F 00530       1312                             LOAD            s5, s3
220 203E2       1313                             CALL            send_crc                ;'crc=' to display CRC value
221 00050       1314                             LOAD            s0, s5
222 202C2       1315                             CALL            send_hex_byte
223 00040       1316                             LOAD            s0, s4
224 202C2       1317                             CALL            send_hex_byte
225 202EC       1318                             CALL            send_cr
226 07DFF       1319                             XOR             sd, #0xff               ;1's complement the computed CRC value
227 07EFF       1320                             XOR             se, #0xff
228 1C4D0       1321                             COMPARE         s4, sd                  ;test received value with computed value
229 3622E       1322                             JUMP            nz, crc16_fail
22A 1C5E0       1323                             COMPARE         s5, se
22B 3622E       1324                             JUMP            nz, crc16_fail
22C 203AD       1325                             CALL            send_pass               ;display 'Pass' with carriage return
22D 25000       1326                             RETURN
22E 203B4       1327     crc16_fail:             CALL            send_fail               ;display 'Fail' with carriage return
22F 25000       1328                             RETURN
                1329     ;
                1330     ;
                1331     ;**************************************************************************************
                1332     ; Initialise the DS2432 1-wire interface.
                1333     ;**************************************************************************************
                1334     ;
                1335     ; The 1-wire interface is an open-collector communication scheme employing an external
                1336     ; pull-up resistor of 680 Ohms.
                1337     ;
                1338     ; The hardware section of this translates the one bit signal from PicoBlaze such that
                1339     ; when this signal is Low the output is driven Low, but when it is High, it turns off
                1340     ; the output buffer and the signal is pulled High externally.
                1341     ;
                1342     ; This initialisation routine simply ensures that the line is High after configuration.
                1343     ; It is vital that DS_wire is generally in the High state because it is the only way in
                1344     ; which the DS2432 device derives power to operate.
                1345     ;
                1346     ; Registers used s0
                1347     ;
230 01001       1348     ds_wire_init:           LOAD            s0, #ds_wire
231 2D008       1349                             OUTPUT          s0, ds_wire_out_port
232 25000       1350                             RETURN
                1351     ;
                1352     ;
                1353     ;**************************************************************************************
                1354     ; DS2432 initialisation - Regular Speed.
                1355     ;**************************************************************************************
                1356     ;
                1357     ; The initialisation sequence must be performed before any communication can be
                1358     ; made with the DS2432 device. This involves the application of an active Low master
                1359     ; reset pulse.
                1360     ;
                1361     ; The regular (slow) speed communication is established by transmitting an active
                1362     ; Low reset pulse for a duration of at least 480us. This design generates a 500us pulse.
                1363     ;
                1364     ; The DS2432 acknowledges the reset and the setting of regular mode by generating an
                1365     ; active Low 'Rx Presence Pulse'. This presence pulse can start 15 to 60us after the
                1366     ; reset pulse and will end between 120 and 300us after the reset pulse.
                1367     ;
                1368     ; To confirm that regular mode has been set, this routine confirms that the presence pulse
                1369     ; is active only after 60us have elapsed since the reset pulse. This ensures that the
                1370     ; faster presence pulse of overdrive mode can not be detected.
                1371     ;
                1372     ; The carry flag will be set if no valid presence pulse was received (wire remained High) and
                1373     ; can be used to indicate an initialisation failure or success.
                1374     ;
                1375     ; The routine only completes 300us after the presence pulse to ensure the DS2432 has
                1376     ; completed the presence pulse and is ready for the first operation.
                1377     ;
                1378     ; Registers used s0,s1,s2
                1379     ;
233 01000       1380     ds_init_regular_mode:   LOAD            s0, #0x00               ;transmit reset pulse
234 2D008       1381                             OUTPUT          s0, ds_wire_out_port
                1382     ;Delay of 500us is equivalent to 12500 instructions at 50MHz.
                1383     ;This delay loop is formed of 28 instructions requiring 446 repetitions.
235 01201       1384                             LOAD            s2, #0x01               ;[s3,s2]=445 decimal (01BD hex)
236 011BD       1385                             LOAD            s1, #0xbd
237 20287       1386     rm_wait_500us:          CALL            delay_1us               ;25 instructions including CALL
238 19101       1387                             SUB             s1, #0x01               ;decrement delay counter
239 1B200       1388                             SUBCY           s2, #0x00
23A 3E237       1389                             JUMP            nc, rm_wait_500us       ;repeat until -1
23B 01001       1390                             LOAD            s0, #0x01               ;end of regular reset pulse
23C 2D008       1391                             OUTPUT          s0, ds_wire_out_port
                1392     ;Delay of 60us is equivalent to 1500 instructions at 50MHz.
                1393     ;This delay and is formed of 27 instructions requiring 56 repetitions.
23D 01138       1394                             LOAD            s1, #0x38               ;56 (38 hex)
23E 20287       1395     rm_wait_60us:           CALL            delay_1us               ;25 instructions including CALL
23F 19101       1396                             SUB             s1, #0x01               ;decrement delay counter
240 3623E       1397                             JUMP            nz, rm_wait_60us        ;repeat until zero
                1398     ;The DS_wire is now checked at approximately 1us intervals for the next 240us looking
                1399     ;to detect an active Low presence pulse. The 240us is equivalent to 6000 instructions
                1400     ;at 50MHz and this polling loop is formed of 33 instructions requiring 182 repetitions.
241 01201       1401                             LOAD            s2, #0x01               ;set bit which will be reset by a presence pulse
242 011B6       1402                             LOAD            s1, #0xb6               ;182 (B6 hex)
243 20287       1403     rm_poll_240us:          CALL            delay_1us               ;25 instructions including CALL
244 2024A       1404                             CALL            read_ds_wire            ;read wire - 5 instructions including CALL
245 02200       1405                             AND             s2, s0                  ;clear flag if DS_wire was Low
246 19101       1406                             SUB             s1, #0x01               ;decrement delay counter
247 36243       1407                             JUMP            nz, rm_poll_240us       ;repeat until zero
248 0D201       1408                             TEST            s2, #0x01               ;set carry flag if no pulse detected
249 25000       1409                             RETURN
                1410     ;
                1411     ;
                1412     ;**************************************************************************************
                1413     ; Read the DS_wire
                1414     ;**************************************************************************************
                1415     ;
                1416     ; The DS_wire signal is read and returned in bit0 of register 's0'.
                1417     ; Additionally the carry flag is set if the signal is High and reset if Low
                1418     ;
                1419     ; Registers used s0
                1420     ;
24A 090C0       1421     read_ds_wire:           INPUT           s0, ds_wire_in_port
24B 03001       1422                             AND             s0, #ds_wire            ;ensure only bit0 is active
24C 0D001       1423                             TEST            s0, #ds_wire            ;set carry flag if DS_wire is High
24D 25000       1424                             RETURN
                1425     ;
                1426     ;
                1427     ;
                1428     ;**************************************************************************************
                1429     ; Write a byte to DS2432 in regular speed mode.
                1430     ;**************************************************************************************
                1431     ;
                1432     ; Bytes are written to the DS2432 with LSB first.
                1433     ;
                1434     ; The byte to be written should be provided in register 's3' and this will be preserved.
                1435     ;
                1436     ; Registers used s0,s1,s2,s3
                1437     ;
24E 01208       1438     write_byte_slow:        LOAD            s2, #0x08               ;8 bits to transmit
24F 1430C       1439     wbs_loop:               RR              s3                      ;test next bit LSB first
250 3A253       1440                             JUMP            c, wbs1                 ;transmit '0' or '1'
251 20257       1441                             CALL            write_low_slow
252 22254       1442                             JUMP            next_slow_bit
253 20262       1443     wbs1:                   CALL            write_high_slow
254 19201       1444     next_slow_bit:          SUB             s2, #0x01               ;count bits
255 3624F       1445                             JUMP            nz, wbs_loop            ;repeat until 8-bits transmitted
256 25000       1446                             RETURN
                1447     ;
                1448     ;
                1449     ;
                1450     ;**************************************************************************************
                1451     ; Write a '0' to DS_wire in regular speed mode.
                1452     ;**************************************************************************************
                1453     ;
                1454     ; To write a '0' to the DS_wire the signal must be Low for 60 to 120us. This design
                1455     ; generates a 78us active Low pulse.
                1456     ;
                1457     ; The DS2432 then requires at least 1us of recovery time for which this routine
                1458     ; provides a 2us delay such that the entire write Low process (slot time) is 80us.
                1459     ; A recovery time of 1us was also found to be marginal in practice probably due
                1460     ; to the rise time of the DS_wire via the external pull up resistor.
                1461     ;
                1462     ; Registers used s0,s1
                1463     ;
257 01000       1464     write_low_slow:         LOAD            s0, #0x00               ;transmit Low pulse
258 2D008       1465                             OUTPUT          s0, ds_wire_out_port
                1466     ;Delay of 78us is equivalent to 1950 instructions at 50MHz.
                1467     ;This delay loop is formed of 27 instructions requiring 72 repetitions.
259 01148       1468                             LOAD            s1, #0x48               ;72 (48 hex)
25A 20287       1469     wls_wait_78us:          CALL            delay_1us               ;25 instructions including CALL
25B 19101       1470                             SUB             s1, #0x01               ;decrement delay counter
25C 3625A       1471                             JUMP            nz, wls_wait_78us       ;repeat until zero
25D 01001       1472                             LOAD            s0, #0x01               ;end of Low pulse
25E 2D008       1473                             OUTPUT          s0, ds_wire_out_port
25F 20287       1474                             CALL            delay_1us               ;2us recovery time
260 20287       1475                             CALL            delay_1us
261 25000       1476                             RETURN
                1477     ;
                1478     ;
                1479     ;**************************************************************************************
                1480     ; Write a '1' to DS_wire in regular speed mode.
                1481     ;**************************************************************************************
                1482     ;
                1483     ; To write a '1' to the DS_wire the signal must be Low for 1 to 15us to instigate the
                1484     ; write of the data. This design generates an 8us active Low pulse for this purpose.
                1485     ;
                1486     ; Then the output must be High for 53 to 114us to provide the '1' for the DS2432 to
                1487     ; read and then provide recovery time. This design implements a 72us delay such that
                1488     ; the entire write High process (slot time) is 80us
                1489     ;
                1490     ; Registers used s0,s1
                1491     ;
262 01000       1492     write_high_slow:        LOAD            s0, #0x00               ;transmit Low pulse
263 2D008       1493                             OUTPUT          s0, ds_wire_out_port
                1494     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1495     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
264 01108       1496                             LOAD            s1, #0x08               ;8 (08 hex)
265 20287       1497     whs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
266 19101       1498                             SUB             s1, #0x01               ;decrement delay counter
267 36265       1499                             JUMP            nz, whs_wait_8us        ;repeat until zero
268 01001       1500                             LOAD            s0, #0x01               ;end of Low pulse
269 2D008       1501                             OUTPUT          s0, ds_wire_out_port
                1502     ;Delay of 72us is equivalent to 1800 instructions at 50MHz.
                1503     ;This delay loop is formed of 27 instructions requiring 67 repetitions.
26A 01143       1504                             LOAD            s1, #0x43               ;67 (43 hex)
26B 20287       1505     whs_wait_72us:          CALL            delay_1us               ;25 instructions including CALL
26C 19101       1506                             SUB             s1, #0x01               ;decrement delay counter
26D 3626B       1507                             JUMP            nz, whs_wait_72us       ;repeat until zero
26E 25000       1508                             RETURN
                1509     ;
                1510     ;
                1511     ;
                1512     ;**************************************************************************************
                1513     ; Read a byte from DS2432 in regular speed mode.
                1514     ;**************************************************************************************
                1515     ;
                1516     ; Bytes are read from the DS2432 with LSB first.
                1517     ;
                1518     ; The byte read will be returned in register 's3'.
                1519     ;
                1520     ; Registers used s0,s1,s2,s3
                1521     ;
26F 01208       1522     read_byte_slow:         LOAD            s2, #0x08               ;8 bits to receive
270 20274       1523     rbs_loop:               CALL            read_bit_slow           ;read next bit LSB first
271 19201       1524                             SUB             s2, #0x01               ;count bits
272 36270       1525                             JUMP            nz, rbs_loop            ;repeat until 8-bits received
273 25000       1526                             RETURN
                1527     ;
                1528     ;
                1529     ;
                1530     ;
                1531     ;**************************************************************************************
                1532     ; Read a data bit sent from the DS2432 in regular speed mode.
                1533     ;**************************************************************************************
                1534     ;
                1535     ; To read a bit, PicoBlaze must initiate the processed with an active Low pulse of
                1536     ; 1 to 15us. This design generates a 4us active Low pulse for this purpose.
                1537     ;
                1538     ; Then DS2432 responds to the Low pulse by diving DS_wire in two different ways
                1539     ; depending on the logic level it is trying to send back.
                1540     ;
                1541     ; For a logic '0' the DS2432 will drive the DS-wire Low for up to 15us after
                1542     ; the start of the instigating pulse. Therefore PicoBlaze must read the DS-wire
                1543     ; before this time has elapsed but only after it has itself released the wire.
                1544     ;
                1545     ; For a logic '1' the DS2432 will do nothing and hence the DS-wire will be pulled
                1546     ; High by the external resistor after PicoBlaze has released the wire. PicoBlaze
                1547     ; will sample the wire and detect the High level.
                1548     ;
                1549     ; In this design, PicoBlaze needs to detect the logic state of the wire after
                1550     ; releasing the wire at 4us. Sampling the wire too quickly would not provide
                1551     ; adequate time for a High signal to be formed by the pull up resistor. However, it
                1552     ; must sample the wire before 15us have elapsed and any potential Low is removed.
                1553     ; This design samples the wire at 12us which is 8us after the initiation pulse ends.
                1554     ;
                1555     ; A further delay of 68us is then allowed for the DS2432 to stop transmitting and
                1556     ; to recover. This also mean that the entire read process (slot time) is 80us.
                1557     ;
                1558     ; The received data bit is SHIFTED into the MSB of register 's3'. In this way
                1559     ; the reception of 8-bits will shift the first bit into the LSB position of 's3'.
                1560     ;
                1561     ; Registers used s0,s1,s3
                1562     ;
274 01000       1563     read_bit_slow:          LOAD            s0, #0x00               ;transmit Low pulse
275 2D008       1564                             OUTPUT          s0, ds_wire_out_port
                1565     ;Delay of 4us is equivalent to 100 instructions at 50MHz.
                1566     ;This delay loop is formed of 27 instructions requiring 4 repetitions.
276 01104       1567                             LOAD            s1, #0x04               ;4 (04 hex)
277 20287       1568     rbs_wait_4us:           CALL            delay_1us               ;25 instructions including CALL
278 19101       1569                             SUB             s1, #0x01               ;decrement delay counter
279 36277       1570                             JUMP            nz, rbs_wait_4us        ;repeat until zero
27A 01001       1571                             LOAD            s0, #0x01               ;end of Low pulse
27B 2D008       1572                             OUTPUT          s0, ds_wire_out_port
                1573     ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1574     ;This delay loop is formed of 27 instructions requiring 8 repetitions.
27C 01108       1575                             LOAD            s1, #0x08               ;8 (08 hex)
27D 20287       1576     rbs_wait_8us:           CALL            delay_1us               ;25 instructions including CALL
27E 19101       1577                             SUB             s1, #0x01               ;decrement delay counter
27F 3627D       1578                             JUMP            nz, rbs_wait_8us        ;repeat until zero
280 2024A       1579                             CALL            read_ds_wire            ;sample wire (carry = state)
281 14308       1580                             SRA             s3                      ;shift received bit into MSB of s3
                1581     ;Delay of 68us is equivalent to 1700 instructions at 50MHz.
                1582     ;This delay loop is formed of 27 instructions requiring 63 repetitions.
282 0113F       1583                             LOAD            s1, #0x3f               ;63 (3F hex)
283 20287       1584     rbs_wait_68us:          CALL            delay_1us               ;25 instructions including CALL
284 19101       1585                             SUB             s1, #0x01               ;decrement delay counter
285 36283       1586                             JUMP            nz, rbs_wait_68us       ;repeat until zero
286 25000       1587                             RETURN
                1588     ;
                1589     ;
                1590     ;**************************************************************************************
                1591     ; Software delay routines
                1592     ;**************************************************************************************
                1593     ;
                1594     ; Delay of 1us.
                1595     ;
                1596     ; Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1597     ; executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1598     ; the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1599     ;
                1600     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1601     ;
                1602     ; Register used s0
                1603     ;
287 0100B       1604     delay_1us:              LOAD            s0, #delay_1us_constant
288 19001       1605     wait_1us:               SUB             s0, #0x01
289 36288       1606                             JUMP            nz, wait_1us
28A 25000       1607                             RETURN
                1608     ;
                1609     ; Delay of 40us.
                1610     ;
                1611     ; Registers used s0, s1
                1612     ;
28B 01128       1613     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
28C 20287       1614     wait_40us:              CALL            delay_1us
28D 19101       1615                             SUB             s1, #0x01
28E 3628C       1616                             JUMP            nz, wait_40us
28F 25000       1617                             RETURN
                1618     ;
                1619     ;
                1620     ; Delay of 1ms.
                1621     ;
                1622     ; Registers used s0, s1, s2
                1623     ;
290 01219       1624     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
291 2028B       1625     wait_1ms:               CALL            delay_40us
292 19201       1626                             SUB             s2, #0x01
293 36291       1627                             JUMP            nz, wait_1ms
294 25000       1628                             RETURN
                1629     ;
                1630     ; Delay of 20ms.
                1631     ;
                1632     ; Registers used s0, s1, s2, s3
                1633     ;
295 01314       1634     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
296 20290       1635     wait_20ms:              CALL            delay_1ms
297 19301       1636                             SUB             s3, #0x01
298 36296       1637                             JUMP            nz, wait_20ms
299 25000       1638                             RETURN
                1639     ;
                1640     ; Delay of approximately 1 second.
                1641     ;
                1642     ; Registers used s0, s1, s2, s3, s4
                1643     ;
29A 01414       1644     delay_1s:               LOAD            s4, #0x14               ;50 x 20ms = 1000ms
29B 20295       1645     wait_1s:                CALL            delay_20ms
29C 19401       1646                             SUB             s4, #0x01
29D 3629B       1647                             JUMP            nz, wait_1s
29E 25000       1648                             RETURN
                1649     ;
                1650     ;
                1651     ;**************************************************************************************
                1652     ; UART communication routines
                1653     ;**************************************************************************************
                1654     ;
                1655     ; Read one character from the UART
                1656     ;
                1657     ; Character read will be returned in a register called 'UART_data'.
                1658     ;
                1659     ; The routine first tests the receiver FIFO buffer to see if data is present.
                1660     ; If the FIFO is empty, the routine waits until there is a character to read.
                1661     ; As this could take any amount of time the wait loop could include a call to a
                1662     ; subroutine which performs a useful function.
                1663     ;
                1664     ;
                1665     ; Registers used s0 and UART_data
                1666     ;
29F 09040       1667     read_from_uart:         INPUT           s0, status_port         ;test Rx_FIFO buffer
2A0 0D004       1668                             TEST            s0, #rx_data_present    ;wait if empty
2A1 362A3       1669                             JUMP            nz, read_character
2A2 2229F       1670                             JUMP            read_from_uart
2A3 09F80       1671     read_character:         INPUT           uart_data, uart_read_port ;read from FIFO
2A4 25000       1672                             RETURN
                1673     ;
                1674     ;
                1675     ;
                1676     ; Transmit one character to the UART
                1677     ;
                1678     ; Character supplied in register called 'UART_data'.
                1679     ;
                1680     ; The routine first tests the transmit FIFO buffer to see if it is full.
                1681     ; If the FIFO is full, then the routine waits until it there is space.
                1682     ;
                1683     ; Registers used s0
                1684     ;
2A5 09040       1685     send_to_uart:           INPUT           s0, status_port         ;test Tx_FIFO buffer
2A6 0D002       1686                             TEST            s0, #tx_full            ;wait if full
2A7 322A9       1687                             JUMP            z, uart_write
2A8 222A5       1688                             JUMP            send_to_uart
2A9 2DF04       1689     uart_write:             OUTPUT          uart_data, uart_write_port
2AA 25000       1690                             RETURN
                1691     ;
                1692     ;
                1693     ;**************************************************************************************
                1694     ; Useful ASCII conversion and handling routines
                1695     ;**************************************************************************************
                1696     ;
                1697     ;
                1698     ; Convert character to upper case
                1699     ;
                1700     ; The character supplied in register s0.
                1701     ; If the character is in the range 'a' to 'z', it is converted
                1702     ; to the equivalent upper case character in the range 'A' to 'Z'.
                1703     ; All other characters remain unchanged.
                1704     ;
                1705     ; Registers used s0.
                1706     ;
2AB 1D061       1707     upper_case:             COMPARE         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
2AC 39000       1708                             RETURN          c
2AD 1D07B       1709                             COMPARE         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
2AE 3D000       1710                             RETURN          nc
2AF 030DF       1711                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
2B0 25000       1712                             RETURN
                1713     ;
                1714     ;
                1715     ; Convert hexadecimal value provided in register s0 into ASCII characters
                1716     ;
                1717     ; The value provided must can be any value in the range 00 to FF and will be converted into
                1718     ; two ASCII characters.
                1719     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1720     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1721     ;
                1722     ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1723     ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1724     ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1725     ;
                1726     ; Registers used s0, s1 and s2.
                1727     ;
2B1 00100       1728     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
2B2 1400E       1729                             SR0             s0                      ;isolate upper nibble
2B3 1400E       1730                             SR0             s0
2B4 1400E       1731                             SR0             s0
2B5 1400E       1732                             SR0             s0
2B6 202BD       1733                             CALL            hex_to_ascii            ;convert
2B7 00200       1734                             LOAD            s2, s0                  ;upper nibble value in s2
2B8 00010       1735                             LOAD            s0, s1                  ;restore complete value
2B9 0300F       1736                             AND             s0, #0x0f               ;isolate lower nibble
2BA 202BD       1737                             CALL            hex_to_ascii            ;convert
2BB 00100       1738                             LOAD            s1, s0                  ;lower nibble value in s1
2BC 25000       1739                             RETURN
                1740     ;
                1741     ; Convert hexadecimal value provided in register s0 into ASCII character
                1742     ;
                1743     ;Register used s0
                1744     ;
2BD 1900A       1745     hex_to_ascii:           SUB             s0, #0x0a               ;test if value is in range 0 to 9
2BE 3A2C0       1746                             JUMP            c, number_char
2BF 11007       1747                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
2C0 1103A       1748     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
2C1 25000       1749                             RETURN
                1750     ;
                1751     ;
                1752     ; Send the two character HEX value of the register contents 's0' to the UART
                1753     ;
                1754     ; Registers used s0, s1, s2
                1755     ;
2C2 202B1       1756     send_hex_byte:          CALL            hex_byte_to_ascii
2C3 00F20       1757                             LOAD            uart_data, s2
2C4 202A5       1758                             CALL            send_to_uart
2C5 00F10       1759                             LOAD            uart_data, s1
2C6 202A5       1760                             CALL            send_to_uart
2C7 25000       1761                             RETURN
                1762     ;
                1763     ;
                1764     ;
                1765     ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                1766     ; an equivalent hexadecimal value in register 's0'.
                1767     ;     The upper nibble is represented by an ASCII character in register s3.
                1768     ;     The lower nibble is represented by an ASCII character in register s2.
                1769     ;
                1770     ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1771     ; will be set on return.
                1772     ;
                1773     ; Registers used s0, s2 and s3.
                1774     ;
2C8 00030       1775     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
2C9 202D5       1776                             CALL            ascii_to_hex            ;convert to value
2CA 39000       1777                             RETURN          c                       ;reject if out of range
2CB 00300       1778                             LOAD            s3, s0                  ;remember value
2CC 14306       1779                             SL0             s3                      ;multiply value by 16 to put in upper nibble
2CD 14306       1780                             SL0             s3
2CE 14306       1781                             SL0             s3
2CF 14306       1782                             SL0             s3
2D0 00020       1783                             LOAD            s0, s2                  ;Take lower nibble
2D1 202D5       1784                             CALL            ascii_to_hex            ;convert to value
2D2 39000       1785                             RETURN          c                       ;reject if out of range
2D3 04030       1786                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
2D4 25000       1787                             RETURN
                1788     ;
                1789     ;
                1790     ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1791     ;
                1792     ; If character is not valid for hex, then CARRY is set on return.
                1793     ;
                1794     ; Register used s0
                1795     ;
2D5 110B9       1796     ascii_to_hex:           ADD             s0, #0xb9               ;test for above ASCII code 46 ('F')
2D6 39000       1797                             RETURN          c
2D7 190E9       1798                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
2D8 39000       1799                             RETURN          c                       ;reject below ASCII code 30 ('0')
2D9 19011       1800                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
2DA 3E2DF       1801                             JUMP            nc, ascii_letter
2DB 11007       1802                             ADD             s0, #0x07               ;test for above ASCII code 46 ('F')
2DC 39000       1803                             RETURN          c
2DD 190F6       1804                             SUB             s0, #0xf6               ;convert to range 00 to 09
2DE 25000       1805                             RETURN
2DF 1100A       1806     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
2E0 25000       1807                             RETURN
                1808     ;
                1809     ;
                1810     ; Read one character from UART and echo.
                1811     ; Convert to upper case and return.
                1812     ;
                1813     ;
2E1 2029F       1814     read_upper_case:        CALL            read_from_uart          ;read command character from UART
2E2 202A5       1815                             CALL            send_to_uart            ;echo character
2E3 000F0       1816                             LOAD            s0, uart_data           ;convert to upper case
2E4 202AB       1817                             CALL            upper_case
2E5 25000       1818                             RETURN
                1819     ;
                1820     ;
                1821     ; Read two hex characters from UART and convert to single byte data
                1822     ;
2E6 202E1       1823     obtain_8bits:           CALL            read_upper_case         ;obtain one byte from UART
2E7 00300       1824                             LOAD            s3, s0
2E8 202E1       1825                             CALL            read_upper_case
2E9 00200       1826                             LOAD            s2, s0
2EA 202C8       1827                             CALL            ascii_byte_to_hex
2EB 25000       1828                             RETURN
                1829     ;
                1830     ;**************************************************************************************
                1831     ; Text messages
                1832     ;**************************************************************************************
                1833     ;
                1834     ;
                1835     ; Send Carriage Return to the UART
                1836     ;
2EC 01F0D       1837     send_cr:                LOAD            uart_data, #character_cr
2ED 202A5       1838                             CALL            send_to_uart
2EE 25000       1839                             RETURN
                1840     ;
                1841     ; Send a space to the UART
                1842     ;
2EF 01F20       1843     send_space:             LOAD            uart_data, #character_space
2F0 202A5       1844                             CALL            send_to_uart
2F1 25000       1845                             RETURN
                1846     ;
                1847     ;
                1848     ; Send a minus sign to the UART
                1849     ;
2F2 01F2D       1850     send_minus:             LOAD            uart_data, #character_minus
2F3 202A5       1851                             CALL            send_to_uart
2F4 25000       1852                             RETURN
                1853     ;
                1854     ;
                1855     ; Send the letter 't' to the UART
                1856     ;
2F5 01F74       1857     send_t:                 LOAD            uart_data, #character_t
2F6 202A5       1858                             CALL            send_to_uart
2F7 25000       1859                             RETURN
                1860     ;
                1861     ; Send the letter 'e' to the UART
                1862     ;
2F8 01F65       1863     send_e:                 LOAD            uart_data, #character_e
2F9 202A5       1864                             CALL            send_to_uart
2FA 25000       1865                             RETURN
                1866     ;
                1867     ; Send the letter 'a' to the UART
                1868     ;
2FB 01F61       1869     send_a:                 LOAD            uart_data, #character_a
2FC 202A5       1870                             CALL            send_to_uart
2FD 25000       1871                             RETURN
                1872     ;
                1873     ;
                1874     ; Send the letter 'd' to the UART
                1875     ;
2FE 01F64       1876     send_d:                 LOAD            uart_data, #character_d
2FF 202A5       1877                             CALL            send_to_uart
300 25000       1878                             RETURN
                1879     ;
                1880     ;
                1881     ; Send the letter 'r' to the UART
                1882     ;
301 01F72       1883     send_r:                 LOAD            uart_data, #character_r
302 202A5       1884                             CALL            send_to_uart
303 25000       1885                             RETURN
                1886     ;
                1887     ;
                1888     ; Send the letter 's' to the UART
                1889     ;
304 01F73       1890     send_s:                 LOAD            uart_data, #character_s
305 202A5       1891                             CALL            send_to_uart
306 25000       1892                             RETURN
                1893     ;
                1894     ;
                1895     ; Send the letter 'c' to the UART
                1896     ;
307 01F63       1897     send_c:                 LOAD            uart_data, #character_c
308 202A5       1898                             CALL            send_to_uart
309 25000       1899                             RETURN
                1900     ;
                1901     ;
                1902     ; Send 'PicoBlaze SHA-1 Algorithm v1.00' string to the UART
                1903     ;
30A 202EC       1904     send_welcome:           CALL            send_cr
30B 202EC       1905                             CALL            send_cr
30C 01F50       1906                             LOAD            uart_data, #_character_p
30D 202A5       1907                             CALL            send_to_uart
30E 01F69       1908                             LOAD            uart_data, #character_i
30F 202A5       1909                             CALL            send_to_uart
310 20307       1910                             CALL            send_c
311 01F6F       1911                             LOAD            uart_data, #character_o
312 202A5       1912                             CALL            send_to_uart
313 01F42       1913                             LOAD            uart_data, #_character_b
314 202A5       1914                             CALL            send_to_uart
315 01F6C       1915                             LOAD            uart_data, #character_l
316 202A5       1916                             CALL            send_to_uart
317 202FB       1917                             CALL            send_a
318 01F7A       1918                             LOAD            uart_data, #character_z
319 202A5       1919                             CALL            send_to_uart
31A 202F8       1920                             CALL            send_e
31B 202EF       1921                             CALL            send_space
31C 01F53       1922                             LOAD            uart_data, #_character_s
31D 202A5       1923                             CALL            send_to_uart
31E 01F48       1924                             LOAD            uart_data, #_character_h
31F 202A5       1925                             CALL            send_to_uart
320 01F41       1926                             LOAD            uart_data, #_character_a
321 202A5       1927                             CALL            send_to_uart
322 202F2       1928                             CALL            send_minus
323 01F31       1929                             LOAD            uart_data, #character_1
324 202A5       1930                             CALL            send_to_uart
325 202EF       1931                             CALL            send_space
326 01F41       1932                             LOAD            uart_data, #_character_a
327 202A5       1933                             CALL            send_to_uart
328 01F6C       1934                             LOAD            uart_data, #character_l
329 202A5       1935                             CALL            send_to_uart
32A 01F67       1936                             LOAD            uart_data, #character_g
32B 202A5       1937                             CALL            send_to_uart
32C 01F6F       1938                             LOAD            uart_data, #character_o
32D 202A5       1939                             CALL            send_to_uart
32E 20301       1940                             CALL            send_r
32F 01F69       1941                             LOAD            uart_data, #character_i
330 202A5       1942                             CALL            send_to_uart
331 202F5       1943                             CALL            send_t
332 01F68       1944                             LOAD            uart_data, #character_h
333 202A5       1945                             CALL            send_to_uart
334 01F6D       1946                             LOAD            uart_data, #character_m
335 202A5       1947                             CALL            send_to_uart
336 202EF       1948                             CALL            send_space
337 01F76       1949                             LOAD            uart_data, #character_v
338 202A5       1950                             CALL            send_to_uart
339 01F31       1951                             LOAD            uart_data, #character_1
33A 202A5       1952                             CALL            send_to_uart
33B 01F2E       1953                             LOAD            uart_data, #character_fullstop
33C 202A5       1954                             CALL            send_to_uart
33D 01F30       1955                             LOAD            uart_data, #character_0
33E 202A5       1956                             CALL            send_to_uart
33F 01F30       1957                             LOAD            uart_data, #character_0
340 202A5       1958                             CALL            send_to_uart
341 202EC       1959                             CALL            send_cr
342 202EC       1960                             CALL            send_cr
343 25000       1961                             RETURN
                1962     ;
                1963     ;
                1964     ;
                1965     ;
                1966     ;
                1967     ;
                1968     ; Send DS2432 menu to the UART
                1969     ;
344 202EC       1970     send_ds2432_menu:       CALL            send_cr
345 202EC       1971                             CALL            send_cr
346 01F31       1972                             LOAD            uart_data, #character_1
347 202A5       1973                             CALL            send_to_uart
348 202F2       1974                             CALL            send_minus
349 203A5       1975                             CALL            send_write
34A 202EF       1976                             CALL            send_space
34B 20384       1977                             CALL            send_scratchpad
34C 202EC       1978                             CALL            send_cr
34D 01F32       1979                             LOAD            uart_data, #character_2
34E 202A5       1980                             CALL            send_to_uart
34F 202F2       1981                             CALL            send_minus
350 2039F       1982                             CALL            send_read
351 202EF       1983                             CALL            send_space
352 20384       1984                             CALL            send_scratchpad
353 202EC       1985                             CALL            send_cr
354 01F33       1986                             LOAD            uart_data, #character_3
355 202A5       1987                             CALL            send_to_uart
356 202F2       1988                             CALL            send_minus
357 01F4C       1989                             LOAD            uart_data, #_character_l
358 202A5       1990                             CALL            send_to_uart
359 01F6F       1991                             LOAD            uart_data, #character_o
35A 202A5       1992                             CALL            send_to_uart
35B 202FB       1993                             CALL            send_a
35C 202FE       1994                             CALL            send_d
35D 202EF       1995                             CALL            send_space
35E 01F66       1996                             LOAD            uart_data, #character_f
35F 202A5       1997                             CALL            send_to_uart
360 01F69       1998                             LOAD            uart_data, #character_i
361 202A5       1999                             CALL            send_to_uart
362 20301       2000                             CALL            send_r
363 20304       2001                             CALL            send_s
364 202F5       2002                             CALL            send_t
365 202EF       2003                             CALL            send_space
366 20391       2004                             CALL            send_secret
367 202EC       2005                             CALL            send_cr
368 01F34       2006                             LOAD            uart_data, #character_4
369 202A5       2007                             CALL            send_to_uart
36A 202F2       2008                             CALL            send_minus
36B 2039F       2009                             CALL            send_read
36C 202EF       2010                             CALL            send_space
36D 01F61       2011                             LOAD            uart_data, #character_a
36E 202A5       2012                             CALL            send_to_uart
36F 01F75       2013                             LOAD            uart_data, #character_u
370 202A5       2014                             CALL            send_to_uart
371 202F5       2015                             CALL            send_t
372 01F68       2016                             LOAD            uart_data, #character_h
373 202A5       2017                             CALL            send_to_uart
374 202EF       2018                             CALL            send_space
375 01F50       2019                             LOAD            uart_data, #_character_p
376 202A5       2020                             CALL            send_to_uart
377 202FB       2021                             CALL            send_a
378 01F67       2022                             LOAD            uart_data, #character_g
379 202A5       2023                             CALL            send_to_uart
37A 202F8       2024                             CALL            send_e
37B 202EC       2025                             CALL            send_cr
37C 25000       2026                             RETURN
                2027     ;
                2028     ;
                2029     ;
                2030     ; Send carriage return, 'OK' and carriage return to the UART
                2031     ;
37D 202EC       2032     send_ok:                CALL            send_cr
37E 01F4F       2033                             LOAD            uart_data, #_character_o
37F 202A5       2034                             CALL            send_to_uart
380 01F4B       2035                             LOAD            uart_data, #_character_k
381 202A5       2036                             CALL            send_to_uart
382 202EC       2037                             CALL            send_cr
383 25000       2038                             RETURN
                2039     ;
                2040     ;
                2041     ; Send 'scratchpad' to the UART
                2042     ;
384 20304       2043     send_scratchpad:        CALL            send_s
385 20307       2044                             CALL            send_c
386 20301       2045                             CALL            send_r
387 202FB       2046                             CALL            send_a
388 202F5       2047                             CALL            send_t
389 20307       2048                             CALL            send_c
38A 01F68       2049                             LOAD            uart_data, #character_h
38B 202A5       2050                             CALL            send_to_uart
38C 01F70       2051                             LOAD            uart_data, #character_p
38D 202A5       2052                             CALL            send_to_uart
38E 202FB       2053                             CALL            send_a
38F 202FE       2054                             CALL            send_d
390 25000       2055                             RETURN
                2056     ;
                2057     ;
                2058     ; Send 'secret' to the UART
                2059     ;
391 20304       2060     send_secret:            CALL            send_s
392 202F8       2061                             CALL            send_e
393 20307       2062                             CALL            send_c
394 20301       2063                             CALL            send_r
395 202F8       2064                             CALL            send_e
396 202F5       2065                             CALL            send_t
397 25000       2066                             RETURN
                2067     ;
                2068     ;
                2069     ; Send 'Byte' to the UART
                2070     ;
398 01F42       2071     send_byte:              LOAD            uart_data, #_character_b
399 202A5       2072                             CALL            send_to_uart
39A 01F79       2073                             LOAD            uart_data, #character_y
39B 202A5       2074                             CALL            send_to_uart
39C 202F5       2075                             CALL            send_t
39D 202F8       2076                             CALL            send_e
39E 25000       2077                             RETURN
                2078     ;
                2079     ;
                2080     ; Send 'Read' to the UART
                2081     ;
39F 01F52       2082     send_read:              LOAD            uart_data, #_character_r
3A0 202A5       2083                             CALL            send_to_uart
3A1 202F8       2084                             CALL            send_e
3A2 202FB       2085                             CALL            send_a
3A3 202FE       2086                             CALL            send_d
3A4 25000       2087                             RETURN
                2088     ;
                2089     ;
                2090     ; Send 'Write' to the UART
                2091     ;
3A5 01F57       2092     send_write:             LOAD            uart_data, #_character_w
3A6 202A5       2093                             CALL            send_to_uart
3A7 20301       2094                             CALL            send_r
3A8 01F69       2095                             LOAD            uart_data, #character_i
3A9 202A5       2096                             CALL            send_to_uart
3AA 202F5       2097                             CALL            send_t
3AB 202F8       2098                             CALL            send_e
3AC 25000       2099                             RETURN
                2100     ;
                2101     ;
                2102     ; Send 'Pass' to the UART
                2103     ;
3AD 01F50       2104     send_pass:              LOAD            uart_data, #_character_p
3AE 202A5       2105                             CALL            send_to_uart
3AF 202FB       2106                             CALL            send_a
3B0 20304       2107                             CALL            send_s
3B1 20304       2108                             CALL            send_s
3B2 202EC       2109                             CALL            send_cr
3B3 25000       2110                             RETURN
                2111     ;
                2112     ;
                2113     ; Send 'Fail' to the UART
                2114     ;
3B4 01F46       2115     send_fail:              LOAD            uart_data, #_character_f
3B5 202A5       2116                             CALL            send_to_uart
3B6 202FB       2117                             CALL            send_a
3B7 01F69       2118                             LOAD            uart_data, #character_i
3B8 202A5       2119                             CALL            send_to_uart
3B9 01F6C       2120                             LOAD            uart_data, #character_l
3BA 202A5       2121                             CALL            send_to_uart
3BB 202EC       2122                             CALL            send_cr
3BC 25000       2123                             RETURN
                2124     ;
                2125     ;
                2126     ; Send 'address=' to the UART
                2127     ;
3BD 202EC       2128     send_address:           CALL            send_cr
3BE 202FB       2129                             CALL            send_a
3BF 202FE       2130                             CALL            send_d
3C0 202FE       2131                             CALL            send_d
3C1 20301       2132                             CALL            send_r
3C2 202F8       2133                             CALL            send_e
3C3 20304       2134                             CALL            send_s
3C4 20304       2135                             CALL            send_s
3C5 01F3D       2136     send_equals:            LOAD            uart_data, #character_equals
3C6 202A5       2137                             CALL            send_to_uart
3C7 25000       2138                             RETURN
                2139     ;
                2140     ;
                2141     ; Send 'data' to the UART
                2142     ;
3C8 202EC       2143     send_data:              CALL            send_cr
3C9 202FE       2144                             CALL            send_d
3CA 202FB       2145                             CALL            send_a
3CB 202F5       2146                             CALL            send_t
3CC 202FB       2147                             CALL            send_a
3CD 25000       2148                             RETURN
                2149     ;
                2150     ;
                2151     ; Send 'E/S=' to the UART
                2152     ;
3CE 202EC       2153     send_es:                CALL            send_cr
3CF 01F45       2154                             LOAD            uart_data, #_character_e
3D0 202A5       2155                             CALL            send_to_uart
3D1 01F2F       2156                             LOAD            uart_data, #character_divide
3D2 202A5       2157                             CALL            send_to_uart
3D3 01F53       2158                             LOAD            uart_data, #_character_s
3D4 202A5       2159                             CALL            send_to_uart
3D5 223C5       2160                             JUMP            send_equals
                2161     ;
                2162     ;
                2163     ; Send 'code=' to the UART
                2164     ;
3D6 20307       2165     send_code:              CALL            send_c
3D7 01F6F       2166                             LOAD            uart_data, #character_o
3D8 202A5       2167                             CALL            send_to_uart
3D9 202FE       2168                             CALL            send_d
3DA 202F8       2169                             CALL            send_e
3DB 223C5       2170                             JUMP            send_equals
                2171     ;
                2172     ;
                2173     ; Send 's/n=' to the UART
                2174     ;
3DC 20304       2175     send_sn:                CALL            send_s
3DD 01F2F       2176                             LOAD            uart_data, #character_divide
3DE 202A5       2177                             CALL            send_to_uart
3DF 01F6E       2178                             LOAD            uart_data, #character_n
3E0 202A5       2179                             CALL            send_to_uart
3E1 223C5       2180                             JUMP            send_equals
                2181     ;
                2182     ;
                2183     ; Send 'crc=' to the UART
                2184     ;
3E2 20307       2185     send_crc:               CALL            send_c
3E3 01F72       2186                             LOAD            uart_data, #character_r
3E4 202A5       2187                             CALL            send_to_uart
3E5 20307       2188                             CALL            send_c
3E6 223C5       2189                             JUMP            send_equals
                2190     ;
                2191     ;
                2192     ;
                2193     ; Send 'mac=' to the UART
                2194     ;
3E7 01F6D       2195     send_mac:               LOAD            uart_data, #character_m
3E8 202A5       2196                             CALL            send_to_uart
3E9 202FB       2197                             CALL            send_a
3EA 20307       2198                             CALL            send_c
3EB 223C5       2199                             JUMP            send_equals
                2200     ;
                2201     ;
                2202     ;**************************************************************************************
                2203     ; Interrupt Service Routine (ISR)
                2204     ;**************************************************************************************
                2205     ;
                2206     ; Interrupts are not used in this design. This is a place keeper only.
                2207     ;
  003FE         2208                             ORG             0x3fe
3FE 29001       2209     isr:                    RETURNI         enable
                2210     ;
                2211     ;
                2212     ;**************************************************************************************
                2213     ; Interrupt Vector
                2214     ;**************************************************************************************
                2215     ;
  003FF         2216                             ORG             0x3ff
3FF 223FE       2217                             JUMP            isr
                2218     ;
                2219     ;
                2220
