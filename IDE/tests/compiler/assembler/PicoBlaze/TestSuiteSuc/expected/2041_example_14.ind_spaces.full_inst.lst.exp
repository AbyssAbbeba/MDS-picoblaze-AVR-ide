                   1     ;KCPSM3 Program - UART programming of SPI Flash memory on Spartan-3E Starter Kit.
                   2     device kcpsm2
                   3     ;
                   4     ;Ken Chapman - Xilinx Ltd
                   5     ;
                   6     ;Version v1.00 - 11th November 2005
                   7     ;
                   8     ;This program uses a 115200 baud UART connection with XON/XOFF flow control
                   9     ;to allow a standard MCS file for the configuration of a Spartan-3E device to
                  10     ;be programmed into the ST Microelectronics M25P16 device on the board.
                  11     ;
                  12     ;
                  13     ;
                  14     ;As well as the port connections vital to communication with the UART and the SPI
                  15     ;FLASH memory, there are additional port connections used to disable the other
                  16     ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
                  17     ;controlled at the hardware level, they are included in this code to aid
                  18     ;future investigations of communication with the other SPI devices using PicoBlaze.
                  19     ;
                  20     ;
                  21     ;
                  22     ;
                  23     ;Port definitions
                  24     ;
  00000           25     status_port             EQU             0x00                    ;UART and filter status input
  00001           26     tx_EQU_present         EQU             0x01                    ;  Transmitter  EQU present - bit0
  00002           27     tx_half_full            EQU             0x02                    ;    FIFO          half full - bit1
  00004           28     tx_full                 EQU             0x04                    ;                       full - bit2
  00008           29     rx_EQU_present         EQU             0x08                    ;               EQU present - bit3
  00010           30     rx_half_full            EQU             0x10                    ;  Receiver        half full - bit4
  00020           31     rx_full                 EQU             0x20                    ;    FIFO               full - bit5
                  32     ;
  00001           33     uart_read_port          EQU             0x01                    ;UART Rx EQU input
                  34     ;
  00010           35     uart_write_port         EQU             0x10                    ;UART Tx EQU output
                  36     ;
                  37     ;
  00008           38     spi_control_port        EQU             0x08                    ;SPI clock and chip selects
  00001           39     spi_sck                 EQU             0x01                    ;                  SCK - bit0
  00002           40     spi_rom_cs              EQU             0x02                    ;    serial rom select - bit1
  00004           41     spi_spare_control       EQU             0x04                    ;                spare - bit2
  00008           42     spi_amp_cs              EQU             0x08                    ;     amplifier select - bit3
  00010           43     spi_adc_conv            EQU             0x10                    ;          A/D convert - bit4
  00020           44     spi_dac_cs              EQU             0x20                    ;           D/A select - bit5
  00040           45     spi_amp_shdn            EQU             0x40                    ;       amplifier SHDN - bit6
  00080           46     spi_dac_clr             EQU             0x80                    ;            D/A clear - bit7
                  47     ;
  00004           48     spi_output_port         EQU             0x04                    ;SPI EQU output
  00080           49     spi_sdo                 EQU             0x80                    ;   SDO - bit7
                  50     ;
  00002           51     spi_input_port          EQU             0x02                    ;SPI EQU input
  00080           52     spi_sdi                 EQU             0x80                    ;             SDI - bit7
  00040           53     spi_amp_sdi             EQU             0x40                    ;   amplifier SDI - bit6
                  54     ;
                  55     ;
                  56     ;
                  57     ;
                  58     ;Special Register usage
                  59     ;
  0000F           60     uart_EQU               REG             sf                      ;used to pass EQU to and from the UART
                  61     ;
                  62     ;
                  63     ;Useful EQU constants
                  64     ;
                  65     ;
                  66     ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                  67     ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                  68     ;calculation highly predictable. The '6' in the following equation even allows for
                  69     ;'CALL delay_1us' instruction in the initiating code.
                  70     ;
                  71     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                  72     ;
                  73     ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                  74     ;For clock rates below 10MHz the value of 1 must be used and the operation will
                  75     ;become lower than intended.
                  76     ;
  0000B           77     delay_1us_constant      EQU             0x0b
                  78     ;
                  79     ;
                  80     ;Useful constants
                  81     ;
                  82     ;
                  83     ;ASCII table
                  84     ;
  00061           85     character_a             EQU             0x61
  00062           86     character_b             EQU             0x62
  00063           87     character_c             EQU             0x63
  00064           88     character_d             EQU             0x64
  00065           89     character_e             EQU             0x65
  00066           90     character_f             EQU             0x66
  00067           91     character_g             EQU             0x67
  00068           92     character_h             EQU             0x68
  00069           93     character_i             EQU             0x69
  0006A           94     character_j             EQU             0x6a
  0006B           95     character_k             EQU             0x6b
  0006C           96     character_l             EQU             0x6c
  0006D           97     character_m             EQU             0x6d
  0006E           98     character_n             EQU             0x6e
  0006F           99     character_o             EQU             0x6f
  00070          100     character_p             EQU             0x70
  00071          101     character_q             EQU             0x71
  00072          102     character_r             EQU             0x72
  00073          103     character_s             EQU             0x73
  00074          104     character_t             EQU             0x74
  00075          105     character_u             EQU             0x75
  00076          106     character_v             EQU             0x76
  00077          107     character_w             EQU             0x77
  00078          108     character_x             EQU             0x78
  00079          109     character_y             EQU             0x79
  0007A          110     character_z             EQU             0x7a
  00041          111     _character_a            EQU             0x41
  00042          112     _character_b            EQU             0x42
  00043          113     _character_c            EQU             0x43
  00044          114     _character_d            EQU             0x44
  00045          115     _character_e            EQU             0x45
  00046          116     _character_f            EQU             0x46
  00047          117     _character_g            EQU             0x47
  00048          118     _character_h            EQU             0x48
  00049          119     _character_i            EQU             0x49
  0004A          120     _character_j            EQU             0x4a
  0004B          121     _character_k            EQU             0x4b
  0004C          122     _character_l            EQU             0x4c
  0004D          123     _character_m            EQU             0x4d
  0004E          124     _character_n            EQU             0x4e
  0004F          125     _character_o            EQU             0x4f
  00050          126     _character_p            EQU             0x50
  00051          127     _character_q            EQU             0x51
  00052          128     _character_r            EQU             0x52
  00053          129     _character_s            EQU             0x53
  00054          130     _character_t            EQU             0x54
  00055          131     _character_u            EQU             0x55
  00056          132     _character_v            EQU             0x56
  00057          133     _character_w            EQU             0x57
  00058          134     _character_x            EQU             0x58
  00059          135     _character_y            EQU             0x59
  0005A          136     _character_z            EQU             0x5a
  00030          137     character_0             EQU             0x30
  00031          138     character_1             EQU             0x31
  00032          139     character_2             EQU             0x32
  00033          140     character_3             EQU             0x33
  00034          141     character_4             EQU             0x34
  00035          142     character_5             EQU             0x35
  00036          143     character_6             EQU             0x36
  00037          144     character_7             EQU             0x37
  00038          145     character_8             EQU             0x38
  00039          146     character_9             EQU             0x39
  0003A          147     character_colon         EQU             0x3a
  0002E          148     character_fullstop      EQU             0x2e
  0003B          149     character_semi_colon    EQU             0x3b
  0002D          150     character_minus         EQU             0x2d
  0002B          151     character_plus          EQU             0x2b
  0002C          152     character_comma         EQU             0x2c
  0003C          153     character_less_than     EQU             0x3c                    ;'<'
  0003E          154     character_greater_than  EQU             0x3e                    ;'>'
  00028          155     character_open          EQU             0x28                    ;'('
  00029          156     character_close         EQU             0x29                    ;')'
  0002F          157     character_divide        EQU             0x2f                    ;'/'
  0003D          158     character_equals        EQU             0x3d
  00020          159     character_space         EQU             0x20
  0000D          160     character_cr            EQU             0x0d                    ;carriage return
  0000A          161     character_lf            EQU             0x0a                    ;line feed
  0003F          162     character_question      EQU             0x3f                    ;'?'
  00024          163     character_dollar        EQU             0x24
  00021          164     character_exclaim       EQU             0x21                    ;'!'
  00008          165     character_bs            EQU             0x08                    ;Back Space command character
  00011          166     character_xon           EQU             0x11                    ;Flow control ON
  00013          167     character_xoff          EQU             0x13                    ;Flow control OFF
                 168     ;
                 169     ;
                 170     ;Scratch Pad Memory Locations
                 171     ;
                 172     ;
  00000          173     isr_preserve_s0         EQU             0x00                    ;preserve register during ISR
                 174     ;
  00001          175     page_address_h          EQU             0x01                    ;Remember page address for SPI boundary checking.
  00002          176     page_address_m          EQU             0x02                    ;high, middle and low bytes
  00003          177     page_address_l          EQU             0x03
                 178     ;
  00004          179     spi_control_status      EQU             0x04                    ;SPI status signals
                 180     ;
                 181     ;
                 182     ;
                 183     ;load up to one line of an MCS file as bytes
                 184     ;A typical EQU line consists of:-
                 185     ;:     Start character which is not loadd
                 186     ;10    Number of EQU bytes included (16 in this case)
                 187     ;aaaa  Lower 16-bits of the storage address
                 188     ;00    Record type (EQU in this case)
                 189     ;dddd...   EQU bytes (typically 16 which is the maximum)
                 190     ;cc    Checksum
                 191     ;CR/LF Line will end in carriage return and/or line feed which is not loadd.
                 192     ;
                 193     ;So a total of 21 could be loadd before processing.
                 194     ;
  0002B          195     line_start              EQU             0x2b                    ;21 bytes until end of memory
                 196     ;
                 197     ;
                 198     ;Initialise the system and welcome message
                 199     ;
                 200     ;
000 3610E        201     cold_start:             CALL            spi_init                ;initialise SPI bus ports
001 361AA        202                             CALL            delay_1s                ;delay because UART is fast and JTAG startup sequence can be slow
002 3C001        203                             ENABLE          interrupt               ;Interrupt is used for XON/XOFF flow control
003 3621D        204     welcome_start:          CALL            send_cr
004 36223        205                             CALL            send_welcome            ;start up message and version number
                 206     ;
                 207     ;Main menu and command selection
                 208     ;
                 209     ;
                 210     ;
005 362BD        211     warm_start:             CALL            send_menu               ;Menu and command selection
006 3621D        212     prompt:                 CALL            send_cr
007 3621D        213                             CALL            send_cr
008 00F3E        214                             LOAD            uart_EQU, #character_greater_than ;prompt for input
009 361C1        215                             CALL            send_to_uart
00A 3601D        216                             CALL            read_upper_case
00B 00045        217                             load         s0, #_character_e       ;command load
00C 35033        218                             JUMP            z, erase_command
00D 00053        219                             load         s0, #_character_s       ;command load
00E 35040        220                             JUMP            z, sector_erase_command
00F 00050        221                             load         s0, #_character_p       ;command load
010 35054        222                             JUMP            z, program_command
011 00052        223                             load         s0, #_character_r       ;command load
012 35059        224                             JUMP            z, read_command
013 00049        225                             load         s0, #_character_i       ;command load
014 35022        226                             JUMP            z, id_command
015 00048        227                             load         s0, #_character_h       ;command load
016 35003        228                             JUMP            z, welcome_start
017 3621D        229                             CALL            send_cr                 ;no valid command input
018 00F3F        230                             LOAD            uart_EQU, #character_question ;display ???
019 361C1        231                             CALL            send_to_uart
01A 361C1        232                             CALL            send_to_uart
01B 361C1        233                             CALL            send_to_uart
01C 34006        234                             JUMP            prompt                  ;Try again!
                 235     ;
                 236     ;
01D 361AF        237     read_upper_case:        CALL            read_from_uart          ;read command character from UART
01E 361C1        238                             CALL            send_to_uart            ;echo character
01F 10078        239                             LOAD            s0, uart_EQU           ;convert to upper case
020 361CE        240                             CALL            upper_case
021 24000        241                             RETURN
                 242     ;
                 243     ;**************************************************************************************
                 244     ;ID Command - Read and display the ID for the SPI FLASH memory
                 245     ;**************************************************************************************
                 246     ;
                 247     ;Normal response should be
                 248     ;   s9 = Manufacturer Identification = 20 hex
                 249     ;   s8 = Memory Type = 20 hex
                 250     ;   s7 = Memory Capacity = 15 hex
                 251     ;
022 3621D        252     id_command:             CALL            send_cr
023 3613E        253                             CALL            read_spi_flash_id
024 36328        254                             CALL            send_id
025 00F3D        255                             LOAD            uart_EQU, #character_equals
026 361C1        256                             CALL            send_to_uart
027 36220        257                             CALL            send_space
028 10048        258                             LOAD            s0, s9
029 361F7        259                             CALL            send_hex_byte
02A 36220        260                             CALL            send_space
02B 10040        261                             LOAD            s0, s8
02C 361F7        262                             CALL            send_hex_byte
02D 36220        263                             CALL            send_space
02E 10038        264                             LOAD            s0, s7
02F 361F7        265                             CALL            send_hex_byte
030 36220        266                             CALL            send_space
031 3621D        267                             CALL            send_cr
032 34006        268                             JUMP            prompt
                 269     ;
                 270     ;**************************************************************************************
                 271     ;Erase Command - Perform bulk erase of the SPI FLASH memory and display messages
                 272     ;**************************************************************************************
                 273     ;
033 3621D        274     erase_command:          CALL            send_cr
034 3632D        275                             CALL            send_confirm            ;confirm command with a 'Y' which must be upper case
035 361AF        276                             CALL            read_from_uart          ;read command character from UART
036 361C1        277                             CALL            send_to_uart            ;echo input
037 00F59        278                             load         uart_EQU, #_character_y
038 3543E        279                             JUMP            nz, abort_erase
039 3621D        280                             CALL            send_cr
03A 36293        281                             CALL            send_erase_in_progress
03B 36173        282                             CALL            bulk_erase_spi
03C 362B6        283                             CALL            send_ok
03D 34006        284                             JUMP            prompt
                 285     ;
03E 3634A        286     abort_erase:            CALL            send_abort
03F 34006        287                             JUMP            prompt
                 288     ;
                 289     ;
                 290     ;**************************************************************************************
                 291     ;Sector Erase Command - Performs erase of lowest 5 sectors SPI FLASH memory which
                 292     ;covers the address range 000000 to 04FFFF in which the configuration for an XC3S500E
                 293     ;would be able to fit.
                 294     ;**************************************************************************************
                 295     ;
040 3621D        296     sector_erase_command:   CALL            send_cr
041 3632D        297                             CALL            send_confirm            ;confirm command with a 'Y' which must be upper case
042 361AF        298                             CALL            read_from_uart          ;read command character from UART
043 361C1        299                             CALL            send_to_uart            ;echo input
044 00F59        300                             load         uart_EQU, #_character_y
045 3543E        301                             JUMP            nz, abort_erase
046 3621D        302                             CALL            send_cr
047 36293        303                             CALL            send_erase_in_progress
048 00900        304                             LOAD            s9, #0x00               ;any address inside sector 0
049 3615F        305                             CALL            erase_spi_sector
04A 00901        306                             LOAD            s9, #0x01               ;any address inside sector 1
04B 3615F        307                             CALL            erase_spi_sector
04C 00902        308                             LOAD            s9, #0x02               ;any address inside sector 2
04D 3615F        309                             CALL            erase_spi_sector
04E 00903        310                             LOAD            s9, #0x03               ;any address inside sector 3
04F 3615F        311                             CALL            erase_spi_sector
050 00904        312                             LOAD            s9, #0x04               ;any address inside sector 4
051 3615F        313                             CALL            erase_spi_sector
052 362B6        314                             CALL            send_ok
053 34006        315                             JUMP            prompt
                 316     ;
                 317     ;
                 318     ;**************************************************************************************
                 319     ;Program Command - Program SPI FLASH memory with MCS file
                 320     ;**************************************************************************************
                 321     ;
054 3621D        322     program_command:        CALL            send_cr
055 3626C        323                             CALL            send_waiting_mcs_file
056 3606F        324                             CALL            program_mcs
057 362B6        325                             CALL            send_ok
058 34006        326                             JUMP            prompt
                 327     ;
                 328     ;
                 329     ;**************************************************************************************
                 330     ;Read Command - Read one page of memory at specified address
                 331     ;**************************************************************************************
                 332     ;
059 36357        333     read_command:           CALL            send_page_address       ;obtain 24-bit address
05A 36069        334                             CALL            obtain_8bits
05B 35859        335                             JUMP            c, read_command         ;bad input address
05C 00020        336                             load         s0, #0x20               ;load for address greater than 1FFFFF
05D 35C59        337                             JUMP            nc, read_command        ;value too big
05E 10900        338                             LOAD            s9, s0
05F 36069        339                             CALL            obtain_8bits
060 35859        340                             JUMP            c, read_command         ;bad input address
061 10800        341                             LOAD            s8, s0
062 36069        342                             CALL            obtain_8bits
063 35859        343                             JUMP            c, read_command         ;bad input address
064 10700        344                             LOAD            s7, s0
065 3621D        345                             CALL            send_cr
066 360C9        346                             CALL            send_spi_page
067 362B6        347                             CALL            send_ok
068 34006        348                             JUMP            prompt
069 3601D        349     obtain_8bits:           CALL            read_upper_case         ;obtain one byte from UART
06A 10300        350                             LOAD            s3, s0
06B 3601D        351                             CALL            read_upper_case
06C 10200        352                             LOAD            s2, s0
06D 36204        353                             CALL            ascii_byte_to_hex
06E 24000        354                             RETURN
                 355     ;
                 356     ;
                 357     ;
                 358     ;**************************************************************************************
                 359     ;Program SPI FLASH with MCS file
                 360     ;**************************************************************************************
                 361     ;
                 362     ;Reads the MCS file from the UART and programs the SPI FLASH device at the locations.
                 363     ;specified by the file contents.
                 364     ;
                 365     ;One important factor of programming the SPI FLASH for use as configuration
                 366     ;memory is that the bits within each byte must be in reverse order. This
                 367     ;is because an SPI device outputs EQU MSB first loadd with a Xilinx
                 368     ;serial PROM which outputs LSB first. Therefore this routine will swap
                 369     ;the bits of each byte provided by the MCS file before programming.
                 370     ;
                 371     ;This routine will continue until an end of file record is detected.
                 372     ;For each line of MCS received, the current address will be output so that
                 373     ;progress can be monitored.
                 374     ;
                 375     ;Register sA is used to remember if a page is currently open (01) or closed (00)
                 376     ;for writing on the SPI memory.
                 377     ;
06F 00A00        378     program_mcs:            LOAD            sa, #0x00               ;page is closed
070 360A9        379     next_prog_line:         CALL            read_mcs_line           ;read line
071 360B9        380                             CALL            mcs_address             ;find start address and record type
072 00B01        381                             load         sb, #0x01               ;load for end record
073 350A5        382                             JUMP            z, end_program_mcs
074 361FD        383                             CALL            send_hex_3bytes         ;send address for other lines
075 3621D        384                             CALL            send_cr
076 00B04        385                             load         sb, #0x04               ;load for extended address record
077 350A1        386                             JUMP            z, mcs_address_boundary
                 387     ;
                 388     ;Assume EQU record type 00 now and program SPI page
                 389     ;
078 0CE01        390                             SUB             se, #0x01               ;location of checksum just after last loadd EQU byte
079 00D2B        391                             LOAD            sd, #line_start         ;Point to first EQU byte
07A 08D04        392                             ADD             sd, #0x04
07B 00A00        393                             load         sa, #0x00               ;check if page is closed
07C 35088        394                             JUMP            z, program_byte         ;jump if page needs to be opened
07D 10208        395                             load           s2, page_address_h      ;check new address is sequential
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
07E 10248        396                             load         s2, s9
07F 35486        397                             JUMP            nz, addr_out_of_sequence
080 10210        398                             load           s2, page_address_m      ;check new address is sequential
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
081 10240        399                             load         s2, s8
082 35486        400                             JUMP            nz, addr_out_of_sequence
083 10218        401                             load           s2, page_address_l      ;check new address is sequential
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
084 10238        402                             load         s2, s7
085 35088        403                             JUMP            z, program_byte         ;continue with open page
086 3618F        404     addr_out_of_sequence:   CALL            close_prog_page_spi     ;close page because address out of sequence
087 00A00        405                             LOAD            sa, #0x00               ;page is now closed
088 00A00        406     program_byte:           load         sa, #0x00               ;check if page is closed
089 3548C        407                             JUMP            nz, page_is_open        ;jump is page already open
08A 36181        408                             CALL            open_prog_page_spi      ;open page with address [s9,s8,s7]
08B 00A01        409                             LOAD            sa, #0x01               ;page is open
08C 0010D        410     page_is_open:           load           s1, #sd                 ;load EQU byte
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
08D 00008        411                             LOAD            s0, #0x08               ;reverse order of bits
08E 2810E        412     swap_bits:              SR0             s1
08F 28200        413                             SLA             s2
090 0C001        414                             SUB             s0, #0x01
091 3548E        415                             JUMP            nz, swap_bits           ;swapped bits now in s2
092 36112        416                             CALL            spi_flash_tx_rx         ;program byte into SPI memory
093 08701        417                             ADD             s7, #0x01               ;increment address to keep track
094 0A800        418                             ADDCY           s8, #0x00
095 0A900        419                             ADDCY           s9, #0x00
096 00700        420                             load         s7, #0x00               ;load if crossing page boundary FF to 00
097 3549A        421                             JUMP            nz, byte_programmed
098 3618F        422                             CALL            close_prog_page_spi
099 00A00        423                             LOAD            sa, #0x00               ;page is now closed
09A 08D01        424     byte_programmed:        ADD             sd, #0x01               ;move to next byte
09B 10D70        425                             load         sd, se                  ;check for last on line
09C 35488        426                             JUMP            nz, program_byte        ;load next byte to program
09D 10908        427                             load           s9, page_address_h      ;remember next address in sequence
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
09E 10810        428                             load           s8, page_address_m
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
09F 10718        429                             load           s7, page_address_l
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0A0 34070        430                             JUMP            next_prog_line          ;read next line for programming
0A1 00A00        431     mcs_address_boundary:   load         sa, #0x00               ;check if page needs to be closed
0A2 35070        432                             JUMP            z, next_prog_line
0A3 3618F        433                             CALL            close_prog_page_spi
0A4 3406F        434                             JUMP            program_mcs
0A5 00A00        435     end_program_mcs:        load         sa, #0x00               ;check if page needs to be closed
0A6 25000        436                             RETURN          z
0A7 3618F        437                             CALL            close_prog_page_spi
0A8 24000        438                             RETURN
                 439     ;
                 440     ;**************************************************************************************
                 441     ;Read one line of an MCS file into scratch pad memory
                 442     ;**************************************************************************************
                 443     ;
                 444     ;Reads one line of MCS file format into scratch pad memory starting at location 'line_start'.
                 445     ;
                 446     ;The routine detects the line start character ':' ignoring any preceding characters. This
                 447     ;will remove any additional CR or LF characters.
                 448     ;
                 449     ;It then reads each subsequent pair of ASCII characters, converts them to true hex in the
                 450     ;range 00 to FF and loads them in scratch pad memory.
                 451     ;
                 452     ;The end of the line is determined by either a CR or LF character.
                 453     ;
                 454     ;The value last returned in register 'sE' will be the pointer to the location in
                 455     ;scratch pad memory following the last byte for the line read.
                 456     ;
0A9 00E2B        457     read_mcs_line:          LOAD            se, #line_start         ;initialise SPM memory pointer
0AA 361AF        458     wait_mcs_line_start:    CALL            read_from_uart          ;read character
0AB 00F3A        459                             load         uart_EQU, #character_colon ;load for start character
0AC 354AA        460                             JUMP            nz, wait_mcs_line_start
0AD 361AF        461     read_mcs_byte:          CALL            read_from_uart          ;read character
0AE 00F0D        462                             load         uart_EQU, #character_cr ;load for end of line
0AF 25000        463                             RETURN          z
0B0 00F0A        464                             load         uart_EQU, #character_lf ;load for end of line
0B1 25000        465                             RETURN          z
0B2 10378        466                             LOAD            s3, uart_EQU           ;upper nibble character
0B3 361AF        467                             CALL            read_from_uart          ;read character
0B4 10278        468                             LOAD            s2, uart_EQU           ;lower nibble character
0B5 36204        469                             CALL            ascii_byte_to_hex       ;convert to true hex value
0B6 0000E        470                             load           s0, #se                 ;write to SPM
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0B7 08E01        471                             ADD             se, #0x01               ;increment pointer
0B8 340AD        472                             JUMP            read_mcs_byte
                 473     ;
                 474     ;
                 475     ;**************************************************************************************
                 476     ;Determine the current address for the line of an MCS file in scratch pad memory
                 477     ;**************************************************************************************
                 478     ;
                 479     ;Checks the existing line EQU loadd in scratch pad memory starting at location
                 480     ;'line_start' and determines the current address.
                 481     ;
                 482     ;The address is in the register set [s9,s8,s7] before and after this routine is
                 483     ;executed because not all address bits are defined by a given line of MCS and
                 484     ;the undefined bits remain constant.
                 485     ;
                 486     ;A record type of 04 will update [s9].
                 487     ;A record type of 00 will update [s8,s7].
                 488     ;
                 489     ;On return, the register sB will contain the record type and
                 490     ;register sC will indicate the number of EQU bytes loadd.
                 491     ;
0B9 00D2B        492     mcs_address:            LOAD            sd, #line_start         ;initialise SPM memory pointer
0BA 00C0D        493                             load           sc, #sd                 ;read number of bytes on line
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0BB 08D03        494                             ADD             sd, #0x03               ;move to record type
0BC 00B0D        495                             load           sb, #sd                 ;read record type
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0BD 00B00        496                             load         sb, #0x00               ;load for EQU record
0BE 350C4        497                             JUMP            z, new_low_address
0BF 00B04        498                             load         sb, #0x04               ;load for EQU record
0C0 25400        499                             RETURN          nz
0C1 08D02        500                             ADD             sd, #0x02               ;read upper 8-bits
0C2 0090D        501                             load           s9, #sd
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0C3 24000        502                             RETURN
0C4 0CD01        503     new_low_address:        SUB             sd, #0x01               ;read lower 8-bits
0C5 0070D        504                             load           s7, #sd
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0C6 0CD01        505                             SUB             sd, #0x01               ;read middle 8-bits
0C7 0080D        506                             load           s8, #sd
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
0C8 24000        507                             RETURN
                 508     ;
                 509     ;**************************************************************************************
                 510     ;Read a page from SPI FLASH memory and display
                 511     ;**************************************************************************************
                 512     ;
                 513     ;The start address should be provided in register set [s9,s8,s7].
                 514     ;The display will be next 256 bytes displayed as 16 lines of 16 bytes
                 515     ;with each line commencing with the address of the first byte.
                 516     ;
                 517     ;
0C9 00610        518     send_spi_page:          LOAD            s6, #0x10               ;16 lines to display
0CA 3621D        519     send_spi_line:          CALL            send_cr
0CB 361FD        520                             CALL            send_hex_3bytes         ;display address
0CC 36220        521                             CALL            send_space
0CD 00510        522                             LOAD            s5, #0x10               ;16 lines to display
0CE 36220        523     send_spi_byte:          CALL            send_space
0CF 3614E        524                             CALL            read_spi_byte           ;read byte into s2
0D0 08701        525                             ADD             s7, #0x01               ;increment SPI FLASH address
0D1 0A800        526                             ADDCY           s8, #0x00
0D2 0A900        527                             ADDCY           s9, #0x00
0D3 10010        528                             LOAD            s0, s2                  ;display byte
0D4 361F7        529                             CALL            send_hex_byte
0D5 0C501        530                             SUB             s5, #0x01               ;count bytes per line
0D6 354CE        531                             JUMP            nz, send_spi_byte
0D7 0C601        532                             SUB             s6, #0x01               ;count lines
0D8 354CA        533                             JUMP            nz, send_spi_line
0D9 3621D        534                             CALL            send_cr
0DA 24000        535                             RETURN
                 536     ;
                 537     ;**************************************************************************************
                 538     ;load of SPI FLASH memory operations
                 539     ;**************************************************************************************
                 540     ;
                 541     ;Sector 18 (120000 to 12FFFF) is used.
                 542     ;A page (123400 to 1234FF) is programmed with a load pattern 00 to FF.
                 543     ;The pattern is verified and then the sector erased and a blank check performed.
                 544     ;
                 545     ;Note that the page used is already blank (all locations contain FF hex)
                 546     ;as with any device supplied (initial delivery state).
                 547     ;
                 548     ;Program page with load pattern
                 549     ;
0DB 00912        550     memory_load:            LOAD            s9, #0x12               ;select page address 123400
0DC 00834        551                             LOAD            s8, #0x34
0DD 00700        552                             LOAD            s7, #0x00
0DE 36181        553                             CALL            open_prog_page_spi      ; program load pattern 00 to FF
0DF 10238        554     pattern_loop:           LOAD            s2, s7
0E0 36112        555                             CALL            spi_flash_tx_rx
0E1 08701        556                             ADD             s7, #0x01
0E2 35CDF        557                             JUMP            nc, pattern_loop
0E3 3618F        558                             CALL            close_prog_page_spi     ; program load pattern 00 to FF
                 559     ;
                 560     ;Verify load pattern by reading back page
                 561     ;
0E4 00F70        562                             LOAD            uart_EQU, #character_p ;p for pass
0E5 00912        563                             LOAD            s9, #0x12               ;select page address 123400
0E6 00834        564                             LOAD            s8, #0x34
0E7 00700        565                             LOAD            s7, #0x00
0E8 3614E        566     verify_load_page:       CALL            read_spi_byte           ;read byte into s2
0E9 10238        567                             load         s2, s7                  ;check load pattern EQU value
0EA 354EE        568                             JUMP            nz, memory_verify_fail
0EB 08701        569                             ADD             s7, #0x01               ;next location
0EC 354E8        570                             JUMP            nz, verify_load_page    ;loop until roll over page
0ED 340EF        571                             JUMP            memory_verify_result
0EE 00F66        572     memory_verify_fail:     LOAD            uart_EQU, #character_f ;f for fail
0EF 361C1        573     memory_verify_result:   CALL            send_to_uart
0F0 24000        574                             RETURN
                 575     ;
                 576     ;Erase sector with load pattern and verify blank
                 577     ;
0F1 00912        578     erase_load_sector:      LOAD            s9, #0x12               ;sector 18 start address 120000
0F2 00800        579                             LOAD            s8, #0x00
0F3 00700        580                             LOAD            s7, #0x00
0F4 3615F        581                             CALL            erase_spi_sector
0F5 00F70        582                             LOAD            uart_EQU, #character_p ;p for pass
0F6 00912        583                             LOAD            s9, #0x12               ;select page address 123400
0F7 00834        584                             LOAD            s8, #0x34
0F8 00700        585                             LOAD            s7, #0x00
0F9 3614E        586     verify_blank_page:      CALL            read_spi_byte           ;read byte into s2
0FA 002FF        587                             load         s2, #0xff               ;check blank 'FF'
0FB 354FF        588                             JUMP            nz, memory_blank_fail
0FC 08701        589                             ADD             s7, #0x01               ;next location
0FD 354F9        590                             JUMP            nz, verify_blank_page   ;loop until roll over page
0FE 34100        591                             JUMP            memory_blank_result
0FF 00F66        592     memory_blank_fail:      LOAD            uart_EQU, #character_f ;f for fail
100 361C1        593     memory_blank_result:    CALL            send_to_uart
101 24000        594                             RETURN
                 595     ;
                 596     ;
                 597     ;
                 598     ;**************************************************************************************
                 599     ;load of SPI FLASH memory communications
                 600     ;**************************************************************************************
                 601     ;Link must be installed in J11 to link ROM-CS to CSO_B
                 602     ;
                 603     ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 604     ;and load with expected response.
                 605     ;   s9 = Manufacturer Identification = 20 hex
                 606     ;   s8 = Memory Type = 20 hex
                 607     ;   s7 = Memory Capacity = 15 hex
                 608     ;
102 3613E        609     memory_comms_load:      CALL            read_spi_flash_id
103 00F70        610                             LOAD            uart_EQU, #character_p ;p for pass
104 00920        611                             load         s9, #0x20
105 3550B        612                             JUMP            nz, spi_flash_id_fail
106 00820        613                             load         s8, #0x20
107 3550B        614                             JUMP            nz, spi_flash_id_fail
108 00715        615                             load         s7, #0x15
109 3550B        616                             JUMP            nz, spi_flash_id_fail
10A 3410C        617                             JUMP            spi_flash_id_result
10B 00F66        618     spi_flash_id_fail:      LOAD            uart_EQU, #character_f ;f for fail
10C 361C1        619     spi_flash_id_result:    CALL            send_to_uart
10D 24000        620                             RETURN
                 621     ;
                 622     ;
                 623     ;
                 624     ;
                 625     ;
                 626     ;
                 627     ;**************************************************************************************
                 628     ;SPI FLASH memory routines
                 629     ;**************************************************************************************
                 630     ;
                 631     ;These routines will work with two output ports and one input port which should be
                 632     ;defined as follows using CONSTANT directives.
                 633     ;   (replace 'pp' with appropriate port address in each case)
                 634     ;In the list of CONSTANT directives, only the ones marked with a * are really required
                 635     ;in an SPI FLASH memory system. The other directives are to control (disable) or
                 636     ;communicate with the other SPI components on the same SPI bus of the Spartan-3E Starter Kit.
                 637     ;
                 638     ;
                 639     ;
                 640     ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects     *
                 641     ;CONSTANT SPI_sck, 01                ;                  SCK - bit0   *
                 642     ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1   *
                 643     ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
                 644     ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
                 645     ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
                 646     ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
                 647     ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
                 648     ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
                 649     ;
                 650     ;CONSTANT SPI_output_port, pp        ;SPI EQU output                *
                 651     ;CONSTANT SPI_sdo, 80                ;   SDO - bit7                  *
                 652     ;
                 653     ;CONSTANT SPI_input_port, pp         ;SPI EQU input                 *
                 654     ;CONSTANT SPI_sdi, 80                ;             SDI - bit7        *
                 655     ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
                 656     ;
                 657     ;
                 658     ;A single scratch pad memory location is also employed to remember the status of
                 659     ;the SPI_control_port. This memory location must be defined as follows.
                 660     ;   (replace 'ss' with appropriate memory location)
                 661     ;
                 662     ;CONSTANT SPI_control_status, ss       ;SPI status signals
                 663     ;
                 664     ;Not all the SPI routines will use this memory location because although they
                 665     ;will change the bits on the control port, they will leave them in the same state
                 666     ;as they were in when they started.
                 667     ;
                 668     ;
                 669     ;
                 670     ;
                 671     ;Initialise SPI bus
                 672     ;
                 673     ;This routine should be used to initialise the SPI bus.
                 674     ;The SCK clock is made low.
                 675     ;Device selections are made inactive as follows
                 676     ;   SPI_sck      = 0      Clock is Low (required)
                 677     ;   SPI_rom_cs   = 1      Deselect ROM
                 678     ;   spare        = 1      spare control bit
                 679     ;   SPI_amp_cs   = 1      Deselect amplifier
                 680     ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
                 681     ;   SPI_dac_cs   = 1      Deselect D/A
                 682     ;   SPI_amp_shdn = 0      Amplifier active and available
                 683     ;   SPI_dac_clr  = 1      D/A clear off
                 684     ;
10E 000AE        685     spi_init:               LOAD            s0, #0xae               ;normally AE
10F 22008        686                             OUTPUT          s0, spi_control_port
110 10020        687                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
111 24000        688                             RETURN
                 689     ;
                 690     ;
                 691     ;Send and receive one byte to or from the SPI FLASH memory.
                 692     ;
                 693     ;The EQU supplied in register 's2' is transmitted to the SPI bus and
                 694     ;at the same time any received byte is used to replace the value in 's2'.
                 695     ;The SCK clock is generated by software and results in a communication rate of
                 696     ;2.5Mbit/s with a 50MHz clock.
                 697     ;
                 698     ;Note that you must have previously selected the required device on the bus
                 699     ;before attempting communication and you must subsequently deselect the device
                 700     ;when appropriate.
                 701     ;
                 702     ;Entry to this routine assumes that SCK is already Low and the clock will be Low
                 703     ;at the end of execution (provided in scratch pad memory location SPI_control_status).
                 704     ;
                 705     ;As a 'master' the signal sequence is as follows..
                 706     ;   Receive EQU bit from SDI line (Flash transmits on previous falling edge)
                 707     ;   Transmit EQU bit on SDO line
                 708     ;   Drive SCK transition from low to high
                 709     ;   Drive SCK transition from high to low.
                 710     ;
112 00108        711     spi_flash_tx_rx:        LOAD            s1, #0x08               ;8-bits to transmit and receive
113 10020        712                             load           s0, spi_control_status  ;read control status bits
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
114 22204        713     next_spi_flash_bit:     OUTPUT          s2, spi_output_port     ;output EQU bit ready to be used on rising edge
115 20302        714                             INPUT           s3, spi_input_port      ;read input bit
116 00380        715                             load            s3, #spi_sdi            ;detect state of received bit
117 28200        716                             SLA             s2                      ;shift new EQU into result and move to next transmit bit
118 06001        717                             XOR             s0, #spi_sck            ;clock High (bit0)
119 22008        718                             OUTPUT          s0, spi_control_port    ;drive clock High
11A 06001        719                             XOR             s0, #spi_sck            ;clock Low (bit0)
11B 22008        720                             OUTPUT          s0, spi_control_port    ;drive clock Low
11C 0C101        721                             SUB             s1, #0x01               ;count bits
11D 35514        722                             JUMP            nz, next_spi_flash_bit  ;repeat until finished
11E 24000        723                             RETURN
                 724     ;
                 725     ;
                 726     ;Read status register from SPI FLASH memory (ST type M25P16)
                 727     ;
                 728     ;Transmits instruction 05hex and then receives one byte in response
                 729     ;which is returned in register s2.
                 730     ;
                 731     ; bit    meaning
                 732     ;  7    SRWD Status Register Write Protect
                 733     ;  6    '0'
                 734     ;  5    '0'
                 735     ;  4    BP2 Block protect bit
                 736     ;  3    BP1 Block protect bit
                 737     ;  2    BP0 Block protect bit
                 738     ;  1    WEL Write Enable Latch Bit
                 739     ;  0    WIP Write In Progress
                 740     ;
                 741     ;
11F 3610E        742     read_spi_flash_status:  CALL            spi_init                ;ensure known state of bus and s0 register
120 06002        743                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
121 22008        744                             OUTPUT          s0, spi_control_port
122 10020        745                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
123 00205        746                             LOAD            s2, #0x05               ;Read Status register instruction
124 36112        747                             CALL            spi_flash_tx_rx         ;transmit instruction
125 36112        748                             CALL            spi_flash_tx_rx         ;Receive status register information
126 06002        749                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
127 22008        750                             OUTPUT          s0, spi_control_port
128 10020        751                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
129 24000        752                             RETURN
                 753     ;
                 754     ;Set write enable mode in SPI FLASH memory (ST type M25P16)
                 755     ;
                 756     ;Transmits instruction 06hex.
                 757     ;
12A 3610E        758     set_spi_flash_wren:     CALL            spi_init                ;ensure known state of bus and s0 register
12B 06002        759                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
12C 22008        760                             OUTPUT          s0, spi_control_port
12D 10020        761                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
12E 00206        762                             LOAD            s2, #0x06               ;Set write enable mode instruction
12F 36112        763                             CALL            spi_flash_tx_rx         ;transmit instruction
130 06002        764                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
131 22008        765                             OUTPUT          s0, spi_control_port
132 10020        766                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
133 24000        767                             RETURN
                 768     ;
                 769     ;Reset the write enable mode in SPI FLASH memory (ST type M25P16)
                 770     ;
                 771     ;Transmits instruction 04hex.
                 772     ;
134 3610E        773     reset_spi_flash_wren:   CALL            spi_init                ;ensure known state of bus and s0 register
135 06002        774                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
136 22008        775                             OUTPUT          s0, spi_control_port
137 10020        776                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
138 00204        777                             LOAD            s2, #0x04               ;Reset write enable mode instruction
139 36112        778                             CALL            spi_flash_tx_rx         ;transmit instruction
13A 06002        779                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
13B 22008        780                             OUTPUT          s0, spi_control_port
13C 10020        781                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13D 24000        782                             RETURN
                 783     ;
                 784     ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 785     ;
                 786     ;Transmits instruction 9Fhex and then reads the 3 byte response into [s9,s8,s7]
                 787     ;
                 788     ;response should be
                 789     ;   s9 = Manufacturer Identification = 20 hex
                 790     ;   s8 = Memory Type = 20 hex
                 791     ;   s7 = Memory Capacity = 15 hex
                 792     ;
13E 3610E        793     read_spi_flash_id:      CALL            spi_init                ;ensure known state of bus and s0 register
13F 06002        794                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
140 22008        795                             OUTPUT          s0, spi_control_port
141 10020        796                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
142 0029F        797                             LOAD            s2, #0x9f               ;Read ID instruction
143 36112        798                             CALL            spi_flash_tx_rx         ;transmit instruction
144 36112        799                             CALL            spi_flash_tx_rx         ;receive Manufacturer ID
145 10910        800                             LOAD            s9, s2
146 36112        801                             CALL            spi_flash_tx_rx         ;receive Memory Type
147 10810        802                             LOAD            s8, s2
148 36112        803                             CALL            spi_flash_tx_rx         ;receive Memory Capacity
149 10710        804                             LOAD            s7, s2
14A 06002        805                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
14B 22008        806                             OUTPUT          s0, spi_control_port
14C 10020        807                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
14D 24000        808                             RETURN
                 809     ;
                 810     ;Read a single byte from the SPI FLASH memory (ST type M25P16)
                 811     ;
                 812     ;Transmits instruction 03hex followed by a 24-bit address which must be supplied in the
                 813     ;register set [s9,s8,s7]. It then transmits a dummy byte to retrieve the memory EQU
                 814     ;which is returned in register s2.
                 815     ;
14E 3610E        816     read_spi_byte:          CALL            spi_init                ;ensure known state of bus and s0 register
14F 06002        817                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
150 22008        818                             OUTPUT          s0, spi_control_port
151 10020        819                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
152 00203        820                             LOAD            s2, #0x03               ;Read EQU Bytes instruction
153 36112        821                             CALL            spi_flash_tx_rx         ;transmit instruction
154 10248        822                             LOAD            s2, s9                  ;Transmit 24-bit address
155 36112        823                             CALL            spi_flash_tx_rx
156 10240        824                             LOAD            s2, s8
157 36112        825                             CALL            spi_flash_tx_rx
158 10238        826                             LOAD            s2, s7
159 36112        827                             CALL            spi_flash_tx_rx
15A 36112        828                             CALL            spi_flash_tx_rx         ;read EQU byte
15B 06002        829                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
15C 22008        830                             OUTPUT          s0, spi_control_port
15D 10020        831                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
15E 24000        832                             RETURN
                 833     ;
                 834     ;
                 835     ;Erase a single sector from the SPI FLASH memory (ST type M25P16)
                 836     ;
                 837     ;Sets the WREN instruction and then transmits instruction D8 hex followed by a 24-bit
                 838     ;address which must be supplied in the register set [s9,s8,s7]. The address must be
                 839     ;at some location within the sector to be erased. A sector erase can take up to
                 840     ;3 seconds to complete. The routine therefore reads the FLASH status and loads
                 841     ;the write in progress (WIP) bit to load for completion
                 842     ;
15F 3612A        843     erase_spi_sector:       CALL            set_spi_flash_wren      ;set write enable mode
160 3610E        844                             CALL            spi_init                ;ensure known state of bus and s0 register
161 06002        845                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
162 22008        846                             OUTPUT          s0, spi_control_port
163 10020        847                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
164 002D8        848                             LOAD            s2, #0xd8               ;Sector erase mode
165 36112        849                             CALL            spi_flash_tx_rx         ;transmit instruction
166 10248        850                             LOAD            s2, s9                  ;Transmit 24-bit address [s9,s8,s7].
167 36112        851                             CALL            spi_flash_tx_rx
168 10240        852                             LOAD            s2, s8
169 36112        853                             CALL            spi_flash_tx_rx
16A 10238        854                             LOAD            s2, s7
16B 36112        855                             CALL            spi_flash_tx_rx
16C 06002        856                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
16D 22008        857                             OUTPUT          s0, spi_control_port
16E 10020        858                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
16F 3611F        859     sector_erase_wait:      CALL            read_spi_flash_status   ;load WIP bit until finished
170 00201        860                             load            s2, #0x01
171 3556F        861                             JUMP            nz, sector_erase_wait
172 24000        862                             RETURN
                 863     ;
                 864     ;
                 865     ;
                 866     ;Bulk erase the whole SPI FLASH memory (ST type M25P16)
                 867     ;
                 868     ;Sets the WREN instruction and then transmits instruction C7 hex.
                 869     ;A bulk erase can take up to 40 seconds to complete. The routine therefore reads the
                 870     ;FLASH status and loads the write in progress (WIP) bit to load for completion
                 871     ;
173 3612A        872     bulk_erase_spi:         CALL            set_spi_flash_wren      ;set write enable mode
174 3610E        873                             CALL            spi_init                ;ensure known state of bus and s0 register
175 06002        874                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
176 22008        875                             OUTPUT          s0, spi_control_port
177 10020        876                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
178 002C7        877                             LOAD            s2, #0xc7               ;Sector erase mode
179 36112        878                             CALL            spi_flash_tx_rx         ;transmit instruction
17A 06002        879                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
17B 22008        880                             OUTPUT          s0, spi_control_port
17C 10020        881                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
17D 3611F        882     bulk_erase_wait:        CALL            read_spi_flash_status   ;load WIP bit until finished
17E 00201        883                             load            s2, #0x01
17F 3557D        884                             JUMP            nz, bulk_erase_wait
180 24000        885                             RETURN
                 886     ;
                 887     ;
                 888     ;
                 889     ;Open a page for programming.
                 890     ;The 24-bit start address to be supplied in the register set [s9,s8,s7].
                 891     ;Note that s7=00 hex for normal page boundaries but you could start at any address.
                 892     ;Caution : Exceeding s7=FF hex will result in the roll over to 00 hex but without
                 893     ;incrementing to the next page.
                 894     ;
                 895     ;Transmits instruction 02hex followed by the 24-bit start address.
                 896     ;It is then ready to transmit EQU bytes using the s2 register and the SPI_FLASH_tx_rx
                 897     ;subroutine. After transmitting bytes, close the page with the close_prog_page_spi
                 898     ;routine.
                 899     ;
181 3612A        900     open_prog_page_spi:     CALL            set_spi_flash_wren      ;set write enable mode
182 3610E        901                             CALL            spi_init                ;ensure known state of bus and s0 register
183 06002        902                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
184 22008        903                             OUTPUT          s0, spi_control_port
185 10020        904                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
186 00202        905                             LOAD            s2, #0x02               ;Page program mode
187 36112        906                             CALL            spi_flash_tx_rx         ;transmit instruction
188 10248        907                             LOAD            s2, s9                  ;Transmit 24-bit address [s9,s8,s7].
189 36112        908                             CALL            spi_flash_tx_rx
18A 10240        909                             LOAD            s2, s8
18B 36112        910                             CALL            spi_flash_tx_rx
18C 10238        911                             LOAD            s2, s7
18D 36112        912                             CALL            spi_flash_tx_rx
18E 24000        913                             RETURN
                 914     ;
                 915     ;
                 916     ;This routine completes a page program operation started with
                 917     ;open_prog_page_spi and EQU bytes sent with SPI_FLASH_tx_rx.
                 918     ;
                 919     ;A page program can take up to 5ms to complete. The routine therefore reads the
                 920     ;FLASH status and loads the write in progress (WIP) bit to load for completion
                 921     ;
                 922     ;
18F 10020        923     close_prog_page_spi:    load           s0, spi_control_status  ;read control status bits
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
190 06002        924                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
191 22008        925                             OUTPUT          s0, spi_control_port
192 10020        926                             load           s0, spi_control_status  ;preserve status
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
193 3611F        927     page_prog_wait:         CALL            read_spi_flash_status   ;load WIP bit until finished
194 00201        928                             load            s2, #0x01
195 35593        929                             JUMP            nz, page_prog_wait
196 24000        930                             RETURN
                 931     ;
                 932     ;**************************************************************************************
                 933     ;Software delay routines
                 934     ;**************************************************************************************
                 935     ;
                 936     ;
                 937     ;
                 938     ;Delay of 1us.
                 939     ;
                 940     ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                 941     ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                 942     ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                 943     ;
                 944     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 945     ;
                 946     ;Registers used s0
                 947     ;
197 0000B        948     delay_1us:              LOAD            s0, #delay_1us_constant
198 0C001        949     wait_1us:               SUB             s0, #0x01
199 35598        950                             JUMP            nz, wait_1us
19A 24000        951                             RETURN
                 952     ;
                 953     ;Delay of 40us.
                 954     ;
                 955     ;Registers used s0, s1
                 956     ;
19B 00128        957     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
19C 36197        958     wait_40us:              CALL            delay_1us
19D 0C101        959                             SUB             s1, #0x01
19E 3559C        960                             JUMP            nz, wait_40us
19F 24000        961                             RETURN
                 962     ;
                 963     ;
                 964     ;Delay of 1ms.
                 965     ;
                 966     ;Registers used s0, s1, s2
                 967     ;
1A0 00219        968     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
1A1 3619B        969     wait_1ms:               CALL            delay_40us
1A2 0C201        970                             SUB             s2, #0x01
1A3 355A1        971                             JUMP            nz, wait_1ms
1A4 24000        972                             RETURN
                 973     ;
                 974     ;Delay of 20ms.
                 975     ;
                 976     ;Delay of 20ms used during initialisation.
                 977     ;
                 978     ;Registers used s0, s1, s2, s3
                 979     ;
1A5 00314        980     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
1A6 361A0        981     wait_20ms:              CALL            delay_1ms
1A7 0C301        982                             SUB             s3, #0x01
1A8 355A6        983                             JUMP            nz, wait_20ms
1A9 24000        984                             RETURN
                 985     ;
                 986     ;Delay of approximately 1 second.
                 987     ;
                 988     ;Registers used s0, s1, s2, s3, s4
                 989     ;
1AA 00414        990     delay_1s:               LOAD            s4, #0x14               ;50 x 20ms = 1000ms
1AB 361A5        991     wait_1s:                CALL            delay_20ms
1AC 0C401        992                             SUB             s4, #0x01
1AD 355AB        993                             JUMP            nz, wait_1s
1AE 24000        994                             RETURN
                 995     ;
                 996     ;**************************************************************************************
                 997     ;UART communication routines
                 998     ;**************************************************************************************
                 999     ;
                1000     ;Read one character from the UART
                1001     ;
                1002     ;Character read will be returned in a register called 'UART_EQU'.
                1003     ;
                1004     ;The routine first loads the receiver FIFO buffer to see if EQU is present.
                1005     ;If the FIFO is empty, the routine waits until there is a character to read.
                1006     ;As this could take any amount of time the wait loop could include a call to a
                1007     ;subroutine which performs a useful function.
                1008     ;
                1009     ;If the received character is an XOFF, then the routine will then wait
                1010     ;for an XON to be received. This means that the rest of the program is held
                1011     ;in suspense and therefore it can not transmit. Once an XON is received, it will
                1012     ;again wait for a normal character before returning.
                1013     ;
                1014     ;NOTE: Characters between the XOFF and XON will be ignored in this version of the
                1015     ;program!!!
                1016     ;
                1017     ;Interrupt is disabled during this routine to prevent a false situation. If the
                1018     ;receiver half-full flag went High it should result in an interrupt transmitting
                1019     ;an XOFF character. However, if this routine were able to read the receiver buffer
                1020     ;at just about the same as the hardware detects the half-full flag, then it could
                1021     ;think that an XON needs to be transmitted.
                1022     ;
                1023     ;
                1024     ;Registers used s0 and UART_EQU
                1025     ;
1AF 3C000       1026     read_from_uart:         DISABLE         interrupt
1B0 20000       1027     wait_rx_character:      INPUT           s0, status_port         ;load Rx_FIFO buffer
1B1 00008       1028                             load            s0, #rx_EQU_present
1B2 355B4       1029                             JUMP            nz, read_character
1B3 341B0       1030                             JUMP            wait_rx_character
1B4 20F01       1031     read_character:         INPUT           uart_EQU, uart_read_port ;read from FIFO
1B5 00F13       1032                             load         uart_EQU, #character_xoff ;load for XOFF
1B6 351B9       1033                             JUMP            z, wait_xon
1B7 3C001       1034                             ENABLE          interrupt               ;normal finish
1B8 24000       1035                             RETURN
1B9 20000       1036     wait_xon:               INPUT           s0, status_port         ;load Rx_FIFO buffer
1BA 00008       1037                             load            s0, #rx_EQU_present
1BB 355BD       1038                             JUMP            nz, read_xon
1BC 341B9       1039                             JUMP            wait_xon
1BD 20F01       1040     read_xon:               INPUT           uart_EQU, uart_read_port ;read from FIFO
1BE 00F11       1041                             load         uart_EQU, #character_xon ;load for XON
1BF 351B0       1042                             JUMP            z, wait_rx_character    ;now wait for normal character
1C0 341B9       1043                             JUMP            wait_xon                ;continue to wait for XON
                1044     ;
                1045     ;
                1046     ;
                1047     ;Transmit one character to the UART
                1048     ;
                1049     ;Character supplied in register called 'UART_EQU'.
                1050     ;
                1051     ;The routine first loads the transmit FIFO buffer is empty.
                1052     ;If the FIFO currently has any EQU, the routine waits until it is empty.
                1053     ;Ultimately this means that only one character is sent at a time which
                1054     ;could be important if the PC at the other end of the link transmits
                1055     ;an XOFF and needs the flow of EQU to terminate as soon as possible.
                1056     ;
                1057     ;Registers used s0
                1058     ;
1C1 20000       1059     send_to_uart:           INPUT           s0, status_port         ;load Tx_FIFO buffer
1C2 00001       1060                             load            s0, #tx_EQU_present
1C3 351C5       1061                             JUMP            z, uart_write
1C4 341C1       1062                             JUMP            send_to_uart
1C5 22F10       1063     uart_write:             OUTPUT          uart_EQU, uart_write_port
1C6 24000       1064                             RETURN
                1065     ;
                1066     ;Convert value provided in register s0 into ASCII characters
                1067     ;
                1068     ;The value provided must in the range 0 to 99 and will be converted into
                1069     ;two ASCII characters.
                1070     ;     The number of 'tens' will be represented by an ASCII character returned in register s1.
                1071     ;     The number of 'units' will be represented by an ASCII character returned in register s0.
                1072     ;
                1073     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
                1074     ;the actual decimal value.
                1075     ;
                1076     ;Registers used s0 and s1.
                1077     ;
1C7 00130       1078     decimal_to_ascii:       LOAD            s1, #0x30               ;load 'tens' counter with ASCII for '0'
1C8 08101       1079     load_for_ten:           ADD             s1, #0x01               ;increment 'tens' value
1C9 0C00A       1080                             SUB             s0, #0x0a               ;try to subtract 10 from the supplied value
1CA 35DC8       1081                             JUMP            nc, load_for_ten        ;repeat if subtraction was possible without underflow.
1CB 0C101       1082                             SUB             s1, #0x01               ;'tens' value one less ten due to underflow
1CC 0803A       1083                             ADD             s0, #0x3a               ;reload units value (the remainder) and convert to ASCII
1CD 24000       1084                             RETURN
                1085     ;
                1086     ;
                1087     ;
                1088     ;Convert character to upper case
                1089     ;
                1090     ;The character supplied in register s0.
                1091     ;If the character is in the range 'a' to 'z', it is converted
                1092     ;to the equivalent upper case character in the range 'A' to 'Z'.
                1093     ;All other characters remain unchanged.
                1094     ;
                1095     ;Registers used s0.
                1096     ;
1CE 00061       1097     upper_case:             load         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
1CF 25800       1098                             RETURN          c
1D0 0007B       1099                             load         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
1D1 25C00       1100                             RETURN          nc
1D2 020DF       1101                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
1D3 24000       1102                             RETURN
                1103     ;
                1104     ;
                1105     ;Convert character '0' to '9' to numerical value in range 0 to 9
                1106     ;
                1107     ;The character supplied in register s0. If the character is in the
                1108     ;range '0' to '9', it is converted to the equivalent decimal value.
                1109     ;Characters not in the range '0' to '9' are signified by the return
                1110     ;with the CARRY flag set.
                1111     ;
                1112     ;Registers used s0.
                1113     ;
1D4 080C6       1114     _1char_to_value:        ADD             s0, #0xc6               ;reject character codes above '9' (39 hex)
1D5 25800       1115                             RETURN          c                       ;carry flag is set
1D6 0C0F6       1116                             SUB             s0, #0xf6               ;reject character codes below '0' (30 hex)
1D7 24000       1117                             RETURN                                  ;carry is set if value not in range
                1118     ;
                1119     ;
                1120     ;Determine the numerical value of a two character decimal string held in
                1121     ;scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
                1122     ;
                1123     ;The string must be loadd in two consecutive memory locations and the
                1124     ;location of the first (tens) character supplied in the s1 register.
                1125     ;The result is provided in register s2. Strings not using characters in the
                1126     ;range '0' to '9' are signified by the return with the CARRY flag set.
                1127     ;
                1128     ;Registers used s0, s1 and s2.
                1129     ;
1D8 00001       1130     _2char_to_value:        load           s0, #s1                 ;read 'tens' character
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
1D9 361D4       1131                             CALL            _1char_to_value         ;convert to numerical value
1DA 25800       1132                             RETURN          c                       ;bad character - CARRY set
1DB 10200       1133                             LOAD            s2, s0
1DC 28206       1134                             SL0             s2                      ;multiply 'tens' value by 10 (0A hex)
1DD 28206       1135                             SL0             s2
1DE 18200       1136                             ADD             s2, s0
1DF 28206       1137                             SL0             s2
1E0 08101       1138                             ADD             s1, #0x01               ;read 'units' character
1E1 00001       1139                             load           s0, #s1
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
1E2 361D4       1140                             CALL            _1char_to_value         ;convert to numerical value
1E3 25800       1141                             RETURN          c                       ;bad character - CARRY set
1E4 18200       1142                             ADD             s2, s0                  ;add units to result and clear CARRY flag
1E5 24000       1143                             RETURN
                1144     ;
                1145     ;
                1146     ;Convert hexadecimal value provided in register s0 into ASCII characters
                1147     ;
                1148     ;The value provided must can be any value in the range 00 to FF and will be converted into
                1149     ;two ASCII characters.
                1150     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1151     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1152     ;
                1153     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1154     ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1155     ;hexadecimal requiring a further addition of 07 to the 30 already added.
                1156     ;
                1157     ;Registers used s0, s1 and s2.
                1158     ;
1E6 10100       1159     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
1E7 2800E       1160                             SR0             s0                      ;isolate upper nibble
1E8 2800E       1161                             SR0             s0
1E9 2800E       1162                             SR0             s0
1EA 2800E       1163                             SR0             s0
1EB 361F2       1164                             CALL            hex_to_ascii            ;convert
1EC 10200       1165                             LOAD            s2, s0                  ;upper nibble value in s2
1ED 10008       1166                             LOAD            s0, s1                  ;reload complete value
1EE 0200F       1167                             AND             s0, #0x0f               ;isolate lower nibble
1EF 361F2       1168                             CALL            hex_to_ascii            ;convert
1F0 10100       1169                             LOAD            s1, s0                  ;lower nibble value in s1
1F1 24000       1170                             RETURN
                1171     ;
                1172     ;Convert hexadecimal value provided in register s0 into ASCII character
                1173     ;
                1174     ;Register used s0
                1175     ;
1F2 0C00A       1176     hex_to_ascii:           SUB             s0, #0x0a               ;load if value is in range 0 to 9
1F3 359F5       1177                             JUMP            c, number_char
1F4 08007       1178                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
1F5 0803A       1179     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
1F6 24000       1180                             RETURN
                1181     ;
                1182     ;
                1183     ;Send the two character HEX value of the register contents 's0' to the UART
                1184     ;
                1185     ;Registers used s0, s1, s2
                1186     ;
1F7 361E6       1187     send_hex_byte:          CALL            hex_byte_to_ascii
1F8 10F10       1188                             LOAD            uart_EQU, s2
1F9 361C1       1189                             CALL            send_to_uart
1FA 10F08       1190                             LOAD            uart_EQU, s1
1FB 361C1       1191                             CALL            send_to_uart
1FC 24000       1192                             RETURN
                1193     ;
                1194     ;
                1195     ;
                1196     ;Send the six character HEX value of the register contents [s9,s8,s7] to the UART
                1197     ;
                1198     ;Registers used s0, s1, s2
                1199     ;
1FD 10048       1200     send_hex_3bytes:        LOAD            s0, s9
1FE 361F7       1201                             CALL            send_hex_byte
1FF 10040       1202                             LOAD            s0, s8
200 361F7       1203                             CALL            send_hex_byte
201 10038       1204                             LOAD            s0, s7
202 361F7       1205                             CALL            send_hex_byte
203 24000       1206                             RETURN
                1207     ;
                1208     ;
                1209     ;Convert the HEX ASCII characters contained in 's3' and 's2' into
                1210     ;an equivalent hexadecimal value in register 's0'.
                1211     ;     The upper nibble is represented by an ASCII character in register s3.
                1212     ;     The lower nibble is represented by an ASCII character in register s2.
                1213     ;
                1214     ;Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1215     ;will be set on return.
                1216     ;
                1217     ;Registers used s0, s2 and s3.
                1218     ;
204 10018       1219     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
205 36211       1220                             CALL            ascii_to_hex            ;convert to value
206 25800       1221                             RETURN          c                       ;reject if out of range
207 10300       1222                             LOAD            s3, s0                  ;remember value
208 28306       1223                             SL0             s3                      ;multiply value by 16 to put in upper nibble
209 28306       1224                             SL0             s3
20A 28306       1225                             SL0             s3
20B 28306       1226                             SL0             s3
20C 10010       1227                             LOAD            s0, s2                  ;Take lower nibble
20D 36211       1228                             CALL            ascii_to_hex            ;convert to value
20E 25800       1229                             RETURN          c                       ;reject if out of range
20F 14018       1230                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
210 24000       1231                             RETURN
                1232     ;
                1233     ;
                1234     ;Routine to convert ASCII EQU in 's0' to an equivalent HEX value.
                1235     ;
                1236     ;If character is not valid for hex, then CARRY is set on return.
                1237     ;
                1238     ;Register used s0
                1239     ;
211 080B9       1240     ascii_to_hex:           ADD             s0, #0xb9               ;load for above ASCII code 46 ('F')
212 25800       1241                             RETURN          c
213 0C0E9       1242                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
214 25800       1243                             RETURN          c                       ;reject below ASCII code 30 ('0')
215 0C011       1244                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
216 35E1B       1245                             JUMP            nc, ascii_letter
217 08007       1246                             ADD             s0, #0x07               ;load for above ASCII code 46 ('F')
218 25800       1247                             RETURN          c
219 0C0F6       1248                             SUB             s0, #0xf6               ;convert to range 00 to 09
21A 24000       1249                             RETURN
21B 0800A       1250     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
21C 24000       1251                             RETURN
                1252     ;
                1253     ;
                1254     ;
                1255     ;Send Carriage Return to the UART
                1256     ;
21D 00F0D       1257     send_cr:                LOAD            uart_EQU, #character_cr
21E 361C1       1258                             CALL            send_to_uart
21F 24000       1259                             RETURN
                1260     ;
                1261     ;Send a space to the UART
                1262     ;
220 00F20       1263     send_space:             LOAD            uart_EQU, #character_space
221 361C1       1264                             CALL            send_to_uart
222 24000       1265                             RETURN
                1266     ;
                1267     ;
                1268     ;**************************************************************************************
                1269     ;Text messages
                1270     ;**************************************************************************************
                1271     ;
                1272     ;
                1273     ;Send 'PicoBlaze SPI FLASH Programmer' string to the UART
                1274     ;
223 3621D       1275     send_welcome:           CALL            send_cr
224 3621D       1276                             CALL            send_cr
225 00F50       1277                             LOAD            uart_EQU, #_character_p
226 361C1       1278                             CALL            send_to_uart
227 00F69       1279                             LOAD            uart_EQU, #character_i
228 361C1       1280                             CALL            send_to_uart
229 00F63       1281                             LOAD            uart_EQU, #character_c
22A 361C1       1282                             CALL            send_to_uart
22B 00F6F       1283                             LOAD            uart_EQU, #character_o
22C 361C1       1284                             CALL            send_to_uart
22D 00F42       1285                             LOAD            uart_EQU, #_character_b
22E 361C1       1286                             CALL            send_to_uart
22F 00F6C       1287                             LOAD            uart_EQU, #character_l
230 361C1       1288                             CALL            send_to_uart
231 00F61       1289                             LOAD            uart_EQU, #character_a
232 361C1       1290                             CALL            send_to_uart
233 00F7A       1291                             LOAD            uart_EQU, #character_z
234 361C1       1292                             CALL            send_to_uart
235 00F65       1293                             LOAD            uart_EQU, #character_e
236 361C1       1294                             CALL            send_to_uart
237 36220       1295                             CALL            send_space
238 00F53       1296                             LOAD            uart_EQU, #_character_s
239 361C1       1297                             CALL            send_to_uart
23A 00F50       1298                             LOAD            uart_EQU, #_character_p
23B 361C1       1299                             CALL            send_to_uart
23C 00F49       1300                             LOAD            uart_EQU, #_character_i
23D 361C1       1301                             CALL            send_to_uart
23E 36220       1302                             CALL            send_space
23F 00F46       1303                             LOAD            uart_EQU, #_character_f
240 361C1       1304                             CALL            send_to_uart
241 00F4C       1305                             LOAD            uart_EQU, #_character_l
242 361C1       1306                             CALL            send_to_uart
243 00F41       1307                             LOAD            uart_EQU, #_character_a
244 361C1       1308                             CALL            send_to_uart
245 00F53       1309                             LOAD            uart_EQU, #_character_s
246 361C1       1310                             CALL            send_to_uart
247 00F48       1311                             LOAD            uart_EQU, #_character_h
248 361C1       1312                             CALL            send_to_uart
249 36220       1313                             CALL            send_space
24A 00F50       1314                             LOAD            uart_EQU, #_character_p
24B 361C1       1315                             CALL            send_to_uart
24C 00F72       1316                             LOAD            uart_EQU, #character_r
24D 361C1       1317                             CALL            send_to_uart
24E 00F6F       1318                             LOAD            uart_EQU, #character_o
24F 361C1       1319                             CALL            send_to_uart
250 00F67       1320                             LOAD            uart_EQU, #character_g
251 361C1       1321                             CALL            send_to_uart
252 00F72       1322                             LOAD            uart_EQU, #character_r
253 361C1       1323                             CALL            send_to_uart
254 00F61       1324                             LOAD            uart_EQU, #character_a
255 361C1       1325                             CALL            send_to_uart
256 00F6D       1326                             LOAD            uart_EQU, #character_m
257 361C1       1327                             CALL            send_to_uart
258 00F6D       1328                             LOAD            uart_EQU, #character_m
259 361C1       1329                             CALL            send_to_uart
25A 00F65       1330                             LOAD            uart_EQU, #character_e
25B 361C1       1331                             CALL            send_to_uart
25C 00F72       1332                             LOAD            uart_EQU, #character_r
25D 361C1       1333                             CALL            send_to_uart
25E 36220       1334                             CALL            send_space
25F 00F76       1335                             LOAD            uart_EQU, #character_v
260 361C1       1336                             CALL            send_to_uart
261 00F31       1337                             LOAD            uart_EQU, #character_1
262 361C1       1338                             CALL            send_to_uart
263 00F2E       1339                             LOAD            uart_EQU, #character_fullstop
264 361C1       1340                             CALL            send_to_uart
265 00F30       1341                             LOAD            uart_EQU, #character_0
266 361C1       1342                             CALL            send_to_uart
267 00F30       1343                             LOAD            uart_EQU, #character_0
268 361C1       1344                             CALL            send_to_uart
269 3621D       1345                             CALL            send_cr
26A 3621D       1346                             CALL            send_cr
26B 24000       1347                             RETURN
                1348     ;
                1349     ;
                1350     ;
                1351     ;Send 'Waiting_MCS_file' string to the UART
                1352     ;
26C 00F57       1353     send_waiting_mcs_file:  LOAD            uart_EQU, #_character_w
26D 361C1       1354                             CALL            send_to_uart
26E 00F61       1355                             LOAD            uart_EQU, #character_a
26F 361C1       1356                             CALL            send_to_uart
270 00F69       1357                             LOAD            uart_EQU, #character_i
271 361C1       1358                             CALL            send_to_uart
272 00F74       1359                             LOAD            uart_EQU, #character_t
273 361C1       1360                             CALL            send_to_uart
274 00F69       1361                             LOAD            uart_EQU, #character_i
275 361C1       1362                             CALL            send_to_uart
276 00F6E       1363                             LOAD            uart_EQU, #character_n
277 361C1       1364                             CALL            send_to_uart
278 00F67       1365                             LOAD            uart_EQU, #character_g
279 361C1       1366                             CALL            send_to_uart
27A 36220       1367                             CALL            send_space
27B 00F66       1368                             LOAD            uart_EQU, #character_f
27C 361C1       1369                             CALL            send_to_uart
27D 00F6F       1370                             LOAD            uart_EQU, #character_o
27E 361C1       1371                             CALL            send_to_uart
27F 00F72       1372                             LOAD            uart_EQU, #character_r
280 361C1       1373                             CALL            send_to_uart
281 36220       1374     send_mcs_file:          CALL            send_space
282 00F4D       1375                             LOAD            uart_EQU, #_character_m
283 361C1       1376                             CALL            send_to_uart
284 00F43       1377                             LOAD            uart_EQU, #_character_c
285 361C1       1378                             CALL            send_to_uart
286 00F53       1379                             LOAD            uart_EQU, #_character_s
287 361C1       1380                             CALL            send_to_uart
288 36220       1381                             CALL            send_space
289 00F46       1382                             LOAD            uart_EQU, #_character_f
28A 361C1       1383                             CALL            send_to_uart
28B 00F69       1384                             LOAD            uart_EQU, #character_i
28C 361C1       1385                             CALL            send_to_uart
28D 00F6C       1386                             LOAD            uart_EQU, #character_l
28E 361C1       1387                             CALL            send_to_uart
28F 00F65       1388                             LOAD            uart_EQU, #character_e
290 361C1       1389                             CALL            send_to_uart
291 3621D       1390                             CALL            send_cr
292 24000       1391                             RETURN
                1392     ;
                1393     ;
                1394     ;Send 'Erase in progress' string to the UART
                1395     ;
293 362AA       1396     send_erase_in_progress: CALL            send_erase
294 00F69       1397                             LOAD            uart_EQU, #character_i
295 361C1       1398                             CALL            send_to_uart
296 00F6E       1399                             LOAD            uart_EQU, #character_n
297 361C1       1400                             CALL            send_to_uart
298 36220       1401                             CALL            send_space
299 00F50       1402                             LOAD            uart_EQU, #_character_p
29A 361C1       1403                             CALL            send_to_uart
29B 00F72       1404                             LOAD            uart_EQU, #character_r
29C 361C1       1405                             CALL            send_to_uart
29D 00F6F       1406                             LOAD            uart_EQU, #character_o
29E 361C1       1407                             CALL            send_to_uart
29F 00F67       1408                             LOAD            uart_EQU, #character_g
2A0 361C1       1409                             CALL            send_to_uart
2A1 00F72       1410                             LOAD            uart_EQU, #character_r
2A2 361C1       1411                             CALL            send_to_uart
2A3 00F65       1412                             LOAD            uart_EQU, #character_e
2A4 361C1       1413                             CALL            send_to_uart
2A5 00F73       1414                             LOAD            uart_EQU, #character_s
2A6 361C1       1415                             CALL            send_to_uart
2A7 361C1       1416                             CALL            send_to_uart
2A8 3621D       1417                             CALL            send_cr
2A9 24000       1418                             RETURN
                1419     ;
                1420     ;
                1421     ;Send 'Erase ' string to the UART
                1422     ;
2AA 00F45       1423     send_erase:             LOAD            uart_EQU, #_character_e
2AB 361C1       1424                             CALL            send_to_uart
2AC 00F72       1425                             LOAD            uart_EQU, #character_r
2AD 361C1       1426                             CALL            send_to_uart
2AE 00F61       1427                             LOAD            uart_EQU, #character_a
2AF 361C1       1428                             CALL            send_to_uart
2B0 00F73       1429                             LOAD            uart_EQU, #character_s
2B1 361C1       1430                             CALL            send_to_uart
2B2 00F65       1431                             LOAD            uart_EQU, #character_e
2B3 361C1       1432                             CALL            send_to_uart
2B4 36220       1433                             CALL            send_space
2B5 24000       1434                             RETURN
                1435     ;
                1436     ;
                1437     ;Send carriage return, 'OK' and carriage return to the UART
                1438     ;
2B6 3621D       1439     send_ok:                CALL            send_cr
2B7 00F4F       1440                             LOAD            uart_EQU, #_character_o
2B8 361C1       1441                             CALL            send_to_uart
2B9 00F4B       1442                             LOAD            uart_EQU, #_character_k
2BA 361C1       1443                             CALL            send_to_uart
2BB 3621D       1444                             CALL            send_cr
2BC 24000       1445                             RETURN
                1446     ;
                1447     ;
                1448     ;
                1449     ;Send menu to the UART
                1450     ;
2BD 3621D       1451     send_menu:              CALL            send_cr
2BE 00F45       1452                             LOAD            uart_EQU, #_character_e
2BF 361C1       1453                             CALL            send_to_uart
2C0 00F2D       1454                             LOAD            uart_EQU, #character_minus
2C1 361C1       1455                             CALL            send_to_uart
2C2 362AA       1456                             CALL            send_erase
2C3 00F61       1457                             LOAD            uart_EQU, #character_a
2C4 361C1       1458                             CALL            send_to_uart
2C5 00F6C       1459                             LOAD            uart_EQU, #character_l
2C6 361C1       1460                             CALL            send_to_uart
2C7 361C1       1461                             CALL            send_to_uart
2C8 3621D       1462                             CALL            send_cr
2C9 00F53       1463                             LOAD            uart_EQU, #_character_s
2CA 361C1       1464                             CALL            send_to_uart
2CB 00F2D       1465                             LOAD            uart_EQU, #character_minus
2CC 361C1       1466                             CALL            send_to_uart
2CD 00F53       1467                             LOAD            uart_EQU, #_character_s
2CE 361C1       1468                             CALL            send_to_uart
2CF 00F65       1469                             LOAD            uart_EQU, #character_e
2D0 361C1       1470                             CALL            send_to_uart
2D1 00F63       1471                             LOAD            uart_EQU, #character_c
2D2 361C1       1472                             CALL            send_to_uart
2D3 00F74       1473                             LOAD            uart_EQU, #character_t
2D4 361C1       1474                             CALL            send_to_uart
2D5 00F6F       1475                             LOAD            uart_EQU, #character_o
2D6 361C1       1476                             CALL            send_to_uart
2D7 00F72       1477                             LOAD            uart_EQU, #character_r
2D8 361C1       1478                             CALL            send_to_uart
2D9 36220       1479                             CALL            send_space
2DA 362AA       1480                             CALL            send_erase
2DB 3621D       1481                             CALL            send_cr
2DC 00F50       1482                             LOAD            uart_EQU, #_character_p
2DD 361C1       1483                             CALL            send_to_uart
2DE 00F2D       1484                             LOAD            uart_EQU, #character_minus
2DF 361C1       1485                             CALL            send_to_uart
2E0 00F50       1486                             LOAD            uart_EQU, #_character_p
2E1 361C1       1487                             CALL            send_to_uart
2E2 00F72       1488                             LOAD            uart_EQU, #character_r
2E3 361C1       1489                             CALL            send_to_uart
2E4 00F6F       1490                             LOAD            uart_EQU, #character_o
2E5 361C1       1491                             CALL            send_to_uart
2E6 00F67       1492                             LOAD            uart_EQU, #character_g
2E7 361C1       1493                             CALL            send_to_uart
2E8 00F72       1494                             LOAD            uart_EQU, #character_r
2E9 361C1       1495                             CALL            send_to_uart
2EA 00F61       1496                             LOAD            uart_EQU, #character_a
2EB 361C1       1497                             CALL            send_to_uart
2EC 00F6D       1498                             LOAD            uart_EQU, #character_m
2ED 361C1       1499                             CALL            send_to_uart
2EE 36281       1500                             CALL            send_mcs_file
2EF 00F52       1501                             LOAD            uart_EQU, #_character_r
2F0 361C1       1502                             CALL            send_to_uart
2F1 00F2D       1503                             LOAD            uart_EQU, #character_minus
2F2 361C1       1504                             CALL            send_to_uart
2F3 00F52       1505                             LOAD            uart_EQU, #_character_r
2F4 361C1       1506                             CALL            send_to_uart
2F5 00F65       1507                             LOAD            uart_EQU, #character_e
2F6 361C1       1508                             CALL            send_to_uart
2F7 00F61       1509                             LOAD            uart_EQU, #character_a
2F8 361C1       1510                             CALL            send_to_uart
2F9 00F64       1511                             LOAD            uart_EQU, #character_d
2FA 361C1       1512                             CALL            send_to_uart
2FB 36220       1513                             CALL            send_space
2FC 3631F       1514                             CALL            send_page
2FD 3621D       1515                             CALL            send_cr
2FE 00F49       1516                             LOAD            uart_EQU, #_character_i
2FF 361C1       1517                             CALL            send_to_uart
300 00F2D       1518                             LOAD            uart_EQU, #character_minus
301 361C1       1519                             CALL            send_to_uart
302 00F44       1520                             LOAD            uart_EQU, #_character_d
303 361C1       1521                             CALL            send_to_uart
304 00F65       1522                             LOAD            uart_EQU, #character_e
305 361C1       1523                             CALL            send_to_uart
306 00F76       1524                             LOAD            uart_EQU, #character_v
307 361C1       1525                             CALL            send_to_uart
308 00F69       1526                             LOAD            uart_EQU, #character_i
309 361C1       1527                             CALL            send_to_uart
30A 00F63       1528                             LOAD            uart_EQU, #character_c
30B 361C1       1529                             CALL            send_to_uart
30C 00F65       1530                             LOAD            uart_EQU, #character_e
30D 361C1       1531                             CALL            send_to_uart
30E 36220       1532                             CALL            send_space
30F 36328       1533                             CALL            send_id
310 3621D       1534                             CALL            send_cr
311 00F48       1535                             LOAD            uart_EQU, #_character_h
312 361C1       1536                             CALL            send_to_uart
313 00F2D       1537                             LOAD            uart_EQU, #character_minus
314 361C1       1538                             CALL            send_to_uart
315 00F48       1539                             LOAD            uart_EQU, #_character_h
316 361C1       1540                             CALL            send_to_uart
317 00F65       1541                             LOAD            uart_EQU, #character_e
318 361C1       1542                             CALL            send_to_uart
319 00F6C       1543                             LOAD            uart_EQU, #character_l
31A 361C1       1544                             CALL            send_to_uart
31B 00F70       1545                             LOAD            uart_EQU, #character_p
31C 361C1       1546                             CALL            send_to_uart
31D 3621D       1547                             CALL            send_cr
31E 24000       1548                             RETURN
                1549     ;
                1550     ;
                1551     ;Send 'page' to the UART
                1552     ;
31F 00F70       1553     send_page:              LOAD            uart_EQU, #character_p
320 361C1       1554                             CALL            send_to_uart
321 00F61       1555                             LOAD            uart_EQU, #character_a
322 361C1       1556                             CALL            send_to_uart
323 00F67       1557                             LOAD            uart_EQU, #character_g
324 361C1       1558                             CALL            send_to_uart
325 00F65       1559                             LOAD            uart_EQU, #character_e
326 361C1       1560                             CALL            send_to_uart
327 24000       1561                             RETURN
                1562     ;
                1563     ;Send 'ID' to the UART
                1564     ;
328 00F49       1565     send_id:                LOAD            uart_EQU, #_character_i
329 361C1       1566                             CALL            send_to_uart
32A 00F44       1567                             LOAD            uart_EQU, #_character_d
32B 361C1       1568                             CALL            send_to_uart
32C 24000       1569                             RETURN
                1570     ;
                1571     ;
                1572     ;Send 'Confirm Erase (Y/n) ' to the UART
                1573     ;
32D 3621D       1574     send_confirm:           CALL            send_cr
32E 00F43       1575                             LOAD            uart_EQU, #_character_c
32F 361C1       1576                             CALL            send_to_uart
330 00F6F       1577                             LOAD            uart_EQU, #character_o
331 361C1       1578                             CALL            send_to_uart
332 00F6E       1579                             LOAD            uart_EQU, #character_n
333 361C1       1580                             CALL            send_to_uart
334 00F66       1581                             LOAD            uart_EQU, #character_f
335 361C1       1582                             CALL            send_to_uart
336 00F69       1583                             LOAD            uart_EQU, #character_i
337 361C1       1584                             CALL            send_to_uart
338 00F72       1585                             LOAD            uart_EQU, #character_r
339 361C1       1586                             CALL            send_to_uart
33A 00F6D       1587                             LOAD            uart_EQU, #character_m
33B 361C1       1588                             CALL            send_to_uart
33C 36220       1589                             CALL            send_space
33D 362AA       1590                             CALL            send_erase
33E 00F28       1591                             LOAD            uart_EQU, #character_open
33F 361C1       1592                             CALL            send_to_uart
340 00F59       1593                             LOAD            uart_EQU, #_character_y
341 361C1       1594                             CALL            send_to_uart
342 00F2F       1595                             LOAD            uart_EQU, #character_divide
343 361C1       1596                             CALL            send_to_uart
344 00F6E       1597                             LOAD            uart_EQU, #character_n
345 361C1       1598                             CALL            send_to_uart
346 00F29       1599                             LOAD            uart_EQU, #character_close
347 361C1       1600                             CALL            send_to_uart
348 36220       1601                             CALL            send_space
349 24000       1602                             RETURN
                1603     ;
                1604     ;
                1605     ;Send 'Abort' to the UART
                1606     ;
34A 3621D       1607     send_abort:             CALL            send_cr
34B 00F41       1608                             LOAD            uart_EQU, #_character_a
34C 361C1       1609                             CALL            send_to_uart
34D 00F62       1610                             LOAD            uart_EQU, #character_b
34E 361C1       1611                             CALL            send_to_uart
34F 00F6F       1612                             LOAD            uart_EQU, #character_o
350 361C1       1613                             CALL            send_to_uart
351 00F72       1614                             LOAD            uart_EQU, #character_r
352 361C1       1615                             CALL            send_to_uart
353 00F74       1616                             LOAD            uart_EQU, #character_t
354 361C1       1617                             CALL            send_to_uart
355 3621D       1618                             CALL            send_cr
356 24000       1619                             RETURN
                1620     ;
                1621     ;Send 'page address' to the UART
                1622     ;
357 3621D       1623     send_page_address:      CALL            send_cr
358 3631F       1624                             CALL            send_page
359 36220       1625                             CALL            send_space
35A 00F61       1626                             LOAD            uart_EQU, #character_a
35B 361C1       1627                             CALL            send_to_uart
35C 00F64       1628                             LOAD            uart_EQU, #character_d
35D 361C1       1629                             CALL            send_to_uart
35E 361C1       1630                             CALL            send_to_uart
35F 00F72       1631                             LOAD            uart_EQU, #character_r
360 361C1       1632                             CALL            send_to_uart
361 00F65       1633                             LOAD            uart_EQU, #character_e
362 361C1       1634                             CALL            send_to_uart
363 00F73       1635                             LOAD            uart_EQU, #character_s
364 361C1       1636                             CALL            send_to_uart
365 361C1       1637                             CALL            send_to_uart
366 00F3D       1638                             LOAD            uart_EQU, #character_equals
367 361C1       1639                             CALL            send_to_uart
368 24000       1640                             RETURN
                1641     ;
                1642     ;
                1643     ;**************************************************************************************
                1644     ;Interrupt Service Routine (ISR)
                1645     ;**************************************************************************************
                1646     ;
                1647     ;An interrupt occurs whenever the status of the UART receiver FIFO 'half_full' flag
                1648     ;changes.
                1649     ;
                1650     ;A change from Low to High means that the buffer is becoming full and therefore
                1651     ;an XOFF character must be transmitted.
                1652     ;
                1653     ;A change from High to Low means that the buffer is starting to empty and therefore
                1654     ;an XON character can be transmitted to restart the flow of new characters.
                1655     ;
                1656     ;
  003F5         1657                             ORG             0x3f5                   ;place at end of memory to keep separate
3F5 10000       1658     isr:                    load           s0, isr_preserve_s0     ;preserve register contents
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
3F6 20000       1659                             INPUT           s0, status_port         ;load 'half_full' status of receiver buffer.
3F7 00010       1660                             load            s0, #rx_half_full
3F8 353FB       1661                             JUMP            z, isr_send_xon
3F9 00013       1662                             LOAD            s0, #character_xoff
3FA 343FC       1663                             JUMP            isr_send_character
3FB 00011       1664     isr_send_xon:           LOAD            s0, #character_xon
3FC 22010       1665     isr_send_character:     OUTPUT          s0, uart_write_port
3FD 10000       1666                             load           s0, isr_preserve_s0     ;reload register contents
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
3FE 2C001       1667                             RETURNI         enable
                1668     ;
                1669     ;
                1670     ;**************************************************************************************
                1671     ;Interrupt Vector
                1672     ;**************************************************************************************
                1673     ;
  003FF         1674                             ORG             0x3ff
3FF 343F5       1675                             JUMP            isr
                1676     ;
                1677     ;
                1678
