                   1     ; KCPSM3 Program - Pulse Width Modulation (PWM) Control on the Spartan-3E Starter Kit.
                   2     ;
                   3     ; Ken Chapman - Xilinx Ltd
                   4     device kcpsm2
                   5     ; Version v1.00 - 22nd May 2006
                   6     ;
                   7     ; Provides control for 12 channels of PWM with a Pulse Repetition Frequency (PRF) of 1KHz
                   8     ; and an 8-bit duty cycle resolution (256 steps). Control is provided for each channel
                   9     ; via the UART interface to the PC running HyperTerminal or similar to enter simple text
                  10     ; commands.
                  11     ;
                  12     ;**************************************************************************************
                  13     ; Port definitions
                  14     ;**************************************************************************************
                  15     ;
                  16     ;
                  17     ;
  00080           18     led_port                EQU             0x80                    ;8 simple LEDs
  00001           19     led0                    EQU             0x01                    ;     LED 0 - bit0
  00002           20     led1                    EQU             0x02                    ;         1 - bit1
  00004           21     led2                    EQU             0x04                    ;         2 - bit2
  00008           22     led3                    EQU             0x08                    ;         3 - bit3
  00010           23     led4                    EQU             0x10                    ;         4 - bit4
  00020           24     led5                    EQU             0x20                    ;         5 - bit5
  00040           25     led6                    EQU             0x40                    ;         6 - bit6
  00080           26     led7                    EQU             0x80                    ;         7 - bit7
                  27     ;
                  28     ;
  00040           29     simple_port             EQU             0x40                    ;4 simple outputs
  00001           30     simple_io9              EQU             0x01                    ;  Header  IO9  - bit0
  00002           31     simple_io10             EQU             0x02                    ;          IO10 - bit1
  00004           32     simple_io11             EQU             0x04                    ;          IO11 - bit2
  00008           33     simple_io12             EQU             0x08                    ;          IO12 - bit3
                  34     ;
                  35     ;
                  36     ;
  00000           37     status_port             EQU             0x00                    ;UART status input
  00001           38     tx_half_full            EQU             0x01                    ;  Transmitter     half full - bit0
  00002           39     tx_full                 EQU             0x02                    ;    FIFO               full - bit1
  00004           40     rx_data_present         EQU             0x04                    ;  Receiver     data present - bit2
  00008           41     rx_half_full            EQU             0x08                    ;    FIFO          half full - bit3
  00010           42     rx_full                 EQU             0x10                    ;                   full - bit4
  00020           43     spare1                  EQU             0x20                    ;                  spare '0' - bit5
  00040           44     spare2                  EQU             0x40                    ;                  spare '0' - bit6
  00080           45     spare3                  EQU             0x80                    ;                  spare '0' - bit7
                  46     ;
  00001           47     uart_read_port          EQU             0x01                    ;UART Rx data input
                  48     ;
  00020           49     uart_write_port         EQU             0x20                    ;UART Tx data output
                  50     ;
                  51     ;
                  52     ;
                  53     ;**************************************************************************************
                  54     ; Special Register usage
                  55     ;**************************************************************************************
                  56     ;
  0000F           57     uart_data               REG             sf                      ;used to pass data to and from the UART
                  58     ;
                  59     ;
                  60     ;
                  61     ;**************************************************************************************
                  62     ;Scratch Pad Memory Locations
                  63     ;**************************************************************************************
                  64     ;
  00000           65     pwm_duty_counter        EQU             0x00                    ;Duty Counter 0 to 255 within 1KHz period (1ms)
  00001           66     pwm_channel0            EQU             0x01                    ;PWM settings for each channel
  00002           67     pwm_channel1            EQU             0x02                    ; Channels 0 to 7 = LEDs 0 to 7
  00003           68     pwm_channel2            EQU             0x03                    ; Channels 8 to 11 = IO9 to IO12
  00004           69     pwm_channel3            EQU             0x04
  00005           70     pwm_channel4            EQU             0x05
  00006           71     pwm_channel5            EQU             0x06
  00007           72     pwm_channel6            EQU             0x07
  00008           73     pwm_channel7            EQU             0x08
  00009           74     pwm_channel8            EQU             0x09
  0000A           75     pwm_channel9            EQU             0x0a
  0000B           76     pwm_channel10           EQU             0x0b
  0000C           77     pwm_channel11           EQU             0x0c
  0000D           78     isr_preserve_s0         EQU             0x0d                    ;preserve register contents during Interrupt Service Routine
  0000E           79     isr_preserve_s1         EQU             0x0e
  0000F           80     isr_preserve_s2         EQU             0x0f
                  81     ;
                  82     ;
                  83     ;
                  84     ;
                  85     ;UART character strings will be loadd in scratch pad memory ending in carriage return.
                  86     ;A string can be up to 16 characters with the start location defined by this constant.
                  87     ;
  00030           88     string_start            EQU             0x30
                  89     ;
                  90     ;
                  91     ;
                  92     ;**************************************************************************************
                  93     ;Useful data constants
                  94     ;**************************************************************************************
                  95     ;
                  96     ;
                  97     ;
                  98     ;
                  99     ;ASCII table
                 100     ;
  00061          101     character_a             EQU             0x61
  00062          102     character_b             EQU             0x62
  00063          103     character_c             EQU             0x63
  00064          104     character_d             EQU             0x64
  00065          105     character_e             EQU             0x65
  00066          106     character_f             EQU             0x66
  00067          107     character_g             EQU             0x67
  00068          108     character_h             EQU             0x68
  00069          109     character_i             EQU             0x69
  0006A          110     character_j             EQU             0x6a
  0006B          111     character_k             EQU             0x6b
  0006C          112     character_l             EQU             0x6c
  0006D          113     character_m             EQU             0x6d
  0006E          114     character_n             EQU             0x6e
  0006F          115     character_o             EQU             0x6f
  00070          116     character_p             EQU             0x70
  00071          117     character_q             EQU             0x71
  00072          118     character_r             EQU             0x72
  00073          119     character_s             EQU             0x73
  00074          120     character_t             EQU             0x74
  00075          121     character_u             EQU             0x75
  00076          122     character_v             EQU             0x76
  00077          123     character_w             EQU             0x77
  00078          124     character_x             EQU             0x78
  00079          125     character_y             EQU             0x79
  0007A          126     character_z             EQU             0x7a
  00041          127     _character_a            EQU             0x41
  00042          128     _character_b            EQU             0x42
  00043          129     _character_c            EQU             0x43
  00044          130     _character_d            EQU             0x44
  00045          131     _character_e            EQU             0x45
  00046          132     _character_f            EQU             0x46
  00047          133     _character_g            EQU             0x47
  00048          134     _character_h            EQU             0x48
  00049          135     _character_i            EQU             0x49
  0004A          136     _character_j            EQU             0x4a
  0004B          137     _character_k            EQU             0x4b
  0004C          138     _character_l            EQU             0x4c
  0004D          139     _character_m            EQU             0x4d
  0004E          140     _character_n            EQU             0x4e
  0004F          141     _character_o            EQU             0x4f
  00050          142     _character_p            EQU             0x50
  00051          143     _character_q            EQU             0x51
  00052          144     _character_r            EQU             0x52
  00053          145     _character_s            EQU             0x53
  00054          146     _character_t            EQU             0x54
  00055          147     _character_u            EQU             0x55
  00056          148     _character_v            EQU             0x56
  00057          149     _character_w            EQU             0x57
  00058          150     _character_x            EQU             0x58
  00059          151     _character_y            EQU             0x59
  0005A          152     _character_z            EQU             0x5a
  00030          153     character_0             EQU             0x30
  00031          154     character_1             EQU             0x31
  00032          155     character_2             EQU             0x32
  00033          156     character_3             EQU             0x33
  00034          157     character_4             EQU             0x34
  00035          158     character_5             EQU             0x35
  00036          159     character_6             EQU             0x36
  00037          160     character_7             EQU             0x37
  00038          161     character_8             EQU             0x38
  00039          162     character_9             EQU             0x39
  0003A          163     character_colon         EQU             0x3a
  0002E          164     character_stop          EQU             0x2e
  0003B          165     character_semi_colon    EQU             0x3b
  0002D          166     character_minus         EQU             0x2d
  0002F          167     character_divide        EQU             0x2f                    ;'/'
  0002B          168     character_plus          EQU             0x2b
  0002C          169     character_comma         EQU             0x2c
  0003C          170     character_less_than     EQU             0x3c
  0003E          171     character_greater_than  EQU             0x3e
  0003D          172     character_equals        EQU             0x3d
  00020          173     character_space         EQU             0x20
  0000D          174     character_cr            EQU             0x0d                    ;carriage return
  0003F          175     character_question      EQU             0x3f                    ;'?'
  00024          176     character_dollar        EQU             0x24
  00021          177     character_exclaim       EQU             0x21                    ;'!'
  00008          178     character_bs            EQU             0x08                    ;Back Space command character
                 179     ;
                 180     ;
                 181     ;
                 182     ;
                 183     ;
                 184     ;**************************************************************************************
                 185     ;Initialise the system
                 186     ;**************************************************************************************
                 187     ;
                 188     ; Each PWM channels will be set to a different initial value just for the purposes
                 189     ; of demonstration. In practice, the initial duty values will depend on the requirements
                 190     ; of a given system but completely off (zero) is normally the safe option.
                 191     ;
                 192     ; Note that it is difficult to distinguish difference between the intensity of LEDs driven
                 193     ; with duty factors more than 40% (40% = 102/256 or 66Hex). So using relatively small values
                 194     ; will better demonstrate the PWM control of intensity.
                 195     ;
                 196     ; Initial values for LEDs give graduated intensity. Large change required for brighter LEDs.
                 197     ;
000 00005        198     cold_start:             LOAD            s0, #0x05               ;5/256 = 2%
001 10008        199                             load           s0, pwm_channel0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
002 0000D        200                             LOAD            s0, #0x0d               ;13/256 = 5%
003 10010        201                             load           s0, pwm_channel1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
004 00014        202                             LOAD            s0, #0x14               ;26/256 = 8%
005 10018        203                             load           s0, pwm_channel2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
006 00026        204                             LOAD            s0, #0x26               ;38/256 = 15%
007 10020        205                             load           s0, pwm_channel3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
008 00040        206                             LOAD            s0, #0x40               ;64/256 = 25%
009 10028        207                             load           s0, pwm_channel4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00A 00058        208                             LOAD            s0, #0x58               ;88/256 = 34%
00B 10030        209                             load           s0, pwm_channel5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00C 00080        210                             LOAD            s0, #0x80               ;128/256 = 50%
00D 10038        211                             load           s0, pwm_channel6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
00E 000FF        212                             LOAD            s0, #0xff               ;255/256 = 99.6% Maximum possible
00F 10040        213                             load           s0, pwm_channel7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 214     ;
                 215     ; Initial values for simple outputs match documentation example
                 216     ;
010 00011        217                             LOAD            s0, #0x11               ;17/256 = 7%
011 10048        218                             load           s0, pwm_channel8
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
012 000BC        219                             LOAD            s0, #0xbc               ;188/256 = 73%
013 10050        220                             load           s0, pwm_channel9
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
014 000EF        221                             LOAD            s0, #0xef               ;239/256 = 93%
015 10058        222                             load           s0, pwm_channel10
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
016 00022        223                             LOAD            s0, #0x22               ;34/256 = 13%
017 10060        224                             load           s0, pwm_channel11
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 225     ;
018 3C001        226                             ENABLE          interrupt               ;interrupts used to drive servo
                 227     ;
019 360B9        228                             CALL            send_welcome            ;Write welcome message to UART
                 229     ;
                 230     ;
                 231     ;
                 232     ;**************************************************************************************
                 233     ; Main program
                 234     ;**************************************************************************************
                 235     ;
                 236     ; Provides a prompt to which an input with one of the following formats is expected...
                 237     ;
                 238     ;     LDn hh
                 239     ;
                 240     ;     IOk hh
                 241     ;     IOkk hh
                 242     ;
                 243     ;
                 244     ;  Where
                 245     ;     'LD' is a command to set one of the LED channels.
                 246     ;     'IO' is a command to set one of the simple I/O outputs on J4.
                 247     ;     'n' is an LED number in the range 0 to 7.
                 248     ;     'k' or 'kk' is a simple I/O number in the range 9 to 12.
                 249     ;     'hh' is a 2 digit hex value to specify the PWM duty factor (range 00 to FF).
                 250     ;
                 251     ; The input allows a degree of editing to be performed and upper and lower case letters
                 252     ; to be used.
                 253     ;
01A 360E6        254     warm_start:             CALL            send_prompt             ;Prompt 'KCPSM3>'
01B 36063        255                             CALL            receive_string          ;obtain input string of up to 16 characters
01C 3608B        256                             CALL            upper_case_string       ;convert string to upper case
                 257     ;
01D 00E30        258                             LOAD            se, #string_start       ;sE is memory pointer
01E 0000E        259                             load           s0, #se                 ;load for carriage return
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
01F 0000D        260                             load         s0, #character_cr
020 3501A        261                             JUMP            z, warm_start
021 0004C        262                             load         s0, #_character_l       ;load for 'L' of 'LD' command
022 35028        263                             JUMP            z, ld_command
023 00049        264                             load         s0, #_character_i       ;load for 'I' of 'IO' command
024 35042        265                             JUMP            z, io_command
025 360B0        266     bad_command:            CALL            send_cr                 ;no valid command entered
026 36107        267                             CALL            send_error
027 3401A        268                             JUMP            warm_start
                 269     ;
                 270     ;Processing potential 'LD' command
                 271     ;
028 36054        272     ld_command:             CALL            read_next_char
029 00044        273                             load         s0, #_character_d       ;load for 'D' of 'LD' command
02A 35425        274                             JUMP            nz, bad_command
02B 36054        275                             CALL            read_next_char          ;load for LED number
02C 36093        276                             CALL            _1char_to_value
02D 35825        277                             JUMP            c, bad_command
02E 00008        278                             load         s0, #0x08               ;load for number in range 0 to 7
02F 35C25        279                             JUMP            nc, bad_command
030 10D00        280                             LOAD            sd, s0                  ;convert number into memory pointer in sD
031 08D01        281                             ADD             sd, #pwm_channel0
032 36054        282     read_duty_value:        CALL            read_next_char          ;load for a space
033 00020        283                             load         s0, #character_space
034 35425        284                             JUMP            nz, bad_command
035 36054        285                             CALL            read_next_char          ;read two character hex value
036 10300        286                             LOAD            s3, s0
037 36054        287                             CALL            read_next_char
038 10200        288                             LOAD            s2, s0
039 36097        289                             CALL            ascii_byte_to_hex       ;convert to value in s0
03A 35825        290                             JUMP            c, bad_command
03B 10C00        291                             LOAD            sc, s0                  ;remember value
03C 36054        292                             CALL            read_next_char          ;load for carriage return to end command
03D 0000D        293                             load         s0, #character_cr
03E 35425        294                             JUMP            nz, bad_command
03F 00C0D        295                             load           sc, #sd                 ;load new PWM duty factor for an LED
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
040 36111        296                             CALL            send_ok
041 3401A        297                             JUMP            warm_start
                 298     ;
                 299     ;Processing potential 'LD' command
                 300     ;
042 36054        301     io_command:             CALL            read_next_char
043 0004F        302                             load         s0, #_character_o       ;load for '0' of 'IO' command
044 35425        303                             JUMP            nz, bad_command
045 36054        304                             CALL            read_next_char          ;load for IO number
046 00031        305                             load         s0, #character_1        ;first number must either be '1' or '9'
047 3504C        306                             JUMP            z, next_io_number
048 00039        307                             load         s0, #character_9
049 35425        308                             JUMP            nz, bad_command
04A 00D09        309                             LOAD            sd, #pwm_channel8       ;IO9 is controlled by PWM channel8
04B 34032        310                             JUMP            read_duty_value
04C 36054        311     next_io_number:         CALL            read_next_char          ;read next number for IO10 to IO12
04D 36093        312                             CALL            _1char_to_value
04E 35825        313                             JUMP            c, bad_command
04F 00003        314                             load         s0, #0x03               ;load for number in range 0 to 2
050 35C25        315                             JUMP            nc, bad_command
051 10D00        316                             LOAD            sd, s0                  ;convert number into memory pointer in sD
052 08D0A        317                             ADD             sd, #pwm_channel9
053 34032        318                             JUMP            read_duty_value
                 319     ;
                 320     ;Read next character from scratch pad memory
                 321     ;
054 08E01        322     read_next_char:         ADD             se, #0x01
055 0000E        323                             load           s0, #se                 ;load for space
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
056 24000        324                             RETURN
                 325     ;
                 326     ;
                 327     ;
                 328     ;**************************************************************************************
                 329     ; UART communication routines
                 330     ;**************************************************************************************
                 331     ;
                 332     ; Read one character from the UART
                 333     ;
                 334     ; Character read will be returned in a register called 'UART_data'.
                 335     ;
                 336     ; The routine first loads the receiver FIFO buffer to see if data is present.
                 337     ; If the FIFO is empty, the routine waits until there is a character to read.
                 338     ; As this could take any amount of time the wait loop could include a call to a
                 339     ; subroutine which performs a useful function.
                 340     ;
                 341     ;
                 342     ; Registers used s0 and UART_data
                 343     ;
057 20000        344     read_from_uart:         INPUT           s0, status_port         ;load Rx_FIFO buffer
058 00004        345                             load            s0, #rx_data_present    ;wait if empty
059 3545B        346                             JUMP            nz, read_character
05A 34057        347                             JUMP            read_from_uart
05B 20F01        348     read_character:         INPUT           uart_data, uart_read_port ;read from FIFO
05C 24000        349                             RETURN
                 350     ;
                 351     ;
                 352     ;
                 353     ; Transmit one character to the UART
                 354     ;
                 355     ; Character supplied in register called 'UART_data'.
                 356     ;
                 357     ; The routine first loads the transmit FIFO buffer to see if it is full.
                 358     ; If the FIFO is full, then the routine waits until it there is space.
                 359     ;
                 360     ; Registers used s0
                 361     ;
05D 20000        362     send_to_uart:           INPUT           s0, status_port         ;load Tx_FIFO buffer
05E 00002        363                             load            s0, #tx_full            ;wait if full
05F 35061        364                             JUMP            z, uart_write
060 3405D        365                             JUMP            send_to_uart
061 22F20        366     uart_write:             OUTPUT          uart_data, uart_write_port
062 24000        367                             RETURN
                 368     ;
                 369     ;
                 370     ;
                 371     ;
                 372     ;Receive ASCII string from UART
                 373     ;
                 374     ;An ASCII string will be read from the UART and loadd in scratch pad memory
                 375     ;commencing at the location specified by a constant named 'string_start'.
                 376     ;The string will have a maximum length of 16 characters including a
                 377     ;carriage return (0D) denoting the end of the string.
                 378     ;
                 379     ;As each character is read, it is echoed to the UART transmitter.
                 380     ;Some minor editing is supported using backspace (BS=08) which is used
                 381     ;to adjust what is loadd in scratch pad memory and adjust the display
                 382     ;on the terminal screen using characters sent to the UART transmitter.
                 383     ;
                 384     ;A load is made for the receiver FIFO becoming full. A full status is treated as
                 385     ;a potential error situation and will result in a 'Overflow Error' message being
                 386     ;transmitted to the UART, the receiver FIFO being purged of all data and an
                 387     ;empty string being loadd (carriage return at first location).
                 388     ;
                 389     ;Registers used s0, s1, s2 and 'UART_data'.
                 390     ;
063 00130        391     receive_string:         LOAD            s1, #string_start       ;locate start of string
064 10208        392                             LOAD            s2, s1                  ;compute 16 character address
065 08210        393                             ADD             s2, #0x10
066 20000        394     receive_full_load:      INPUT           s0, status_port         ;load Rx_FIFO buffer for full
067 00010        395                             load            s0, #rx_full
068 3547C        396                             JUMP            nz, read_error
069 36057        397                             CALL            read_from_uart          ;obtain and echo character
06A 3605D        398                             CALL            send_to_uart
06B 00F01        399                             load           uart_data, #s1          ;write to memory
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
06C 00F0D        400                             load         uart_data, #character_cr ;load for end of string
06D 25000        401                             RETURN          z
06E 00F08        402                             load         uart_data, #character_bs ;load for back space
06F 35074        403                             JUMP            z, bs_edit
070 08101        404                             ADD             s1, #0x01               ;increment memory pointer
071 10110        405                             load         s1, s2                  ;load for pointer exceeding 16 characters
072 35466        406                             JUMP            nz, receive_full_load   ;next character
073 360B6        407                             CALL            send_backspace          ;hold end of string position on terminal display
074 0C101        408     bs_edit:                SUB             s1, #0x01               ;memory pointer back one
075 00130        409                             load         s1, #string_start       ;load for under flow
076 3587A        410                             JUMP            c, string_start_again
077 360B3        411                             CALL            send_space              ;clear character at current position
078 360B6        412                             CALL            send_backspace          ;position cursor
079 34066        413                             JUMP            receive_full_load       ;next character
07A 360F3        414     string_start_again:     CALL            send_greater_than       ;reload '>' at prompt
07B 34063        415                             JUMP            receive_string          ;begin again
                 416     ;Receiver buffer overflow condition
07C 360B0        417     read_error:             CALL            send_cr                 ;Transmit error message
07D 10F80        418                             load           uart_data, string_start ;empty string in memory (start with CR)
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x30, allowed range is [0x0,0x1f] (trimmed to 5 bits) which makes it 0x10.
07E 360F6        419                             CALL            send_overflow_error
07F 360B0        420                             CALL            send_cr
080 20000        421     clear_uart_rx_loop:     INPUT           s0, status_port         ;load Rx_FIFO buffer for data
081 00004        422                             load            s0, #rx_data_present
082 25000        423                             RETURN          z                       ;finish when buffer is empty
083 20F01        424                             INPUT           uart_data, uart_read_port ;read from FIFO and ignore
084 34080        425                             JUMP            clear_uart_rx_loop
                 426     ;
                 427     ;
                 428     ;**************************************************************************************
                 429     ; Useful ASCII conversion and handling routines
                 430     ;**************************************************************************************
                 431     ;
                 432     ;
                 433     ;
                 434     ; Convert character to upper case
                 435     ;
                 436     ; The character supplied in register s0.
                 437     ; If the character is in the range 'a' to 'z', it is converted
                 438     ; to the equivalent upper case character in the range 'A' to 'Z'.
                 439     ; All other characters remain unchanged.
                 440     ;
                 441     ; Registers used s0.
                 442     ;
085 00061        443     upper_case:             load         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
086 25800        444                             RETURN          c
087 0007B        445                             load         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
088 25C00        446                             RETURN          nc
089 020DF        447                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
08A 24000        448                             RETURN
                 449     ;
                 450     ;
                 451     ;
                 452     ; Convert string held in scratch pad memory to upper case.
                 453     ;
                 454     ; Registers used s0, s1
                 455     ;
08B 00130        456     upper_case_string:      LOAD            s1, #string_start
08C 00001        457     ucs_loop:               load           s0, #s1
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
08D 0000D        458                             load         s0, #character_cr
08E 25000        459                             RETURN          z
08F 36085        460                             CALL            upper_case
090 00001        461                             load           s0, #s1
W: instruction `LOAD sX, kk' requires operand #2 to be of type(s): number, or expression; while the given operand is of type: register.
091 08101        462                             ADD             s1, #0x01
092 3408C        463                             JUMP            ucs_loop
                 464     ;
                 465     ;
                 466     ; Convert character '0' to '9' to numerical value in range 0 to 9
                 467     ;
                 468     ; The character supplied in register s0. If the character is in the
                 469     ; range '0' to '9', it is converted to the equivalent decimal value.
                 470     ; Characters not in the range '0' to '9' are signified by the return
                 471     ; with the CARRY flag set.
                 472     ;
                 473     ; Registers used s0.
                 474     ;
093 080C6        475     _1char_to_value:        ADD             s0, #0xc6               ;reject character codes above '9' (39 hex)
094 25800        476                             RETURN          c                       ;carry flag is set
095 0C0F6        477                             SUB             s0, #0xf6               ;reject character codes below '0' (30 hex)
096 24000        478                             RETURN                                  ;carry is set if value not in range
                 479     ;
                 480     ;
                 481     ;
                 482     ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                 483     ; an equivalent hexadecimal value in register 's0'.
                 484     ;     The upper nibble is represented by an ASCII character in register s3.
                 485     ;     The lower nibble is represented by an ASCII character in register s2.
                 486     ;
                 487     ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                 488     ; will be set on return.
                 489     ;
                 490     ; Registers used s0, s2 and s3.
                 491     ;
097 10018        492     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
098 360A4        493                             CALL            ascii_to_hex            ;convert to value
099 25800        494                             RETURN          c                       ;reject if out of range
09A 10300        495                             LOAD            s3, s0                  ;remember value
09B 28306        496                             SL0             s3                      ;multiply value by 16 to put in upper nibble
09C 28306        497                             SL0             s3
09D 28306        498                             SL0             s3
09E 28306        499                             SL0             s3
09F 10010        500                             LOAD            s0, s2                  ;Take lower nibble
0A0 360A4        501                             CALL            ascii_to_hex            ;convert to value
0A1 25800        502                             RETURN          c                       ;reject if out of range
0A2 14018        503                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
0A3 24000        504                             RETURN
                 505     ;
                 506     ;
                 507     ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                 508     ;
                 509     ; If character is not valid for hex, then CARRY is set on return.
                 510     ;
                 511     ; Register used s0
                 512     ;
0A4 080B9        513     ascii_to_hex:           ADD             s0, #0xb9               ;load for above ASCII code 46 ('F')
0A5 25800        514                             RETURN          c
0A6 0C0E9        515                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
0A7 25800        516                             RETURN          c                       ;reject below ASCII code 30 ('0')
0A8 0C011        517                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
0A9 35CAE        518                             JUMP            nc, ascii_letter
0AA 08007        519                             ADD             s0, #0x07               ;load for above ASCII code 46 ('F')
0AB 25800        520                             RETURN          c
0AC 0C0F6        521                             SUB             s0, #0xf6               ;convert to range 00 to 09
0AD 24000        522                             RETURN
0AE 0800A        523     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
0AF 24000        524                             RETURN
                 525     ;
                 526     ;
                 527     ;
                 528     ;**************************************************************************************
                 529     ; Text messages
                 530     ;**************************************************************************************
                 531     ;
                 532     ;
                 533     ; Send Carriage Return to the UART
                 534     ;
0B0 00F0D        535     send_cr:                LOAD            uart_data, #character_cr
0B1 3605D        536                             CALL            send_to_uart
0B2 24000        537                             RETURN
                 538     ;
                 539     ; Send a space to the UART
                 540     ;
0B3 00F20        541     send_space:             LOAD            uart_data, #character_space
0B4 3605D        542                             CALL            send_to_uart
0B5 24000        543                             RETURN
                 544     ;
                 545     ;
                 546     ;
                 547     ;Send a back space to the UART
                 548     ;
0B6 00F08        549     send_backspace:         LOAD            uart_data, #character_bs
0B7 3605D        550                             CALL            send_to_uart
0B8 24000        551                             RETURN
                 552     ;
                 553     ;
                 554     ; Send 'PicoBlaze Servo Control' string to the UART
                 555     ;
0B9 360B0        556     send_welcome:           CALL            send_cr
0BA 360B0        557                             CALL            send_cr
0BB 00F50        558                             LOAD            uart_data, #_character_p
0BC 3605D        559                             CALL            send_to_uart
0BD 00F69        560                             LOAD            uart_data, #character_i
0BE 3605D        561                             CALL            send_to_uart
0BF 00F63        562                             LOAD            uart_data, #character_c
0C0 3605D        563                             CALL            send_to_uart
0C1 00F6F        564                             LOAD            uart_data, #character_o
0C2 3605D        565                             CALL            send_to_uart
0C3 00F42        566                             LOAD            uart_data, #_character_b
0C4 3605D        567                             CALL            send_to_uart
0C5 00F6C        568                             LOAD            uart_data, #character_l
0C6 3605D        569                             CALL            send_to_uart
0C7 00F61        570                             LOAD            uart_data, #character_a
0C8 3605D        571                             CALL            send_to_uart
0C9 00F7A        572                             LOAD            uart_data, #character_z
0CA 3605D        573                             CALL            send_to_uart
0CB 00F65        574                             LOAD            uart_data, #character_e
0CC 3605D        575                             CALL            send_to_uart
0CD 360B3        576                             CALL            send_space
0CE 00F50        577                             LOAD            uart_data, #_character_p
0CF 3605D        578                             CALL            send_to_uart
0D0 00F57        579                             LOAD            uart_data, #_character_w
0D1 3605D        580                             CALL            send_to_uart
0D2 00F4D        581                             LOAD            uart_data, #_character_m
0D3 3605D        582                             CALL            send_to_uart
0D4 360B3        583                             CALL            send_space
0D5 00F43        584                             LOAD            uart_data, #_character_c
0D6 3605D        585                             CALL            send_to_uart
0D7 00F6F        586                             LOAD            uart_data, #character_o
0D8 3605D        587                             CALL            send_to_uart
0D9 00F6E        588                             LOAD            uart_data, #character_n
0DA 3605D        589                             CALL            send_to_uart
0DB 00F74        590                             LOAD            uart_data, #character_t
0DC 3605D        591                             CALL            send_to_uart
0DD 00F72        592                             LOAD            uart_data, #character_r
0DE 3605D        593                             CALL            send_to_uart
0DF 00F6F        594                             LOAD            uart_data, #character_o
0E0 3605D        595                             CALL            send_to_uart
0E1 00F6C        596                             LOAD            uart_data, #character_l
0E2 3605D        597                             CALL            send_to_uart
0E3 360B0        598                             CALL            send_cr
0E4 360B0        599                             CALL            send_cr
0E5 24000        600                             RETURN
                 601     ;
                 602     ;
                 603     ;Send 'KCPSM3>' prompt to the UART
                 604     ;
0E6 360B0        605     send_prompt:            CALL            send_cr                 ;start new line
0E7 00F4B        606                             LOAD            uart_data, #_character_k
0E8 3605D        607                             CALL            send_to_uart
0E9 00F43        608                             LOAD            uart_data, #_character_c
0EA 3605D        609                             CALL            send_to_uart
0EB 00F50        610                             LOAD            uart_data, #_character_p
0EC 3605D        611                             CALL            send_to_uart
0ED 00F53        612                             LOAD            uart_data, #_character_s
0EE 3605D        613                             CALL            send_to_uart
0EF 00F4D        614                             LOAD            uart_data, #_character_m
0F0 3605D        615                             CALL            send_to_uart
0F1 00F33        616                             LOAD            uart_data, #character_3
0F2 3605D        617                             CALL            send_to_uart
                 618     ;
                 619     ;Send '>' character to the UART
                 620     ;
0F3 00F3E        621     send_greater_than:      LOAD            uart_data, #character_greater_than
0F4 3605D        622                             CALL            send_to_uart
0F5 24000        623                             RETURN
                 624     ;
                 625     ;
                 626     ;Send 'Overflow Error' to the UART
                 627     ;
0F6 00F4F        628     send_overflow_error:    LOAD            uart_data, #_character_o
0F7 3605D        629                             CALL            send_to_uart
0F8 00F76        630                             LOAD            uart_data, #character_v
0F9 3605D        631                             CALL            send_to_uart
0FA 00F65        632                             LOAD            uart_data, #character_e
0FB 3605D        633                             CALL            send_to_uart
0FC 00F72        634                             LOAD            uart_data, #character_r
0FD 3605D        635                             CALL            send_to_uart
0FE 00F66        636                             LOAD            uart_data, #character_f
0FF 3605D        637                             CALL            send_to_uart
100 00F6C        638                             LOAD            uart_data, #character_l
101 3605D        639                             CALL            send_to_uart
102 00F6F        640                             LOAD            uart_data, #character_o
103 3605D        641                             CALL            send_to_uart
104 00F77        642                             LOAD            uart_data, #character_w
105 3605D        643                             CALL            send_to_uart
106 360B3        644     send_space_error:       CALL            send_space
                 645     ;
                 646     ;Send 'Error' to the UART
                 647     ;
107 00F45        648     send_error:             LOAD            uart_data, #_character_e
108 3605D        649                             CALL            send_to_uart
109 00F72        650                             LOAD            uart_data, #character_r
10A 3605D        651                             CALL            send_to_uart
10B 3605D        652                             CALL            send_to_uart
10C 00F6F        653                             LOAD            uart_data, #character_o
10D 3605D        654                             CALL            send_to_uart
10E 00F72        655                             LOAD            uart_data, #character_r
10F 3605D        656                             CALL            send_to_uart
110 340B0        657                             JUMP            send_cr
                 658     ;
                 659     ;
                 660     ;Send 'OK' to the UART
                 661     ;
111 360B0        662     send_ok:                CALL            send_cr
112 00F4F        663                             LOAD            uart_data, #_character_o
113 3605D        664                             CALL            send_to_uart
114 00F4B        665                             LOAD            uart_data, #_character_k
115 3605D        666                             CALL            send_to_uart
116 340B0        667                             JUMP            send_cr
                 668     ;
                 669     ;
                 670     ;**************************************************************************************
                 671     ; Interrupt Service Routine (ISR)
                 672     ;**************************************************************************************
                 673     ;
                 674     ; Interrupts occur at 3.92us intervals and are used to generate the PWM pulses generated
                 675     ; at a PRF of 1KHz. The 3.92us interrupt rate corresponds with a resolution of 256 steps
                 676     ; over the 1ms associated with the 1KHz PRF.
                 677     ;
                 678     ; The ISR is self contained and all registers used are preserved. Scratch pad memory
                 679     ; locations are used to determine the desired duty factor for each of 12 channels.
                 680     ;
                 681     ; Note that an interrupt is generated every 196 clock cycles. This means that there is
                 682     ; only time to execute 98 instructions between each interrupt. This ISR is 48 instructions
                 683     ; long. A further 3 instructions are also consumed by the interrupt process
                 684     ; (abandoned instruction, virtual CALL to 3FF and the interrupt vector JUMP) and hence
                 685     ; PicoBlaze has approximately half of its time available for other tasks in the main program.
                 686     ;
                 687     ; Although a loop would normal be employed in software to process each of 12 channels,
                 688     ; the implementation of a loop would increase the number of instructions which needed to
                 689     ; be executed to such an extent that this 12 channel implementation would not be possible.
                 690     ; Consequently the code is written out in a linear fashion which consumes more program
                 691     ; space but which executes faster.
                 692     ;
117 10068        693     isr:                    load           s0, isr_preserve_s0     ;preserve registers to be used
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
118 10170        694                             load           s1, isr_preserve_s1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
119 10278        695                             load           s2, isr_preserve_s2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 696     ;Determine the number of steps currently through the 1ms PWM cycle
11A 10100        697                             load           s1, pwm_duty_counter    ;read 8-bit counter of steps
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11B 08101        698                             ADD             s1, #0x01               ;increment counter (will roll over to zero)
11C 10100        699                             load           s1, pwm_duty_counter    ;update count value in memory for next interrupt.
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
                 700     ;Read duty factor for each channel and load it with the duty counter and set or
                 701     ;reset a bit in register s2 accordingly.
11D 10060        702                             load           s0, pwm_channel11       ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
11E 10100        703                             load         s1, s0                  ;set carry flag if duty factor > duty counter
11F 28200        704                             SLA             s2                      ;shift carry into register s2
120 10058        705                             load           s0, pwm_channel10       ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
121 10100        706                             load         s1, s0                  ;set carry flag if duty factor > duty counter
122 28200        707                             SLA             s2                      ;shift carry into register s2
123 10050        708                             load           s0, pwm_channel9        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
124 10100        709                             load         s1, s0                  ;set carry flag if duty factor > duty counter
125 28200        710                             SLA             s2                      ;shift carry into register s2
126 10048        711                             load           s0, pwm_channel8        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
127 10100        712                             load         s1, s0                  ;set carry flag if duty factor > duty counter
128 28200        713                             SLA             s2                      ;shift carry into register s2
129 22240        714                             OUTPUT          s2, simple_port         ;drive pins on connector J4
12A 10040        715                             load           s0, pwm_channel7        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
12B 10100        716                             load         s1, s0                  ;set carry flag if duty factor > duty counter
12C 28200        717                             SLA             s2                      ;shift carry into register s2
12D 10038        718                             load           s0, pwm_channel6        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
12E 10100        719                             load         s1, s0                  ;set carry flag if duty factor > duty counter
12F 28200        720                             SLA             s2                      ;shift carry into register s2
130 10030        721                             load           s0, pwm_channel5        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
131 10100        722                             load         s1, s0                  ;set carry flag if duty factor > duty counter
132 28200        723                             SLA             s2                      ;shift carry into register s2
133 10028        724                             load           s0, pwm_channel4        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
134 10100        725                             load         s1, s0                  ;set carry flag if duty factor > duty counter
135 28200        726                             SLA             s2                      ;shift carry into register s2
136 10020        727                             load           s0, pwm_channel3        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
137 10100        728                             load         s1, s0                  ;set carry flag if duty factor > duty counter
138 28200        729                             SLA             s2                      ;shift carry into register s2
139 10018        730                             load           s0, pwm_channel2        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13A 10100        731                             load         s1, s0                  ;set carry flag if duty factor > duty counter
13B 28200        732                             SLA             s2                      ;shift carry into register s2
13C 10010        733                             load           s0, pwm_channel1        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
13D 10100        734                             load         s1, s0                  ;set carry flag if duty factor > duty counter
13E 28200        735                             SLA             s2                      ;shift carry into register s2
13F 10008        736                             load           s0, pwm_channel0        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
140 10100        737                             load         s1, s0                  ;set carry flag if duty factor > duty counter
141 28200        738                             SLA             s2                      ;shift carry into register s2
142 22280        739                             OUTPUT          s2, led_port            ;drive LEDs
143 10068        740                             load           s0, isr_preserve_s0     ;reload register values
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
144 10170        741                             load           s1, isr_preserve_s1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
145 10278        742                             load           s2, isr_preserve_s2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
146 2C001        743                             RETURNI         enable
                 744     ;
                 745     ;
                 746     ;**************************************************************************************
                 747     ; Interrupt Vector
                 748     ;**************************************************************************************
                 749     ;
  003FF          750                             ORG             0x3ff
3FF 34117        751                             JUMP            isr
                 752     ;
                 753     ;
                 754
