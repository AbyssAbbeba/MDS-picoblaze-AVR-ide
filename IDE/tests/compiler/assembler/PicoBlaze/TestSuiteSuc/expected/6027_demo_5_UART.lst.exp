                   1     ; MDS PicoBlaze IDE - Demonstration code
                   2
                   3     ; Macro instructions
                   4     ; See manual for more info
                   5
                   6     ; You may find some useful advices how to use this
                   7     ; IDE more efficiently
                   8     ; [Main menu] -> [Help] -> [Tip of the day]
                   9
                  10     ; Web page: www.moravia-microsystems.com
                  11     ; --------------------
                  12     ; Simple program for comunication with UART.
                  13     ; You can easily modify this example and use it in your aplication.
                  14     ; VHDL code of UART is included
                  15     ;
                  16     ; Press Start simulation and Animate to run the program
                  17     ;
                  18     device kcpsm6
                  19
                  20     ; Asign names to registers
  00000           21             NAMEREG         s0,temp1              ; temporary data register
  00001           22             NAMEREG         s1,temp2              ; temporary data register
  00002           23             NAMEREG         s2,temp3              ; temporary data register
                  24             ; OR
  00003           25             RX_data        AUTOREG   AT 3          ; RX data
  00004           26             TXdata        AUTOREG               ; TX data
  00005           27             LED_reg       AUTOREG           ; Leds data register
                  28
                  29     ; PORT_IDs
  00001           30             TX_id       PORT        0x01          ;  data register port ID
  00002           31             RX_id       PORT        0x02          ;  data register port ID
  00004           32             UART_stat   PORT        0x04          ; status register port ID
  00008           33             LED_id      PORT        0x08          ; Led register
                  34     ; UART Status register:
                  35     ;  [2] Tx ready
                  36     ;  [3] new Rx data
                  37     ;  [4] Rx buffer overflow
                  38
                  39     ;  Macro definition
                  40     ;==============================================================================;
                  41     ; UART status checking MACRO (IF TX can be done)
                  42     UART_ready_wait     MACRO
                  43                         INPUT       Temp1, UART_stat    ; checking UART status
                  44                         TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
                  45                         JUMP        Z, ($ - 2)
                  46                         ENDM
                  47     ; UART status checking MACRO (NEW RX data?)
                  48     UART_new_data_wait  MACRO
                  49                         INPUT       Temp1, UART_stat    ; checking UART status
                  50                         TEST        Temp1, 8            ; test bit 2 (is Tx ready?)
                  51                         JUMP        Z, ($ - 2)
                  52                         ENDM
                  53     ;==============================================================================;
                  54     ; Macro for sending character via UART
                  55     ; Parameters: 1
                  56     ;==============================================================================;
                  57     Sendchar            MACRO       char                 ; One parameter
                  58                         UART_ready_wait                  ; Expand UART_ready_wait MACRO here
                  59                         LOAD        TXdata, char
                  60                         OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                  61                         ENDM
                  62     ;==============================================================================;
                  63     ; Reads a single character from UART (waits on receive when none is prepared)
                  64     ; Registers used: Temp1, chreg
                  65     ;==============================================================================;
                  66     GetChar             MACRO
                  67                         UART_new_data_wait              ; Wait for new data
                  68                         INPUT       RX_data, RX_id       ; TX PORT_ID, sending char parameter
                  69                         ENDM
                  70     ;==============================================================================;
                  71     ; Send 0D and 0A character pair via UART
                  72     ; Macros used: SendChar
                  73     ;==============================================================================;
                  74     SendCRLF            MACRO
                  75                         SendChar  0x0D          ; CR character
                  76                         SendChar  0x0A          ; CR character
                  77                         ENDM                           ; Return from procedure
                  78     ;==============================================================================;
                  79
                  80     ;==============================================================================;
                  81     ; Procedures for waiting for specified time
                  82     ; Duration is set in registers Temp1, Temp2 and Temp3
                  83     ;
                  84     ;   clock           instruction execution time
                  85     ;   10.00 MHz              200.00 ns
                  86     ;   19.44 MHz              102.88 ns
                  87     ;   38.88 MHz               51.44 ns
                  88     ;   50.00 MHz               40.00 ns
                  89     ;  100.00 MHz               20.00 ns
                  90     ;
                  91     ; wait_time = (4 + (((2 * Temp1) + 2) * Temp2 + 2) * Temp3) * 2 * clk_period
                  92     ;   1s @ (10 MHz, Temp1 = 250, Temp2 = 249, Temp3 = 40)
                  93     ;
                  94     ; Waiting loops
                  95     ;==============================================================================;
                  96     wait_for_1s         MACRO
                  97
                  98                         LOCAL     wait_1s
                  99                         LOCAL     wait_1s_i
                 100
                 101     wait_1s:            LOAD      Temp1, #250          ; Load Temp1 register
                 102                         LOAD      Temp2, #249          ; Load Temp2 register
                 103                         LOAD      Temp3, #200          ; Load Temp3 register
                 104     wait_1s_i:          SUB       Temp1, #1
                 105                         JUMP      NZ, wait_1s_i
                 106                         SUB       Temp2, #1
                 107                         JUMP      NZ, wait_1s_i
                 108                         SUB       Temp3, #1
                 109                         JUMP      NZ, wait_1s_i
                 110                         ENDM
                 111     ;--------------------------------------------------------------------------
                 112     wait_for_100ms      MACRO
                 113
                 114                         LOCAL     wait_100ms
                 115                         LOCAL     wait_100ms_i
                 116
                 117     wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
                 118                         LOAD      Temp2, #249          ; Load Temp2 register
                 119                         LOAD      Temp3, #20           ; Load Temp3 register
                 120     wait_100ms_i:       SUB       Temp1, #1
                 121                         JUMP      NZ, wait_100ms_i
                 122                         SUB       Temp2, #1
                 123                         JUMP      NZ, wait_100ms_i
                 124                         SUB       Temp3, #1
                 125                         JUMP      NZ, wait_100ms_i
                 126                         ENDM
                 127     ;==============================================================================;
                 128     ; UART RX register:
                 129     ;  [1] Rotate leds 8x
                 130     ;  [2] Send "Hello world" via UART
                 131     ;-------------------------------------------------------------------------------------
                 132     RX_resolve          MACRO     uart_byte
                 133
                 134                         IF  uart_byte == #1
                 135                                 REPT    8
                 136                             RR      LED_reg
                 137                             wait_for_100ms
                 138                             ENDR
                 139
                 140
                 141                         ELSEIF      uart_byte == #2
                 142                             SendChar  'I'
W: value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
                 143                             SendChar  'N'
W: value out of range: 0x4e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
                 144                             SendChar  'T'
W: value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 145                             SendChar  'E'
W: value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
                 146                             SendChar  'R'
W: value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
                 147                             SendChar  'R'
W: value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
                 148                             SendChar  'U'
W: value out of range: 0x55, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
                 149                             SendChar  'P'
W: value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
                 150                             SendChar  'T'
W: value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 151                             SendCRLF
                 152
                 153                         ENDIF
                 154
                 155                         ENDM
                 156
                 157     ;=======================================================================
                 158     ; END OF MACRO DEFINITIONS ;;
                 159     ;=======================================================================
                 160     ; Main program >>>
                 161
                 162     ; Vectors
  003FF          163             ADDRESS 0x3FF                             ; interrupt vector
3FF 22001        164             JUMP    INTERRUPT
  00000          165             ADDRESS 0x000                             ; RESET vector
000 22039        166             JUMP    Start
                 167
                 168     ;-------------------------------------------------------------------------
                 169     ; Interrupt routine
  00001          170     INTERRUPT:          SendChar  'I'
W: value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
W: ==> ==> value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
                 171 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
001 09004        172 +2                      INPUT       Temp1, UART_stat    ; checking UART status
002 0C040        173 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
003 32001        174 +2                      JUMP        Z, ($ - 2)
004 00490        175 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
005 2D401        176 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 177                         SendChar  'N'
W: value out of range: 0x4e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
W: ==> ==> value out of range: 0x4e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
                 178 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
006 09004        179 +2                      INPUT       Temp1, UART_stat    ; checking UART status
007 0C040        180 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
008 32006        181 +2                      JUMP        Z, ($ - 2)
009 004E0        182 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x4e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
00A 2D401        183 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 184                         SendChar  'T'
W: value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
W: ==> ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 185 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
00B 09004        186 +2                      INPUT       Temp1, UART_stat    ; checking UART status
00C 0C040        187 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
00D 3200B        188 +2                      JUMP        Z, ($ - 2)
00E 00440        189 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
00F 2D401        190 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 191                         SendChar  'E'
W: value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
W: ==> ==> value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
                 192 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
010 09004        193 +2                      INPUT       Temp1, UART_stat    ; checking UART status
011 0C040        194 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
012 32010        195 +2                      JUMP        Z, ($ - 2)
013 00450        196 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
014 2D401        197 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 198                         SendChar  'R'
W: value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
W: ==> ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
                 199 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
015 09004        200 +2                      INPUT       Temp1, UART_stat    ; checking UART status
016 0C040        201 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
017 32015        202 +2                      JUMP        Z, ($ - 2)
018 00420        203 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
019 2D401        204 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 205                         SendChar  'R'
W: value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
W: ==> ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
                 206 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
01A 09004        207 +2                      INPUT       Temp1, UART_stat    ; checking UART status
01B 0C040        208 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
01C 3201A        209 +2                      JUMP        Z, ($ - 2)
01D 00420        210 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
01E 2D401        211 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 212                         SendChar  'U'
W: value out of range: 0x55, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
W: ==> ==> value out of range: 0x55, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
                 213 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
01F 09004        214 +2                      INPUT       Temp1, UART_stat    ; checking UART status
020 0C040        215 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
021 3201F        216 +2                      JUMP        Z, ($ - 2)
022 00450        217 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x55, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
023 2D401        218 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 219                         SendChar  'P'
W: value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
W: ==> ==> value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
                 220 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
024 09004        221 +2                      INPUT       Temp1, UART_stat    ; checking UART status
025 0C040        222 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
026 32024        223 +2                      JUMP        Z, ($ - 2)
027 00400        224 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
028 2D401        225 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 226                         SendChar  'T'
W: value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
W: ==> ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 227 +1                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
029 09004        228 +2                      INPUT       Temp1, UART_stat    ; checking UART status
02A 0C040        229 +2                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
02B 32029        230 +2                      JUMP        Z, ($ - 2)
02C 00440        231 +1                      LOAD        TXdata, char
W: ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
02D 2D401        232 +1                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 233                         SendCRLF
                 234 +1                      SendChar  0x0D          ; CR character
                 235 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
02E 09004        236 +3                      INPUT       Temp1, UART_stat    ; checking UART status
02F 0C040        237 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
030 3202E        238 +3                      JUMP        Z, ($ - 2)
031 004D0        239 +2                      LOAD        TXdata, char
032 2D401        240 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 241 +1                      SendChar  0x0A          ; CR character
                 242 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
033 09004        243 +3                      INPUT       Temp1, UART_stat    ; checking UART status
034 0C040        244 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
035 32033        245 +3                      JUMP        Z, ($ - 2)
036 004A0        246 +2                      LOAD        TXdata, char
037 2D401        247 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
038 29001        248                         RETURNI ENABLE
                 249     ; Start of main program
  00039          250     Start:
                 251                         wait_for_1s             ; wait for initialization of FPGA circuits
                 252 +1                      LOCAL     wait_1s
                 253 +1                      LOCAL     wait_1s_i
                 254 +1
039 010FA        255 +1  wait_1s:            LOAD      Temp1, #250          ; Load Temp1 register
03A 011F9        256 +1                      LOAD      Temp2, #249          ; Load Temp2 register
03B 012C8        257 +1                      LOAD      Temp3, #200          ; Load Temp3 register
03C 19001        258 +1  wait_1s_i:          SUB       Temp1, #1
03D 3603C        259 +1                      JUMP      NZ, wait_1s_i
03E 19101        260 +1                      SUB       Temp2, #1
03F 3603C        261 +1                      JUMP      NZ, wait_1s_i
040 19201        262 +1                      SUB       Temp3, #1
041 3603C        263 +1                      JUMP      NZ, wait_1s_i
042 28001        264                         ENABLE INTERRUPT
                 265     ; ---------------------------------------- Main loop
                 266
  00043          267     main_loop:          GetChar                       ; Receive via UART, get status of switches for example
                 268 +1                      UART_new_data_wait              ; Wait for new data
043 09004        269 +2                      INPUT       Temp1, UART_stat    ; checking UART status
044 0C080        270 +2                      TEST        Temp1, 8            ; test bit 2 (is Tx ready?)
045 32043        271 +2                      JUMP        Z, ($ - 2)
046 09302        272 +1                      INPUT       RX_data, RX_id       ; TX PORT_ID, sending char parameter
                 273                         RX_resolve  RX_data           ; Resolve received byte
W: ==> ==> ==> value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
W: ==> ==> ==> value out of range: 0x4e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
W: ==> ==> ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
W: ==> ==> ==> value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
W: ==> ==> ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
W: ==> ==> ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
W: ==> ==> ==> value out of range: 0x55, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
W: ==> ==> ==> value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
W: ==> ==> ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 274 +1                      IF  uart_byte == #1
047 1D301        275 +2      COMPARE RX_DATA, #0x1
048 3609A        276 +2      JUMP    NZ, IF-0
                 277 +1                              REPT    8
                 278 +1                          RR      LED_reg
                 279 +1                          wait_for_100ms
                 280 +1                          ENDR
049 1450C        281 +2                          RR      LED_reg
                 282 +2                          wait_for_100ms
                 283 +3                      LOCAL     wait_100ms
                 284 +3                      LOCAL     wait_100ms_i
                 285 +3
04A 010FA        286 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
04B 011F9        287 +3                      LOAD      Temp2, #249          ; Load Temp2 register
04C 01214        288 +3                      LOAD      Temp3, #20           ; Load Temp3 register
04D 19001        289 +3  wait_100ms_i:       SUB       Temp1, #1
04E 3604D        290 +3                      JUMP      NZ, wait_100ms_i
04F 19101        291 +3                      SUB       Temp2, #1
050 3604D        292 +3                      JUMP      NZ, wait_100ms_i
051 19201        293 +3                      SUB       Temp3, #1
052 3604D        294 +3                      JUMP      NZ, wait_100ms_i
053 1450C        295 +2                          RR      LED_reg
                 296 +2                          wait_for_100ms
                 297 +3                      LOCAL     wait_100ms
                 298 +3                      LOCAL     wait_100ms_i
                 299 +3
054 010FA        300 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
055 011F9        301 +3                      LOAD      Temp2, #249          ; Load Temp2 register
056 01214        302 +3                      LOAD      Temp3, #20           ; Load Temp3 register
057 19001        303 +3  wait_100ms_i:       SUB       Temp1, #1
058 36057        304 +3                      JUMP      NZ, wait_100ms_i
059 19101        305 +3                      SUB       Temp2, #1
05A 36057        306 +3                      JUMP      NZ, wait_100ms_i
05B 19201        307 +3                      SUB       Temp3, #1
05C 36057        308 +3                      JUMP      NZ, wait_100ms_i
05D 1450C        309 +2                          RR      LED_reg
                 310 +2                          wait_for_100ms
                 311 +3                      LOCAL     wait_100ms
                 312 +3                      LOCAL     wait_100ms_i
                 313 +3
05E 010FA        314 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
05F 011F9        315 +3                      LOAD      Temp2, #249          ; Load Temp2 register
060 01214        316 +3                      LOAD      Temp3, #20           ; Load Temp3 register
061 19001        317 +3  wait_100ms_i:       SUB       Temp1, #1
062 36061        318 +3                      JUMP      NZ, wait_100ms_i
063 19101        319 +3                      SUB       Temp2, #1
064 36061        320 +3                      JUMP      NZ, wait_100ms_i
065 19201        321 +3                      SUB       Temp3, #1
066 36061        322 +3                      JUMP      NZ, wait_100ms_i
067 1450C        323 +2                          RR      LED_reg
                 324 +2                          wait_for_100ms
                 325 +3                      LOCAL     wait_100ms
                 326 +3                      LOCAL     wait_100ms_i
                 327 +3
068 010FA        328 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
069 011F9        329 +3                      LOAD      Temp2, #249          ; Load Temp2 register
06A 01214        330 +3                      LOAD      Temp3, #20           ; Load Temp3 register
06B 19001        331 +3  wait_100ms_i:       SUB       Temp1, #1
06C 3606B        332 +3                      JUMP      NZ, wait_100ms_i
06D 19101        333 +3                      SUB       Temp2, #1
06E 3606B        334 +3                      JUMP      NZ, wait_100ms_i
06F 19201        335 +3                      SUB       Temp3, #1
070 3606B        336 +3                      JUMP      NZ, wait_100ms_i
071 1450C        337 +2                          RR      LED_reg
                 338 +2                          wait_for_100ms
                 339 +3                      LOCAL     wait_100ms
                 340 +3                      LOCAL     wait_100ms_i
                 341 +3
072 010FA        342 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
073 011F9        343 +3                      LOAD      Temp2, #249          ; Load Temp2 register
074 01214        344 +3                      LOAD      Temp3, #20           ; Load Temp3 register
075 19001        345 +3  wait_100ms_i:       SUB       Temp1, #1
076 36075        346 +3                      JUMP      NZ, wait_100ms_i
077 19101        347 +3                      SUB       Temp2, #1
078 36075        348 +3                      JUMP      NZ, wait_100ms_i
079 19201        349 +3                      SUB       Temp3, #1
07A 36075        350 +3                      JUMP      NZ, wait_100ms_i
07B 1450C        351 +2                          RR      LED_reg
                 352 +2                          wait_for_100ms
                 353 +3                      LOCAL     wait_100ms
                 354 +3                      LOCAL     wait_100ms_i
                 355 +3
07C 010FA        356 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
07D 011F9        357 +3                      LOAD      Temp2, #249          ; Load Temp2 register
07E 01214        358 +3                      LOAD      Temp3, #20           ; Load Temp3 register
07F 19001        359 +3  wait_100ms_i:       SUB       Temp1, #1
080 3607F        360 +3                      JUMP      NZ, wait_100ms_i
081 19101        361 +3                      SUB       Temp2, #1
082 3607F        362 +3                      JUMP      NZ, wait_100ms_i
083 19201        363 +3                      SUB       Temp3, #1
084 3607F        364 +3                      JUMP      NZ, wait_100ms_i
085 1450C        365 +2                          RR      LED_reg
                 366 +2                          wait_for_100ms
                 367 +3                      LOCAL     wait_100ms
                 368 +3                      LOCAL     wait_100ms_i
                 369 +3
086 010FA        370 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
087 011F9        371 +3                      LOAD      Temp2, #249          ; Load Temp2 register
088 01214        372 +3                      LOAD      Temp3, #20           ; Load Temp3 register
089 19001        373 +3  wait_100ms_i:       SUB       Temp1, #1
08A 36089        374 +3                      JUMP      NZ, wait_100ms_i
08B 19101        375 +3                      SUB       Temp2, #1
08C 36089        376 +3                      JUMP      NZ, wait_100ms_i
08D 19201        377 +3                      SUB       Temp3, #1
08E 36089        378 +3                      JUMP      NZ, wait_100ms_i
08F 1450C        379 +2                          RR      LED_reg
                 380 +2                          wait_for_100ms
                 381 +3                      LOCAL     wait_100ms
                 382 +3                      LOCAL     wait_100ms_i
                 383 +3
090 010FA        384 +3  wait_100ms:         LOAD      Temp1, #250          ; Load Temp1 register
091 011F9        385 +3                      LOAD      Temp2, #249          ; Load Temp2 register
092 01214        386 +3                      LOAD      Temp3, #20           ; Load Temp3 register
093 19001        387 +3  wait_100ms_i:       SUB       Temp1, #1
094 36093        388 +3                      JUMP      NZ, wait_100ms_i
095 19101        389 +3                      SUB       Temp2, #1
096 36093        390 +3                      JUMP      NZ, wait_100ms_i
097 19201        391 +3                      SUB       Temp3, #1
098 36093        392 +3                      JUMP      NZ, wait_100ms_i
                 393 +1
                 394 +1
                 395 +1                      ELSEIF      uart_byte == #2
099 220D3        396 +2      JUMP    IF-0-END
  0009A          397 +2  IF-0:
09A 1D302        398 +2      COMPARE RX_DATA, #0x2
09B 360D3        399 +2      JUMP    NZ, IF-1
                 400 +1                          SendChar  'I'
W: ==> ==> value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
                 401 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
09C 09004        402 +3                      INPUT       Temp1, UART_stat    ; checking UART status
09D 0C040        403 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
09E 3209C        404 +3                      JUMP        Z, ($ - 2)
09F 00490        405 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
0A0 2D401        406 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 407 +1                          SendChar  'N'
W: ==> ==> value out of range: 0x4e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
                 408 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0A1 09004        409 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0A2 0C040        410 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0A3 320A1        411 +3                      JUMP        Z, ($ - 2)
0A4 004E0        412 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x4e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
0A5 2D401        413 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 414 +1                          SendChar  'T'
W: ==> ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 415 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0A6 09004        416 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0A7 0C040        417 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0A8 320A6        418 +3                      JUMP        Z, ($ - 2)
0A9 00440        419 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
0AA 2D401        420 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 421 +1                          SendChar  'E'
W: ==> ==> value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
                 422 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0AB 09004        423 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0AC 0C040        424 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0AD 320AB        425 +3                      JUMP        Z, ($ - 2)
0AE 00450        426 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
0AF 2D401        427 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 428 +1                          SendChar  'R'
W: ==> ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
                 429 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0B0 09004        430 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0B1 0C040        431 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0B2 320B0        432 +3                      JUMP        Z, ($ - 2)
0B3 00420        433 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
0B4 2D401        434 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 435 +1                          SendChar  'R'
W: ==> ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
                 436 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0B5 09004        437 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0B6 0C040        438 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0B7 320B5        439 +3                      JUMP        Z, ($ - 2)
0B8 00420        440 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
0B9 2D401        441 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 442 +1                          SendChar  'U'
W: ==> ==> value out of range: 0x55, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
                 443 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0BA 09004        444 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0BB 0C040        445 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0BC 320BA        446 +3                      JUMP        Z, ($ - 2)
0BD 00450        447 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x55, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
0BE 2D401        448 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 449 +1                          SendChar  'P'
W: ==> ==> value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
                 450 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0BF 09004        451 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0C0 0C040        452 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0C1 320BF        453 +3                      JUMP        Z, ($ - 2)
0C2 00400        454 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
0C3 2D401        455 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 456 +1                          SendChar  'T'
W: ==> ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
                 457 +2                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0C4 09004        458 +3                      INPUT       Temp1, UART_stat    ; checking UART status
0C5 0C040        459 +3                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0C6 320C4        460 +3                      JUMP        Z, ($ - 2)
0C7 00440        461 +2                      LOAD        TXdata, char
W: ==> value out of range: 0x54, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
0C8 2D401        462 +2                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 463 +1                          SendCRLF
                 464 +2                      SendChar  0x0D          ; CR character
                 465 +3                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0C9 09004        466 +4                      INPUT       Temp1, UART_stat    ; checking UART status
0CA 0C040        467 +4                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0CB 320C9        468 +4                      JUMP        Z, ($ - 2)
0CC 004D0        469 +3                      LOAD        TXdata, char
0CD 2D401        470 +3                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 471 +2                      SendChar  0x0A          ; CR character
                 472 +3                      UART_ready_wait                  ; Expand UART_ready_wait MACRO here
0CE 09004        473 +4                      INPUT       Temp1, UART_stat    ; checking UART status
0CF 0C040        474 +4                      TEST        Temp1, 4            ; test bit 2 (is Tx ready?)
0D0 320CE        475 +4                      JUMP        Z, ($ - 2)
0D1 004A0        476 +3                      LOAD        TXdata, char
0D2 2D401        477 +3                      OUTPUT      TXdata, TX_id       ; TX PORT_ID, sending char parameter
                 478 +1
                 479 +1                      ENDIF
  000D3          480 +2  IF-0-END:
  000D3          481 +2  IF-1:
0D3 22043        482                         JUMP        main_loop
                 483
                 484
                 485     ; AND NOW YOU ARE READY !
                 486     ; We hope this example can help you use this IDE at his maximum potential
                 487     ; Click on [Main menu] -> [Project] -> [New] and create your own PicoBlaze project ...
