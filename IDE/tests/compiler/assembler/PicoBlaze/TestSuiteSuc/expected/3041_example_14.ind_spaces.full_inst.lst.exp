                   1     ;KCPSM3 Program - UART programming of SPI Flash memory on Spartan-3E Starter Kit.
                   2     device kcpsm3
                   3     ;
                   4     ;Ken Chapman - Xilinx Ltd
                   5     ;
                   6     ;Version v1.00 - 11th November 2005
                   7     ;
                   8     ;This program uses a 115200 baud UART connection with XON/XOFF flow control
                   9     ;to allow a standard MCS file for the configuration of a Spartan-3E device to
                  10     ;be programmed into the ST Microelectronics M25P16 device on the board.
                  11     ;
                  12     ;
                  13     ;
                  14     ;As well as the port connections vital to communication with the UART and the SPI
                  15     ;FLASH memory, there are additional port connections used to disable the other
                  16     ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
                  17     ;controlled at the hardware level, they are included in this code to aid
                  18     ;future investigations of communication with the other SPI devices using PicoBlaze.
                  19     ;
                  20     ;
                  21     ;
                  22     ;
                  23     ;Port definitions
                  24     ;
  00000           25     status_port             EQU             0x00                    ;UART and filter status input
  00001           26     tx_data_present         EQU             0x01                    ;  Transmitter  data present - bit0
  00002           27     tx_half_full            EQU             0x02                    ;    FIFO          half full - bit1
  00004           28     tx_full                 EQU             0x04                    ;                       full - bit2
  00008           29     rx_data_present         EQU             0x08                    ;               data present - bit3
  00010           30     rx_half_full            EQU             0x10                    ;  Receiver        half full - bit4
  00020           31     rx_full                 EQU             0x20                    ;    FIFO               full - bit5
                  32     ;
  00001           33     uart_read_port          EQU             0x01                    ;UART Rx data input
                  34     ;
  00010           35     uart_write_port         EQU             0x10                    ;UART Tx data output
                  36     ;
                  37     ;
  00008           38     spi_control_port        EQU             0x08                    ;SPI clock and chip selects
  00001           39     spi_sck                 EQU             0x01                    ;                  SCK - bit0
  00002           40     spi_rom_cs              EQU             0x02                    ;    serial rom select - bit1
  00004           41     spi_spare_control       EQU             0x04                    ;                spare - bit2
  00008           42     spi_amp_cs              EQU             0x08                    ;     amplifier select - bit3
  00010           43     spi_adc_conv            EQU             0x10                    ;          A/D convert - bit4
  00020           44     spi_dac_cs              EQU             0x20                    ;           D/A select - bit5
  00040           45     spi_amp_shdn            EQU             0x40                    ;       amplifier SHDN - bit6
  00080           46     spi_dac_clr             EQU             0x80                    ;            D/A clear - bit7
                  47     ;
  00004           48     spi_output_port         EQU             0x04                    ;SPI data output
  00080           49     spi_sdo                 EQU             0x80                    ;   SDO - bit7
                  50     ;
  00002           51     spi_input_port          EQU             0x02                    ;SPI data input
  00080           52     spi_sdi                 EQU             0x80                    ;             SDI - bit7
  00040           53     spi_amp_sdi             EQU             0x40                    ;   amplifier SDI - bit6
                  54     ;
                  55     ;
                  56     ;
                  57     ;
                  58     ;Special Register usage
                  59     ;
  0000F           60     uart_data               REG             sf                      ;used to pass data to and from the UART
                  61     ;
                  62     ;
                  63     ;Useful data constants
                  64     ;
                  65     ;
                  66     ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                  67     ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                  68     ;calculation highly predictable. The '6' in the following equation even allows for
                  69     ;'CALL delay_1us' instruction in the initiating code.
                  70     ;
                  71     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                  72     ;
                  73     ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                  74     ;For clock rates below 10MHz the value of 1 must be used and the operation will
                  75     ;become lower than intended.
                  76     ;
  0000B           77     delay_1us_constant      EQU             0x0b
                  78     ;
                  79     ;
                  80     ;Useful constants
                  81     ;
                  82     ;
                  83     ;ASCII table
                  84     ;
  00061           85     character_a             EQU             0x61
  00062           86     character_b             EQU             0x62
  00063           87     character_c             EQU             0x63
  00064           88     character_d             EQU             0x64
  00065           89     character_e             EQU             0x65
  00066           90     character_f             EQU             0x66
  00067           91     character_g             EQU             0x67
  00068           92     character_h             EQU             0x68
  00069           93     character_i             EQU             0x69
  0006A           94     character_j             EQU             0x6a
  0006B           95     character_k             EQU             0x6b
  0006C           96     character_l             EQU             0x6c
  0006D           97     character_m             EQU             0x6d
  0006E           98     character_n             EQU             0x6e
  0006F           99     character_o             EQU             0x6f
  00070          100     character_p             EQU             0x70
  00071          101     character_q             EQU             0x71
  00072          102     character_r             EQU             0x72
  00073          103     character_s             EQU             0x73
  00074          104     character_t             EQU             0x74
  00075          105     character_u             EQU             0x75
  00076          106     character_v             EQU             0x76
  00077          107     character_w             EQU             0x77
  00078          108     character_x             EQU             0x78
  00079          109     character_y             EQU             0x79
  0007A          110     character_z             EQU             0x7a
  00041          111     _character_a            EQU             0x41
  00042          112     _character_b            EQU             0x42
  00043          113     _character_c            EQU             0x43
  00044          114     _character_d            EQU             0x44
  00045          115     _character_e            EQU             0x45
  00046          116     _character_f            EQU             0x46
  00047          117     _character_g            EQU             0x47
  00048          118     _character_h            EQU             0x48
  00049          119     _character_i            EQU             0x49
  0004A          120     _character_j            EQU             0x4a
  0004B          121     _character_k            EQU             0x4b
  0004C          122     _character_l            EQU             0x4c
  0004D          123     _character_m            EQU             0x4d
  0004E          124     _character_n            EQU             0x4e
  0004F          125     _character_o            EQU             0x4f
  00050          126     _character_p            EQU             0x50
  00051          127     _character_q            EQU             0x51
  00052          128     _character_r            EQU             0x52
  00053          129     _character_s            EQU             0x53
  00054          130     _character_t            EQU             0x54
  00055          131     _character_u            EQU             0x55
  00056          132     _character_v            EQU             0x56
  00057          133     _character_w            EQU             0x57
  00058          134     _character_x            EQU             0x58
  00059          135     _character_y            EQU             0x59
  0005A          136     _character_z            EQU             0x5a
  00030          137     character_0             EQU             0x30
  00031          138     character_1             EQU             0x31
  00032          139     character_2             EQU             0x32
  00033          140     character_3             EQU             0x33
  00034          141     character_4             EQU             0x34
  00035          142     character_5             EQU             0x35
  00036          143     character_6             EQU             0x36
  00037          144     character_7             EQU             0x37
  00038          145     character_8             EQU             0x38
  00039          146     character_9             EQU             0x39
  0003A          147     character_colon         EQU             0x3a
  0002E          148     character_fullstop      EQU             0x2e
  0003B          149     character_semi_colon    EQU             0x3b
  0002D          150     character_minus         EQU             0x2d
  0002B          151     character_plus          EQU             0x2b
  0002C          152     character_comma         EQU             0x2c
  0003C          153     character_less_than     EQU             0x3c                    ;'<'
  0003E          154     character_greater_than  EQU             0x3e                    ;'>'
  00028          155     character_open          EQU             0x28                    ;'('
  00029          156     character_close         EQU             0x29                    ;')'
  0002F          157     character_divide        EQU             0x2f                    ;'/'
  0003D          158     character_equals        EQU             0x3d
  00020          159     character_space         EQU             0x20
  0000D          160     character_cr            EQU             0x0d                    ;carriage return
  0000A          161     character_lf            EQU             0x0a                    ;line feed
  0003F          162     character_question      EQU             0x3f                    ;'?'
  00024          163     character_dollar        EQU             0x24
  00021          164     character_exclaim       EQU             0x21                    ;'!'
  00008          165     character_bs            EQU             0x08                    ;Back Space command character
  00011          166     character_xon           EQU             0x11                    ;Flow control ON
  00013          167     character_xoff          EQU             0x13                    ;Flow control OFF
                 168     ;
                 169     ;
                 170     ;Scratch Pad Memory Locations
                 171     ;
                 172     ;
  00000          173     isr_preserve_s0         EQU             0x00                    ;preserve register during ISR
                 174     ;
  00001          175     page_address_h          EQU             0x01                    ;Remember page address for SPI boundary checking.
  00002          176     page_address_m          EQU             0x02                    ;high, middle and low bytes
  00003          177     page_address_l          EQU             0x03
                 178     ;
  00004          179     spi_control_status      EQU             0x04                    ;SPI status signals
                 180     ;
                 181     ;
                 182     ;
                 183     ;Store up to one line of an MCS file as bytes
                 184     ;A typical data line consists of:-
                 185     ;:     Start character which is not stored
                 186     ;10    Number of data bytes included (16 in this case)
                 187     ;aaaa  Lower 16-bits of the storage address
                 188     ;00    Record type (data in this case)
                 189     ;dddd...   Data bytes (typically 16 which is the maximum)
                 190     ;cc    Checksum
                 191     ;CR/LF Line will end in carriage return and/or line feed which is not stored.
                 192     ;
                 193     ;So a total of 21 could be stored before processing.
                 194     ;
  0002B          195     line_start              EQU             0x2b                    ;21 bytes until end of memory
                 196     ;
                 197     ;
                 198     ;Initialise the system and welcome message
                 199     ;
                 200     ;
000 3010E        201     cold_start:             CALL            spi_init                ;initialise SPI bus ports
001 301AA        202                             CALL            delay_1s                ;delay because UART is fast and JTAG startup sequence can be slow
002 3C001        203                             ENABLE          interrupt               ;Interrupt is used for XON/XOFF flow control
003 3021D        204     welcome_start:          CALL            send_cr
004 30223        205                             CALL            send_welcome            ;start up message and version number
                 206     ;
                 207     ;Main menu and command selection
                 208     ;
                 209     ;
                 210     ;
005 302BD        211     warm_start:             CALL            send_menu               ;Menu and command selection
006 3021D        212     prompt:                 CALL            send_cr
007 3021D        213                             CALL            send_cr
008 00F3E        214                             LOAD            uart_data, #character_greater_than ;prompt for input
009 301C1        215                             CALL            send_to_uart
00A 3001D        216                             CALL            read_upper_case
00B 14045        217                             COMPARE         s0, #_character_e       ;command test
00C 35033        218                             JUMP            z, erase_command
00D 14053        219                             COMPARE         s0, #_character_s       ;command test
00E 35040        220                             JUMP            z, sector_erase_command
00F 14050        221                             COMPARE         s0, #_character_p       ;command test
010 35054        222                             JUMP            z, program_command
011 14052        223                             COMPARE         s0, #_character_r       ;command test
012 35059        224                             JUMP            z, read_command
013 14049        225                             COMPARE         s0, #_character_i       ;command test
014 35022        226                             JUMP            z, id_command
015 14048        227                             COMPARE         s0, #_character_h       ;command test
016 35003        228                             JUMP            z, welcome_start
017 3021D        229                             CALL            send_cr                 ;no valid command input
018 00F3F        230                             LOAD            uart_data, #character_question ;display ???
019 301C1        231                             CALL            send_to_uart
01A 301C1        232                             CALL            send_to_uart
01B 301C1        233                             CALL            send_to_uart
01C 34006        234                             JUMP            prompt                  ;Try again!
                 235     ;
                 236     ;
01D 301AF        237     read_upper_case:        CALL            read_from_uart          ;read command character from UART
01E 301C1        238                             CALL            send_to_uart            ;echo character
01F 010F0        239                             LOAD            s0, uart_data           ;convert to upper case
020 301CE        240                             CALL            upper_case
021 2A000        241                             RETURN
                 242     ;
                 243     ;**************************************************************************************
                 244     ;ID Command - Read and display the ID for the SPI FLASH memory
                 245     ;**************************************************************************************
                 246     ;
                 247     ;Normal response should be
                 248     ;   s9 = Manufacturer Identification = 20 hex
                 249     ;   s8 = Memory Type = 20 hex
                 250     ;   s7 = Memory Capacity = 15 hex
                 251     ;
022 3021D        252     id_command:             CALL            send_cr
023 3013E        253                             CALL            read_spi_flash_id
024 30328        254                             CALL            send_id
025 00F3D        255                             LOAD            uart_data, #character_equals
026 301C1        256                             CALL            send_to_uart
027 30220        257                             CALL            send_space
028 01090        258                             LOAD            s0, s9
029 301F7        259                             CALL            send_hex_byte
02A 30220        260                             CALL            send_space
02B 01080        261                             LOAD            s0, s8
02C 301F7        262                             CALL            send_hex_byte
02D 30220        263                             CALL            send_space
02E 01070        264                             LOAD            s0, s7
02F 301F7        265                             CALL            send_hex_byte
030 30220        266                             CALL            send_space
031 3021D        267                             CALL            send_cr
032 34006        268                             JUMP            prompt
                 269     ;
                 270     ;**************************************************************************************
                 271     ;Erase Command - Perform bulk erase of the SPI FLASH memory and display messages
                 272     ;**************************************************************************************
                 273     ;
033 3021D        274     erase_command:          CALL            send_cr
034 3032D        275                             CALL            send_confirm            ;confirm command with a 'Y' which must be upper case
035 301AF        276                             CALL            read_from_uart          ;read command character from UART
036 301C1        277                             CALL            send_to_uart            ;echo input
037 14F59        278                             COMPARE         uart_data, #_character_y
038 3543E        279                             JUMP            nz, abort_erase
039 3021D        280                             CALL            send_cr
03A 30293        281                             CALL            send_erase_in_progress
03B 30173        282                             CALL            bulk_erase_spi
03C 302B6        283                             CALL            send_ok
03D 34006        284                             JUMP            prompt
                 285     ;
03E 3034A        286     abort_erase:            CALL            send_abort
03F 34006        287                             JUMP            prompt
                 288     ;
                 289     ;
                 290     ;**************************************************************************************
                 291     ;Sector Erase Command - Performs erase of lowest 5 sectors SPI FLASH memory which
                 292     ;covers the address range 000000 to 04FFFF in which the configuration for an XC3S500E
                 293     ;would be able to fit.
                 294     ;**************************************************************************************
                 295     ;
040 3021D        296     sector_erase_command:   CALL            send_cr
041 3032D        297                             CALL            send_confirm            ;confirm command with a 'Y' which must be upper case
042 301AF        298                             CALL            read_from_uart          ;read command character from UART
043 301C1        299                             CALL            send_to_uart            ;echo input
044 14F59        300                             COMPARE         uart_data, #_character_y
045 3543E        301                             JUMP            nz, abort_erase
046 3021D        302                             CALL            send_cr
047 30293        303                             CALL            send_erase_in_progress
048 00900        304                             LOAD            s9, #0x00               ;any address inside sector 0
049 3015F        305                             CALL            erase_spi_sector
04A 00901        306                             LOAD            s9, #0x01               ;any address inside sector 1
04B 3015F        307                             CALL            erase_spi_sector
04C 00902        308                             LOAD            s9, #0x02               ;any address inside sector 2
04D 3015F        309                             CALL            erase_spi_sector
04E 00903        310                             LOAD            s9, #0x03               ;any address inside sector 3
04F 3015F        311                             CALL            erase_spi_sector
050 00904        312                             LOAD            s9, #0x04               ;any address inside sector 4
051 3015F        313                             CALL            erase_spi_sector
052 302B6        314                             CALL            send_ok
053 34006        315                             JUMP            prompt
                 316     ;
                 317     ;
                 318     ;**************************************************************************************
                 319     ;Program Command - Program SPI FLASH memory with MCS file
                 320     ;**************************************************************************************
                 321     ;
054 3021D        322     program_command:        CALL            send_cr
055 3026C        323                             CALL            send_waiting_mcs_file
056 3006F        324                             CALL            program_mcs
057 302B6        325                             CALL            send_ok
058 34006        326                             JUMP            prompt
                 327     ;
                 328     ;
                 329     ;**************************************************************************************
                 330     ;Read Command - Read one page of memory at specified address
                 331     ;**************************************************************************************
                 332     ;
059 30357        333     read_command:           CALL            send_page_address       ;obtain 24-bit address
05A 30069        334                             CALL            obtain_8bits
05B 35859        335                             JUMP            c, read_command         ;bad input address
05C 14020        336                             COMPARE         s0, #0x20               ;test for address greater than 1FFFFF
05D 35C59        337                             JUMP            nc, read_command        ;value too big
05E 01900        338                             LOAD            s9, s0
05F 30069        339                             CALL            obtain_8bits
060 35859        340                             JUMP            c, read_command         ;bad input address
061 01800        341                             LOAD            s8, s0
062 30069        342                             CALL            obtain_8bits
063 35859        343                             JUMP            c, read_command         ;bad input address
064 01700        344                             LOAD            s7, s0
065 3021D        345                             CALL            send_cr
066 300C9        346                             CALL            send_spi_page
067 302B6        347                             CALL            send_ok
068 34006        348                             JUMP            prompt
069 3001D        349     obtain_8bits:           CALL            read_upper_case         ;obtain one byte from UART
06A 01300        350                             LOAD            s3, s0
06B 3001D        351                             CALL            read_upper_case
06C 01200        352                             LOAD            s2, s0
06D 30204        353                             CALL            ascii_byte_to_hex
06E 2A000        354                             RETURN
                 355     ;
                 356     ;
                 357     ;
                 358     ;**************************************************************************************
                 359     ;Program SPI FLASH with MCS file
                 360     ;**************************************************************************************
                 361     ;
                 362     ;Reads the MCS file from the UART and programs the SPI FLASH device at the locations.
                 363     ;specified by the file contents.
                 364     ;
                 365     ;One important factor of programming the SPI FLASH for use as configuration
                 366     ;memory is that the bits within each byte must be in reverse order. This
                 367     ;is because an SPI device outputs data MSB first compared with a Xilinx
                 368     ;serial PROM which outputs LSB first. Therefore this routine will swap
                 369     ;the bits of each byte provided by the MCS file before programming.
                 370     ;
                 371     ;This routine will continue until an end of file record is detected.
                 372     ;For each line of MCS received, the current address will be output so that
                 373     ;progress can be monitored.
                 374     ;
                 375     ;Register sA is used to remember if a page is currently open (01) or closed (00)
                 376     ;for writing on the SPI memory.
                 377     ;
06F 00A00        378     program_mcs:            LOAD            sa, #0x00               ;page is closed
070 300A9        379     next_prog_line:         CALL            read_mcs_line           ;read line
071 300B9        380                             CALL            mcs_address             ;find start address and record type
072 14B01        381                             COMPARE         sb, #0x01               ;test for end record
073 350A5        382                             JUMP            z, end_program_mcs
074 301FD        383                             CALL            send_hex_3bytes         ;send address for other lines
075 3021D        384                             CALL            send_cr
076 14B04        385                             COMPARE         sb, #0x04               ;test for extended address record
077 350A1        386                             JUMP            z, mcs_address_boundary
                 387     ;
                 388     ;Assume data record type 00 now and program SPI page
                 389     ;
078 1CE01        390                             SUB             se, #0x01               ;location of checksum just after last stored data byte
079 00D2B        391                             LOAD            sd, #line_start         ;Point to first data byte
07A 18D04        392                             ADD             sd, #0x04
07B 14A00        393                             COMPARE         sa, #0x00               ;check if page is closed
07C 35088        394                             JUMP            z, program_byte         ;jump if page needs to be opened
07D 06201        395                             FETCH           s2, page_address_h      ;check new address is sequential
07E 15290        396                             COMPARE         s2, s9
07F 35486        397                             JUMP            nz, addr_out_of_sequence
080 06202        398                             FETCH           s2, page_address_m      ;check new address is sequential
081 15280        399                             COMPARE         s2, s8
082 35486        400                             JUMP            nz, addr_out_of_sequence
083 06203        401                             FETCH           s2, page_address_l      ;check new address is sequential
084 15270        402                             COMPARE         s2, s7
085 35088        403                             JUMP            z, program_byte         ;continue with open page
086 3018F        404     addr_out_of_sequence:   CALL            close_prog_page_spi     ;close page because address out of sequence
087 00A00        405                             LOAD            sa, #0x00               ;page is now closed
088 14A00        406     program_byte:           COMPARE         sa, #0x00               ;check if page is closed
089 3548C        407                             JUMP            nz, page_is_open        ;jump is page already open
08A 30181        408                             CALL            open_prog_page_spi      ;open page with address [s9,s8,s7]
08B 00A01        409                             LOAD            sa, #0x01               ;page is open
08C 071D0        410     page_is_open:           FETCH           s1, @sd                 ;fetch data byte
08D 00008        411                             LOAD            s0, #0x08               ;reverse order of bits
08E 2010E        412     swap_bits:              SR0             s1
08F 20200        413                             SLA             s2
090 1C001        414                             SUB             s0, #0x01
091 3548E        415                             JUMP            nz, swap_bits           ;swapped bits now in s2
092 30112        416                             CALL            spi_flash_tx_rx         ;program byte into SPI memory
093 18701        417                             ADD             s7, #0x01               ;increment address to keep track
094 1A800        418                             ADDCY           s8, #0x00
095 1A900        419                             ADDCY           s9, #0x00
096 14700        420                             COMPARE         s7, #0x00               ;test if crossing page boundary FF to 00
097 3549A        421                             JUMP            nz, byte_programmed
098 3018F        422                             CALL            close_prog_page_spi
099 00A00        423                             LOAD            sa, #0x00               ;page is now closed
09A 18D01        424     byte_programmed:        ADD             sd, #0x01               ;move to next byte
09B 15DE0        425                             COMPARE         sd, se                  ;check for last on line
09C 35488        426                             JUMP            nz, program_byte        ;fetch next byte to program
09D 2E901        427                             STORE           s9, page_address_h      ;remember next address in sequence
09E 2E802        428                             STORE           s8, page_address_m
09F 2E703        429                             STORE           s7, page_address_l
0A0 34070        430                             JUMP            next_prog_line          ;read next line for programming
0A1 14A00        431     mcs_address_boundary:   COMPARE         sa, #0x00               ;check if page needs to be closed
0A2 35070        432                             JUMP            z, next_prog_line
0A3 3018F        433                             CALL            close_prog_page_spi
0A4 3406F        434                             JUMP            program_mcs
0A5 14A00        435     end_program_mcs:        COMPARE         sa, #0x00               ;check if page needs to be closed
0A6 2B000        436                             RETURN          z
0A7 3018F        437                             CALL            close_prog_page_spi
0A8 2A000        438                             RETURN
                 439     ;
                 440     ;**************************************************************************************
                 441     ;Read one line of an MCS file into scratch pad memory
                 442     ;**************************************************************************************
                 443     ;
                 444     ;Reads one line of MCS file format into scratch pad memory starting at location 'line_start'.
                 445     ;
                 446     ;The routine detects the line start character ':' ignoring any preceding characters. This
                 447     ;will remove any additional CR or LF characters.
                 448     ;
                 449     ;It then reads each subsequent pair of ASCII characters, converts them to true hex in the
                 450     ;range 00 to FF and stores them in scratch pad memory.
                 451     ;
                 452     ;The end of the line is determined by either a CR or LF character.
                 453     ;
                 454     ;The value last returned in register 'sE' will be the pointer to the location in
                 455     ;scratch pad memory following the last byte for the line read.
                 456     ;
0A9 00E2B        457     read_mcs_line:          LOAD            se, #line_start         ;initialise SPM memory pointer
0AA 301AF        458     wait_mcs_line_start:    CALL            read_from_uart          ;read character
0AB 14F3A        459                             COMPARE         uart_data, #character_colon ;test for start character
0AC 354AA        460                             JUMP            nz, wait_mcs_line_start
0AD 301AF        461     read_mcs_byte:          CALL            read_from_uart          ;read character
0AE 14F0D        462                             COMPARE         uart_data, #character_cr ;test for end of line
0AF 2B000        463                             RETURN          z
0B0 14F0A        464                             COMPARE         uart_data, #character_lf ;test for end of line
0B1 2B000        465                             RETURN          z
0B2 013F0        466                             LOAD            s3, uart_data           ;upper nibble character
0B3 301AF        467                             CALL            read_from_uart          ;read character
0B4 012F0        468                             LOAD            s2, uart_data           ;lower nibble character
0B5 30204        469                             CALL            ascii_byte_to_hex       ;convert to true hex value
0B6 2F0E0        470                             STORE           s0, @se                 ;write to SPM
0B7 18E01        471                             ADD             se, #0x01               ;increment pointer
0B8 340AD        472                             JUMP            read_mcs_byte
                 473     ;
                 474     ;
                 475     ;**************************************************************************************
                 476     ;Determine the current address for the line of an MCS file in scratch pad memory
                 477     ;**************************************************************************************
                 478     ;
                 479     ;Checks the existing line data stored in scratch pad memory starting at location
                 480     ;'line_start' and determines the current address.
                 481     ;
                 482     ;The address is in the register set [s9,s8,s7] before and after this routine is
                 483     ;executed because not all address bits are defined by a given line of MCS and
                 484     ;the undefined bits remain constant.
                 485     ;
                 486     ;A record type of 04 will update [s9].
                 487     ;A record type of 00 will update [s8,s7].
                 488     ;
                 489     ;On return, the register sB will contain the record type and
                 490     ;register sC will indicate the number of data bytes stored.
                 491     ;
0B9 00D2B        492     mcs_address:            LOAD            sd, #line_start         ;initialise SPM memory pointer
0BA 07CD0        493                             FETCH           sc, @sd                 ;read number of bytes on line
0BB 18D03        494                             ADD             sd, #0x03               ;move to record type
0BC 07BD0        495                             FETCH           sb, @sd                 ;read record type
0BD 14B00        496                             COMPARE         sb, #0x00               ;test for data record
0BE 350C4        497                             JUMP            z, new_low_address
0BF 14B04        498                             COMPARE         sb, #0x04               ;test for data record
0C0 2B400        499                             RETURN          nz
0C1 18D02        500                             ADD             sd, #0x02               ;read upper 8-bits
0C2 079D0        501                             FETCH           s9, @sd
0C3 2A000        502                             RETURN
0C4 1CD01        503     new_low_address:        SUB             sd, #0x01               ;read lower 8-bits
0C5 077D0        504                             FETCH           s7, @sd
0C6 1CD01        505                             SUB             sd, #0x01               ;read middle 8-bits
0C7 078D0        506                             FETCH           s8, @sd
0C8 2A000        507                             RETURN
                 508     ;
                 509     ;**************************************************************************************
                 510     ;Read a page from SPI FLASH memory and display
                 511     ;**************************************************************************************
                 512     ;
                 513     ;The start address should be provided in register set [s9,s8,s7].
                 514     ;The display will be next 256 bytes displayed as 16 lines of 16 bytes
                 515     ;with each line commencing with the address of the first byte.
                 516     ;
                 517     ;
0C9 00610        518     send_spi_page:          LOAD            s6, #0x10               ;16 lines to display
0CA 3021D        519     send_spi_line:          CALL            send_cr
0CB 301FD        520                             CALL            send_hex_3bytes         ;display address
0CC 30220        521                             CALL            send_space
0CD 00510        522                             LOAD            s5, #0x10               ;16 lines to display
0CE 30220        523     send_spi_byte:          CALL            send_space
0CF 3014E        524                             CALL            read_spi_byte           ;read byte into s2
0D0 18701        525                             ADD             s7, #0x01               ;increment SPI FLASH address
0D1 1A800        526                             ADDCY           s8, #0x00
0D2 1A900        527                             ADDCY           s9, #0x00
0D3 01020        528                             LOAD            s0, s2                  ;display byte
0D4 301F7        529                             CALL            send_hex_byte
0D5 1C501        530                             SUB             s5, #0x01               ;count bytes per line
0D6 354CE        531                             JUMP            nz, send_spi_byte
0D7 1C601        532                             SUB             s6, #0x01               ;count lines
0D8 354CA        533                             JUMP            nz, send_spi_line
0D9 3021D        534                             CALL            send_cr
0DA 2A000        535                             RETURN
                 536     ;
                 537     ;**************************************************************************************
                 538     ;Test of SPI FLASH memory operations
                 539     ;**************************************************************************************
                 540     ;
                 541     ;Sector 18 (120000 to 12FFFF) is used.
                 542     ;A page (123400 to 1234FF) is programmed with a test pattern 00 to FF.
                 543     ;The pattern is verified and then the sector erased and a blank check performed.
                 544     ;
                 545     ;Note that the page used is already blank (all locations contain FF hex)
                 546     ;as with any device supplied (initial delivery state).
                 547     ;
                 548     ;Program page with test pattern
                 549     ;
0DB 00912        550     memory_test:            LOAD            s9, #0x12               ;select page address 123400
0DC 00834        551                             LOAD            s8, #0x34
0DD 00700        552                             LOAD            s7, #0x00
0DE 30181        553                             CALL            open_prog_page_spi      ; program test pattern 00 to FF
0DF 01270        554     pattern_loop:           LOAD            s2, s7
0E0 30112        555                             CALL            spi_flash_tx_rx
0E1 18701        556                             ADD             s7, #0x01
0E2 35CDF        557                             JUMP            nc, pattern_loop
0E3 3018F        558                             CALL            close_prog_page_spi     ; program test pattern 00 to FF
                 559     ;
                 560     ;Verify test pattern by reading back page
                 561     ;
0E4 00F70        562                             LOAD            uart_data, #character_p ;p for pass
0E5 00912        563                             LOAD            s9, #0x12               ;select page address 123400
0E6 00834        564                             LOAD            s8, #0x34
0E7 00700        565                             LOAD            s7, #0x00
0E8 3014E        566     verify_test_page:       CALL            read_spi_byte           ;read byte into s2
0E9 15270        567                             COMPARE         s2, s7                  ;check test pattern data value
0EA 354EE        568                             JUMP            nz, memory_verify_fail
0EB 18701        569                             ADD             s7, #0x01               ;next location
0EC 354E8        570                             JUMP            nz, verify_test_page    ;loop until roll over page
0ED 340EF        571                             JUMP            memory_verify_result
0EE 00F66        572     memory_verify_fail:     LOAD            uart_data, #character_f ;f for fail
0EF 301C1        573     memory_verify_result:   CALL            send_to_uart
0F0 2A000        574                             RETURN
                 575     ;
                 576     ;Erase sector with test pattern and verify blank
                 577     ;
0F1 00912        578     erase_test_sector:      LOAD            s9, #0x12               ;sector 18 start address 120000
0F2 00800        579                             LOAD            s8, #0x00
0F3 00700        580                             LOAD            s7, #0x00
0F4 3015F        581                             CALL            erase_spi_sector
0F5 00F70        582                             LOAD            uart_data, #character_p ;p for pass
0F6 00912        583                             LOAD            s9, #0x12               ;select page address 123400
0F7 00834        584                             LOAD            s8, #0x34
0F8 00700        585                             LOAD            s7, #0x00
0F9 3014E        586     verify_blank_page:      CALL            read_spi_byte           ;read byte into s2
0FA 142FF        587                             COMPARE         s2, #0xff               ;check blank 'FF'
0FB 354FF        588                             JUMP            nz, memory_blank_fail
0FC 18701        589                             ADD             s7, #0x01               ;next location
0FD 354F9        590                             JUMP            nz, verify_blank_page   ;loop until roll over page
0FE 34100        591                             JUMP            memory_blank_result
0FF 00F66        592     memory_blank_fail:      LOAD            uart_data, #character_f ;f for fail
100 301C1        593     memory_blank_result:    CALL            send_to_uart
101 2A000        594                             RETURN
                 595     ;
                 596     ;
                 597     ;
                 598     ;**************************************************************************************
                 599     ;Test of SPI FLASH memory communications
                 600     ;**************************************************************************************
                 601     ;Link must be installed in J11 to link ROM-CS to CSO_B
                 602     ;
                 603     ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 604     ;and compare with expected response.
                 605     ;   s9 = Manufacturer Identification = 20 hex
                 606     ;   s8 = Memory Type = 20 hex
                 607     ;   s7 = Memory Capacity = 15 hex
                 608     ;
102 3013E        609     memory_comms_test:      CALL            read_spi_flash_id
103 00F70        610                             LOAD            uart_data, #character_p ;p for pass
104 14920        611                             COMPARE         s9, #0x20
105 3550B        612                             JUMP            nz, spi_flash_id_fail
106 14820        613                             COMPARE         s8, #0x20
107 3550B        614                             JUMP            nz, spi_flash_id_fail
108 14715        615                             COMPARE         s7, #0x15
109 3550B        616                             JUMP            nz, spi_flash_id_fail
10A 3410C        617                             JUMP            spi_flash_id_result
10B 00F66        618     spi_flash_id_fail:      LOAD            uart_data, #character_f ;f for fail
10C 301C1        619     spi_flash_id_result:    CALL            send_to_uart
10D 2A000        620                             RETURN
                 621     ;
                 622     ;
                 623     ;
                 624     ;
                 625     ;
                 626     ;
                 627     ;**************************************************************************************
                 628     ;SPI FLASH memory routines
                 629     ;**************************************************************************************
                 630     ;
                 631     ;These routines will work with two output ports and one input port which should be
                 632     ;defined as follows using CONSTANT directives.
                 633     ;   (replace 'pp' with appropriate port address in each case)
                 634     ;In the list of CONSTANT directives, only the ones marked with a * are really required
                 635     ;in an SPI FLASH memory system. The other directives are to control (disable) or
                 636     ;communicate with the other SPI components on the same SPI bus of the Spartan-3E Starter Kit.
                 637     ;
                 638     ;
                 639     ;
                 640     ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects     *
                 641     ;CONSTANT SPI_sck, 01                ;                  SCK - bit0   *
                 642     ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1   *
                 643     ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
                 644     ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
                 645     ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
                 646     ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
                 647     ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
                 648     ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
                 649     ;
                 650     ;CONSTANT SPI_output_port, pp        ;SPI data output                *
                 651     ;CONSTANT SPI_sdo, 80                ;   SDO - bit7                  *
                 652     ;
                 653     ;CONSTANT SPI_input_port, pp         ;SPI data input                 *
                 654     ;CONSTANT SPI_sdi, 80                ;             SDI - bit7        *
                 655     ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
                 656     ;
                 657     ;
                 658     ;A single scratch pad memory location is also employed to remember the status of
                 659     ;the SPI_control_port. This memory location must be defined as follows.
                 660     ;   (replace 'ss' with appropriate memory location)
                 661     ;
                 662     ;CONSTANT SPI_control_status, ss       ;SPI status signals
                 663     ;
                 664     ;Not all the SPI routines will use this memory location because although they
                 665     ;will change the bits on the control port, they will leave them in the same state
                 666     ;as they were in when they started.
                 667     ;
                 668     ;
                 669     ;
                 670     ;
                 671     ;Initialise SPI bus
                 672     ;
                 673     ;This routine should be used to initialise the SPI bus.
                 674     ;The SCK clock is made low.
                 675     ;Device selections are made inactive as follows
                 676     ;   SPI_sck      = 0      Clock is Low (required)
                 677     ;   SPI_rom_cs   = 1      Deselect ROM
                 678     ;   spare        = 1      spare control bit
                 679     ;   SPI_amp_cs   = 1      Deselect amplifier
                 680     ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
                 681     ;   SPI_dac_cs   = 1      Deselect D/A
                 682     ;   SPI_amp_shdn = 0      Amplifier active and available
                 683     ;   SPI_dac_clr  = 1      D/A clear off
                 684     ;
10E 000AE        685     spi_init:               LOAD            s0, #0xae               ;normally AE
10F 2C008        686                             OUTPUT          s0, spi_control_port
110 2E004        687                             STORE           s0, spi_control_status  ;preserve status
111 2A000        688                             RETURN
                 689     ;
                 690     ;
                 691     ;Send and receive one byte to or from the SPI FLASH memory.
                 692     ;
                 693     ;The data supplied in register 's2' is transmitted to the SPI bus and
                 694     ;at the same time any received byte is used to replace the value in 's2'.
                 695     ;The SCK clock is generated by software and results in a communication rate of
                 696     ;2.5Mbit/s with a 50MHz clock.
                 697     ;
                 698     ;Note that you must have previously selected the required device on the bus
                 699     ;before attempting communication and you must subsequently deselect the device
                 700     ;when appropriate.
                 701     ;
                 702     ;Entry to this routine assumes that SCK is already Low and the clock will be Low
                 703     ;at the end of execution (provided in scratch pad memory location SPI_control_status).
                 704     ;
                 705     ;As a 'master' the signal sequence is as follows..
                 706     ;   Receive data bit from SDI line (Flash transmits on previous falling edge)
                 707     ;   Transmit data bit on SDO line
                 708     ;   Drive SCK transition from low to high
                 709     ;   Drive SCK transition from high to low.
                 710     ;
112 00108        711     spi_flash_tx_rx:        LOAD            s1, #0x08               ;8-bits to transmit and receive
113 06004        712                             FETCH           s0, spi_control_status  ;read control status bits
114 2C204        713     next_spi_flash_bit:     OUTPUT          s2, spi_output_port     ;output data bit ready to be used on rising edge
115 04302        714                             INPUT           s3, spi_input_port      ;read input bit
116 12380        715                             TEST            s3, #spi_sdi            ;detect state of received bit
117 20200        716                             SLA             s2                      ;shift new data into result and move to next transmit bit
118 0E001        717                             XOR             s0, #spi_sck            ;clock High (bit0)
119 2C008        718                             OUTPUT          s0, spi_control_port    ;drive clock High
11A 0E001        719                             XOR             s0, #spi_sck            ;clock Low (bit0)
11B 2C008        720                             OUTPUT          s0, spi_control_port    ;drive clock Low
11C 1C101        721                             SUB             s1, #0x01               ;count bits
11D 35514        722                             JUMP            nz, next_spi_flash_bit  ;repeat until finished
11E 2A000        723                             RETURN
                 724     ;
                 725     ;
                 726     ;Read status register from SPI FLASH memory (ST type M25P16)
                 727     ;
                 728     ;Transmits instruction 05hex and then receives one byte in response
                 729     ;which is returned in register s2.
                 730     ;
                 731     ; bit    meaning
                 732     ;  7    SRWD Status Register Write Protect
                 733     ;  6    '0'
                 734     ;  5    '0'
                 735     ;  4    BP2 Block protect bit
                 736     ;  3    BP1 Block protect bit
                 737     ;  2    BP0 Block protect bit
                 738     ;  1    WEL Write Enable Latch Bit
                 739     ;  0    WIP Write In Progress
                 740     ;
                 741     ;
11F 3010E        742     read_spi_flash_status:  CALL            spi_init                ;ensure known state of bus and s0 register
120 0E002        743                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
121 2C008        744                             OUTPUT          s0, spi_control_port
122 2E004        745                             STORE           s0, spi_control_status  ;preserve status
123 00205        746                             LOAD            s2, #0x05               ;Read Status register instruction
124 30112        747                             CALL            spi_flash_tx_rx         ;transmit instruction
125 30112        748                             CALL            spi_flash_tx_rx         ;Receive status register information
126 0E002        749                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
127 2C008        750                             OUTPUT          s0, spi_control_port
128 2E004        751                             STORE           s0, spi_control_status  ;preserve status
129 2A000        752                             RETURN
                 753     ;
                 754     ;Set write enable mode in SPI FLASH memory (ST type M25P16)
                 755     ;
                 756     ;Transmits instruction 06hex.
                 757     ;
12A 3010E        758     set_spi_flash_wren:     CALL            spi_init                ;ensure known state of bus and s0 register
12B 0E002        759                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
12C 2C008        760                             OUTPUT          s0, spi_control_port
12D 2E004        761                             STORE           s0, spi_control_status  ;preserve status
12E 00206        762                             LOAD            s2, #0x06               ;Set write enable mode instruction
12F 30112        763                             CALL            spi_flash_tx_rx         ;transmit instruction
130 0E002        764                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
131 2C008        765                             OUTPUT          s0, spi_control_port
132 2E004        766                             STORE           s0, spi_control_status  ;preserve status
133 2A000        767                             RETURN
                 768     ;
                 769     ;Reset the write enable mode in SPI FLASH memory (ST type M25P16)
                 770     ;
                 771     ;Transmits instruction 04hex.
                 772     ;
134 3010E        773     reset_spi_flash_wren:   CALL            spi_init                ;ensure known state of bus and s0 register
135 0E002        774                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
136 2C008        775                             OUTPUT          s0, spi_control_port
137 2E004        776                             STORE           s0, spi_control_status  ;preserve status
138 00204        777                             LOAD            s2, #0x04               ;Reset write enable mode instruction
139 30112        778                             CALL            spi_flash_tx_rx         ;transmit instruction
13A 0E002        779                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
13B 2C008        780                             OUTPUT          s0, spi_control_port
13C 2E004        781                             STORE           s0, spi_control_status  ;preserve status
13D 2A000        782                             RETURN
                 783     ;
                 784     ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 785     ;
                 786     ;Transmits instruction 9Fhex and then reads the 3 byte response into [s9,s8,s7]
                 787     ;
                 788     ;response should be
                 789     ;   s9 = Manufacturer Identification = 20 hex
                 790     ;   s8 = Memory Type = 20 hex
                 791     ;   s7 = Memory Capacity = 15 hex
                 792     ;
13E 3010E        793     read_spi_flash_id:      CALL            spi_init                ;ensure known state of bus and s0 register
13F 0E002        794                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
140 2C008        795                             OUTPUT          s0, spi_control_port
141 2E004        796                             STORE           s0, spi_control_status  ;preserve status
142 0029F        797                             LOAD            s2, #0x9f               ;Read ID instruction
143 30112        798                             CALL            spi_flash_tx_rx         ;transmit instruction
144 30112        799                             CALL            spi_flash_tx_rx         ;receive Manufacturer ID
145 01920        800                             LOAD            s9, s2
146 30112        801                             CALL            spi_flash_tx_rx         ;receive Memory Type
147 01820        802                             LOAD            s8, s2
148 30112        803                             CALL            spi_flash_tx_rx         ;receive Memory Capacity
149 01720        804                             LOAD            s7, s2
14A 0E002        805                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
14B 2C008        806                             OUTPUT          s0, spi_control_port
14C 2E004        807                             STORE           s0, spi_control_status  ;preserve status
14D 2A000        808                             RETURN
                 809     ;
                 810     ;Read a single byte from the SPI FLASH memory (ST type M25P16)
                 811     ;
                 812     ;Transmits instruction 03hex followed by a 24-bit address which must be supplied in the
                 813     ;register set [s9,s8,s7]. It then transmits a dummy byte to retrieve the memory data
                 814     ;which is returned in register s2.
                 815     ;
14E 3010E        816     read_spi_byte:          CALL            spi_init                ;ensure known state of bus and s0 register
14F 0E002        817                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
150 2C008        818                             OUTPUT          s0, spi_control_port
151 2E004        819                             STORE           s0, spi_control_status  ;preserve status
152 00203        820                             LOAD            s2, #0x03               ;Read Data Bytes instruction
153 30112        821                             CALL            spi_flash_tx_rx         ;transmit instruction
154 01290        822                             LOAD            s2, s9                  ;Transmit 24-bit address
155 30112        823                             CALL            spi_flash_tx_rx
156 01280        824                             LOAD            s2, s8
157 30112        825                             CALL            spi_flash_tx_rx
158 01270        826                             LOAD            s2, s7
159 30112        827                             CALL            spi_flash_tx_rx
15A 30112        828                             CALL            spi_flash_tx_rx         ;read data byte
15B 0E002        829                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
15C 2C008        830                             OUTPUT          s0, spi_control_port
15D 2E004        831                             STORE           s0, spi_control_status  ;preserve status
15E 2A000        832                             RETURN
                 833     ;
                 834     ;
                 835     ;Erase a single sector from the SPI FLASH memory (ST type M25P16)
                 836     ;
                 837     ;Sets the WREN instruction and then transmits instruction D8 hex followed by a 24-bit
                 838     ;address which must be supplied in the register set [s9,s8,s7]. The address must be
                 839     ;at some location within the sector to be erased. A sector erase can take up to
                 840     ;3 seconds to complete. The routine therefore reads the FLASH status and tests
                 841     ;the write in progress (WIP) bit to test for completion
                 842     ;
15F 3012A        843     erase_spi_sector:       CALL            set_spi_flash_wren      ;set write enable mode
160 3010E        844                             CALL            spi_init                ;ensure known state of bus and s0 register
161 0E002        845                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
162 2C008        846                             OUTPUT          s0, spi_control_port
163 2E004        847                             STORE           s0, spi_control_status  ;preserve status
164 002D8        848                             LOAD            s2, #0xd8               ;Sector erase mode
165 30112        849                             CALL            spi_flash_tx_rx         ;transmit instruction
166 01290        850                             LOAD            s2, s9                  ;Transmit 24-bit address [s9,s8,s7].
167 30112        851                             CALL            spi_flash_tx_rx
168 01280        852                             LOAD            s2, s8
169 30112        853                             CALL            spi_flash_tx_rx
16A 01270        854                             LOAD            s2, s7
16B 30112        855                             CALL            spi_flash_tx_rx
16C 0E002        856                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
16D 2C008        857                             OUTPUT          s0, spi_control_port
16E 2E004        858                             STORE           s0, spi_control_status  ;preserve status
16F 3011F        859     sector_erase_wait:      CALL            read_spi_flash_status   ;test WIP bit until finished
170 12201        860                             TEST            s2, #0x01
171 3556F        861                             JUMP            nz, sector_erase_wait
172 2A000        862                             RETURN
                 863     ;
                 864     ;
                 865     ;
                 866     ;Bulk erase the whole SPI FLASH memory (ST type M25P16)
                 867     ;
                 868     ;Sets the WREN instruction and then transmits instruction C7 hex.
                 869     ;A bulk erase can take up to 40 seconds to complete. The routine therefore reads the
                 870     ;FLASH status and tests the write in progress (WIP) bit to test for completion
                 871     ;
173 3012A        872     bulk_erase_spi:         CALL            set_spi_flash_wren      ;set write enable mode
174 3010E        873                             CALL            spi_init                ;ensure known state of bus and s0 register
175 0E002        874                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
176 2C008        875                             OUTPUT          s0, spi_control_port
177 2E004        876                             STORE           s0, spi_control_status  ;preserve status
178 002C7        877                             LOAD            s2, #0xc7               ;Sector erase mode
179 30112        878                             CALL            spi_flash_tx_rx         ;transmit instruction
17A 0E002        879                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
17B 2C008        880                             OUTPUT          s0, spi_control_port
17C 2E004        881                             STORE           s0, spi_control_status  ;preserve status
17D 3011F        882     bulk_erase_wait:        CALL            read_spi_flash_status   ;test WIP bit until finished
17E 12201        883                             TEST            s2, #0x01
17F 3557D        884                             JUMP            nz, bulk_erase_wait
180 2A000        885                             RETURN
                 886     ;
                 887     ;
                 888     ;
                 889     ;Open a page for programming.
                 890     ;The 24-bit start address to be supplied in the register set [s9,s8,s7].
                 891     ;Note that s7=00 hex for normal page boundaries but you could start at any address.
                 892     ;Caution : Exceeding s7=FF hex will result in the roll over to 00 hex but without
                 893     ;incrementing to the next page.
                 894     ;
                 895     ;Transmits instruction 02hex followed by the 24-bit start address.
                 896     ;It is then ready to transmit data bytes using the s2 register and the SPI_FLASH_tx_rx
                 897     ;subroutine. After transmitting bytes, close the page with the close_prog_page_spi
                 898     ;routine.
                 899     ;
181 3012A        900     open_prog_page_spi:     CALL            set_spi_flash_wren      ;set write enable mode
182 3010E        901                             CALL            spi_init                ;ensure known state of bus and s0 register
183 0E002        902                             XOR             s0, #spi_rom_cs         ;select (Low) FLASH
184 2C008        903                             OUTPUT          s0, spi_control_port
185 2E004        904                             STORE           s0, spi_control_status  ;preserve status
186 00202        905                             LOAD            s2, #0x02               ;Page program mode
187 30112        906                             CALL            spi_flash_tx_rx         ;transmit instruction
188 01290        907                             LOAD            s2, s9                  ;Transmit 24-bit address [s9,s8,s7].
189 30112        908                             CALL            spi_flash_tx_rx
18A 01280        909                             LOAD            s2, s8
18B 30112        910                             CALL            spi_flash_tx_rx
18C 01270        911                             LOAD            s2, s7
18D 30112        912                             CALL            spi_flash_tx_rx
18E 2A000        913                             RETURN
                 914     ;
                 915     ;
                 916     ;This routine completes a page program operation started with
                 917     ;open_prog_page_spi and data bytes sent with SPI_FLASH_tx_rx.
                 918     ;
                 919     ;A page program can take up to 5ms to complete. The routine therefore reads the
                 920     ;FLASH status and tests the write in progress (WIP) bit to test for completion
                 921     ;
                 922     ;
18F 06004        923     close_prog_page_spi:    FETCH           s0, spi_control_status  ;read control status bits
190 0E002        924                             XOR             s0, #spi_rom_cs         ;deselect (High) FLASH
191 2C008        925                             OUTPUT          s0, spi_control_port
192 2E004        926                             STORE           s0, spi_control_status  ;preserve status
193 3011F        927     page_prog_wait:         CALL            read_spi_flash_status   ;test WIP bit until finished
194 12201        928                             TEST            s2, #0x01
195 35593        929                             JUMP            nz, page_prog_wait
196 2A000        930                             RETURN
                 931     ;
                 932     ;**************************************************************************************
                 933     ;Software delay routines
                 934     ;**************************************************************************************
                 935     ;
                 936     ;
                 937     ;
                 938     ;Delay of 1us.
                 939     ;
                 940     ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                 941     ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                 942     ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                 943     ;
                 944     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 945     ;
                 946     ;Registers used s0
                 947     ;
197 0000B        948     delay_1us:              LOAD            s0, #delay_1us_constant
198 1C001        949     wait_1us:               SUB             s0, #0x01
199 35598        950                             JUMP            nz, wait_1us
19A 2A000        951                             RETURN
                 952     ;
                 953     ;Delay of 40us.
                 954     ;
                 955     ;Registers used s0, s1
                 956     ;
19B 00128        957     delay_40us:             LOAD            s1, #0x28               ;40 x 1us = 40us
19C 30197        958     wait_40us:              CALL            delay_1us
19D 1C101        959                             SUB             s1, #0x01
19E 3559C        960                             JUMP            nz, wait_40us
19F 2A000        961                             RETURN
                 962     ;
                 963     ;
                 964     ;Delay of 1ms.
                 965     ;
                 966     ;Registers used s0, s1, s2
                 967     ;
1A0 00219        968     delay_1ms:              LOAD            s2, #0x19               ;25 x 40us = 1ms
1A1 3019B        969     wait_1ms:               CALL            delay_40us
1A2 1C201        970                             SUB             s2, #0x01
1A3 355A1        971                             JUMP            nz, wait_1ms
1A4 2A000        972                             RETURN
                 973     ;
                 974     ;Delay of 20ms.
                 975     ;
                 976     ;Delay of 20ms used during initialisation.
                 977     ;
                 978     ;Registers used s0, s1, s2, s3
                 979     ;
1A5 00314        980     delay_20ms:             LOAD            s3, #0x14               ;20 x 1ms = 20ms
1A6 301A0        981     wait_20ms:              CALL            delay_1ms
1A7 1C301        982                             SUB             s3, #0x01
1A8 355A6        983                             JUMP            nz, wait_20ms
1A9 2A000        984                             RETURN
                 985     ;
                 986     ;Delay of approximately 1 second.
                 987     ;
                 988     ;Registers used s0, s1, s2, s3, s4
                 989     ;
1AA 00414        990     delay_1s:               LOAD            s4, #0x14               ;50 x 20ms = 1000ms
1AB 301A5        991     wait_1s:                CALL            delay_20ms
1AC 1C401        992                             SUB             s4, #0x01
1AD 355AB        993                             JUMP            nz, wait_1s
1AE 2A000        994                             RETURN
                 995     ;
                 996     ;**************************************************************************************
                 997     ;UART communication routines
                 998     ;**************************************************************************************
                 999     ;
                1000     ;Read one character from the UART
                1001     ;
                1002     ;Character read will be returned in a register called 'UART_data'.
                1003     ;
                1004     ;The routine first tests the receiver FIFO buffer to see if data is present.
                1005     ;If the FIFO is empty, the routine waits until there is a character to read.
                1006     ;As this could take any amount of time the wait loop could include a call to a
                1007     ;subroutine which performs a useful function.
                1008     ;
                1009     ;If the received character is an XOFF, then the routine will then wait
                1010     ;for an XON to be received. This means that the rest of the program is held
                1011     ;in suspense and therefore it can not transmit. Once an XON is received, it will
                1012     ;again wait for a normal character before returning.
                1013     ;
                1014     ;NOTE: Characters between the XOFF and XON will be ignored in this version of the
                1015     ;program!!!
                1016     ;
                1017     ;Interrupt is disabled during this routine to prevent a false situation. If the
                1018     ;receiver half-full flag went High it should result in an interrupt transmitting
                1019     ;an XOFF character. However, if this routine were able to read the receiver buffer
                1020     ;at just about the same as the hardware detects the half-full flag, then it could
                1021     ;think that an XON needs to be transmitted.
                1022     ;
                1023     ;
                1024     ;Registers used s0 and UART_data
                1025     ;
1AF 3C000       1026     read_from_uart:         DISABLE         interrupt
1B0 04000       1027     wait_rx_character:      INPUT           s0, status_port         ;test Rx_FIFO buffer
1B1 12008       1028                             TEST            s0, #rx_data_present
1B2 355B4       1029                             JUMP            nz, read_character
1B3 341B0       1030                             JUMP            wait_rx_character
1B4 04F01       1031     read_character:         INPUT           uart_data, uart_read_port ;read from FIFO
1B5 14F13       1032                             COMPARE         uart_data, #character_xoff ;test for XOFF
1B6 351B9       1033                             JUMP            z, wait_xon
1B7 3C001       1034                             ENABLE          interrupt               ;normal finish
1B8 2A000       1035                             RETURN
1B9 04000       1036     wait_xon:               INPUT           s0, status_port         ;test Rx_FIFO buffer
1BA 12008       1037                             TEST            s0, #rx_data_present
1BB 355BD       1038                             JUMP            nz, read_xon
1BC 341B9       1039                             JUMP            wait_xon
1BD 04F01       1040     read_xon:               INPUT           uart_data, uart_read_port ;read from FIFO
1BE 14F11       1041                             COMPARE         uart_data, #character_xon ;test for XON
1BF 351B0       1042                             JUMP            z, wait_rx_character    ;now wait for normal character
1C0 341B9       1043                             JUMP            wait_xon                ;continue to wait for XON
                1044     ;
                1045     ;
                1046     ;
                1047     ;Transmit one character to the UART
                1048     ;
                1049     ;Character supplied in register called 'UART_data'.
                1050     ;
                1051     ;The routine first tests the transmit FIFO buffer is empty.
                1052     ;If the FIFO currently has any data, the routine waits until it is empty.
                1053     ;Ultimately this means that only one character is sent at a time which
                1054     ;could be important if the PC at the other end of the link transmits
                1055     ;an XOFF and needs the flow of data to terminate as soon as possible.
                1056     ;
                1057     ;Registers used s0
                1058     ;
1C1 04000       1059     send_to_uart:           INPUT           s0, status_port         ;test Tx_FIFO buffer
1C2 12001       1060                             TEST            s0, #tx_data_present
1C3 351C5       1061                             JUMP            z, uart_write
1C4 341C1       1062                             JUMP            send_to_uart
1C5 2CF10       1063     uart_write:             OUTPUT          uart_data, uart_write_port
1C6 2A000       1064                             RETURN
                1065     ;
                1066     ;Convert value provided in register s0 into ASCII characters
                1067     ;
                1068     ;The value provided must in the range 0 to 99 and will be converted into
                1069     ;two ASCII characters.
                1070     ;     The number of 'tens' will be represented by an ASCII character returned in register s1.
                1071     ;     The number of 'units' will be represented by an ASCII character returned in register s0.
                1072     ;
                1073     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
                1074     ;the actual decimal value.
                1075     ;
                1076     ;Registers used s0 and s1.
                1077     ;
1C7 00130       1078     decimal_to_ascii:       LOAD            s1, #0x30               ;load 'tens' counter with ASCII for '0'
1C8 18101       1079     test_for_ten:           ADD             s1, #0x01               ;increment 'tens' value
1C9 1C00A       1080                             SUB             s0, #0x0a               ;try to subtract 10 from the supplied value
1CA 35DC8       1081                             JUMP            nc, test_for_ten        ;repeat if subtraction was possible without underflow.
1CB 1C101       1082                             SUB             s1, #0x01               ;'tens' value one less ten due to underflow
1CC 1803A       1083                             ADD             s0, #0x3a               ;restore units value (the remainder) and convert to ASCII
1CD 2A000       1084                             RETURN
                1085     ;
                1086     ;
                1087     ;
                1088     ;Convert character to upper case
                1089     ;
                1090     ;The character supplied in register s0.
                1091     ;If the character is in the range 'a' to 'z', it is converted
                1092     ;to the equivalent upper case character in the range 'A' to 'Z'.
                1093     ;All other characters remain unchanged.
                1094     ;
                1095     ;Registers used s0.
                1096     ;
1CE 14061       1097     upper_case:             COMPARE         s0, #0x61               ;eliminate character codes below 'a' (61 hex)
1CF 2B800       1098                             RETURN          c
1D0 1407B       1099                             COMPARE         s0, #0x7b               ;eliminate character codes above 'z' (7A hex)
1D1 2BC00       1100                             RETURN          nc
1D2 0A0DF       1101                             AND             s0, #0xdf               ;mask bit5 to convert to upper case
1D3 2A000       1102                             RETURN
                1103     ;
                1104     ;
                1105     ;Convert character '0' to '9' to numerical value in range 0 to 9
                1106     ;
                1107     ;The character supplied in register s0. If the character is in the
                1108     ;range '0' to '9', it is converted to the equivalent decimal value.
                1109     ;Characters not in the range '0' to '9' are signified by the return
                1110     ;with the CARRY flag set.
                1111     ;
                1112     ;Registers used s0.
                1113     ;
1D4 180C6       1114     _1char_to_value:        ADD             s0, #0xc6               ;reject character codes above '9' (39 hex)
1D5 2B800       1115                             RETURN          c                       ;carry flag is set
1D6 1C0F6       1116                             SUB             s0, #0xf6               ;reject character codes below '0' (30 hex)
1D7 2A000       1117                             RETURN                                  ;carry is set if value not in range
                1118     ;
                1119     ;
                1120     ;Determine the numerical value of a two character decimal string held in
                1121     ;scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
                1122     ;
                1123     ;The string must be stored in two consecutive memory locations and the
                1124     ;location of the first (tens) character supplied in the s1 register.
                1125     ;The result is provided in register s2. Strings not using characters in the
                1126     ;range '0' to '9' are signified by the return with the CARRY flag set.
                1127     ;
                1128     ;Registers used s0, s1 and s2.
                1129     ;
1D8 07010       1130     _2char_to_value:        FETCH           s0, @s1                 ;read 'tens' character
1D9 301D4       1131                             CALL            _1char_to_value         ;convert to numerical value
1DA 2B800       1132                             RETURN          c                       ;bad character - CARRY set
1DB 01200       1133                             LOAD            s2, s0
1DC 20206       1134                             SL0             s2                      ;multiply 'tens' value by 10 (0A hex)
1DD 20206       1135                             SL0             s2
1DE 19200       1136                             ADD             s2, s0
1DF 20206       1137                             SL0             s2
1E0 18101       1138                             ADD             s1, #0x01               ;read 'units' character
1E1 07010       1139                             FETCH           s0, @s1
1E2 301D4       1140                             CALL            _1char_to_value         ;convert to numerical value
1E3 2B800       1141                             RETURN          c                       ;bad character - CARRY set
1E4 19200       1142                             ADD             s2, s0                  ;add units to result and clear CARRY flag
1E5 2A000       1143                             RETURN
                1144     ;
                1145     ;
                1146     ;Convert hexadecimal value provided in register s0 into ASCII characters
                1147     ;
                1148     ;The value provided must can be any value in the range 00 to FF and will be converted into
                1149     ;two ASCII characters.
                1150     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1151     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1152     ;
                1153     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1154     ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1155     ;hexadecimal requiring a further addition of 07 to the 30 already added.
                1156     ;
                1157     ;Registers used s0, s1 and s2.
                1158     ;
1E6 01100       1159     hex_byte_to_ascii:      LOAD            s1, s0                  ;remember value supplied
1E7 2000E       1160                             SR0             s0                      ;isolate upper nibble
1E8 2000E       1161                             SR0             s0
1E9 2000E       1162                             SR0             s0
1EA 2000E       1163                             SR0             s0
1EB 301F2       1164                             CALL            hex_to_ascii            ;convert
1EC 01200       1165                             LOAD            s2, s0                  ;upper nibble value in s2
1ED 01010       1166                             LOAD            s0, s1                  ;restore complete value
1EE 0A00F       1167                             AND             s0, #0x0f               ;isolate lower nibble
1EF 301F2       1168                             CALL            hex_to_ascii            ;convert
1F0 01100       1169                             LOAD            s1, s0                  ;lower nibble value in s1
1F1 2A000       1170                             RETURN
                1171     ;
                1172     ;Convert hexadecimal value provided in register s0 into ASCII character
                1173     ;
                1174     ;Register used s0
                1175     ;
1F2 1C00A       1176     hex_to_ascii:           SUB             s0, #0x0a               ;test if value is in range 0 to 9
1F3 359F5       1177                             JUMP            c, number_char
1F4 18007       1178                             ADD             s0, #0x07               ;ASCII char A to F in range 41 to 46
1F5 1803A       1179     number_char:            ADD             s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
1F6 2A000       1180                             RETURN
                1181     ;
                1182     ;
                1183     ;Send the two character HEX value of the register contents 's0' to the UART
                1184     ;
                1185     ;Registers used s0, s1, s2
                1186     ;
1F7 301E6       1187     send_hex_byte:          CALL            hex_byte_to_ascii
1F8 01F20       1188                             LOAD            uart_data, s2
1F9 301C1       1189                             CALL            send_to_uart
1FA 01F10       1190                             LOAD            uart_data, s1
1FB 301C1       1191                             CALL            send_to_uart
1FC 2A000       1192                             RETURN
                1193     ;
                1194     ;
                1195     ;
                1196     ;Send the six character HEX value of the register contents [s9,s8,s7] to the UART
                1197     ;
                1198     ;Registers used s0, s1, s2
                1199     ;
1FD 01090       1200     send_hex_3bytes:        LOAD            s0, s9
1FE 301F7       1201                             CALL            send_hex_byte
1FF 01080       1202                             LOAD            s0, s8
200 301F7       1203                             CALL            send_hex_byte
201 01070       1204                             LOAD            s0, s7
202 301F7       1205                             CALL            send_hex_byte
203 2A000       1206                             RETURN
                1207     ;
                1208     ;
                1209     ;Convert the HEX ASCII characters contained in 's3' and 's2' into
                1210     ;an equivalent hexadecimal value in register 's0'.
                1211     ;     The upper nibble is represented by an ASCII character in register s3.
                1212     ;     The lower nibble is represented by an ASCII character in register s2.
                1213     ;
                1214     ;Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1215     ;will be set on return.
                1216     ;
                1217     ;Registers used s0, s2 and s3.
                1218     ;
204 01030       1219     ascii_byte_to_hex:      LOAD            s0, s3                  ;Take upper nibble
205 30211       1220                             CALL            ascii_to_hex            ;convert to value
206 2B800       1221                             RETURN          c                       ;reject if out of range
207 01300       1222                             LOAD            s3, s0                  ;remember value
208 20306       1223                             SL0             s3                      ;multiply value by 16 to put in upper nibble
209 20306       1224                             SL0             s3
20A 20306       1225                             SL0             s3
20B 20306       1226                             SL0             s3
20C 01020       1227                             LOAD            s0, s2                  ;Take lower nibble
20D 30211       1228                             CALL            ascii_to_hex            ;convert to value
20E 2B800       1229                             RETURN          c                       ;reject if out of range
20F 0D030       1230                             OR              s0, s3                  ;merge in the upper nibble with CARRY reset
210 2A000       1231                             RETURN
                1232     ;
                1233     ;
                1234     ;Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1235     ;
                1236     ;If character is not valid for hex, then CARRY is set on return.
                1237     ;
                1238     ;Register used s0
                1239     ;
211 180B9       1240     ascii_to_hex:           ADD             s0, #0xb9               ;test for above ASCII code 46 ('F')
212 2B800       1241                             RETURN          c
213 1C0E9       1242                             SUB             s0, #0xe9               ;normalise 0 to 9 with A-F in 11 to 16 hex
214 2B800       1243                             RETURN          c                       ;reject below ASCII code 30 ('0')
215 1C011       1244                             SUB             s0, #0x11               ;isolate A-F down to 00 to 05 hex
216 35E1B       1245                             JUMP            nc, ascii_letter
217 18007       1246                             ADD             s0, #0x07               ;test for above ASCII code 46 ('F')
218 2B800       1247                             RETURN          c
219 1C0F6       1248                             SUB             s0, #0xf6               ;convert to range 00 to 09
21A 2A000       1249                             RETURN
21B 1800A       1250     ascii_letter:           ADD             s0, #0x0a               ;convert to range 0A to 0F
21C 2A000       1251                             RETURN
                1252     ;
                1253     ;
                1254     ;
                1255     ;Send Carriage Return to the UART
                1256     ;
21D 00F0D       1257     send_cr:                LOAD            uart_data, #character_cr
21E 301C1       1258                             CALL            send_to_uart
21F 2A000       1259                             RETURN
                1260     ;
                1261     ;Send a space to the UART
                1262     ;
220 00F20       1263     send_space:             LOAD            uart_data, #character_space
221 301C1       1264                             CALL            send_to_uart
222 2A000       1265                             RETURN
                1266     ;
                1267     ;
                1268     ;**************************************************************************************
                1269     ;Text messages
                1270     ;**************************************************************************************
                1271     ;
                1272     ;
                1273     ;Send 'PicoBlaze SPI FLASH Programmer' string to the UART
                1274     ;
223 3021D       1275     send_welcome:           CALL            send_cr
224 3021D       1276                             CALL            send_cr
225 00F50       1277                             LOAD            uart_data, #_character_p
226 301C1       1278                             CALL            send_to_uart
227 00F69       1279                             LOAD            uart_data, #character_i
228 301C1       1280                             CALL            send_to_uart
229 00F63       1281                             LOAD            uart_data, #character_c
22A 301C1       1282                             CALL            send_to_uart
22B 00F6F       1283                             LOAD            uart_data, #character_o
22C 301C1       1284                             CALL            send_to_uart
22D 00F42       1285                             LOAD            uart_data, #_character_b
22E 301C1       1286                             CALL            send_to_uart
22F 00F6C       1287                             LOAD            uart_data, #character_l
230 301C1       1288                             CALL            send_to_uart
231 00F61       1289                             LOAD            uart_data, #character_a
232 301C1       1290                             CALL            send_to_uart
233 00F7A       1291                             LOAD            uart_data, #character_z
234 301C1       1292                             CALL            send_to_uart
235 00F65       1293                             LOAD            uart_data, #character_e
236 301C1       1294                             CALL            send_to_uart
237 30220       1295                             CALL            send_space
238 00F53       1296                             LOAD            uart_data, #_character_s
239 301C1       1297                             CALL            send_to_uart
23A 00F50       1298                             LOAD            uart_data, #_character_p
23B 301C1       1299                             CALL            send_to_uart
23C 00F49       1300                             LOAD            uart_data, #_character_i
23D 301C1       1301                             CALL            send_to_uart
23E 30220       1302                             CALL            send_space
23F 00F46       1303                             LOAD            uart_data, #_character_f
240 301C1       1304                             CALL            send_to_uart
241 00F4C       1305                             LOAD            uart_data, #_character_l
242 301C1       1306                             CALL            send_to_uart
243 00F41       1307                             LOAD            uart_data, #_character_a
244 301C1       1308                             CALL            send_to_uart
245 00F53       1309                             LOAD            uart_data, #_character_s
246 301C1       1310                             CALL            send_to_uart
247 00F48       1311                             LOAD            uart_data, #_character_h
248 301C1       1312                             CALL            send_to_uart
249 30220       1313                             CALL            send_space
24A 00F50       1314                             LOAD            uart_data, #_character_p
24B 301C1       1315                             CALL            send_to_uart
24C 00F72       1316                             LOAD            uart_data, #character_r
24D 301C1       1317                             CALL            send_to_uart
24E 00F6F       1318                             LOAD            uart_data, #character_o
24F 301C1       1319                             CALL            send_to_uart
250 00F67       1320                             LOAD            uart_data, #character_g
251 301C1       1321                             CALL            send_to_uart
252 00F72       1322                             LOAD            uart_data, #character_r
253 301C1       1323                             CALL            send_to_uart
254 00F61       1324                             LOAD            uart_data, #character_a
255 301C1       1325                             CALL            send_to_uart
256 00F6D       1326                             LOAD            uart_data, #character_m
257 301C1       1327                             CALL            send_to_uart
258 00F6D       1328                             LOAD            uart_data, #character_m
259 301C1       1329                             CALL            send_to_uart
25A 00F65       1330                             LOAD            uart_data, #character_e
25B 301C1       1331                             CALL            send_to_uart
25C 00F72       1332                             LOAD            uart_data, #character_r
25D 301C1       1333                             CALL            send_to_uart
25E 30220       1334                             CALL            send_space
25F 00F76       1335                             LOAD            uart_data, #character_v
260 301C1       1336                             CALL            send_to_uart
261 00F31       1337                             LOAD            uart_data, #character_1
262 301C1       1338                             CALL            send_to_uart
263 00F2E       1339                             LOAD            uart_data, #character_fullstop
264 301C1       1340                             CALL            send_to_uart
265 00F30       1341                             LOAD            uart_data, #character_0
266 301C1       1342                             CALL            send_to_uart
267 00F30       1343                             LOAD            uart_data, #character_0
268 301C1       1344                             CALL            send_to_uart
269 3021D       1345                             CALL            send_cr
26A 3021D       1346                             CALL            send_cr
26B 2A000       1347                             RETURN
                1348     ;
                1349     ;
                1350     ;
                1351     ;Send 'Waiting_MCS_file' string to the UART
                1352     ;
26C 00F57       1353     send_waiting_mcs_file:  LOAD            uart_data, #_character_w
26D 301C1       1354                             CALL            send_to_uart
26E 00F61       1355                             LOAD            uart_data, #character_a
26F 301C1       1356                             CALL            send_to_uart
270 00F69       1357                             LOAD            uart_data, #character_i
271 301C1       1358                             CALL            send_to_uart
272 00F74       1359                             LOAD            uart_data, #character_t
273 301C1       1360                             CALL            send_to_uart
274 00F69       1361                             LOAD            uart_data, #character_i
275 301C1       1362                             CALL            send_to_uart
276 00F6E       1363                             LOAD            uart_data, #character_n
277 301C1       1364                             CALL            send_to_uart
278 00F67       1365                             LOAD            uart_data, #character_g
279 301C1       1366                             CALL            send_to_uart
27A 30220       1367                             CALL            send_space
27B 00F66       1368                             LOAD            uart_data, #character_f
27C 301C1       1369                             CALL            send_to_uart
27D 00F6F       1370                             LOAD            uart_data, #character_o
27E 301C1       1371                             CALL            send_to_uart
27F 00F72       1372                             LOAD            uart_data, #character_r
280 301C1       1373                             CALL            send_to_uart
281 30220       1374     send_mcs_file:          CALL            send_space
282 00F4D       1375                             LOAD            uart_data, #_character_m
283 301C1       1376                             CALL            send_to_uart
284 00F43       1377                             LOAD            uart_data, #_character_c
285 301C1       1378                             CALL            send_to_uart
286 00F53       1379                             LOAD            uart_data, #_character_s
287 301C1       1380                             CALL            send_to_uart
288 30220       1381                             CALL            send_space
289 00F46       1382                             LOAD            uart_data, #_character_f
28A 301C1       1383                             CALL            send_to_uart
28B 00F69       1384                             LOAD            uart_data, #character_i
28C 301C1       1385                             CALL            send_to_uart
28D 00F6C       1386                             LOAD            uart_data, #character_l
28E 301C1       1387                             CALL            send_to_uart
28F 00F65       1388                             LOAD            uart_data, #character_e
290 301C1       1389                             CALL            send_to_uart
291 3021D       1390                             CALL            send_cr
292 2A000       1391                             RETURN
                1392     ;
                1393     ;
                1394     ;Send 'Erase in progress' string to the UART
                1395     ;
293 302AA       1396     send_erase_in_progress: CALL            send_erase
294 00F69       1397                             LOAD            uart_data, #character_i
295 301C1       1398                             CALL            send_to_uart
296 00F6E       1399                             LOAD            uart_data, #character_n
297 301C1       1400                             CALL            send_to_uart
298 30220       1401                             CALL            send_space
299 00F50       1402                             LOAD            uart_data, #_character_p
29A 301C1       1403                             CALL            send_to_uart
29B 00F72       1404                             LOAD            uart_data, #character_r
29C 301C1       1405                             CALL            send_to_uart
29D 00F6F       1406                             LOAD            uart_data, #character_o
29E 301C1       1407                             CALL            send_to_uart
29F 00F67       1408                             LOAD            uart_data, #character_g
2A0 301C1       1409                             CALL            send_to_uart
2A1 00F72       1410                             LOAD            uart_data, #character_r
2A2 301C1       1411                             CALL            send_to_uart
2A3 00F65       1412                             LOAD            uart_data, #character_e
2A4 301C1       1413                             CALL            send_to_uart
2A5 00F73       1414                             LOAD            uart_data, #character_s
2A6 301C1       1415                             CALL            send_to_uart
2A7 301C1       1416                             CALL            send_to_uart
2A8 3021D       1417                             CALL            send_cr
2A9 2A000       1418                             RETURN
                1419     ;
                1420     ;
                1421     ;Send 'Erase ' string to the UART
                1422     ;
2AA 00F45       1423     send_erase:             LOAD            uart_data, #_character_e
2AB 301C1       1424                             CALL            send_to_uart
2AC 00F72       1425                             LOAD            uart_data, #character_r
2AD 301C1       1426                             CALL            send_to_uart
2AE 00F61       1427                             LOAD            uart_data, #character_a
2AF 301C1       1428                             CALL            send_to_uart
2B0 00F73       1429                             LOAD            uart_data, #character_s
2B1 301C1       1430                             CALL            send_to_uart
2B2 00F65       1431                             LOAD            uart_data, #character_e
2B3 301C1       1432                             CALL            send_to_uart
2B4 30220       1433                             CALL            send_space
2B5 2A000       1434                             RETURN
                1435     ;
                1436     ;
                1437     ;Send carriage return, 'OK' and carriage return to the UART
                1438     ;
2B6 3021D       1439     send_ok:                CALL            send_cr
2B7 00F4F       1440                             LOAD            uart_data, #_character_o
2B8 301C1       1441                             CALL            send_to_uart
2B9 00F4B       1442                             LOAD            uart_data, #_character_k
2BA 301C1       1443                             CALL            send_to_uart
2BB 3021D       1444                             CALL            send_cr
2BC 2A000       1445                             RETURN
                1446     ;
                1447     ;
                1448     ;
                1449     ;Send menu to the UART
                1450     ;
2BD 3021D       1451     send_menu:              CALL            send_cr
2BE 00F45       1452                             LOAD            uart_data, #_character_e
2BF 301C1       1453                             CALL            send_to_uart
2C0 00F2D       1454                             LOAD            uart_data, #character_minus
2C1 301C1       1455                             CALL            send_to_uart
2C2 302AA       1456                             CALL            send_erase
2C3 00F61       1457                             LOAD            uart_data, #character_a
2C4 301C1       1458                             CALL            send_to_uart
2C5 00F6C       1459                             LOAD            uart_data, #character_l
2C6 301C1       1460                             CALL            send_to_uart
2C7 301C1       1461                             CALL            send_to_uart
2C8 3021D       1462                             CALL            send_cr
2C9 00F53       1463                             LOAD            uart_data, #_character_s
2CA 301C1       1464                             CALL            send_to_uart
2CB 00F2D       1465                             LOAD            uart_data, #character_minus
2CC 301C1       1466                             CALL            send_to_uart
2CD 00F53       1467                             LOAD            uart_data, #_character_s
2CE 301C1       1468                             CALL            send_to_uart
2CF 00F65       1469                             LOAD            uart_data, #character_e
2D0 301C1       1470                             CALL            send_to_uart
2D1 00F63       1471                             LOAD            uart_data, #character_c
2D2 301C1       1472                             CALL            send_to_uart
2D3 00F74       1473                             LOAD            uart_data, #character_t
2D4 301C1       1474                             CALL            send_to_uart
2D5 00F6F       1475                             LOAD            uart_data, #character_o
2D6 301C1       1476                             CALL            send_to_uart
2D7 00F72       1477                             LOAD            uart_data, #character_r
2D8 301C1       1478                             CALL            send_to_uart
2D9 30220       1479                             CALL            send_space
2DA 302AA       1480                             CALL            send_erase
2DB 3021D       1481                             CALL            send_cr
2DC 00F50       1482                             LOAD            uart_data, #_character_p
2DD 301C1       1483                             CALL            send_to_uart
2DE 00F2D       1484                             LOAD            uart_data, #character_minus
2DF 301C1       1485                             CALL            send_to_uart
2E0 00F50       1486                             LOAD            uart_data, #_character_p
2E1 301C1       1487                             CALL            send_to_uart
2E2 00F72       1488                             LOAD            uart_data, #character_r
2E3 301C1       1489                             CALL            send_to_uart
2E4 00F6F       1490                             LOAD            uart_data, #character_o
2E5 301C1       1491                             CALL            send_to_uart
2E6 00F67       1492                             LOAD            uart_data, #character_g
2E7 301C1       1493                             CALL            send_to_uart
2E8 00F72       1494                             LOAD            uart_data, #character_r
2E9 301C1       1495                             CALL            send_to_uart
2EA 00F61       1496                             LOAD            uart_data, #character_a
2EB 301C1       1497                             CALL            send_to_uart
2EC 00F6D       1498                             LOAD            uart_data, #character_m
2ED 301C1       1499                             CALL            send_to_uart
2EE 30281       1500                             CALL            send_mcs_file
2EF 00F52       1501                             LOAD            uart_data, #_character_r
2F0 301C1       1502                             CALL            send_to_uart
2F1 00F2D       1503                             LOAD            uart_data, #character_minus
2F2 301C1       1504                             CALL            send_to_uart
2F3 00F52       1505                             LOAD            uart_data, #_character_r
2F4 301C1       1506                             CALL            send_to_uart
2F5 00F65       1507                             LOAD            uart_data, #character_e
2F6 301C1       1508                             CALL            send_to_uart
2F7 00F61       1509                             LOAD            uart_data, #character_a
2F8 301C1       1510                             CALL            send_to_uart
2F9 00F64       1511                             LOAD            uart_data, #character_d
2FA 301C1       1512                             CALL            send_to_uart
2FB 30220       1513                             CALL            send_space
2FC 3031F       1514                             CALL            send_page
2FD 3021D       1515                             CALL            send_cr
2FE 00F49       1516                             LOAD            uart_data, #_character_i
2FF 301C1       1517                             CALL            send_to_uart
300 00F2D       1518                             LOAD            uart_data, #character_minus
301 301C1       1519                             CALL            send_to_uart
302 00F44       1520                             LOAD            uart_data, #_character_d
303 301C1       1521                             CALL            send_to_uart
304 00F65       1522                             LOAD            uart_data, #character_e
305 301C1       1523                             CALL            send_to_uart
306 00F76       1524                             LOAD            uart_data, #character_v
307 301C1       1525                             CALL            send_to_uart
308 00F69       1526                             LOAD            uart_data, #character_i
309 301C1       1527                             CALL            send_to_uart
30A 00F63       1528                             LOAD            uart_data, #character_c
30B 301C1       1529                             CALL            send_to_uart
30C 00F65       1530                             LOAD            uart_data, #character_e
30D 301C1       1531                             CALL            send_to_uart
30E 30220       1532                             CALL            send_space
30F 30328       1533                             CALL            send_id
310 3021D       1534                             CALL            send_cr
311 00F48       1535                             LOAD            uart_data, #_character_h
312 301C1       1536                             CALL            send_to_uart
313 00F2D       1537                             LOAD            uart_data, #character_minus
314 301C1       1538                             CALL            send_to_uart
315 00F48       1539                             LOAD            uart_data, #_character_h
316 301C1       1540                             CALL            send_to_uart
317 00F65       1541                             LOAD            uart_data, #character_e
318 301C1       1542                             CALL            send_to_uart
319 00F6C       1543                             LOAD            uart_data, #character_l
31A 301C1       1544                             CALL            send_to_uart
31B 00F70       1545                             LOAD            uart_data, #character_p
31C 301C1       1546                             CALL            send_to_uart
31D 3021D       1547                             CALL            send_cr
31E 2A000       1548                             RETURN
                1549     ;
                1550     ;
                1551     ;Send 'page' to the UART
                1552     ;
31F 00F70       1553     send_page:              LOAD            uart_data, #character_p
320 301C1       1554                             CALL            send_to_uart
321 00F61       1555                             LOAD            uart_data, #character_a
322 301C1       1556                             CALL            send_to_uart
323 00F67       1557                             LOAD            uart_data, #character_g
324 301C1       1558                             CALL            send_to_uart
325 00F65       1559                             LOAD            uart_data, #character_e
326 301C1       1560                             CALL            send_to_uart
327 2A000       1561                             RETURN
                1562     ;
                1563     ;Send 'ID' to the UART
                1564     ;
328 00F49       1565     send_id:                LOAD            uart_data, #_character_i
329 301C1       1566                             CALL            send_to_uart
32A 00F44       1567                             LOAD            uart_data, #_character_d
32B 301C1       1568                             CALL            send_to_uart
32C 2A000       1569                             RETURN
                1570     ;
                1571     ;
                1572     ;Send 'Confirm Erase (Y/n) ' to the UART
                1573     ;
32D 3021D       1574     send_confirm:           CALL            send_cr
32E 00F43       1575                             LOAD            uart_data, #_character_c
32F 301C1       1576                             CALL            send_to_uart
330 00F6F       1577                             LOAD            uart_data, #character_o
331 301C1       1578                             CALL            send_to_uart
332 00F6E       1579                             LOAD            uart_data, #character_n
333 301C1       1580                             CALL            send_to_uart
334 00F66       1581                             LOAD            uart_data, #character_f
335 301C1       1582                             CALL            send_to_uart
336 00F69       1583                             LOAD            uart_data, #character_i
337 301C1       1584                             CALL            send_to_uart
338 00F72       1585                             LOAD            uart_data, #character_r
339 301C1       1586                             CALL            send_to_uart
33A 00F6D       1587                             LOAD            uart_data, #character_m
33B 301C1       1588                             CALL            send_to_uart
33C 30220       1589                             CALL            send_space
33D 302AA       1590                             CALL            send_erase
33E 00F28       1591                             LOAD            uart_data, #character_open
33F 301C1       1592                             CALL            send_to_uart
340 00F59       1593                             LOAD            uart_data, #_character_y
341 301C1       1594                             CALL            send_to_uart
342 00F2F       1595                             LOAD            uart_data, #character_divide
343 301C1       1596                             CALL            send_to_uart
344 00F6E       1597                             LOAD            uart_data, #character_n
345 301C1       1598                             CALL            send_to_uart
346 00F29       1599                             LOAD            uart_data, #character_close
347 301C1       1600                             CALL            send_to_uart
348 30220       1601                             CALL            send_space
349 2A000       1602                             RETURN
                1603     ;
                1604     ;
                1605     ;Send 'Abort' to the UART
                1606     ;
34A 3021D       1607     send_abort:             CALL            send_cr
34B 00F41       1608                             LOAD            uart_data, #_character_a
34C 301C1       1609                             CALL            send_to_uart
34D 00F62       1610                             LOAD            uart_data, #character_b
34E 301C1       1611                             CALL            send_to_uart
34F 00F6F       1612                             LOAD            uart_data, #character_o
350 301C1       1613                             CALL            send_to_uart
351 00F72       1614                             LOAD            uart_data, #character_r
352 301C1       1615                             CALL            send_to_uart
353 00F74       1616                             LOAD            uart_data, #character_t
354 301C1       1617                             CALL            send_to_uart
355 3021D       1618                             CALL            send_cr
356 2A000       1619                             RETURN
                1620     ;
                1621     ;Send 'page address' to the UART
                1622     ;
357 3021D       1623     send_page_address:      CALL            send_cr
358 3031F       1624                             CALL            send_page
359 30220       1625                             CALL            send_space
35A 00F61       1626                             LOAD            uart_data, #character_a
35B 301C1       1627                             CALL            send_to_uart
35C 00F64       1628                             LOAD            uart_data, #character_d
35D 301C1       1629                             CALL            send_to_uart
35E 301C1       1630                             CALL            send_to_uart
35F 00F72       1631                             LOAD            uart_data, #character_r
360 301C1       1632                             CALL            send_to_uart
361 00F65       1633                             LOAD            uart_data, #character_e
362 301C1       1634                             CALL            send_to_uart
363 00F73       1635                             LOAD            uart_data, #character_s
364 301C1       1636                             CALL            send_to_uart
365 301C1       1637                             CALL            send_to_uart
366 00F3D       1638                             LOAD            uart_data, #character_equals
367 301C1       1639                             CALL            send_to_uart
368 2A000       1640                             RETURN
                1641     ;
                1642     ;
                1643     ;**************************************************************************************
                1644     ;Interrupt Service Routine (ISR)
                1645     ;**************************************************************************************
                1646     ;
                1647     ;An interrupt occurs whenever the status of the UART receiver FIFO 'half_full' flag
                1648     ;changes.
                1649     ;
                1650     ;A change from Low to High means that the buffer is becoming full and therefore
                1651     ;an XOFF character must be transmitted.
                1652     ;
                1653     ;A change from High to Low means that the buffer is starting to empty and therefore
                1654     ;an XON character can be transmitted to restart the flow of new characters.
                1655     ;
                1656     ;
  003F5         1657                             ORG             0x3f5                   ;place at end of memory to keep separate
3F5 2E000       1658     isr:                    STORE           s0, isr_preserve_s0     ;preserve register contents
3F6 04000       1659                             INPUT           s0, status_port         ;test 'half_full' status of receiver buffer.
3F7 12010       1660                             TEST            s0, #rx_half_full
3F8 353FB       1661                             JUMP            z, isr_send_xon
3F9 00013       1662                             LOAD            s0, #character_xoff
3FA 343FC       1663                             JUMP            isr_send_character
3FB 00011       1664     isr_send_xon:           LOAD            s0, #character_xon
3FC 2C010       1665     isr_send_character:     OUTPUT          s0, uart_write_port
3FD 06000       1666                             FETCH           s0, isr_preserve_s0     ;restore register contents
3FE 38001       1667                             RETURNI         enable
                1668     ;
                1669     ;
                1670     ;**************************************************************************************
                1671     ;Interrupt Vector
                1672     ;**************************************************************************************
                1673     ;
  003FF         1674                             ORG             0x3ff
3FF 343F5       1675                             JUMP            isr
                1676     ;
                1677     ;
                1678
