                   1     ; KCPSM3 Program - Automatic Pulse Width Modulation (PWM) Control on the Spartan-3E Starter Kit.
                   2     device kcpsm1
                   3     ; Ken Chapman - Xilinx Ltd
                   4     ;
                   5     ; Version v1.00 - 24th May 2006
                   6     ;
                   7     ; Automatically sequences the LEDs on the board using PWM to change intensity.
                   8     ;
                   9     ;**************************************************************************************
                  10     ; Port definitions
                  11     ;**************************************************************************************
                  12     ;
                  13     ;
                  14     ;
  00080           15     led_port                EQU     0x80                    ;8 simple LEDs
  00001           16     led0                    EQU     0x01                    ;     LED 0 - bit0
  00002           17     led1                    EQU     0x02                    ;         1 - bit1
  00004           18     led2                    EQU     0x04                    ;         2 - bit2
  00008           19     led3                    EQU     0x08                    ;         3 - bit3
  00010           20     led4                    EQU     0x10                    ;         4 - bit4
  00020           21     led5                    EQU     0x20                    ;         5 - bit5
  00040           22     led6                    EQU     0x40                    ;         6 - bit6
  00080           23     led7                    EQU     0x80                    ;         7 - bit7
                  24     ;
                  25     ;
  00040           26     simple_port             EQU     0x40                    ;4 simple outputs
  00001           27     simple_io9              EQU     0x01                    ;  Header  IO9  - bit0
  00002           28     simple_io10             EQU     0x02                    ;          IO10 - bit1
  00004           29     simple_io11             EQU     0x04                    ;          IO11 - bit2
  00008           30     simple_io12             EQU     0x08                    ;          IO12 - bit3
                  31     ;
                  32     ;
                  33     ;
  00000           34     status_port             EQU     0x00                    ;UART status input
  00001           35     tx_half_full            EQU     0x01                    ;  Transmitter     half full - bit0
  00002           36     tx_full                 EQU     0x02                    ;    FIFO               full - bit1
  00004           37     rx_data_present         EQU     0x04                    ;  Receiver     data present - bit2
  00008           38     rx_half_full            EQU     0x08                    ;    FIFO          half full - bit3
  00010           39     rx_full                 EQU     0x10                    ;                   full - bit4
  00020           40     spare1                  EQU     0x20                    ;                  spare '0' - bit5
  00040           41     spare2                  EQU     0x40                    ;                  spare '0' - bit6
  00080           42     spare3                  EQU     0x80                    ;                  spare '0' - bit7
                  43     ;
  00001           44     uart_read_port          EQU     0x01                    ;UART Rx data input
                  45     ;
  00020           46     uart_write_port         EQU     0x20                    ;UART Tx data output
                  47     ;
                  48     ;
                  49     ;
                  50     ;**************************************************************************************
                  51     ; Special Register usage
                  52     ;**************************************************************************************
                  53     ;
  0000F           54     uart_data               REG     sf                      ;used to pass data to and from the UART
                  55     ;
                  56     ;
                  57     ;
                  58     ;**************************************************************************************
                  59     ;Scratch Pad Memory Locations
                  60     ;**************************************************************************************
                  61     ;
  00000           62     pwm_duty_counter        EQU     0x00                    ;Duty Counter 0 to 255 within 1KHz period (1ms)
  00001           63     pwm_channel0            EQU     0x01                    ;PWM settings for each channel
  00002           64     pwm_channel1            EQU     0x02                    ; Channels 0 to 7 = LEDs 0 to 7
  00003           65     pwm_channel2            EQU     0x03                    ; Channels 8 to 11 = IO9 to IO12
  00004           66     pwm_channel3            EQU     0x04
  00005           67     pwm_channel4            EQU     0x05
  00006           68     pwm_channel5            EQU     0x06
  00007           69     pwm_channel6            EQU     0x07
  00008           70     pwm_channel7            EQU     0x08
  00009           71     pwm_channel8            EQU     0x09
  0000A           72     pwm_channel9            EQU     0x0a
  0000B           73     pwm_channel10           EQU     0x0b
  0000C           74     pwm_channel11           EQU     0x0c
  0000D           75     isr_preserve_s0         EQU     0x0d                    ;preserve register contents during Interrupt Service Routine
  0000E           76     isr_preserve_s1         EQU     0x0e
  0000F           77     isr_preserve_s2         EQU     0x0f
                  78     ;
                  79     ;
  00010           80     led0_sequence           EQU     0x10                    ;LED sequence values
  00011           81     led1_sequence           EQU     0x11
  00012           82     led2_sequence           EQU     0x12
  00013           83     led3_sequence           EQU     0x13
  00014           84     led4_sequence           EQU     0x14
  00015           85     led5_sequence           EQU     0x15
  00016           86     led6_sequence           EQU     0x16
  00017           87     led7_sequence           EQU     0x17
                  88     ;
                  89     ;
                  90     ;
                  91     ;**************************************************************************************
                  92     ;Useful data constants
                  93     ;**************************************************************************************
                  94     ;
                  95     ;
                  96     ;
                  97     ;
                  98     ;ASCII table
                  99     ;
  00061          100     character_a             EQU     0x61
  00062          101     character_b             EQU     0x62
  00063          102     character_c             EQU     0x63
  00064          103     character_d             EQU     0x64
  00065          104     character_e             EQU     0x65
  00066          105     character_f             EQU     0x66
  00067          106     character_g             EQU     0x67
  00068          107     character_h             EQU     0x68
  00069          108     character_i             EQU     0x69
  0006A          109     character_j             EQU     0x6a
  0006B          110     character_k             EQU     0x6b
  0006C          111     character_l             EQU     0x6c
  0006D          112     character_m             EQU     0x6d
  0006E          113     character_n             EQU     0x6e
  0006F          114     character_o             EQU     0x6f
  00070          115     character_p             EQU     0x70
  00071          116     character_q             EQU     0x71
  00072          117     character_r             EQU     0x72
  00073          118     character_s             EQU     0x73
  00074          119     character_t             EQU     0x74
  00075          120     character_u             EQU     0x75
  00076          121     character_v             EQU     0x76
  00077          122     character_w             EQU     0x77
  00078          123     character_x             EQU     0x78
  00079          124     character_y             EQU     0x79
  0007A          125     character_z             EQU     0x7a
  00041          126     _character_a            EQU     0x41
  00042          127     _character_b            EQU     0x42
  00043          128     _character_c            EQU     0x43
  00044          129     _character_d            EQU     0x44
  00045          130     _character_e            EQU     0x45
  00046          131     _character_f            EQU     0x46
  00047          132     _character_g            EQU     0x47
  00048          133     _character_h            EQU     0x48
  00049          134     _character_i            EQU     0x49
  0004A          135     _character_j            EQU     0x4a
  0004B          136     _character_k            EQU     0x4b
  0004C          137     _character_l            EQU     0x4c
  0004D          138     _character_m            EQU     0x4d
  0004E          139     _character_n            EQU     0x4e
  0004F          140     _character_o            EQU     0x4f
  00050          141     _character_p            EQU     0x50
  00051          142     _character_q            EQU     0x51
  00052          143     _character_r            EQU     0x52
  00053          144     _character_s            EQU     0x53
  00054          145     _character_t            EQU     0x54
  00055          146     _character_u            EQU     0x55
  00056          147     _character_v            EQU     0x56
  00057          148     _character_w            EQU     0x57
  00058          149     _character_x            EQU     0x58
  00059          150     _character_y            EQU     0x59
  0005A          151     _character_z            EQU     0x5a
  00030          152     character_0             EQU     0x30
  00031          153     character_1             EQU     0x31
  00032          154     character_2             EQU     0x32
  00033          155     character_3             EQU     0x33
  00034          156     character_4             EQU     0x34
  00035          157     character_5             EQU     0x35
  00036          158     character_6             EQU     0x36
  00037          159     character_7             EQU     0x37
  00038          160     character_8             EQU     0x38
  00039          161     character_9             EQU     0x39
  0003A          162     character_colon         EQU     0x3a
  0002E          163     character_stop          EQU     0x2e
  0003B          164     character_semi_colon    EQU     0x3b
  0002D          165     character_minus         EQU     0x2d
  0002F          166     character_divide        EQU     0x2f                    ;'/'
  0002B          167     character_plus          EQU     0x2b
  0002C          168     character_comma         EQU     0x2c
  0003C          169     character_less_than     EQU     0x3c
  0003E          170     character_greater_than  EQU     0x3e
  0003D          171     character_equals        EQU     0x3d
  00020          172     character_space         EQU     0x20
  0000D          173     character_cr            EQU     0x0d                    ;carriage return
  0003F          174     character_question      EQU     0x3f                    ;'?'
  00024          175     character_dollar        EQU     0x24
  00021          176     character_exclaim       EQU     0x21                    ;'!'
  00008          177     character_bs            EQU     0x08                    ;Back Space command character
                 178     ;
                 179     ;
                 180     ;
                 181     ;
                 182     ;
                 183     ;**************************************************************************************
                 184     ;Initialise the system
                 185     ;**************************************************************************************
                 186     ;
                 187     ; All PWM channels initialise to off (zero).
                 188     ; Simple I/O outputs will remain off at all times.
                 189     ;
000 00000        190     cold_start:             LD      s0, #0x00
001 00101        191                             LD      s1, #pwm_channel0
  00002          192     clear_loop:             ST      s0, s1
W: instruction `STORE sX, ss' requires operand #2 to be of type(s): number, or data, or expression; while the given operand is of type: register.
E: instruction not supported on the this device: STORE sX, ss.
002 0010C        193                             load     s1, #pwm_channel11
003 09107        194                             JUMP    z, enable_int
004 04101        195                             ADD     s1, #0x01
005 08102        196                             JUMP    clear_loop
                 197     ;
006 08030        198     enable_int:             ENA                             ;interrupts used to drive servo
                 199     ;
007 083C7        200                             CALL    send_welcome            ;Write welcome message to UART
008 083FB        201                             CALL    send_ok
                 202     ;
                 203     ;
                 204     ; Initialise LED pattern sequence
                 205     ;
009 00001        206                             LD      s0, #0x01               ;trigger to start wave pattern
                 207                             ST      s0, led0_sequence
E: instruction not supported on the this device: STORE sX, ss.
00A 00000        208                             LD      s0, #0x00
                 209                             ST      s0, led1_sequence
E: instruction not supported on the this device: STORE sX, ss.
                 210                             ST      s0, led2_sequence
E: instruction not supported on the this device: STORE sX, ss.
                 211                             ST      s0, led3_sequence
E: instruction not supported on the this device: STORE sX, ss.
                 212                             ST      s0, led4_sequence
E: instruction not supported on the this device: STORE sX, ss.
                 213                             ST      s0, led5_sequence
E: instruction not supported on the this device: STORE sX, ss.
                 214                             ST      s0, led6_sequence
E: instruction not supported on the this device: STORE sX, ss.
                 215                             ST      s0, led7_sequence
E: instruction not supported on the this device: STORE sX, ss.
                 216     ;
                 217     ;**************************************************************************************
                 218     ; Main program
                 219     ;**************************************************************************************
                 220     ;
                 221     ; Provides a pattern of interest on the LEDs :-)
                 222     ;
                 223     ; Each LED increases intensity in 8 steps and then decreases intensity in 8 steps until it is off.
                 224     ; The middle LEDs (LD2 to LD5) each start to turn on when either neighbour is turned half on and increasing
                 225     ; to provide the effect of a passing a 'wave' of light passing from side to side. The pair of LEDs at each
                 226     ; (LD0, Ld1 and LD6, LD7) are required to reflect the 'wave' so that the pattern continues.
                 227     ;
                 228     ; I'm sure this code cold be written in more elegant way, but I leave that as an exercise to you :-)
                 229     ;
00B 00203        230     warm_start:             LD      s2, #0x03               ;simple delay loop (time will be increased by ISR processing)
00C 001FF        231     delay_s2_loop:          LD      s1, #0xff
00D 000FF        232     delay_s1_loop:          LD      s0, #0xff
00E 06001        233     delay_s0_loop:          SUB     s0, #0x01
00F 09D17        234                             JUMP    nc, delay_s0_loop
010 06101        235                             SUB     s1, #0x01
011 09D16        236                             JUMP    nc, delay_s1_loop
012 06201        237                             SUB     s2, #0x01
013 09D15        238                             JUMP    nc, delay_s2_loop
                 239     ;
                 240     ;Pattern generation
                 241     ;
014 0C000        242                             load      s0, led0_sequence       ;read sequence for LED0
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
015 00000        243                             load     s0, #0x00
016 09125        244                             JUMP    z, load_led0_start
017 06020        245                             SUB     s0, #0x20               ;Count longer to ensure end stops then reset count if maximum
018 09128        246                             JUMP    z, update_led0
019 04020        247                             ADD     s0, #0x20
01A 04001        248     inc_led0:               ADD     s0, #0x01               ;increment counter
01B 08128        249                             JUMP    update_led0
01C 0C110        250     load_led0_start:        load      s1, led1_sequence       ;start LED0 if LED1 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
01D 00104        251                             load     s1, #0x04
01E 09123        252                             JUMP    z, inc_led0
  00028          253     update_led0:            ST      s0, led0_sequence
E: instruction not supported on the this device: STORE sX, ss.
01F 083A7        254                             CALL    led_to_duty
                 255                             ST      s1, pwm_channel0
E: instruction not supported on the this device: STORE sX, ss.
                 256     ;
020 0C100        257                             load      s1, led0_sequence       ; refresh LED1 if LED0 = 11 (0B hex) to reflect wave
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
021 0010B        258                             load     s1, #0x0b
022 09530        259                             JUMP    nz, normal_led1
023 00004        260                             LD      s0, #0x04
024 0813E        261                             JUMP    update_led1
025 0C010        262     normal_led1:            load      s0, led1_sequence       ;read sequence for LED1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
026 00000        263                             load     s0, #0x00
027 09138        264                             JUMP    z, load_led1_start
028 06010        265                             SUB     s0, #0x10               ;reset count if maximum
029 0913E        266                             JUMP    z, update_led1
02A 04010        267                             ADD     s0, #0x10
02B 04001        268     inc_led1:               ADD     s0, #0x01               ;increment counter
02C 0813E        269                             JUMP    update_led1
02D 0C100        270     load_led1_start:        load      s1, led0_sequence       ;start LED1 if LED0 = 11 (0B hex) to reflect wave
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x10, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
02E 0010B        271                             load     s1, #0x0b
02F 09136        272                             JUMP    z, inc_led1
030 0C120        273                             load      s1, led2_sequence       ;start LED1 if LED2 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
031 00104        274                             load     s1, #0x04
032 09136        275                             JUMP    z, inc_led1
  0003E          276     update_led1:            ST      s0, led1_sequence
E: instruction not supported on the this device: STORE sX, ss.
033 083A7        277                             CALL    led_to_duty
                 278                             ST      s1, pwm_channel1
E: instruction not supported on the this device: STORE sX, ss.
                 279     ;
034 0C020        280                             load      s0, led2_sequence       ;read sequence for LED2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
035 00000        281                             load     s0, #0x00
036 09149        282                             JUMP    z, load_led2_start
037 06010        283                             SUB     s0, #0x10               ;reset count if maximum
038 0914F        284                             JUMP    z, update_led2
039 04010        285                             ADD     s0, #0x10
03A 04001        286     inc_led2:               ADD     s0, #0x01               ;increment counter
03B 0814F        287                             JUMP    update_led2
03C 0C110        288     load_led2_start:        load      s1, led1_sequence       ;start LED2 if LED1 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x11, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
03D 00104        289                             load     s1, #0x04
03E 09147        290                             JUMP    z, inc_led2
03F 0C130        291                             load      s1, led3_sequence       ;start LED2 if LED3 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
040 00104        292                             load     s1, #0x04
041 09147        293                             JUMP    z, inc_led2
  0004F          294     update_led2:            ST      s0, led2_sequence
E: instruction not supported on the this device: STORE sX, ss.
042 083A7        295                             CALL    led_to_duty
                 296                             ST      s1, pwm_channel2
E: instruction not supported on the this device: STORE sX, ss.
                 297     ;
                 298     ;
043 0C030        299                             load      s0, led3_sequence       ;read sequence for LED3
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
044 00000        300                             load     s0, #0x00
045 0915A        301                             JUMP    z, load_led3_start
046 06010        302                             SUB     s0, #0x10               ;reset count if maximum
047 09160        303                             JUMP    z, update_led3
048 04010        304                             ADD     s0, #0x10
049 04001        305     inc_led3:               ADD     s0, #0x01               ;increment counter
04A 08160        306                             JUMP    update_led3
04B 0C120        307     load_led3_start:        load      s1, led2_sequence       ;start LED3 if LED2 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
04C 00104        308                             load     s1, #0x04
04D 09158        309                             JUMP    z, inc_led3
04E 0C140        310                             load      s1, led4_sequence       ;start LED3 if LED4 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x14, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
04F 00104        311                             load     s1, #0x04
050 09158        312                             JUMP    z, inc_led3
  00060          313     update_led3:            ST      s0, led3_sequence
E: instruction not supported on the this device: STORE sX, ss.
051 083A7        314                             CALL    led_to_duty
                 315                             ST      s1, pwm_channel3
E: instruction not supported on the this device: STORE sX, ss.
                 316     ;
052 0C040        317                             load      s0, led4_sequence       ;read sequence for LED4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x14, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
053 00000        318                             load     s0, #0x00
054 0916B        319                             JUMP    z, load_led4_start
055 06010        320                             SUB     s0, #0x10               ;reset count if maximum
056 09171        321                             JUMP    z, update_led4
057 04010        322                             ADD     s0, #0x10
058 04001        323     inc_led4:               ADD     s0, #0x01               ;increment counter
059 08171        324                             JUMP    update_led4
05A 0C130        325     load_led4_start:        load      s1, led3_sequence       ;start LED4 if LED3 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
05B 00104        326                             load     s1, #0x04
05C 09169        327                             JUMP    z, inc_led4
05D 0C150        328                             load      s1, led5_sequence       ;start LED4 if LED5 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x15, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
05E 00104        329                             load     s1, #0x04
05F 09169        330                             JUMP    z, inc_led4
  00071          331     update_led4:            ST      s0, led4_sequence
E: instruction not supported on the this device: STORE sX, ss.
060 083A7        332                             CALL    led_to_duty
                 333                             ST      s1, pwm_channel4
E: instruction not supported on the this device: STORE sX, ss.
                 334     ;
061 0C050        335                             load      s0, led5_sequence       ;read sequence for LED5
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x15, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
062 00000        336                             load     s0, #0x00
063 0917C        337                             JUMP    z, load_led5_start
064 06010        338                             SUB     s0, #0x10               ;reset count if maximum
065 09182        339                             JUMP    z, update_led5
066 04010        340                             ADD     s0, #0x10
067 04001        341     inc_led5:               ADD     s0, #0x01               ;increment counter
068 08182        342                             JUMP    update_led5
069 0C140        343     load_led5_start:        load      s1, led4_sequence       ;start LED5 if LED4 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x14, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
06A 00104        344                             load     s1, #0x04
06B 0917A        345                             JUMP    z, inc_led5
06C 0C160        346                             load      s1, led6_sequence       ;start LED5 if LED6 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x16, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
06D 00104        347                             load     s1, #0x04
06E 0917A        348                             JUMP    z, inc_led5
  00082          349     update_led5:            ST      s0, led5_sequence
E: instruction not supported on the this device: STORE sX, ss.
06F 083A7        350                             CALL    led_to_duty
                 351                             ST      s1, pwm_channel5
E: instruction not supported on the this device: STORE sX, ss.
                 352     ;
070 0C170        353                             load      s1, led7_sequence       ; refresh LED6 if LED7 = 11 (0B hex) to reflect wave
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x17, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x7.
071 0010B        354                             load     s1, #0x0b
072 0958A        355                             JUMP    nz, normal_led6
073 00004        356                             LD      s0, #0x04
074 08195        357                             JUMP    update_led6
075 0C060        358     normal_led6:            load      s0, led6_sequence       ;read sequence for LED6
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x16, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
076 00000        359                             load     s0, #0x00
077 09192        360                             JUMP    z, load_led6_start
078 06010        361                             SUB     s0, #0x10               ;reset count if maximum
079 09195        362                             JUMP    z, update_led6
07A 04010        363                             ADD     s0, #0x10
07B 04001        364     inc_led6:               ADD     s0, #0x01               ;increment counter
07C 08195        365                             JUMP    update_led6
07D 0C150        366     load_led6_start:        load      s1, led5_sequence       ;start LED6 if LED5 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x15, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
07E 00104        367                             load     s1, #0x04
07F 09190        368                             JUMP    z, inc_led6
  00095          369     update_led6:            ST      s0, led6_sequence
E: instruction not supported on the this device: STORE sX, ss.
080 083A7        370                             CALL    led_to_duty
                 371                             ST      s1, pwm_channel6
E: instruction not supported on the this device: STORE sX, ss.
                 372     ;
081 0C070        373                             load      s0, led7_sequence       ;read sequence for LED7
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x17, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x7.
082 00000        374                             load     s0, #0x00
083 091A0        375                             JUMP    z, load_led7_start
084 06020        376                             SUB     s0, #0x20               ;Count longer to ensure end stops then reset count if maximum
085 091A3        377                             JUMP    z, update_led7
086 04020        378                             ADD     s0, #0x20
087 04001        379     inc_led7:               ADD     s0, #0x01               ;increment counter
088 081A3        380                             JUMP    update_led7
089 0C160        381     load_led7_start:        load      s1, led6_sequence       ;start LED7 if LED6 = 4
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
W: value out of range: 0x16, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
08A 00104        382                             load     s1, #0x04
08B 0919E        383                             JUMP    z, inc_led7
  000A3          384     update_led7:            ST      s0, led7_sequence
E: instruction not supported on the this device: STORE sX, ss.
08C 083A7        385                             CALL    led_to_duty
                 386                             ST      s1, pwm_channel7
E: instruction not supported on the this device: STORE sX, ss.
08D 08114        387                             JUMP    warm_start
                 388     ;
                 389     ;
                 390     ; Convert LED sequence number into PWM intensity figure
                 391     ;
                 392     ; LEDs duty cycle values are 0,1,2,4,8,16,32 and 64 because they appear to give what
                 393     ; appears to be a fairly liner change in intensity and provides a simple way to set
                 394     ; the duty value.
                 395     ;
                 396     ; Provide sequence value in register s0 and intensity will be
                 397     ; returned in register s1.
                 398     ;
                 399     ; s0   s1
                 400     ; 00   00
                 401     ; 01   01
                 402     ; 02   02
                 403     ; 03   04
                 404     ; 04   08
                 405     ; 05   10
                 406     ; 06   20
                 407     ; 07   40
                 408     ; 08   80
                 409     ; 09   40
                 410     ; 0A   20
                 411     ; 0B   10
                 412     ; 0C   08
                 413     ; 0D   04
                 414     ; 0E   02
                 415     ; 0F   01
                 416     ; 10   00  and zero for all larger values of s0
                 417     ;
08E 00100        418     led_to_duty:            LD      s1, #0x00
08F 00000        419                             load     s0, #0x00               ;load for zero
090 08080        420                             RET
091 00101        421                             LD      s1, #0x01               ;inject '1'
092 06001        422     go_up_loop:             SUB     s0, #0x01
093 08080        423                             RET
094 0D106        424                             SL0     s1                      ;multiply by 2
095 099B0        425                             JUMP    c, go_down
096 081AB        426                             JUMP    go_up_loop
097 00140        427     go_down:                LD      s1, #0x40
098 06001        428     go_down_loop:           SUB     s0, #0x01
099 08080        429                             RET
09A 0D10E        430                             SR0     s1                      ;divide by 2
09B 081B1        431                             JUMP    go_down_loop
                 432     ;
                 433     ;**************************************************************************************
                 434     ; UART communication routines
                 435     ;**************************************************************************************
                 436     ;
                 437     ; Read one character from the UART
                 438     ;
                 439     ; Character read will be returned in a register called 'UART_data'.
                 440     ;
                 441     ; The routine first loads the receiver FIFO buffer to see if data is present.
                 442     ; If the FIFO is empty, the routine waits until there is a character to read.
                 443     ; As this could take any amount of time the wait loop could include a call to a
                 444     ; subroutine which performs a useful function.
                 445     ;
                 446     ;
                 447     ; Registers used s0 and UART_data
                 448     ;
09C 0A000        449     read_from_uart:         IN      s0, status_port         ;load Rx_FIFO buffer
09D 00004        450                             load    s0, #rx_data_present    ;wait if empty
09E 095B9        451                             JUMP    nz, read_character
09F 081B5        452                             JUMP    read_from_uart
0A0 0AF01        453     read_character:         IN      uart_data, uart_read_port ;read from FIFO
0A1 08080        454                             RET
                 455     ;
                 456     ;
                 457     ;
                 458     ; Transmit one character to the UART
                 459     ;
                 460     ; Character supplied in register called 'UART_data'.
                 461     ;
                 462     ; The routine first loads the transmit FIFO buffer to see if it is full.
                 463     ; If the FIFO is full, then the routine waits until it there is space.
                 464     ;
                 465     ; Registers used s0
                 466     ;
0A2 0A000        467     send_to_uart:           IN      s0, status_port         ;load Tx_FIFO buffer
0A3 00002        468                             load    s0, #tx_full            ;wait if full
0A4 091BF        469                             JUMP    z, uart_write
0A5 081BB        470                             JUMP    send_to_uart
0A6 0EF20        471     uart_write:             OUT     uart_data, uart_write_port
0A7 08080        472                             RET
                 473     ;
                 474     ;
                 475     ;
                 476     ;**************************************************************************************
                 477     ; Text messages
                 478     ;**************************************************************************************
                 479     ;
                 480     ;
                 481     ; Send Carriage Return to the UART
                 482     ;
0A8 00F0D        483     send_cr:                LD      uart_data, #character_cr
0A9 083BB        484                             CALL    send_to_uart
0AA 08080        485                             RET
                 486     ;
                 487     ; Send a space to the UART
                 488     ;
0AB 00F20        489     send_space:             LD      uart_data, #character_space
0AC 083BB        490                             CALL    send_to_uart
0AD 08080        491                             RET
                 492     ;
                 493     ;
                 494     ;
                 495     ; Send 'PicoBlaze Servo Control' string to the UART
                 496     ;
0AE 083C1        497     send_welcome:           CALL    send_cr
0AF 083C1        498                             CALL    send_cr
0B0 00F50        499                             LD      uart_data, #_character_p
0B1 083BB        500                             CALL    send_to_uart
0B2 00F69        501                             LD      uart_data, #character_i
0B3 083BB        502                             CALL    send_to_uart
0B4 00F63        503                             LD      uart_data, #character_c
0B5 083BB        504                             CALL    send_to_uart
0B6 00F6F        505                             LD      uart_data, #character_o
0B7 083BB        506                             CALL    send_to_uart
0B8 00F42        507                             LD      uart_data, #_character_b
0B9 083BB        508                             CALL    send_to_uart
0BA 00F6C        509                             LD      uart_data, #character_l
0BB 083BB        510                             CALL    send_to_uart
0BC 00F61        511                             LD      uart_data, #character_a
0BD 083BB        512                             CALL    send_to_uart
0BE 00F7A        513                             LD      uart_data, #character_z
0BF 083BB        514                             CALL    send_to_uart
0C0 00F65        515                             LD      uart_data, #character_e
0C1 083BB        516                             CALL    send_to_uart
0C2 083C4        517                             CALL    send_space
0C3 00F41        518                             LD      uart_data, #_character_a
0C4 083BB        519                             CALL    send_to_uart
0C5 00F75        520                             LD      uart_data, #character_u
0C6 083BB        521                             CALL    send_to_uart
0C7 00F74        522                             LD      uart_data, #character_t
0C8 083BB        523                             CALL    send_to_uart
0C9 00F6F        524                             LD      uart_data, #character_o
0CA 083BB        525                             CALL    send_to_uart
0CB 083C4        526                             CALL    send_space
0CC 00F50        527                             LD      uart_data, #_character_p
0CD 083BB        528                             CALL    send_to_uart
0CE 00F57        529                             LD      uart_data, #_character_w
0CF 083BB        530                             CALL    send_to_uart
0D0 00F4D        531                             LD      uart_data, #_character_m
0D1 083BB        532                             CALL    send_to_uart
0D2 083C4        533                             CALL    send_space
0D3 00F41        534                             LD      uart_data, #_character_a
0D4 083BB        535                             CALL    send_to_uart
0D5 00F63        536                             LD      uart_data, #character_c
0D6 083BB        537                             CALL    send_to_uart
0D7 00F74        538                             LD      uart_data, #character_t
0D8 083BB        539                             CALL    send_to_uart
0D9 00F69        540                             LD      uart_data, #character_i
0DA 083BB        541                             CALL    send_to_uart
0DB 00F76        542                             LD      uart_data, #character_v
0DC 083BB        543                             CALL    send_to_uart
0DD 00F65        544                             LD      uart_data, #character_e
0DE 083BB        545                             CALL    send_to_uart
0DF 083C1        546                             CALL    send_cr
0E0 083C1        547                             CALL    send_cr
0E1 08080        548                             RET
                 549     ;
                 550     ;
                 551     ;Send 'OK' to the UART
                 552     ;
0E2 083C1        553     send_ok:                CALL    send_cr
0E3 00F4F        554                             LD      uart_data, #_character_o
0E4 083BB        555                             CALL    send_to_uart
0E5 00F4B        556                             LD      uart_data, #_character_k
0E6 083BB        557                             CALL    send_to_uart
0E7 081C1        558                             JUMP    send_cr
                 559     ;
                 560     ;
                 561     ;**************************************************************************************
                 562     ; Interrupt Service Routine (ISR)
                 563     ;**************************************************************************************
                 564     ;
                 565     ; Interrupts occur at 3.92us intervals and are used to generate the PWM pulses generated
                 566     ; at a PRF of 1KHz. The 3.92us interrupt rate corresponds with a resolution of 256 steps
                 567     ; over the 1ms associated with the 1KHz PRF.
                 568     ;
                 569     ; The ISR is self contained and all registers used are preserved. Scratch pad memory
                 570     ; locations are used to determine the desired duty factor for each of 12 channels.
                 571     ;
                 572     ; Note that an interrupt is generated every 196 clock cycles. This means that there is
                 573     ; only time to execute 98 instructions between each interrupt. This ISR is 48 instructions
                 574     ; long. A further 3 instructions are also consumed by the interrupt process
                 575     ; (abandoned instruction, virtual CALL to 3FF and the interrupt vector JUMP) and hence
                 576     ; PicoBlaze has approximately half of its time available for other tasks in the main program.
                 577     ;
                 578     ; Although a loop would normal be employed in soloadware to process each of 12 channels,
                 579     ; the implementation of a loop would increase the number of instructions which needed to
                 580     ; be executed to such an extent that this 12 channel implementation would not be possible.
                 581     ; Consequently the code is written out in a linear fashion which consumes more program
                 582     ; space but which executes faster.
                 583     ;
  00101          584     isr:                    ST      s0, isr_preserve_s0     ;preserve registers to be used
E: instruction not supported on the this device: STORE sX, ss.
                 585                             ST      s1, isr_preserve_s1
E: instruction not supported on the this device: STORE sX, ss.
                 586                             ST      s2, isr_preserve_s2
E: instruction not supported on the this device: STORE sX, ss.
                 587     ;Determine the number of steps currently through the 1ms PWM cycle
0E8 0C100        588                             load      s1, pwm_duty_counter    ;read 8-bit counter of steps
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0E9 04101        589                             ADD     s1, #0x01               ;increment counter (will roll over to zero)
                 590                             ST      s1, pwm_duty_counter    ;update count value in memory for next interrupt.
E: instruction not supported on the this device: STORE sX, ss.
                 591     ;Read duty factor for each channel and load it with the duty counter and set or
                 592     ;reset a bit in register s2 accordingly.
0EA 0C0C0        593                             load      s0, pwm_channel11       ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0EB 0C100        594                             load     s1, s0                  ;set carry flag if duty factor > duty counter
0EC 0D200        595                             SLA     s2                      ;shiload carry into register s2
0ED 0C0B0        596                             load      s0, pwm_channel10       ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0EE 0C100        597                             load     s1, s0                  ;set carry flag if duty factor > duty counter
0EF 0D200        598                             SLA     s2                      ;shiload carry into register s2
0F0 0C0A0        599                             load      s0, pwm_channel9        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0F1 0C100        600                             load     s1, s0                  ;set carry flag if duty factor > duty counter
0F2 0D200        601                             SLA     s2                      ;shiload carry into register s2
0F3 0C090        602                             load      s0, pwm_channel8        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0F4 0C100        603                             load     s1, s0                  ;set carry flag if duty factor > duty counter
0F5 0D200        604                             SLA     s2                      ;shiload carry into register s2
0F6 0E240        605                             OUT     s2, simple_port         ;drive pins on connector J4
0F7 0C080        606                             load      s0, pwm_channel7        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0F8 0C100        607                             load     s1, s0                  ;set carry flag if duty factor > duty counter
0F9 0D200        608                             SLA     s2                      ;shiload carry into register s2
0FA 0C070        609                             load      s0, pwm_channel6        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0FB 0C100        610                             load     s1, s0                  ;set carry flag if duty factor > duty counter
0FC 0D200        611                             SLA     s2                      ;shiload carry into register s2
0FD 0C060        612                             load      s0, pwm_channel5        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
0FE 0C100        613                             load     s1, s0                  ;set carry flag if duty factor > duty counter
0FF 0D200        614                             SLA     s2                      ;shiload carry into register s2
100 0C050        615                             load      s0, pwm_channel4        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
101 0C100        616                             load     s1, s0                  ;set carry flag if duty factor > duty counter
102 0D200        617                             SLA     s2                      ;shiload carry into register s2
103 0C040        618                             load      s0, pwm_channel3        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
104 0C100        619                             load     s1, s0                  ;set carry flag if duty factor > duty counter
105 0D200        620                             SLA     s2                      ;shiload carry into register s2
106 0C030        621                             load      s0, pwm_channel2        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
107 0C100        622                             load     s1, s0                  ;set carry flag if duty factor > duty counter
108 0D200        623                             SLA     s2                      ;shiload carry into register s2
109 0C020        624                             load      s0, pwm_channel1        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
10A 0C100        625                             load     s1, s0                  ;set carry flag if duty factor > duty counter
10B 0D200        626                             SLA     s2                      ;shiload carry into register s2
10C 0C010        627                             load      s0, pwm_channel0        ;read desired setting of pulse width
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
10D 0C100        628                             load     s1, s0                  ;set carry flag if duty factor > duty counter
10E 0D200        629                             SLA     s2                      ;shiload carry into register s2
10F 0E280        630                             OUT     s2, led_port            ;drive LEDs
110 0C0D0        631                             load      s0, isr_preserve_s0     ;reload register values
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
111 0C1E0        632                             load      s1, isr_preserve_s1
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
112 0C2F0        633                             load      s2, isr_preserve_s2
W: instruction `LOAD sX, sY' requires operand #2 to be of type(s): register; while the given operand is of type: number.
113 080F0        634                             RETIE
                 635     ;
                 636     ;
                 637     ;**************************************************************************************
                 638     ; Interrupt Vector
                 639     ;**************************************************************************************
                 640     ;
  003FF          641                             ORG     0x3ff
3FF 08101        642                             JUMP    isr
W: value out of range: 0x101, allowed range is [0x0,0xff] (trimmed to 8 bits) which makes it 0x1.
                 643     ;
                 644     ;
                 645
