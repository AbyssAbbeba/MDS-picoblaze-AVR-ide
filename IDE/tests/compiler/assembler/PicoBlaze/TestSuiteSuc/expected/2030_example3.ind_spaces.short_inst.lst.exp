                   1     ; KCPSM3 Program - Security control and design authentication.
                   2     ;
                   3     ; This program is provided for use with the reference design
                   4     ; 'low_cost_design_authentication_for_spartan_3e.vhd' implemented on the Spartan-3E Starter
                   5     ; Kit. The program provides design authentication control over the 'real' application as well
                   6     ; as providing features to enable evaluation of the design authentication method.
                   7     ;
                   8     ; Ken Chapman - Xilinx Ltd
                   9     device kcpsm2
                  10     ; Version v1.00 - 1st November 2006
                  11     ;
                  12     ; This code communicates with the StrataFLASH memory to implement a design authentication
                  13     ; algorithm which then enables the main application design in various ways. To facilitate
                  14     ; evaluation of design authentication this design also interacts with the LCD display
                  15     ; and PC (via UART based RS232 link) to indicate authentication status and allow control
                  16     ; over the authentication validity of the design. Therefore this program includes:-
                  17     ;
                  18     ; 1) Code required to check authorisation which would be included in a production design.
                  19     ; 2) Code required to program the authentication value into FLASH memory which would
                  20     ;    typically only be implemented in a special design used at a secure programming
                  21     ;    facility as part of the production programming procedure.
                  22     ; 3) Code to allow you to see what is happening at all stages which is code that should
                  23     ;    never be included in a real production design as it reveals secrets that should remain
                  24     ;    hidden in order to make the task of breaking the security as difficult as possible.
                  25     ;
                  26     ; IMPORTANT - Feel free to use this code as a reference for your own security scheme but
                  27     ;             never use this code unmodified.
                  28     ;
                  29     ;
                  30     ;**************************************************************************************
                  31     ; NOTICE:
                  32     ;
                  33     ; Copyright Xilinx, Inc. 2006.   This code may be contain portions patented by other
                  34     ; third parties.  By providing this core as one possible implementation of a standard,
                  35     ; Xilinx is making no representation that the provided implementation of this standard
                  36     ; is free from any claims of infringement by any third party.  Xilinx expressly
                  37     ; disclaims any warranty with respect to the adequacy of the implementation, including
                  38     ; but not limited to any warranty or representation that the implementation is free
                  39     ; from claims of any third party.  Furthermore, Xilinx is providing this core as a
                  40     ; courtesy to you and suggests that you contact all third parties to obtain the
                  41     ; necessary rights to use this implementation.
                  42     ;
                  43     ;
                  44     ;**************************************************************************************
                  45     ; Port definitions
                  46     ;**************************************************************************************
                  47     ;
                  48     ;
                  49     ; UART ports
                  50     ;
                  51     ; Connection to PC to allow display of progress information and to operate simple
                  52     ; menu of commands.
                  53     ;
  00000           54     status_port             EQU     0x00                    ;UART and memory status
  00001           55     tx_half_full            EQU     0x01                    ;  Transmitter     half full - bit0
  00002           56     tx_full                 EQU     0x02                    ;    FIFO            tx_full - bit1
  00004           57     rx_data_present         EQU     0x04                    ;  Receiver     data present - bit2
  00008           58     rx_half_full            EQU     0x08                    ;    FIFO          half full - bit3
  00010           59     rx_full                 EQU     0x10                    ;                    rx_full - bit4
  00020           60     spare1                  EQU     0x20                    ;                  spare '0' - bit5
  00040           61     spare2                  EQU     0x40                    ;                  spare '0' - bit6
  00080           62     strataflash_sts         EQU     0x80                    ;  StrataFLASH           STS - bit7
                  63     ;
  00001           64     uart_read_port          EQU     0x01                    ;UART Rx data input
                  65     ;
  00008           66     uart_write_port         EQU     0x08                    ;UART Tx data output
                  67     ;
                  68     ;
                  69     ; LCD Display
                  70     ;
                  71     ;The master enable signal is not used by the LCD display itself
                  72     ;but is used to prevent any contention with the StrataFLASH memory that
                  73     ;is connected to the same data pins. In this design the StrataFLASH memory is
                  74     ;used in 8-bit mode so not contention should exist but this master enable
                  75     ;facilty is then available for anyone wanting to modify the design for use
                  76     ;with a 16-bit interface.
                  77     ;
  00020           78     lcd_output_port         EQU     0x20                    ;LCD character module output data and control
  00001           79     lcd_e                   EQU     0x01                    ;   active High Enable        E - bit0
  00002           80     lcd_rw                  EQU     0x02                    ;   Read=1 Write=0           RW - bit1
  00004           81     lcd_rs                  EQU     0x04                    ;   Instruction=0 Data=1     RS - bit2
  00008           82     lcd_drive               EQU     0x08                    ;   Master enable (active High) - bit3
  00010           83     lcd_db4                 EQU     0x10                    ;   4-bit              Data DB4 - bit4
  00020           84     lcd_db5                 EQU     0x20                    ;   interface          Data DB5 - bit5
  00040           85     lcd_db6                 EQU     0x40                    ;                      Data DB6 - bit6
  00080           86     lcd_db7                 EQU     0x80                    ;                      Data DB7 - bit7
                  87     ;
                  88     ;
  00003           89     lcd_input_port          EQU     0x03                    ;LCD character module input data
  00001           90     lcd_read_spare0         EQU     0x01                    ;    Spare bits               - bit0
  00002           91     lcd_read_spare1         EQU     0x02                    ;    are zero                 - bit1
  00004           92     lcd_read_spare2         EQU     0x04                    ;                             - bit2
  00008           93     lcd_read_spare3         EQU     0x08                    ;                             - bit3
  00010           94     lcd_read_db4            EQU     0x10                    ;    4-bit           Data DB4 - bit4
  00020           95     lcd_read_db5            EQU     0x20                    ;    interface       Data DB5 - bit5
  00040           96     lcd_read_db6            EQU     0x40                    ;                    Data DB6 - bit6
  00080           97     lcd_read_db7            EQU     0x80                    ;                    Data DB7 - bit7
                  98     ;
                  99     ;
                 100     ;
                 101     ; StrataFLASH memory ports
                 102     ;
                 103     ; The FLASH memory is used to hold the authentication value as well as provide the
                 104     ; unique serial number from which the authentication algorithm computes the value.
                 105     ; In practice, the FLASH will also hold the configuration image for the Spartan device.
                 106     ;
                 107     ;
  00002          108     sf_data_in_port         EQU     0x02                    ;Read data from StrataFLASH device
                 109     ;
  00080          110     sf_data_out_port        EQU     0x80                    ;Data to write into StrataFLASH device
                 111     ;
  00083          112     sf_addr_hi_port         EQU     0x83                    ;StrataFLASH address[21:16] (6 LSB's)
  00082          113     sf_addr_mi_port         EQU     0x82                    ;StrataFLASH address[15:8]
  00081          114     sf_addr_lo_port         EQU     0x81                    ;StrataFLASH address[7:0]
                 115     ;
  00040          116     sf_control_port         EQU     0x40                    ;StrataFLASH control
  00001          117     sf_read                 EQU     0x01                    ;         active High read - bit0
  00002          118     sf_ce                   EQU     0x02                    ; active Low device enable - bit1
  00004          119     sf_we                   EQU     0x04                    ;         active Low write - bit2
                 120     ;
                 121     ;
                 122     ; Design Authentication enable/disable signals.
                 123     ;
                 124     ; Hardware controls over the 'real' application.
                 125     ;
  00010          126     authentication_control_port EQU 0x10                    ;Design disable control port
  00001          127     security_disable_interrupts EQU 0x01                    ;   active High disable of interrupt generation - bit0
  00002          128     security_disable_outputs EQU    0x02                    ;            active High disable of output pins - bit1
                 129     ;
                 130     ; Pseudo Random number generator
                 131     ;
  00004          132     random_value_port       EQU     0x04                    ;read LFSR counter value
                 133     ;
                 134     ;
                 135     ; Link FIFO buffer
                 136     ;
                 137     ; Provides a connection to the 'real' application such that 'soft tokens' in the
                 138     ; form of short messages to be passed to the 'real' application to enable or disable
                 139     ; it depending on the authentication status.
                 140     ;
  00004          141     link_fifo_write_port    EQU     0x04                    ;write data to FIFO
                 142     ;
                 143     ;
                 144     ;**************************************************************************************
                 145     ; Special Register usage
                 146     ;**************************************************************************************
                 147     ;
  0000F          148     uart_data               REG     sf                      ;used to pass data to and from the UART
                 149     ;
                 150     ;
                 151     ;
                 152     ;**************************************************************************************
                 153     ;Scratch Pad Memory Locations
                 154     ;**************************************************************************************
                 155     ;
  00000          156     isr_preserve_s0         EQU     0x00                    ;preserve register contents during Interrupt Service Routine
                 157     ;
                 158     ;
  00010          159     serial_number0          EQU     0x10                    ;64-bit serial number of StrataFlash
  00011          160     serial_number1          EQU     0x11                    ;LS-Byte first
  00012          161     serial_number2          EQU     0x12
  00013          162     serial_number3          EQU     0x13
  00014          163     serial_number4          EQU     0x14
  00015          164     serial_number5          EQU     0x15
  00016          165     serial_number6          EQU     0x16
  00017          166     serial_number7          EQU     0x17
                 167     ;
                 168     ;
  00018          169     computed_crc0           EQU     0x18                    ;computed 16-bit CRC based on the
  00019          170     computed_crc1           EQU     0x19                    ;  StrataFlash unique serial number (LS-Byte first)
                 171     ;
                 172     ;
  0001A          173     authentication_crc0     EQU     0x1a                    ;16-bit CRC value read from authentication
  0001B          174     authentication_crc1     EQU     0x1b                    ;  area of StrataFLASH memory (LS-Byte first)
                 175     ;
                 176     ;
  0001C          177     authentication_status   EQU     0x1c                    ;Status of design authentication
                 178     ;
                 179     ;
                 180     ;**************************************************************************************
                 181     ;Useful data constants
                 182     ;**************************************************************************************
                 183     ;
                 184     ;
                 185     ;
                 186     ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                 187     ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 188     ;calculation highly predictable. The '6' in the following equation even allows for
                 189     ;'CALL delay_1us' instruction in the initiating code.
                 190     ;
                 191     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 192     ;
                 193     ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 194     ;For clock rates below 10MHz the value of 1 must be used and the operation will
                 195     ;become lower than intended.
                 196     ;
  0000B          197     delay_1us_constant      EQU     0x0b
                 198     ;
                 199     ;
                 200     ;
                 201     ;
                 202     ;ASCII table
                 203     ;
  00061          204     character_a             EQU     0x61
  00062          205     character_b             EQU     0x62
  00063          206     character_c             EQU     0x63
  00064          207     character_d             EQU     0x64
  00065          208     character_e             EQU     0x65
  00066          209     character_f             EQU     0x66
  00067          210     character_g             EQU     0x67
  00068          211     character_h             EQU     0x68
  00069          212     character_i             EQU     0x69
  0006A          213     character_j             EQU     0x6a
  0006B          214     character_k             EQU     0x6b
  0006C          215     character_l             EQU     0x6c
  0006D          216     character_m             EQU     0x6d
  0006E          217     character_n             EQU     0x6e
  0006F          218     character_o             EQU     0x6f
  00070          219     character_p             EQU     0x70
  00071          220     character_q             EQU     0x71
  00072          221     character_r             EQU     0x72
  00073          222     character_s             EQU     0x73
  00074          223     character_t             EQU     0x74
  00075          224     character_u             EQU     0x75
  00076          225     character_v             EQU     0x76
  00077          226     character_w             EQU     0x77
  00078          227     character_x             EQU     0x78
  00079          228     character_y             EQU     0x79
  0007A          229     character_z             EQU     0x7a
  00041          230     _character_a            EQU     0x41
  00042          231     _character_b            EQU     0x42
  00043          232     _character_c            EQU     0x43
  00044          233     _character_d            EQU     0x44
  00045          234     _character_e            EQU     0x45
  00046          235     _character_f            EQU     0x46
  00047          236     _character_g            EQU     0x47
  00048          237     _character_h            EQU     0x48
  00049          238     _character_i            EQU     0x49
  0004A          239     _character_j            EQU     0x4a
  0004B          240     _character_k            EQU     0x4b
  0004C          241     _character_l            EQU     0x4c
  0004D          242     _character_m            EQU     0x4d
  0004E          243     _character_n            EQU     0x4e
  0004F          244     _character_o            EQU     0x4f
  00050          245     _character_p            EQU     0x50
  00051          246     _character_q            EQU     0x51
  00052          247     _character_r            EQU     0x52
  00053          248     _character_s            EQU     0x53
  00054          249     _character_t            EQU     0x54
  00055          250     _character_u            EQU     0x55
  00056          251     _character_v            EQU     0x56
  00057          252     _character_w            EQU     0x57
  00058          253     _character_x            EQU     0x58
  00059          254     _character_y            EQU     0x59
  0005A          255     _character_z            EQU     0x5a
  00030          256     character_0             EQU     0x30
  00031          257     character_1             EQU     0x31
  00032          258     character_2             EQU     0x32
  00033          259     character_3             EQU     0x33
  00034          260     character_4             EQU     0x34
  00035          261     character_5             EQU     0x35
  00036          262     character_6             EQU     0x36
  00037          263     character_7             EQU     0x37
  00038          264     character_8             EQU     0x38
  00039          265     character_9             EQU     0x39
  0003A          266     character_colon         EQU     0x3a
  0002E          267     character_fullstop      EQU     0x2e
  0003B          268     character_semi_colon    EQU     0x3b
  0002D          269     character_minus         EQU     0x2d
  0002F          270     character_divide        EQU     0x2f                    ;'/'
  0002B          271     character_plus          EQU     0x2b
  0002C          272     character_comma         EQU     0x2c
  0003C          273     character_less_than     EQU     0x3c
  0003E          274     character_greater_than  EQU     0x3e
  0003D          275     character_equals        EQU     0x3d
  00020          276     character_space         EQU     0x20
  0000D          277     character_cr            EQU     0x0d                    ;carriage return
  0003F          278     character_question      EQU     0x3f                    ;'?'
  00024          279     character_dollar        EQU     0x24
  00021          280     character_exclaim       EQU     0x21                    ;'!'
  00008          281     character_bs            EQU     0x08                    ;Back Space command character
                 282     ;
                 283     ;
                 284     ;
                 285     ;
                 286     ;
                 287     ;**************************************************************************************
                 288     ;Initialise the system
                 289     ;**************************************************************************************
                 290     ;
000 360E1        291     cold_start:             CALL    sf_init                 ;initialise StrataFLASH controls
001 00000        292                             LD      s0, #0x00               ;Start with application enabled in hardware
002 22010        293                             OUT     s0, authentication_control_port
003 00050        294                             LD      s0, #_character_p       ;start with design enabled by software (see ISR)
                 295                             ST      s0, authentication_status
E: instruction not supported on the this device: STORE sX, ss.
004 3635B        296                             CALL    delay_1s                ;delay to allow system to settle
005 36328        297                             CALL    lcd_reset               ;Initialise the LCD
                 298     ;
006 3C001        299                             ENA                             ;interrupts to provide software enable to application
                 300     ;
                 301     ;**************************************************************************************
                 302     ; Main program
                 303     ;**************************************************************************************
                 304     ;
                 305     ; The main program follows a logical sequence of events describing the power on and
                 306     ; authentication process of a design. This process will is either successfully authorises
                 307     ; the 'real' application to operate or fail to authenticate and disable the 'real'
                 308     ; application in a similar way to a production design. The only difference that it keeps
                 309     ; you informed about what it is doing on both the LCD display and PC terminal via the UART.
                 310     ; A real production design should keep all details hidden.
                 311     ;
                 312     ; Following the authentication check and control over the 'real' application a simple menu
                 313     ; is provided on the PC terminal to allow you to read, write and erase the authentication
                 314     ; area of the StrataFLASH memory and therefore evaluate the design authentication security
                 315     ; of this reference design.
                 316     ;
                 317     ;
                 318     ;
                 319     ; Write welcome message to LCD display
                 320     ;
007 00512        321     warm_start:             LD      s5, #0x12               ;Line 1 position 2
008 3633E        322                             CALL    lcd_cursor
009 36364        323                             CALL    disp_picoblaze          ;Display 'PicoBlaze'
00A 00525        324                             LD      s5, #0x25               ;Line 2 position 5
00B 3633E        325                             CALL    lcd_cursor
00C 36377        326                             CALL    disp_security           ;Display 'Security'
                 327     ;
                 328     ; Write welcome message to PC via UART
                 329     ;
00D 36164        330                             CALL    send_welcome
                 331     ;
                 332     ;
                 333     ; Display 'Copyright Ken Chapman 2006' via the UART.
                 334     ;
                 335     ; This message is significant because it demonstrates that the design now has a 'watermark'.
                 336     ; The ASCII codes for this string are part of the PicoBlaze program stored in a Block
                 337     ; Memory and therefore are also part of the configuration bit stream. If someone tries to
                 338     ; change or delete this copyright message the hardware design will detect the change to the
                 339     ; Block memory contents and also inhibit the design.
                 340     ;
00E 361B4        341                             CALL    send_copyright
                 342     ;
                 343     ;
                 344     ;
                 345     ; Delay of 10 seconds before performing any security checks.
                 346     ;
                 347     ; This allows the design to work for a short time which could be important for
                 348     ; production testing.
                 349     ;
                 350     ; Having a significant time delay (days or weeks) before security checks means that someone
                 351     ; attempting to clone the product may not be aware that there is any form of design security
                 352     ; at all until products are in the field are failing. A time delay also impedes the ability to
                 353     ; attempt to break the security and confirm if an attempt is or is not successful.
                 354     ;
00F 0050A        355                             LD      s5, #0x0a               ;delay of 10 seconds.
010 36360        356                             CALL    delay_ns
                 357     ;
                 358     ;
                 359     ;
                 360     ; Read serial number of the StrataFLASH memory.
                 361     ; The whole principle of low cost design security is based on this unique number. Clearly this
                 362     ; number is not a secret, but what we then go on to do with it should normally be kept secret.
                 363     ;
011 360F2        364                             CALL    read_sf_serial_number   ;read serial number from FLASH memory
012 36065        365                             CALL    send_serial_number      ;send value to UART for display on PC
013 36070        366                             CALL    disp_serial_number      ;display serial number on LCD display.
014 36154        367                             CALL    send_cr
                 368     ;
                 369     ;
                 370     ;
015 0050A        371                             LD      s5, #0x0a               ;delay of 10 seconds to read messages.
016 36360        372                             CALL    delay_ns
                 373     ;
                 374     ;
                 375     ;
                 376     ; Compute the 16-bit CRC for the serial number as an authentication value for the design.
                 377     ; The CRC value is formed in register pair [sE,sD]. To complicate the authentication value
                 378     ; the initial contents of the registers are seeded with a 'secret' number.
                 379     ; Hint 1 - The CRC computation could be implemented in hardware where it is less visible.
                 380     ; Hint 2 - There are more secure algorithms such as SHA-1 which could be used to generate
                 381     ;          authentication values that are extremely difficult to decode.
                 382     ;
                 383     ;
017 00E15        384                             LD      se, #0x15               ;seed CRC register with an initial value provided by my daughter when asked :-)
018 00D8E        385                             LD      sd, #0x8e
019 3607F        386                             CALL    compute_seeded_crc      ;compute CRC for serial number and configuration memory
                 387     ;
                 388     ; Store CRC value in scratch pad memory and display computed CRC value on the PC via UART.
                 389     ;
                 390                             ST      sd, computed_crc0       ;store CRC value
E: instruction not supported on the this device: STORE sX, ss.
                 391                             ST      se, computed_crc1
E: instruction not supported on the this device: STORE sX, ss.
01A 36252        392                             CALL    send_computed_crc       ;display computed CRC value on PC via UART
01B 10070        393                             LD      s0, se
01C 36140        394                             CALL    send_hex_byte
01D 10068        395                             LD      s0, sd
01E 36140        396                             CALL    send_hex_byte
01F 36154        397                             CALL    send_cr
                 398     ;
                 399     ;
                 400     ;
                 401     ; Read the authenticated CRC value stored in StrataFLASH memory.
                 402     ; 16-bit value is hidden in 256 bytes of random numbers to make it more difficult
                 403     ; for an attacker to identify.
                 404     ; Read value is stored in scratch pad memory and displayed on the PC via UART.
                 405     ;
020 36094        406                             CALL    read_authentication     ;read StrataFLASH memory into [sB,sA]
                 407                             ST      sa, authentication_crc0 ;store CRC value
E: instruction not supported on the this device: STORE sX, ss.
                 408                             ST      sb, authentication_crc1
E: instruction not supported on the this device: STORE sX, ss.
021 36248        409                             CALL    send_flash_crc          ;display CRC value from FLASH on PC via UART
022 10058        410                             LD      s0, sb
023 36140        411                             CALL    send_hex_byte
024 10050        412                             LD      s0, sa
025 36140        413                             CALL    send_hex_byte
026 36154        414                             CALL    send_cr
                 415     ;
                 416     ;
                 417     ; Compare the computed CRC value with the authentication value stored in StrataFLASH
                 418     ; and determine if the design is authenticated. Then decide course of action.
                 419     ;
027 36339        420                             CALL    lcd_clear               ;clear LCD display
028 363A9        421                             CALL    disp_authentication     ;prepare LCD display for result of authentication
029 36232        422                             CALL    send_authentication     ;prepare PC display for result of authentication
                 423     ;
                 424                             CMP     sa, sd                  ;Perform comparison of CRC values
E: instruction not supported on the this device: COMPARE sX, sY.
02A 35436        425                             JUMP    nz, auth_failure
                 426                             CMP     sb, se
E: instruction not supported on the this device: COMPARE sX, sY.
02B 35436        427                             JUMP    nz, auth_failure
                 428     ;
                 429     ;
                 430     ; Authentication Successful Process
                 431     ;
                 432     ; In this mode the design continues to operate and for evaluation
                 433     ; purposes this design transfers control to the simple menu immediately.
                 434     ;
02C 363C8        435     auth_passed:            CALL    disp_passed             ;display successful authentication on LCD display
02D 3629D        436                             CALL    send_passed             ;display successful authentication on PC via UART
02E 3403C        437                             JUMP    menu
                 438     ;
                 439     ; Authentication Failure Process
                 440     ;
                 441     ; When the authentication fails two hardware based disable methods are demonstrated. Then
                 442     ; the failed status is remembered for future software token messages to demonstrate software
                 443     ; based disabling of the 'real' application. Finally the simple menu of options is presented
                 444     ; to allow evaluation to continue.
                 445     ;
                 446     ;
02F 363D6        447     auth_failure:           CALL    disp_failed             ;display failure to authenticate on LCD display
030 3628F        448                             CALL    send_failed             ;display failure to authenticate on PC via UART
031 36154        449                             CALL    send_cr
032 36056        450                             CALL    disable_app_hardware    ;sequence hardware disable signals
033 00046        451                             LD      s0, #_character_f       ;change authentication status to 'F' for failed.
                 452                             ST      s0, authentication_status ; so that application software disable is demonstrated
E: instruction not supported on the this device: STORE sX, ss.
                 453     ;
                 454     ;
                 455     ;
                 456     ; Menu of options for authentication processing
                 457     ;
034 362BC        458     menu:                   CALL    send_menu               ;display menu and prompt
035 3611D        459                             CALL    read_from_uart          ;read character from PC
036 36129        460                             CALL    upper_case              ;convert to upper case
                 461                             CMP     uart_data, #_character_r
E: instruction not supported on the this device: COMPARE sX, kk.
037 35046        462                             JUMP    z, read_command
                 463                             CMP     uart_data, #_character_e
E: instruction not supported on the this device: COMPARE sX, kk.
038 3504B        464                             JUMP    z, erase_command
                 465                             CMP     uart_data, #_character_a
E: instruction not supported on the this device: COMPARE sX, kk.
039 3504F        466                             JUMP    z, authorise_command
03A 3403C        467                             JUMP    menu                    ;repeat menu for invalid selection
                 468     ;
                 469     ;
                 470     ;
03B 36154        471     read_command:           CALL    send_cr
03C 360AE        472                             CALL    send_auth_page
03D 36154        473                             CALL    send_cr
03E 36154        474                             CALL    send_cr
03F 3403C        475                             JUMP    menu
                 476     ;
                 477     ;
                 478     ;
040 3626F        479     erase_command:          CALL    send_erase_in_progress
041 360DE        480                             CALL    erase_authentication
042 36289        481                             CALL    send_ok
043 3403C        482                             JUMP    menu
                 483     ;
                 484     ;
                 485     ;
044 362AA        486     authorise_command:      CALL    send_writing            ;Send 'Writing Authorisation' message
045 36154        487                             CALL    send_cr
                 488                             FT      sd, computed_crc0       ;fetch computed CRC value
E: instruction not supported on the this device: FETCH sX, ss.
                 489                             FT      se, computed_crc1
E: instruction not supported on the this device: FETCH sX, ss.
046 360BE        490                             CALL    write_authentication    ;write computed CRC to FLASH with random data
047 36289        491                             CALL    send_ok
048 3403C        492                             JUMP    menu
                 493     ;
                 494     ;
                 495     ;**************************************************************************************
                 496     ; Drive failure signals to the application.
                 497     ;**************************************************************************************
                 498     ;
                 499     ; When the design fails to authorise, these controls cause the application to behave in
                 500     ; a strange way!
                 501     ;
                 502     ;
                 503     ; Disable interrupts to application PicoBlaze to stop PWM generation completely for 5 seconds
                 504     ;
049 00001        505     disable_app_hardware:   LD      s0, #security_disable_interrupts
04A 22010        506                             OUT     s0, authentication_control_port
04B 00505        507                             LD      s5, #0x05
04C 36360        508                             CALL    delay_ns
                 509     ;
                 510     ; Enable application for 5 seconds
                 511     ;
04D 00000        512                             LD      s0, #0x00
04E 22010        513                             OUT     s0, authentication_control_port
04F 00505        514                             LD      s5, #0x05
050 36360        515                             CALL    delay_ns
                 516     ;
                 517     ; Disable and/or scramble outputs connected to application PicoBlaze for 5 seconds
                 518     ;
051 00002        519                             LD      s0, #security_disable_outputs
052 22010        520                             OUT     s0, authentication_control_port
053 00505        521                             LD      s5, #0x05
054 36360        522                             CALL    delay_ns
                 523     ;
                 524     ;
                 525     ; Enable application in hardware so that software disable function can then be
                 526     ; demonstrated until the design is reconfigured and authentication test repeated.
                 527     ;
055 00000        528                             LD      s0, #0x00
056 22010        529                             OUT     s0, authentication_control_port
057 24000        530                             RET
                 531     ;
                 532     ;
                 533     ;
                 534     ;**************************************************************************************
                 535     ; Send the 64-bit serial number stored in scratch pad memory to the UART
                 536     ;**************************************************************************************
                 537     ;
                 538     ; The serial number should previously have been copied into the 8 ascending scratch pad
                 539     ; memory locations called 'serial_number0' through to 'serial_number7'.
                 540     ;
                 541     ; The serial number is displayed MS-Byte first.
                 542     ;
                 543     ; Registers used s0,s1,s2,s3
                 544     ;
058 361F2        545     send_serial_number:     CALL    send_flash_serial_number ;display text message
059 00317        546                             LD      s3, #serial_number7     ;pointer to scratch pad memory
  00067          547     send_sn_loop:           FT      s0, @s3                 ;read serial number byte
E: instruction not supported on the this device: FETCH sX, sY.
05A 36140        548                             CALL    send_hex_byte           ;display byte
05B 36157        549                             CALL    send_space              ;display byte
                 550                             CMP     s3, #serial_number0     ;check for 8 bytes sent to UART
E: instruction not supported on the this device: COMPARE sX, kk.
05C 3506E        551                             JUMP    z, end_send_sn
05D 0C301        552                             SUB     s3, #0x01               ;increment memory pointer
05E 34067        553                             JUMP    send_sn_loop
                 554     ;
05F 36154        555     end_send_sn:            CALL    send_cr
060 24000        556                             RET
                 557     ;
                 558     ;
                 559     ;
                 560     ;**************************************************************************************
                 561     ; Display the 64-bit serial number stored in scratch pad memory on the LCD display
                 562     ;**************************************************************************************
                 563     ;
                 564     ; The serial number should previously have been copied into the 8 ascending scratch pad
                 565     ; memory locations called 'serial_number0' through to 'serial_number7'.
                 566     ;
                 567     ; The serial number is displayed MS-Byte first.
                 568     ;
                 569     ; Registers used s0,s1,s2,s3,s4,s5,s6
                 570     ;
061 36339        571     disp_serial_number:     CALL    lcd_clear               ;clear LCD display
062 00510        572                             LD      s5, #0x10               ;Line 1 position 0
063 3633E        573                             CALL    lcd_cursor
064 36388        574                             CALL    disp_flash_serial_no    ;display text message
065 00520        575                             LD      s5, #0x20               ;Line 2 position 0
066 3633E        576                             CALL    lcd_cursor
067 00617        577                             LD      s6, #serial_number7     ;pointer to scratch pad memory
  00077          578     disp_sn_loop:           FT      s0, @s6                 ;read serial number byte
E: instruction not supported on the this device: FETCH sX, sY.
068 3614D        579                             CALL    disp_hex_byte           ;display byte
                 580                             CMP     s6, #serial_number0     ;check for 8 bytes sent to UART
E: instruction not supported on the this device: COMPARE sX, kk.
069 3507D        581                             JUMP    z, end_disp_sn
06A 0C601        582                             SUB     s6, #0x01               ;increment memory pointer
06B 34077        583                             JUMP    disp_sn_loop
                 584     ;
06C 36154        585     end_disp_sn:            CALL    send_cr
06D 24000        586                             RET
                 587     ;
                 588     ;
                 589     ;**************************************************************************************
                 590     ; Compute a 16-bit CRC value for the StrataFLASH 64-bit serial number.
                 591     ;**************************************************************************************
                 592     ;
                 593     ; This routing performs a 16-bit CRC calculation for the 64-bit unique serial number
                 594     ; of the StrataFLASH memory which forms the authentication value for the design.
                 595     ;
                 596     ; The 16-bit CRC value returned in register pair [sE,sD] will be reflective of the unique
                 597     ; serial number. This will be used as the authentication value for the design which is
                 598     ; stored at known locations in the FLASH memory.
                 599     ;
                 600     ; A direct copy of the FLASH contents will not authorise a design to operate because the
                 601     ; authentication value will not match the CRC value generated from the different serial number.
                 602     ;
                 603     ; To complicate the CRC value generation the CRC register can be seeded with a value rather
                 604     ; than starting with a clear register.
                 605     ;
                 606     ;
                 607     ; Registers used s0,s1,s2,s3
                 608     ;
06E 00410        609     compute_seeded_crc:     LD      s4, #serial_number0     ;pointer to scratch pad memory holding serial number
  00080          610     crc_send_loop:          FT      s3, @s4                 ;read serial number byte
E: instruction not supported on the this device: FETCH sX, sY.
06F 36086        611                             CALL    compute_crc16           ;compute CRC for value in 's3'
                 612                             CMP     s4, #serial_number7     ;check for 8 bytes processed
E: instruction not supported on the this device: COMPARE sX, kk.
070 24000        613                             RET
071 08401        614                             ADD     s4, #0x01               ;increment memory pointer
072 34080        615                             JUMP    crc_send_loop
                 616     ;
                 617     ;
                 618     ;**************************************************************************************
                 619     ; Compute 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                 620     ;**************************************************************************************
                 621     ;
                 622     ;
                 623     ; This routine computes a 16-bit CRC in the register pair [sE,sD] and these
                 624     ; registers must not be disturbed between calls of this routine.
                 625     ;
                 626     ; This routine has been written such that the CRC can be computed one
                 627     ; byte at a time. The byte to be processed should be provided in register 's3'
                 628     ; and the contents of this register are preserved.
                 629     ;
                 630     ; Before starting a CRC computation either clear or pre-load (seed) the register pair
                 631     ; [sE,sD] and do not disturb the value of the register pair between calling this routine.
                 632     ;
                 633     ; Registers used s0,s1,s3,sD,sE
                 634     ;    s3 is preserved.
                 635     ;    sD and sE should not be disturbed between calls if CRC value is required.
                 636     ;
                 637     ;
                 638     ;
073 00108        639     compute_crc16:          LD      s1, #0x08               ;8-bits to shift
074 10068        640     crc16_loop:             LD      s0, sd                  ;copy current CRC value
075 16018        641                             XOR     s0, s3                  ;Need to know LSB XOR next input bit
                 642                             TEST    s0, #0x01               ;test result of XOR in LSB
E: instruction not supported on the this device: TEST sX, kk.
076 35C8D        643                             JUMP    nc, crc16_shift
077 06D02        644                             XOR     sd, #0x02               ;compliment bit 1 of CRC
078 06E40        645                             XOR     se, #0x40               ;compliment bit 14 of CRC
079 2800E        646     crc16_shift:            SR0     s0                      ;Carry gets LSB XOR next input bit
07A 28E08        647                             SRA     se                      ;shift Carry into MSB to form new CRC value
07B 28D08        648                             SRA     sd
07C 2830C        649                             RR      s3                      ;shift input value
07D 0C101        650                             SUB     s1, #0x01               ;count bits
07E 35487        651                             JUMP    nz, crc16_loop          ;next bit
07F 24000        652                             RET
                 653     ;
                 654     ;
                 655     ;**************************************************************************************
                 656     ; Read 256 bytes of StrataFLASH memory including the authentication value.
                 657     ;**************************************************************************************
                 658     ;
                 659     ; This routine reads the authentication value from the StrataFLASH memory. In this
                 660     ; design the authentication value is only 2 bytes which once read will be returned
                 661     ; in the register pair [sB,sA].
                 662     ;
                 663     ; To make the authentication value more difficult to identify, it is hidden in 256 bytes
                 664     ; of pseudo random values which will also appear different in each FLASH device inspected.
                 665     ; This routine deliberately reads all 256 bytes that are stored and abstracts the required
                 666     ; 2 bytes of information from them otherwise it would be easy to observe which addresses
                 667     ; of the block were being accessed.
                 668     ;
                 669     ; Another way that an attacker may deduce which address locations are important would be to
                 670     ; observe the time between read accesses and note when there is any difference. In this case
                 671     ; the attacker is attempting to detect when PicoBlaze takes slightly longer to execute the
                 672     ; instructions which store the important bytes in scratch pad memory. So to avoid this
                 673     ; detection this routine inserts an additional random delay between reads to mask any code
                 674     ; execution differences.
                 675     ;
                 676     ; The 256 bytes are stored at addresses 060000 to 0600FF hex (the first block above the
                 677     ; XC3S500E configuration image which occupies 000000 to 04547F hex). The 2 bytes forming the
                 678     ; actual authentication value are stored as 4-bit nibbles in 4 different locations in this range.
                 679     ;
                 680     ;
                 681     ;                             High Order Nibble           Low Order Nibble
                 682     ;                               (NNNNxxxx)                  (xxxxNNNN)
                 683     ;
                 684     ; LS-Byte in 'sA'              Addr=060010                 Addr=06007F
                 685     ; MS-Byte in 'sB'              Addr=060025                 Addr=0600FA
                 686     ;
                 687     ;
080 00906        688     read_authentication:    LD      s9, #0x06               ;start address in FLASH
081 00800        689                             LD      s8, #0x00
082 00700        690                             LD      s7, #0x00
083 36101        691     auth_read_loop:         CALL    sf_byte_read            ;read byte from FLASH into s0
                 692                             CMP     s7, #0x10               ;check for bytes/nibbles that contain real information
E: instruction not supported on the this device: COMPARE sX, kk.
084 3549C        693                             JUMP    nz, auth_check2
085 10A00        694                             LD      sa, s0                  ;isolate upper order nibble for LS-Byte
086 02AF0        695                             AND     sa, #0xf0
  0009C          696     auth_check2:            CMP     s7, #0x25
E: instruction not supported on the this device: COMPARE sX, kk.
087 354A0        697                             JUMP    nz, auth_check3
088 10B00        698                             LD      sb, s0                  ;isolate upper order nibble for MS-Byte
089 02BF0        699                             AND     sb, #0xf0
  000A0          700     auth_check3:            CMP     s7, #0x7f
E: instruction not supported on the this device: COMPARE sX, kk.
08A 354A4        701                             JUMP    nz, auth_check4
08B 0200F        702                             AND     s0, #0x0f               ;isolate lower order nibble for LS-Byte
08C 14A00        703                             OR      sa, s0                  ;  and merge with upper order nibble
  000A4          704     auth_check4:            CMP     s7, #0xfa
E: instruction not supported on the this device: COMPARE sX, kk.
08D 354A8        705                             JUMP    nz, next_auth_read
08E 0200F        706                             AND     s0, #0x0f               ;isolate lower order nibble for MS-Byte
08F 14B00        707                             OR      sb, s0                  ;  and merge with upper order nibble
090 08701        708     next_auth_read:         ADD     s7, #0x01               ;increment address
091 24000        709                             RET                             ;complete after 256 reads
092 20004        710                             IN      s0, random_value_port   ;random delay between reads
093 0C001        711     auth_read_delay:        SUB     s0, #0x01
094 354AB        712                             JUMP    nz, auth_read_delay
095 34097        713                             JUMP    auth_read_loop
                 714     ;
                 715     ;
                 716     ;**************************************************************************************
                 717     ; Read 256 bytes (page) of StrataFLASH memory containing the authentication value.
                 718     ;**************************************************************************************
                 719     ;
                 720     ; This routine reads the StrataFLASH memory and displays the contents on the PC display
                 721     ; via the UART. The display will be 256 bytes from address range 060000 to 0600FF displayed
                 722     ; as 16 lines of 16 bytes with each line commencing with the address of the first byte.
                 723     ;
096 00906        724     send_auth_page:         LD      s9, #0x06               ;start address in FLASH
097 00800        725                             LD      s8, #0x00
098 00700        726                             LD      s7, #0x00
099 36154        727     auth_line_loop:         CALL    send_cr
09A 36146        728                             CALL    send_hex_3bytes         ;display address
09B 36157        729                             CALL    send_space
09C 36157        730     auth_byte_loop:         CALL    send_space
09D 36101        731                             CALL    sf_byte_read            ;read byte into s0
09E 36140        732                             CALL    send_hex_byte           ;display byte
09F 08701        733                             ADD     s7, #0x01               ;increment FLASH address
                 734                             TEST    s7, #0x0f               ;test for 16 byte boundary
E: instruction not supported on the this device: TEST sX, kk.
0A0 354B4        735                             JUMP    nz, auth_byte_loop
                 736                             TEST    s7, #0xff               ;test for roll over of 256 bytes
E: instruction not supported on the this device: TEST sX, kk.
0A1 354B1        737                             JUMP    nz, auth_line_loop
0A2 36154        738                             CALL    send_cr
0A3 24000        739                             RET
                 740     ;
                 741     ;
                 742     ;
                 743     ;
                 744     ;**************************************************************************************
                 745     ; Write 256 bytes of StrataFLASH memory including the authentication value.
                 746     ;**************************************************************************************
                 747     ;
                 748     ; This routine writes the authentication value to the StrataFLASH memory. This routine
                 749     ; would normally be part of a production programming mechanism and not part of the
                 750     ; final design which only reads and confirms authentication. This routine does not
                 751     ; require and special measures to confuse an attacker if it is only used in a secure
                 752     ; production environment.
                 753     ;
                 754     ; The 2 bytes forming the actual authentication value are stored as 4-bit nibbles in
                 755     ; 4 different locations in the address range 600000 to 6000FF hex (256 bytes) with
                 756     ; all remaining locations filled with pseudo random values.
                 757     ;
                 758     ; The authentication value to be stored in StrataFLASH memory should be provided in
                 759     ; the register pair [sE,sD] and will be stored in the following locations.
                 760     ;
                 761     ;                             High Order Nibble           Low Order Nibble
                 762     ;                               (NNNNxxxx)                  (xxxxNNNN)
                 763     ;
                 764     ; LS-Byte in 'sD'              Addr=060010                 Addr=06007F
                 765     ; MS-Byte in 'sE'              Addr=060025                 Addr=0600FA
                 766     ;
                 767     ;
0A4 00906        768     write_authentication:   LD      s9, #0x06               ;start address in FLASH
0A5 00800        769                             LD      s8, #0x00
0A6 00700        770                             LD      s7, #0x00
0A7 20004        771     auth_write_loop:        IN      s0, random_value_port   ;Obtain random value
                 772                             CMP     s7, #0x10               ;check for bytes/nibbles that need to be real information
E: instruction not supported on the this device: COMPARE sX, kk.
0A8 354C8        773                             JUMP    nz, auth_write_check2
0A9 10168        774                             LD      s1, sd                  ;merge upper order nibble for LS-Byte with random
0AA 021F0        775                             AND     s1, #0xf0
0AB 0200F        776                             AND     s0, #0x0f
0AC 14008        777                             OR      s0, s1
  000C8          778     auth_write_check2:      CMP     s7, #0x25
E: instruction not supported on the this device: COMPARE sX, kk.
0AD 354CE        779                             JUMP    nz, auth_write_check3
0AE 10170        780                             LD      s1, se                  ;merge upper order nibble for MS-Byte with random
0AF 021F0        781                             AND     s1, #0xf0
0B0 0200F        782                             AND     s0, #0x0f
0B1 14008        783                             OR      s0, s1
  000CE          784     auth_write_check3:      CMP     s7, #0x7f
E: instruction not supported on the this device: COMPARE sX, kk.
0B2 354D4        785                             JUMP    nz, auth_write_check4
0B3 10168        786                             LD      s1, sd                  ;merge lower order nibble for LS-Byte with random
0B4 0210F        787                             AND     s1, #0x0f
0B5 020F0        788                             AND     s0, #0xf0
0B6 14008        789                             OR      s0, s1
  000D4          790     auth_write_check4:      CMP     s7, #0xfa
E: instruction not supported on the this device: COMPARE sX, kk.
0B7 354DA        791                             JUMP    nz, write_auth
0B8 10170        792                             LD      s1, se                  ;merge lower order nibble for MS-Byte with random
0B9 0210F        793                             AND     s1, #0x0f
0BA 020F0        794                             AND     s0, #0xf0
0BB 14008        795                             OR      s0, s1
0BC 360EC        796     write_auth:             CALL    sf_single_byte_write    ;write byte to FLASH
0BD 08701        797                             ADD     s7, #0x01               ;increment address
0BE 24000        798                             RET                             ;complete after 256 writes
0BF 340C1        799                             JUMP    auth_write_loop
                 800     ;
                 801     ;
                 802     ;**************************************************************************************
                 803     ; Erase authentication value from StrataFLASH memory.
                 804     ;**************************************************************************************
                 805     ;
                 806     ; Erase block 3 of the StrataFLASH memory which covers the address range 060000 to 07FFFF.
                 807     ; This erases the area containing the authentication value and random values which helps
                 808     ; to hide it.
                 809     ;
0C0 00906        810     erase_authentication:   LD      s9, #0x06               ;set address to 06xxxx hex which defines block 3 (060000 to 07FFFF)
0C1 360E4        811                             CALL    sf_erase_block
0C2 24000        812                             RET
                 813     ;
                 814     ;
                 815     ;**************************************************************************************
                 816     ; Initialise the StrataFlash Memory control signals.
                 817     ;**************************************************************************************
                 818     ;
                 819     ; SF_read = 0   - Output enable off
                 820     ; SF_ce = 1     - Deselect StrataFLASH memory
                 821     ; SF_we = 1     - Write enable off
                 822     ;
                 823     ; Register used s0
                 824     ;
0C3 00006        825     sf_init:                LD      s0, #0x06
0C4 22040        826                             OUT     s0, sf_control_port
0C5 24000        827                             RET
                 828     ;
                 829     ;
                 830     ;
                 831     ;**************************************************************************************
                 832     ; StrataFLASH Block Erase
                 833     ;**************************************************************************************
                 834     ;
                 835     ; This routine will erase one 128k-byte block of the StrataFLASH memory.
                 836     ; The block to be erased is specified by the contents of register 's9'.
                 837     ;
                 838     ; s9=06 erases Block 3 (address range 060000 to 07FFFF)
                 839     ;
                 840     ;
                 841     ; To erase a block the 24-bit address must be set and then the block erase command
                 842     ; (20 hex) written to the memory followed by the write confirm command (D0 hex).
                 843     ;
                 844     ; The act of erasing a block may take up to 1 second to complete. This routine
                 845     ; waits for the memory to be ready before restoring the normal read array mode and
                 846     ; returning.
                 847     ;
                 848     ; Registers used s0,s1,s7,s8,s9
                 849     ;
0C6 00800        850     sf_erase_block:         LD      s8, #0x00               ;define lower address of block = xx0000
0C7 00700        851                             LD      s7, #0x00
0C8 00120        852                             LD      s1, #0x20               ;block erase command
0C9 3610B        853                             CALL    sf_byte_write
0CA 001D0        854                             LD      s1, #0xd0               ;write confirm command
0CB 3610B        855                             CALL    sf_byte_write
0CC 36118        856                             CALL    wait_sf_ready           ;wait for erase to complete
0CD 24000        857                             RET
                 858     ;
                 859     ;
                 860     ;**************************************************************************************
                 861     ; Write a single byte to StrataFlash Memory
                 862     ;**************************************************************************************
                 863     ;
                 864     ; To write a single byte to StrataFLASH memory the address must be set and the
                 865     ; single-word/byte program command (40 hex) sent to the memory. Then the data byte can
                 866     ; be written to the memory using the same address.
                 867     ;
                 868     ; The 24-bit address should be supplied in register set [s9,s8,s7].
                 869     ; Register s0 should contain the byte data to be written to the memory.
                 870     ;
                 871     ; The act of writing the memory array may take up to 175us to complete. This routine
                 872     ; waits for the memory to be ready before restoring the normal read array mode and
                 873     ; returning.
                 874     ;
                 875     ; Registers used s0,s1,s7,s8,s9   (s7,s8,s9 not changed)
                 876     ;
                 877     ; Registers used s0,s1,s7,s8,s9
                 878     ;
0CE 00140        879     sf_single_byte_write:   LD      s1, #0x40               ;command for single byte program
0CF 3610B        880                             CALL    sf_byte_write
0D0 10100        881                             LD      s1, s0                  ;write data to be programmed
0D1 3610B        882                             CALL    sf_byte_write
0D2 36118        883                             CALL    wait_sf_ready           ;wait for program to complete
0D3 24000        884                             RET
                 885     ;
                 886     ;
                 887     ;
                 888     ;**************************************************************************************
                 889     ; Read the unique 64-bit serial number of the StrataFLASH FLASH memory
                 890     ;**************************************************************************************
                 891     ;
                 892     ; To read the device information the Read device information command (90)
                 893     ; must be written to the memory. The information is read back from address 000102
                 894     ; to 000109 (note these are byte access addresses).
                 895     ;
                 896     ; The serial number is copied to 8 ascending scratch pad memory locations called
                 897     ; 'serial_number0' through to 'serial_number7' for future use.
                 898     ;
                 899     ; After reading the device information the read array command is written to the
                 900     ; device to put it back to normal read mode.
                 901     ;
                 902     ; Registers used s0,s1,s2,s7,s8,s9
                 903     ;
0D4 00900        904     read_sf_serial_number:  LD      s9, #0x00               ;StrataFLASH address to read serial number = 000102
0D5 00801        905                             LD      s8, #0x01
0D6 00702        906                             LD      s7, #0x02
0D7 00210        907                             LD      s2, #serial_number0     ;pointer to scratch pad memory
0D8 00190        908                             LD      s1, #0x90               ;command to read device information
0D9 3610B        909                             CALL    sf_byte_write
0DA 36101        910     read_sn_loop:           CALL    sf_byte_read            ;read serial number value
                 911                             ST      s0, @s2
E: instruction not supported on the this device: STORE sX, sY.
                 912                             CMP     s2, #serial_number7     ;check for 8 bytes copied
E: instruction not supported on the this device: COMPARE sX, kk.
0DB 350FF        913                             JUMP    z, end_read_sn
0DC 08701        914                             ADD     s7, #0x01               ;increment StrataFLASH address
0DD 08201        915                             ADD     s2, #0x01               ;increment memory pointer
0DE 340F8        916                             JUMP    read_sn_loop
                 917     ;
0DF 36115        918     end_read_sn:            CALL    set_sf_read_array_mode  ;restore normal read array mode
0E0 24000        919                             RET
                 920     ;
                 921     ;
                 922     ;
                 923     ;**************************************************************************************
                 924     ; Read a byte from StrataFlash Memory
                 925     ;**************************************************************************************
                 926     ;
                 927     ; The 24-bit address should be supplied in register set [s9,s8,s7].
                 928     ; Register s0 will return the byte data retrieved from the memory.
                 929     ;
                 930     ; To read a byte, the address needs to be set up on the address lines
                 931     ; and the controls set as follows
                 932     ;    SF_read = 1 - disable Spartan data outputs and enable StrataFlash outputs (OE=0)
                 933     ;      SF_ce = 0 - enable StrataFLASH memory
                 934     ;      SF_we = 1 - Write enable off
                 935     ;
                 936     ; The access time of the memory is 75ns. This is equivalent to 3.75 clock cycles at
                 937     ; 50MHz. Since each KCPSM3 instruction takes 2 clock cycles to execute, two instructions
                 938     ; provides adequate delay for the memory to be accessed.
                 939     ;
                 940     ; Registers used s0,s1,s7,s8,s9
                 941     ;
0E1 22983        942     sf_byte_read:           OUT     s9, sf_addr_hi_port     ;set 24-bit address
0E2 22882        943                             OUT     s8, sf_addr_mi_port
0E3 22781        944                             OUT     s7, sf_addr_lo_port
0E4 00105        945                             LD      s1, #0x05               ;set controls
0E5 22140        946                             OUT     s1, sf_control_port
0E6 00106        947                             LD      s1, #0x06               ;>75ns delay
0E7 00106        948                             LD      s1, #0x06               ;but do something useful!
0E8 20002        949                             IN      s0, sf_data_in_port     ;read data byte
0E9 22140        950                             OUT     s1, sf_control_port     ;clear controls
0EA 24000        951                             RET
                 952     ;
                 953     ;
                 954     ;**************************************************************************************
                 955     ; Write data or command byte to StrataFlash Memory
                 956     ;**************************************************************************************
                 957     ;
                 958     ; The 24-bit address should be supplied in register set [s9,s8,s7].
                 959     ; Register s1 should contain the byte to be written to the memory.
                 960     ;
                 961     ; To write a byte, the address needs to be set up on the address lines
                 962     ; and the controls set as follows
                 963     ;    SF_read = 0 - enable Spartan data outputs and disable StrataFlash outputs (OE=1)
                 964     ;      SF_ce = 0 - enable StrataFLASH memory
                 965     ;      SF_we = 0 - Write enable on
                 966     ;
                 967     ; The setup time of the memory is 60ns. This is equivalent to 3 clock cycles at
                 968     ; 50MHz. Since each KCPSM3 instruction takes 2 clock cycles to execute, two instructions
                 969     ; provides adequate delay for the memory.
                 970     ;
                 971     ; Registers used s1,s7,s8,s9
                 972     ;
0EB 22983        973     sf_byte_write:          OUT     s9, sf_addr_hi_port     ;set 24-bit address
0EC 22882        974                             OUT     s8, sf_addr_mi_port
0ED 22781        975                             OUT     s7, sf_addr_lo_port
0EE 22180        976                             OUT     s1, sf_data_out_port    ;set data byte to be written
0EF 00100        977                             LD      s1, #0x00               ;set controls
0F0 22140        978                             OUT     s1, sf_control_port
0F1 00106        979                             LD      s1, #0x06               ;>60ns delay
0F2 00106        980                             LD      s1, #0x06               ;but do something useful!
0F3 22140        981                             OUT     s1, sf_control_port     ;clear controls
0F4 24000        982                             RET
                 983     ;
                 984     ;
                 985     ;**************************************************************************************
                 986     ; Set 'Read Array' mode on StrataFLASH
                 987     ;**************************************************************************************
                 988     ;
                 989     ; The read array mode is the default mode of the memory and allows the contents
                 990     ; of the memory to be read based on the supplied address.
                 991     ;
                 992     ; Read array is the default mode of the device, but it must also be placed back
                 993     ; into this mode after programming, erasing or reading the status register.
                 994     ;
                 995     ; The read array command (FF hex) is written to the Strata flash memory.
                 996     ;
                 997     ; Registers used s1,s7,s8,s9
                 998     ;
0F5 001FF        999     set_sf_read_array_mode: LD      s1, #0xff               ;command to read array
0F6 3610B       1000                             CALL    sf_byte_write
0F7 24000       1001                             RET
                1002     ;
                1003     ;
                1004     ;**************************************************************************************
                1005     ; Wait for StrataFLASH to be ready
                1006     ;**************************************************************************************
                1007     ;
                1008     ; This routine will typically be used after instigating a program or erase
                1009     ; command. It continuously reads the StrataFLASH status register and tests the
                1010     ; information provided by bit7 which indicates if the memory is busy(0) or ready(1).
                1011     ; The routine waits for the ready condition before sending a read array command
                1012     ; which puts the memory back to normal read mode.
                1013     ;
                1014     ;
                1015     ; Registers used s0,s1,s7,s8,s9   (s7,s8,s9 not changed)
                1016     ;
                1017     ;
0F8 36101       1018     wait_sf_ready:          CALL    sf_byte_read            ;read status register into s0
                1019                             TEST    s0, #0x80               ;test ready/busy flag
E: instruction not supported on the this device: TEST sX, kk.
0F9 35118       1020                             JUMP    z, wait_sf_ready
0FA 36115       1021                             CALL    set_sf_read_array_mode  ;restore normal read array mode
0FB 24000       1022                             RET
                1023     ;
                1024     ;
                1025     ;
                1026     ;
                1027     ;**************************************************************************************
                1028     ; UART communication routines
                1029     ;**************************************************************************************
                1030     ;
                1031     ; Read one character from the UART
                1032     ;
                1033     ; Character read will be returned in a register called 'UART_data'.
                1034     ;
                1035     ; The routine first tests the receiver FIFO buffer to see if data is present.
                1036     ; If the FIFO is empty, the routine waits until there is a character to read.
                1037     ; As this could take any amount of time the wait loop could include a call to a
                1038     ; subroutine which performs a useful function.
                1039     ;
                1040     ;
                1041     ; Registers used s0 and UART_data
                1042     ;
0FC 20000       1043     read_from_uart:         IN      s0, status_port         ;test Rx_FIFO buffer
                1044                             TEST    s0, #rx_data_present    ;wait if empty
E: instruction not supported on the this device: TEST sX, kk.
0FD 35521       1045                             JUMP    nz, read_character
0FE 3411D       1046                             JUMP    read_from_uart
0FF 20F01       1047     read_character:         IN      uart_data, uart_read_port ;read from FIFO
100 24000       1048                             RET
                1049     ;
                1050     ;
                1051     ;
                1052     ; Transmit one character to the UART
                1053     ;
                1054     ; Character supplied in register called 'UART_data'.
                1055     ;
                1056     ; The routine first tests the transmit FIFO buffer to see if it is full.
                1057     ; If the FIFO is full, then the routine waits until it there is space.
                1058     ;
                1059     ; Registers used s0
                1060     ;
101 20000       1061     send_to_uart:           IN      s0, status_port         ;test Tx_FIFO buffer
                1062                             TEST    s0, #tx_full            ;wait if full
E: instruction not supported on the this device: TEST sX, kk.
102 35127       1063                             JUMP    z, uart_write
103 34123       1064                             JUMP    send_to_uart
104 22F08       1065     uart_write:             OUT     uart_data, uart_write_port
105 24000       1066                             RET
                1067     ;
                1068     ;
                1069     ;
                1070     ;**************************************************************************************
                1071     ;Useful ASCII conversion and handling routines
                1072     ;**************************************************************************************
                1073     ;
                1074     ;
                1075     ;
                1076     ;Convert character to upper case
                1077     ;
                1078     ;The character supplied in register UART_data.
                1079     ;If the character is in the range 'a' to 'z', it is converted
                1080     ;to the equivalent upper case character in the range 'A' to 'Z'.
                1081     ;All other characters remain unchanged.
                1082     ;
                1083     ;Registers used s0.
                1084     ;
  00129         1085     upper_case:             CMP     uart_data, #0x61        ;eliminate character codes below 'a' (61 hex)
E: instruction not supported on the this device: COMPARE sX, kk.
106 24000       1086                             RET
                1087                             CMP     uart_data, #0x7b        ;eliminate character codes above 'z' (7A hex)
E: instruction not supported on the this device: COMPARE sX, kk.
107 24000       1088                             RET
108 02FDF       1089                             AND     uart_data, #0xdf        ;mask bit5 to convert to upper case
109 24000       1090                             RET
                1091     ;
                1092     ;
                1093     ;Convert hexadecimal value provided in register s0 into ASCII characters
                1094     ;
                1095     ;The value provided must can be any value in the range 00 to FF and will be converted into
                1096     ;two ASCII characters.
                1097     ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1098     ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1099     ;
                1100     ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1101     ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1102     ;hexadecimal requiring a further addition of 07 to the 30 already added.
                1103     ;
                1104     ;Registers used s0, s1 and s2.
                1105     ;
10A 10100       1106     hex_byte_to_ascii:      LD      s1, s0                  ;remember value supplied
10B 2800E       1107                             SR0     s0                      ;isolate upper nibble
10C 2800E       1108                             SR0     s0
10D 2800E       1109                             SR0     s0
10E 2800E       1110                             SR0     s0
10F 3613B       1111                             CALL    hex_to_ascii            ;convert
110 10200       1112                             LD      s2, s0                  ;upper nibble value in s2
111 10008       1113                             LD      s0, s1                  ;restore complete value
112 0200F       1114                             AND     s0, #0x0f               ;isolate lower nibble
113 3613B       1115                             CALL    hex_to_ascii            ;convert
114 10100       1116                             LD      s1, s0                  ;lower nibble value in s1
115 24000       1117                             RET
                1118     ;
                1119     ;Convert hexadecimal value provided in register s0 into ASCII character
                1120     ;
                1121     ;Register used s0
                1122     ;
116 0C00A       1123     hex_to_ascii:           SUB     s0, #0x0a               ;test if value is in range 0 to 9
117 3593E       1124                             JUMP    c, number_char
118 08007       1125                             ADD     s0, #0x07               ;ASCII char A to F in range 41 to 46
119 0803A       1126     number_char:            ADD     s0, #0x3a               ;ASCII char 0 to 9 in range 30 to 40
11A 24000       1127                             RET
                1128     ;
                1129     ;
                1130     ;Send the two character HEX value of the register contents 's0' to the UART
                1131     ;
                1132     ;Registers used s0, s1, s2
                1133     ;
11B 3612F       1134     send_hex_byte:          CALL    hex_byte_to_ascii
11C 10F10       1135                             LD      uart_data, s2
11D 36123       1136                             CALL    send_to_uart
11E 10F08       1137                             LD      uart_data, s1
11F 36123       1138                             CALL    send_to_uart
120 24000       1139                             RET
                1140     ;
                1141     ;
                1142     ;Send the six character HEX value of the register contents [s9,s8,s7] to the UART
                1143     ;
                1144     ;Registers used s0, s1, s2
                1145     ;
121 10048       1146     send_hex_3bytes:        LD      s0, s9
122 36140       1147                             CALL    send_hex_byte
123 10040       1148                             LD      s0, s8
124 36140       1149                             CALL    send_hex_byte
125 10038       1150                             LD      s0, s7
126 36140       1151                             CALL    send_hex_byte
127 24000       1152                             RET
                1153     ;
                1154     ;
                1155     ;Display the two character HEX value of the register contents 's0' on the LCD display
                1156     ;
                1157     ;Registers used s0,s1,s2,s3,s4,s5
                1158     ;
128 3612F       1159     disp_hex_byte:          CALL    hex_byte_to_ascii
129 10308       1160                             LD      s3, s1                  ;remember least significant digit
12A 10510       1161                             LD      s5, s2
12B 362FE       1162                             CALL    lcd_write_data          ;display most significant digit
12C 10518       1163                             LD      s5, s3
12D 362FE       1164                             CALL    lcd_write_data          ;display least significant digit
12E 24000       1165                             RET
                1166     ;
                1167     ;
                1168     ;
                1169     ;**************************************************************************************
                1170     ; UART Text messages
                1171     ;**************************************************************************************
                1172     ;
                1173     ;
                1174     ;Send Carriage Return to the UART
                1175     ;
12F 00F0D       1176     send_cr:                LD      uart_data, #character_cr
130 36123       1177                             CALL    send_to_uart
131 24000       1178                             RET
                1179     ;
                1180     ;Send a space to the UART
                1181     ;
132 00F20       1182     send_space:             LD      uart_data, #character_space
133 36123       1183                             CALL    send_to_uart
134 24000       1184                             RET
                1185     ;
                1186     ;
                1187     ;Send an equals sign to the UART with a space each side
                1188     ;
135 36157       1189     send_equals:            CALL    send_space
136 00F3D       1190                             LD      uart_data, #character_equals
137 36123       1191                             CALL    send_to_uart
138 36157       1192                             CALL    send_space
139 24000       1193                             RET
                1194     ;
                1195     ;
                1196     ;
                1197     ;Send an minus sign (dash) to the UART with a space each side
                1198     ;
13A 36157       1199     send_dash:              CALL    send_space
13B 00F2D       1200                             LD      uart_data, #character_minus
13C 36123       1201                             CALL    send_to_uart
13D 36157       1202                             CALL    send_space
13E 24000       1203                             RET
                1204     ;
                1205     ;
                1206     ;Send 'PicoBlaze Low Cost Design Security v1.00' string to the UART
                1207     ;
13F 36154       1208     send_welcome:           CALL    send_cr
140 36154       1209                             CALL    send_cr
141 00F50       1210                             LD      uart_data, #_character_p
142 36123       1211                             CALL    send_to_uart
143 00F69       1212                             LD      uart_data, #character_i
144 36123       1213                             CALL    send_to_uart
145 00F63       1214                             LD      uart_data, #character_c
146 36123       1215                             CALL    send_to_uart
147 00F6F       1216                             LD      uart_data, #character_o
148 36123       1217                             CALL    send_to_uart
149 00F42       1218                             LD      uart_data, #_character_b
14A 36123       1219                             CALL    send_to_uart
14B 00F6C       1220                             LD      uart_data, #character_l
14C 36123       1221                             CALL    send_to_uart
14D 00F61       1222                             LD      uart_data, #character_a
14E 36123       1223                             CALL    send_to_uart
14F 00F7A       1224                             LD      uart_data, #character_z
150 36123       1225                             CALL    send_to_uart
151 00F65       1226                             LD      uart_data, #character_e
152 36123       1227                             CALL    send_to_uart
153 36157       1228                             CALL    send_space
154 00F4C       1229                             LD      uart_data, #_character_l
155 36123       1230                             CALL    send_to_uart
156 00F6F       1231                             LD      uart_data, #character_o
157 36123       1232                             CALL    send_to_uart
158 00F77       1233                             LD      uart_data, #character_w
159 36123       1234                             CALL    send_to_uart
15A 36157       1235                             CALL    send_space
15B 00F43       1236                             LD      uart_data, #_character_c
15C 36123       1237                             CALL    send_to_uart
15D 00F6F       1238                             LD      uart_data, #character_o
15E 36123       1239                             CALL    send_to_uart
15F 00F73       1240                             LD      uart_data, #character_s
160 36123       1241                             CALL    send_to_uart
161 00F74       1242                             LD      uart_data, #character_t
162 36123       1243                             CALL    send_to_uart
163 36157       1244                             CALL    send_space
164 00F44       1245                             LD      uart_data, #_character_d
165 36123       1246                             CALL    send_to_uart
166 00F65       1247                             LD      uart_data, #character_e
167 36123       1248                             CALL    send_to_uart
168 00F73       1249                             LD      uart_data, #character_s
169 36123       1250                             CALL    send_to_uart
16A 00F69       1251                             LD      uart_data, #character_i
16B 36123       1252                             CALL    send_to_uart
16C 00F67       1253                             LD      uart_data, #character_g
16D 36123       1254                             CALL    send_to_uart
16E 00F6E       1255                             LD      uart_data, #character_n
16F 36123       1256                             CALL    send_to_uart
170 36157       1257                             CALL    send_space
171 00F53       1258                             LD      uart_data, #_character_s
172 36123       1259                             CALL    send_to_uart
173 00F65       1260                             LD      uart_data, #character_e
174 36123       1261                             CALL    send_to_uart
175 00F63       1262                             LD      uart_data, #character_c
176 36123       1263                             CALL    send_to_uart
177 00F75       1264                             LD      uart_data, #character_u
178 36123       1265                             CALL    send_to_uart
179 00F72       1266                             LD      uart_data, #character_r
17A 36123       1267                             CALL    send_to_uart
17B 00F69       1268                             LD      uart_data, #character_i
17C 36123       1269                             CALL    send_to_uart
17D 00F74       1270                             LD      uart_data, #character_t
17E 36123       1271                             CALL    send_to_uart
17F 00F79       1272                             LD      uart_data, #character_y
180 36123       1273                             CALL    send_to_uart
181 36157       1274                             CALL    send_space
182 00F76       1275                             LD      uart_data, #character_v
183 36123       1276                             CALL    send_to_uart
184 00F31       1277                             LD      uart_data, #character_1
185 36123       1278                             CALL    send_to_uart
186 00F2E       1279                             LD      uart_data, #character_fullstop
187 36123       1280                             CALL    send_to_uart
188 00F30       1281                             LD      uart_data, #character_0
189 36123       1282                             CALL    send_to_uart
18A 00F30       1283                             LD      uart_data, #character_0
18B 36123       1284                             CALL    send_to_uart
18C 36154       1285                             CALL    send_cr
18D 36154       1286                             CALL    send_cr
18E 24000       1287                             RET
                1288     ;
                1289     ;
                1290     ;
                1291     ;Send 'Copyright Ken Chapman 2006' string to the UART
                1292     ;
                1293     ;This message is significant because it demonstrates that the design
                1294     ;now has a 'watermark'. The ASCII codes for this string will be
                1295     ;stored in the design configuration bit stream somewhere as well as
                1296     ;being played out by the UART. If someone tries to change or delete
                1297     ;this message the contents of the BRAM will change and the hardware
                1298     ;check of the BRAM contents will fail to match the expected value and
                1299     ;the design will again be disabled.
                1300     ;
18F 00F43       1301     send_copyright:         LD      uart_data, #_character_c
190 36123       1302                             CALL    send_to_uart
191 00F6F       1303                             LD      uart_data, #character_o
192 36123       1304                             CALL    send_to_uart
193 00F70       1305                             LD      uart_data, #character_p
194 36123       1306                             CALL    send_to_uart
195 00F79       1307                             LD      uart_data, #character_y
196 36123       1308                             CALL    send_to_uart
197 00F72       1309                             LD      uart_data, #character_r
198 36123       1310                             CALL    send_to_uart
199 00F69       1311                             LD      uart_data, #character_i
19A 36123       1312                             CALL    send_to_uart
19B 00F67       1313                             LD      uart_data, #character_g
19C 36123       1314                             CALL    send_to_uart
19D 00F68       1315                             LD      uart_data, #character_h
19E 36123       1316                             CALL    send_to_uart
19F 00F74       1317                             LD      uart_data, #character_t
1A0 36123       1318                             CALL    send_to_uart
1A1 36157       1319                             CALL    send_space
1A2 00F4B       1320                             LD      uart_data, #_character_k
1A3 36123       1321                             CALL    send_to_uart
1A4 00F65       1322                             LD      uart_data, #character_e
1A5 36123       1323                             CALL    send_to_uart
1A6 00F6E       1324                             LD      uart_data, #character_n
1A7 36123       1325                             CALL    send_to_uart
1A8 36157       1326                             CALL    send_space
1A9 00F43       1327                             LD      uart_data, #_character_c
1AA 36123       1328                             CALL    send_to_uart
1AB 00F68       1329                             LD      uart_data, #character_h
1AC 36123       1330                             CALL    send_to_uart
1AD 00F61       1331                             LD      uart_data, #character_a
1AE 36123       1332                             CALL    send_to_uart
1AF 00F70       1333                             LD      uart_data, #character_p
1B0 36123       1334                             CALL    send_to_uart
1B1 00F6D       1335                             LD      uart_data, #character_m
1B2 36123       1336                             CALL    send_to_uart
1B3 00F61       1337                             LD      uart_data, #character_a
1B4 36123       1338                             CALL    send_to_uart
1B5 00F6E       1339                             LD      uart_data, #character_n
1B6 36123       1340                             CALL    send_to_uart
1B7 36157       1341                             CALL    send_space
1B8 00F32       1342                             LD      uart_data, #character_2
1B9 36123       1343                             CALL    send_to_uart
1BA 00F30       1344                             LD      uart_data, #character_0
1BB 36123       1345                             CALL    send_to_uart
1BC 36123       1346                             CALL    send_to_uart
1BD 00F36       1347                             LD      uart_data, #character_6
1BE 36123       1348                             CALL    send_to_uart
1BF 36154       1349                             CALL    send_cr
1C0 36154       1350                             CALL    send_cr
1C1 24000       1351                             RET
                1352     ;
                1353     ;
                1354     ;
                1355     ;Send 'FLASH ' string to the UART
                1356     ;
1C2 00F46       1357     send_flash:             LD      uart_data, #_character_f
1C3 36123       1358                             CALL    send_to_uart
1C4 00F4C       1359                             LD      uart_data, #_character_l
1C5 36123       1360                             CALL    send_to_uart
1C6 00F41       1361                             LD      uart_data, #_character_a
1C7 36123       1362                             CALL    send_to_uart
1C8 00F53       1363                             LD      uart_data, #_character_s
1C9 36123       1364                             CALL    send_to_uart
1CA 00F48       1365                             LD      uart_data, #_character_h
1CB 36123       1366                             CALL    send_to_uart
1CC 24000       1367                             RET
                1368     ;
                1369     ;
                1370     ;
                1371     ;Send 'FLASH Serial Number = ' string to the UART
                1372     ;
1CD 361E7       1373     send_flash_serial_number: CALL  send_flash
1CE 36157       1374                             CALL    send_space
1CF 00F53       1375                             LD      uart_data, #_character_s
1D0 36123       1376                             CALL    send_to_uart
1D1 00F65       1377                             LD      uart_data, #character_e
1D2 36123       1378                             CALL    send_to_uart
1D3 00F72       1379                             LD      uart_data, #character_r
1D4 36123       1380                             CALL    send_to_uart
1D5 00F69       1381                             LD      uart_data, #character_i
1D6 36123       1382                             CALL    send_to_uart
1D7 00F61       1383                             LD      uart_data, #character_a
1D8 36123       1384                             CALL    send_to_uart
1D9 00F6C       1385                             LD      uart_data, #character_l
1DA 36123       1386                             CALL    send_to_uart
1DB 36157       1387                             CALL    send_space
1DC 00F4E       1388                             LD      uart_data, #_character_n
1DD 36123       1389                             CALL    send_to_uart
1DE 00F75       1390                             LD      uart_data, #character_u
1DF 36123       1391                             CALL    send_to_uart
1E0 00F6D       1392                             LD      uart_data, #character_m
1E1 36123       1393                             CALL    send_to_uart
1E2 00F62       1394                             LD      uart_data, #character_b
1E3 36123       1395                             CALL    send_to_uart
1E4 00F65       1396                             LD      uart_data, #character_e
1E5 36123       1397                             CALL    send_to_uart
1E6 00F72       1398                             LD      uart_data, #character_r
1E7 36123       1399                             CALL    send_to_uart
1E8 3615A       1400                             CALL    send_equals
1E9 24000       1401                             RET
                1402     ;
                1403     ;
                1404     ;Send 'Auth' string to the UART
                1405     ;
1EA 00F41       1406     send_auth:              LD      uart_data, #_character_a
1EB 36123       1407                             CALL    send_to_uart
1EC 00F75       1408                             LD      uart_data, #character_u
1ED 36123       1409                             CALL    send_to_uart
1EE 00F74       1410                             LD      uart_data, #character_t
1EF 36123       1411                             CALL    send_to_uart
1F0 00F68       1412                             LD      uart_data, #character_h
1F1 36123       1413                             CALL    send_to_uart
1F2 24000       1414                             RET
                1415     ;
                1416     ;Send 'Authoris' to the UART
                1417     ;
1F3 3620F       1418     send_authoris:          CALL    send_auth
1F4 00F6F       1419                             LD      uart_data, #character_o
1F5 36123       1420                             CALL    send_to_uart
1F6 00F72       1421                             LD      uart_data, #character_r
1F7 36123       1422                             CALL    send_to_uart
1F8 00F69       1423                             LD      uart_data, #character_i
1F9 36123       1424                             CALL    send_to_uart
1FA 00F73       1425                             LD      uart_data, #character_s
1FB 36123       1426                             CALL    send_to_uart
1FC 24000       1427                             RET
                1428     ;
                1429     ;Send 'Authorisation' to the UART
                1430     ;
1FD 36218       1431     send_authorisation:     CALL    send_authoris
1FE 00F61       1432                             LD      uart_data, #character_a
1FF 36123       1433                             CALL    send_to_uart
200 00F74       1434                             LD      uart_data, #character_t
201 36123       1435                             CALL    send_to_uart
202 00F69       1436                             LD      uart_data, #character_i
203 36123       1437                             CALL    send_to_uart
204 00F6F       1438                             LD      uart_data, #character_o
205 36123       1439                             CALL    send_to_uart
206 00F6E       1440                             LD      uart_data, #character_n
207 36123       1441                             CALL    send_to_uart
208 24000       1442                             RET
                1443     ;
                1444     ;Send 'Authorise' to the UART
                1445     ;
209 36218       1446     send_authorise:         CALL    send_authoris
20A 00F65       1447                             LD      uart_data, #character_e
20B 36123       1448                             CALL    send_to_uart
20C 24000       1449                             RET
                1450     ;
                1451     ;Send 'Authentication' string to the UART
                1452     ;
20D 3620F       1453     send_authentication:    CALL    send_auth
20E 00F65       1454                             LD      uart_data, #character_e
20F 36123       1455                             CALL    send_to_uart
210 00F6E       1456                             LD      uart_data, #character_n
211 36123       1457                             CALL    send_to_uart
212 00F74       1458                             LD      uart_data, #character_t
213 36123       1459                             CALL    send_to_uart
214 00F69       1460                             LD      uart_data, #character_i
215 36123       1461                             CALL    send_to_uart
216 00F63       1462                             LD      uart_data, #character_c
217 36123       1463                             CALL    send_to_uart
218 00F61       1464                             LD      uart_data, #character_a
219 36123       1465                             CALL    send_to_uart
21A 00F74       1466                             LD      uart_data, #character_t
21B 36123       1467                             CALL    send_to_uart
21C 00F69       1468                             LD      uart_data, #character_i
21D 36123       1469                             CALL    send_to_uart
21E 00F6F       1470                             LD      uart_data, #character_o
21F 36123       1471                             CALL    send_to_uart
220 00F6E       1472                             LD      uart_data, #character_n
221 36123       1473                             CALL    send_to_uart
222 24000       1474                             RET
                1475     ;
                1476     ;
                1477     ;Send 'FLASH CRC = ' string to the UART
                1478     ;
223 361E7       1479     send_flash_crc:         CALL    send_flash
                1480     ;
                1481     ;
                1482     ;Send ' CRC = ' string to the UART
                1483     ;
224 36157       1484     send_crc:               CALL    send_space
225 00F43       1485                             LD      uart_data, #_character_c
226 36123       1486                             CALL    send_to_uart
227 00F52       1487                             LD      uart_data, #_character_r
228 36123       1488                             CALL    send_to_uart
229 00F43       1489                             LD      uart_data, #_character_c
22A 36123       1490                             CALL    send_to_uart
22B 3615A       1491                             CALL    send_equals
22C 24000       1492                             RET
                1493     ;
                1494     ;
                1495     ;
                1496     ;Send 'Computed CRC = ' string to the UART
                1497     ;
22D 00F43       1498     send_computed_crc:      LD      uart_data, #_character_c
22E 36123       1499                             CALL    send_to_uart
22F 00F6F       1500                             LD      uart_data, #character_o
230 36123       1501                             CALL    send_to_uart
231 00F6D       1502                             LD      uart_data, #character_m
232 36123       1503                             CALL    send_to_uart
233 00F70       1504                             LD      uart_data, #character_p
234 36123       1505                             CALL    send_to_uart
235 00F75       1506                             LD      uart_data, #character_u
236 36123       1507                             CALL    send_to_uart
237 00F74       1508                             LD      uart_data, #character_t
238 36123       1509                             CALL    send_to_uart
239 00F65       1510                             LD      uart_data, #character_e
23A 36123       1511                             CALL    send_to_uart
23B 00F64       1512                             LD      uart_data, #character_d
23C 36123       1513                             CALL    send_to_uart
23D 34249       1514                             JUMP    send_crc
                1515     ;
                1516     ;
                1517     ;Send 'Erase ' string to the UART
                1518     ;
23E 00F45       1519     send_erase:             LD      uart_data, #_character_e
23F 36123       1520                             CALL    send_to_uart
240 00F72       1521                             LD      uart_data, #character_r
241 36123       1522                             CALL    send_to_uart
242 00F61       1523                             LD      uart_data, #character_a
243 36123       1524                             CALL    send_to_uart
244 00F73       1525                             LD      uart_data, #character_s
245 36123       1526                             CALL    send_to_uart
246 00F65       1527                             LD      uart_data, #character_e
247 36123       1528                             CALL    send_to_uart
248 36157       1529                             CALL    send_space
249 24000       1530                             RET
                1531     ;
                1532     ;
                1533     ;Send 'Erase Authorisation in progress' string to the UART
                1534     ;
24A 36154       1535     send_erase_in_progress: CALL    send_cr
24B 36263       1536                             CALL    send_erase
24C 36222       1537                             CALL    send_authorisation
24D 36157       1538                             CALL    send_space
24E 00F69       1539                             LD      uart_data, #character_i
24F 36123       1540                             CALL    send_to_uart
250 00F6E       1541                             LD      uart_data, #character_n
251 36123       1542                             CALL    send_to_uart
252 36157       1543                             CALL    send_space
253 00F50       1544                             LD      uart_data, #_character_p
254 36123       1545                             CALL    send_to_uart
255 00F72       1546                             LD      uart_data, #character_r
256 36123       1547                             CALL    send_to_uart
257 00F6F       1548                             LD      uart_data, #character_o
258 36123       1549                             CALL    send_to_uart
259 00F67       1550                             LD      uart_data, #character_g
25A 36123       1551                             CALL    send_to_uart
25B 00F72       1552                             LD      uart_data, #character_r
25C 36123       1553                             CALL    send_to_uart
25D 00F65       1554                             LD      uart_data, #character_e
25E 36123       1555                             CALL    send_to_uart
25F 00F73       1556                             LD      uart_data, #character_s
260 36123       1557                             CALL    send_to_uart
261 36123       1558                             CALL    send_to_uart
262 36154       1559                             CALL    send_cr
263 24000       1560                             RET
                1561     ;
                1562     ;
                1563     ;Send 'OK' to the UART
                1564     ;
264 00F4F       1565     send_ok:                LD      uart_data, #_character_o
265 36123       1566                             CALL    send_to_uart
266 00F4B       1567                             LD      uart_data, #_character_k
267 36123       1568                             CALL    send_to_uart
268 36154       1569                             CALL    send_cr
269 24000       1570                             RET
                1571     ;
                1572     ;
                1573     ;Send ' FAILED' to the UART
                1574     ;
26A 36157       1575     send_failed:            CALL    send_space
26B 00F46       1576                             LD      uart_data, #_character_f
26C 36123       1577                             CALL    send_to_uart
26D 00F41       1578                             LD      uart_data, #_character_a
26E 36123       1579                             CALL    send_to_uart
26F 00F49       1580                             LD      uart_data, #_character_i
270 36123       1581                             CALL    send_to_uart
271 00F4C       1582                             LD      uart_data, #_character_l
272 36123       1583                             CALL    send_to_uart
273 00F45       1584                             LD      uart_data, #_character_e
274 36123       1585                             CALL    send_to_uart
275 00F44       1586                             LD      uart_data, #_character_d
276 36123       1587                             CALL    send_to_uart
277 24000       1588                             RET
                1589     ;
                1590     ;
                1591     ;Send ' PASSED' to the UART
                1592     ;
278 36157       1593     send_passed:            CALL    send_space
279 00F50       1594                             LD      uart_data, #_character_p
27A 36123       1595                             CALL    send_to_uart
27B 00F41       1596                             LD      uart_data, #_character_a
27C 36123       1597                             CALL    send_to_uart
27D 00F53       1598                             LD      uart_data, #_character_s
27E 36123       1599                             CALL    send_to_uart
27F 36123       1600                             CALL    send_to_uart
280 00F45       1601                             LD      uart_data, #_character_e
281 36123       1602                             CALL    send_to_uart
282 00F44       1603                             LD      uart_data, #_character_d
283 36123       1604                             CALL    send_to_uart
284 24000       1605                             RET
                1606     ;
                1607     ;
                1608     ;
                1609     ;Send 'Writing Authorisation' to the UART
                1610     ;
285 36154       1611     send_writing:           CALL    send_cr
286 00F57       1612                             LD      uart_data, #_character_w
287 36123       1613                             CALL    send_to_uart
288 00F72       1614                             LD      uart_data, #character_r
289 36123       1615                             CALL    send_to_uart
28A 00F69       1616                             LD      uart_data, #character_i
28B 36123       1617                             CALL    send_to_uart
28C 00F74       1618                             LD      uart_data, #character_t
28D 36123       1619                             CALL    send_to_uart
28E 00F69       1620                             LD      uart_data, #character_i
28F 36123       1621                             CALL    send_to_uart
290 00F6E       1622                             LD      uart_data, #character_n
291 36123       1623                             CALL    send_to_uart
292 00F67       1624                             LD      uart_data, #character_g
293 36123       1625                             CALL    send_to_uart
294 36157       1626                             CALL    send_space
295 36222       1627                             CALL    send_authorisation
296 24000       1628                             RET
                1629     ;
                1630     ;Send simple menu of options to the UART
                1631     ;
                1632     ;
297 36154       1633     send_menu:              CALL    send_cr
298 36154       1634                             CALL    send_cr
299 00F4D       1635                             LD      uart_data, #_character_m
29A 36123       1636                             CALL    send_to_uart
29B 00F65       1637                             LD      uart_data, #character_e
29C 36123       1638                             CALL    send_to_uart
29D 00F6E       1639                             LD      uart_data, #character_n
29E 36123       1640                             CALL    send_to_uart
29F 00F75       1641                             LD      uart_data, #character_u
2A0 36123       1642                             CALL    send_to_uart
2A1 36154       1643                             CALL    send_cr
2A2 36154       1644                             CALL    send_cr
2A3 00F52       1645                             LD      uart_data, #_character_r
2A4 36123       1646                             CALL    send_to_uart
2A5 3615F       1647                             CALL    send_dash
2A6 00F52       1648                             LD      uart_data, #_character_r
2A7 36123       1649                             CALL    send_to_uart
2A8 00F65       1650                             LD      uart_data, #character_e
2A9 36123       1651                             CALL    send_to_uart
2AA 00F61       1652                             LD      uart_data, #character_a
2AB 36123       1653                             CALL    send_to_uart
2AC 00F64       1654                             LD      uart_data, #character_d
2AD 36123       1655                             CALL    send_to_uart
2AE 36157       1656                             CALL    send_space
2AF 36222       1657                             CALL    send_authorisation
2B0 36154       1658                             CALL    send_cr
2B1 00F45       1659                             LD      uart_data, #_character_e
2B2 36123       1660                             CALL    send_to_uart
2B3 3615F       1661                             CALL    send_dash
2B4 36263       1662                             CALL    send_erase
2B5 36222       1663                             CALL    send_authorisation
2B6 36154       1664                             CALL    send_cr
2B7 00F41       1665                             LD      uart_data, #_character_a
2B8 36123       1666                             CALL    send_to_uart
2B9 3615F       1667                             CALL    send_dash
2BA 3622E       1668                             CALL    send_authorise
2BB 36154       1669                             CALL    send_cr
2BC 36154       1670                             CALL    send_cr
2BD 00F3E       1671                             LD      uart_data, #character_greater_than ;prompt for input
2BE 36123       1672                             CALL    send_to_uart
2BF 24000       1673                             RET
                1674     ;
                1675     ;**************************************************************************************
                1676     ;LCD Character Module Routines
                1677     ;**************************************************************************************
                1678     ;
                1679     ;LCD module is a 16 character by 2 line display but all displays are very similar
                1680     ;The 4-wire data interface will be used (DB4 to DB7).
                1681     ;
                1682     ;The LCD modules are relatively slow and software delay loops are used to slow down
                1683     ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
                1684     ;a different section (see above in this case).
                1685     ;
                1686     ;
                1687     ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
                1688     ;
                1689     ;Register s4 should define the current state of the LCD output port.
                1690     ;
                1691     ;Registers used s0, s4
                1692     ;
2C0 06401       1693     lcd_pulse_e:            XOR     s4, #lcd_e              ;E=1
2C1 22420       1694                             OUT     s4, lcd_output_port
2C2 36348       1695                             CALL    delay_1us
2C3 06401       1696                             XOR     s4, #lcd_e              ;E=0
2C4 22420       1697                             OUT     s4, lcd_output_port
2C5 24000       1698                             RET
                1699     ;
                1700     ;Write 4-bit instruction to LCD display.
                1701     ;
                1702     ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
                1703     ;Note that this routine does not release the master enable but as it is only
                1704     ;used during initialisation and as part of the 8-bit instruction write it
                1705     ;should be acceptable.
                1706     ;
                1707     ;Registers used s4
                1708     ;
2C6 024F8       1709     lcd_write_inst4:        AND     s4, #0xf8               ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
2C7 22420       1710                             OUT     s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
2C8 362E5       1711                             CALL    lcd_pulse_e
2C9 24000       1712                             RET
                1713     ;
                1714     ;
                1715     ;Write 8-bit instruction to LCD display.
                1716     ;
                1717     ;The 8-bit instruction should be provided in register s5.
                1718     ;Instructions are written using the following sequence
                1719     ; Upper nibble
                1720     ; wait >1us
                1721     ; Lower nibble
                1722     ; wait >40us
                1723     ;
                1724     ;Registers used s0, s1, s4, s5
                1725     ;
2CA 10428       1726     lcd_write_inst8:        LD      s4, s5
2CB 024F0       1727                             AND     s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
2CC 04408       1728                             OR      s4, #lcd_drive          ;Enable=1
2CD 362EB       1729                             CALL    lcd_write_inst4         ;write upper nibble
2CE 36348       1730                             CALL    delay_1us               ;wait >1us
2CF 10428       1731                             LD      s4, s5                  ;select lower nibble with
2D0 28407       1732                             SL1     s4                      ;Enable=1
2D1 28406       1733                             SL0     s4                      ;RS=0 Instruction
2D2 28406       1734                             SL0     s4                      ;RW=0 Write
2D3 28406       1735                             SL0     s4                      ;E=0
2D4 362EB       1736                             CALL    lcd_write_inst4         ;write lower nibble
2D5 3634C       1737                             CALL    delay_40us              ;wait >40us
2D6 004F0       1738                             LD      s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
2D7 22420       1739                             OUT     s4, lcd_output_port     ;Release master enable
2D8 24000       1740                             RET
                1741     ;
                1742     ;
                1743     ;
                1744     ;Write 8-bit data to LCD display.
                1745     ;
                1746     ;The 8-bit data should be provided in register s5.
                1747     ;Data bytes are written using the following sequence
                1748     ; Upper nibble
                1749     ; wait >1us
                1750     ; Lower nibble
                1751     ; wait >40us
                1752     ;
                1753     ;Registers used s0, s1, s4, s5
                1754     ;
2D9 10428       1755     lcd_write_data:         LD      s4, s5
2DA 024F0       1756                             AND     s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
2DB 0440C       1757                             OR      s4, #0x0c               ;Enable=1 RS=1 Data, RW=0 Write, E=0
2DC 22420       1758                             OUT     s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
2DD 362E5       1759                             CALL    lcd_pulse_e             ;write upper nibble
2DE 36348       1760                             CALL    delay_1us               ;wait >1us
2DF 10428       1761                             LD      s4, s5                  ;select lower nibble with
2E0 28407       1762                             SL1     s4                      ;Enable=1
2E1 28407       1763                             SL1     s4                      ;RS=1 Data
2E2 28406       1764                             SL0     s4                      ;RW=0 Write
2E3 28406       1765                             SL0     s4                      ;E=0
2E4 22420       1766                             OUT     s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
2E5 362E5       1767                             CALL    lcd_pulse_e             ;write lower nibble
2E6 3634C       1768                             CALL    delay_40us              ;wait >40us
2E7 004F0       1769                             LD      s4, #0xf0               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
2E8 22420       1770                             OUT     s4, lcd_output_port     ;Release master enable
2E9 24000       1771                             RET
                1772     ;
                1773     ;
                1774     ;
                1775     ;
                1776     ;Read 8-bit data from LCD display.
                1777     ;
                1778     ;The 8-bit data will be read from the current LCD memory address
                1779     ;and will be returned in register s5.
                1780     ;It is advisable to set the LCD address (cursor position) before
                1781     ;using the data read for the first time otherwise the display may
                1782     ;generate invalid data on the first read.
                1783     ;
                1784     ;Data bytes are read using the following sequence
                1785     ; Upper nibble
                1786     ; wait >1us
                1787     ; Lower nibble
                1788     ; wait >40us
                1789     ;
                1790     ;Registers used s0, s1, s4, s5
                1791     ;
2EA 0040E       1792     lcd_read_data8:         LD      s4, #0x0e               ;Enable=1 RS=1 Data, RW=1 Read, E=0
2EB 22420       1793                             OUT     s4, lcd_output_port     ;set up RS and RW >40ns before enable pulse
2EC 06401       1794                             XOR     s4, #lcd_e              ;E=1
2ED 22420       1795                             OUT     s4, lcd_output_port
2EE 36348       1796                             CALL    delay_1us               ;wait >260ns to access data
2EF 20503       1797                             IN      s5, lcd_input_port      ;read upper nibble
2F0 06401       1798                             XOR     s4, #lcd_e              ;E=0
2F1 22420       1799                             OUT     s4, lcd_output_port
2F2 36348       1800                             CALL    delay_1us               ;wait >1us
2F3 06401       1801                             XOR     s4, #lcd_e              ;E=1
2F4 22420       1802                             OUT     s4, lcd_output_port
2F5 36348       1803                             CALL    delay_1us               ;wait >260ns to access data
2F6 20003       1804                             IN      s0, lcd_input_port      ;read lower nibble
2F7 06401       1805                             XOR     s4, #lcd_e              ;E=0
2F8 22420       1806                             OUT     s4, lcd_output_port
2F9 025F0       1807                             AND     s5, #0xf0               ;merge upper and lower nibbles
2FA 2800E       1808                             SR0     s0
2FB 2800E       1809                             SR0     s0
2FC 2800E       1810                             SR0     s0
2FD 2800E       1811                             SR0     s0
2FE 14500       1812                             OR      s5, s0
2FF 00404       1813                             LD      s4, #0x04               ;Enable=0 RS=1 Data, RW=0 Write, E=0
300 22420       1814                             OUT     s4, lcd_output_port     ;Stop reading 5V device and release master enable
301 3634C       1815                             CALL    delay_40us              ;wait >40us
302 24000       1816                             RET
                1817     ;
                1818     ;
                1819     ;Reset and initialise display to communicate using 4-bit data mode
                1820     ;Includes routine to clear the display.
                1821     ;
                1822     ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
                1823     ;following by the 8-bit instructions to set up the display.
                1824     ;
                1825     ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
                1826     ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
                1827     ;  0C = '00001' Display control, '1' display on, '0' cursor off, '0' cursor blink off
                1828     ;  01 = '00000001' Display clear
                1829     ;
                1830     ;Registers used s0, s1, s2, s3, s4
                1831     ;
303 36356       1832     lcd_reset:              CALL    delay_20ms              ;wait more that 15ms for display to be ready
304 00430       1833                             LD      s4, #0x30
305 362EB       1834                             CALL    lcd_write_inst4         ;send '3'
306 36356       1835                             CALL    delay_20ms              ;wait >4.1ms
307 362EB       1836                             CALL    lcd_write_inst4         ;send '3'
308 36351       1837                             CALL    delay_1ms               ;wait >100us
309 362EB       1838                             CALL    lcd_write_inst4         ;send '3'
30A 3634C       1839                             CALL    delay_40us              ;wait >40us
30B 00420       1840                             LD      s4, #0x20
30C 362EB       1841                             CALL    lcd_write_inst4         ;send '2'
30D 3634C       1842                             CALL    delay_40us              ;wait >40us
30E 00528       1843                             LD      s5, #0x28               ;Function set
30F 362EF       1844                             CALL    lcd_write_inst8
310 00506       1845                             LD      s5, #0x06               ;Entry mode
311 362EF       1846                             CALL    lcd_write_inst8
312 0050C       1847                             LD      s5, #0x0c               ;Display control
313 362EF       1848                             CALL    lcd_write_inst8
314 00501       1849     lcd_clear:              LD      s5, #0x01               ;Display clear
315 362EF       1850                             CALL    lcd_write_inst8
316 36351       1851                             CALL    delay_1ms               ;wait >1.64ms for display to clear
317 36351       1852                             CALL    delay_1ms
318 24000       1853                             RET
                1854     ;
                1855     ;Position the cursor ready for characters to be written.
                1856     ;The display is formed of 2 lines of 16 characters and each
                1857     ;position has a corresponding address as indicated below.
                1858     ;
                1859     ;                   Character position
                1860     ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
                1861     ;
                1862     ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
                1863     ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
                1864     ;
                1865     ;This routine will set the cursor position using the value provided
                1866     ;in register s5. The upper nibble will define the line and the lower
                1867     ;nibble the character position on the line.
                1868     ; Example s5 = 2B will position the cursor on line 2 position 11
                1869     ;
                1870     ;Registers used s0, s1, s2, s3, s4
                1871     ;
  0033E         1872     lcd_cursor:             TEST    s5, #0x10               ;test for line 1
E: instruction not supported on the this device: TEST sX, kk.
319 35344       1873                             JUMP    z, set_line2
31A 0250F       1874                             AND     s5, #0x0f               ;make address in range 80 to 8F for line 1
31B 04580       1875                             OR      s5, #0x80
31C 362EF       1876                             CALL    lcd_write_inst8         ;instruction write to set cursor
31D 24000       1877                             RET
31E 0250F       1878     set_line2:              AND     s5, #0x0f               ;make address in range C0 to CF for line 2
31F 045C0       1879                             OR      s5, #0xc0
320 362EF       1880                             CALL    lcd_write_inst8         ;instruction write to set cursor
321 24000       1881                             RET
                1882     ;
                1883     ;**************************************************************************************
                1884     ;Software delay routines
                1885     ;**************************************************************************************
                1886     ;
                1887     ;
                1888     ;
                1889     ;Delay of 1us.
                1890     ;
                1891     ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1892     ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1893     ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1894     ;
                1895     ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1896     ;
                1897     ;Registers used s0
                1898     ;
322 0000B       1899     delay_1us:              LD      s0, #delay_1us_constant
323 0C001       1900     wait_1us:               SUB     s0, #0x01
324 35749       1901                             JUMP    nz, wait_1us
325 24000       1902                             RET
                1903     ;
                1904     ;Delay of 40us.
                1905     ;
                1906     ;Registers used s0, s1
                1907     ;
326 00128       1908     delay_40us:             LD      s1, #0x28               ;40 x 1us = 40us
327 36348       1909     wait_40us:              CALL    delay_1us
328 0C101       1910                             SUB     s1, #0x01
329 3574D       1911                             JUMP    nz, wait_40us
32A 24000       1912                             RET
                1913     ;
                1914     ;
                1915     ;Delay of 1ms.
                1916     ;
                1917     ;Registers used s0, s1, s2
                1918     ;
32B 00219       1919     delay_1ms:              LD      s2, #0x19               ;25 x 40us = 1ms
32C 3634C       1920     wait_1ms:               CALL    delay_40us
32D 0C201       1921                             SUB     s2, #0x01
32E 35752       1922                             JUMP    nz, wait_1ms
32F 24000       1923                             RET
                1924     ;
                1925     ;Delay of 20ms.
                1926     ;
                1927     ;Delay of 20ms used during initialisation.
                1928     ;
                1929     ;Registers used s0, s1, s2, s3
                1930     ;
330 00314       1931     delay_20ms:             LD      s3, #0x14               ;20 x 1ms = 20ms
331 36351       1932     wait_20ms:              CALL    delay_1ms
332 0C301       1933                             SUB     s3, #0x01
333 35757       1934                             JUMP    nz, wait_20ms
334 24000       1935                             RET
                1936     ;
                1937     ;Delay of approximately 1 second.
                1938     ;
                1939     ;Registers used s0, s1, s2, s3, s4
                1940     ;
335 00432       1941     delay_1s:               LD      s4, #0x32               ;50 x 20ms = 1000ms
336 36356       1942     wait_1s:                CALL    delay_20ms
337 0C401       1943                             SUB     s4, #0x01
338 3575C       1944                             JUMP    nz, wait_1s
339 24000       1945                             RET
                1946     ;
                1947     ;
                1948     ;Delay of approximately N seconds where 'N' is provided in register s5.
                1949     ;
                1950     ;Registers used s0, s1, s2, s3, s4, s5
                1951     ;
33A 3635B       1952     delay_ns:               CALL    delay_1s
33B 0C501       1953                             SUB     s5, #0x01
33C 35760       1954                             JUMP    nz, delay_ns
33D 24000       1955                             RET
                1956     ;
                1957     ;
                1958     ;
                1959     ;**************************************************************************************
                1960     ;LCD text messages
                1961     ;**************************************************************************************
                1962     ;
                1963     ;
                1964     ;
                1965     ;Display 'PicoBlaze' on LCD at current cursor position
                1966     ;
                1967     ;
33E 00550       1968     disp_picoblaze:         LD      s5, #_character_p
33F 362FE       1969                             CALL    lcd_write_data
340 00569       1970                             LD      s5, #character_i
341 362FE       1971                             CALL    lcd_write_data
342 00563       1972                             LD      s5, #character_c
343 362FE       1973                             CALL    lcd_write_data
344 0056F       1974                             LD      s5, #character_o
345 362FE       1975                             CALL    lcd_write_data
346 00542       1976                             LD      s5, #_character_b
347 362FE       1977                             CALL    lcd_write_data
348 0056C       1978                             LD      s5, #character_l
349 362FE       1979                             CALL    lcd_write_data
34A 00561       1980                             LD      s5, #character_a
34B 362FE       1981                             CALL    lcd_write_data
34C 0057A       1982                             LD      s5, #character_z
34D 362FE       1983                             CALL    lcd_write_data
34E 00565       1984                             LD      s5, #character_e
34F 362FE       1985                             CALL    lcd_write_data
350 24000       1986                             RET
                1987     ;
                1988     ;
                1989     ;Display 'Security' on LCD at current cursor position
                1990     ;
                1991     ;
351 00553       1992     disp_security:          LD      s5, #_character_s
352 362FE       1993                             CALL    lcd_write_data
353 00565       1994                             LD      s5, #character_e
354 362FE       1995                             CALL    lcd_write_data
355 00563       1996                             LD      s5, #character_c
356 362FE       1997                             CALL    lcd_write_data
357 00575       1998                             LD      s5, #character_u
358 362FE       1999                             CALL    lcd_write_data
359 00572       2000                             LD      s5, #character_r
35A 362FE       2001                             CALL    lcd_write_data
35B 00569       2002                             LD      s5, #character_i
35C 362FE       2003                             CALL    lcd_write_data
35D 00574       2004                             LD      s5, #character_t
35E 362FE       2005                             CALL    lcd_write_data
35F 00579       2006                             LD      s5, #character_y
360 362FE       2007                             CALL    lcd_write_data
361 24000       2008                             RET
                2009     ;
                2010     ;
                2011     ;Display 'FLASH Serial No.' on LCD at current cursor position
                2012     ;
                2013     ;
362 00546       2014     disp_flash_serial_no:   LD      s5, #_character_f
363 362FE       2015                             CALL    lcd_write_data
364 0054C       2016                             LD      s5, #_character_l
365 362FE       2017                             CALL    lcd_write_data
366 00541       2018                             LD      s5, #_character_a
367 362FE       2019                             CALL    lcd_write_data
368 00553       2020                             LD      s5, #_character_s
369 362FE       2021                             CALL    lcd_write_data
36A 00548       2022                             LD      s5, #_character_h
36B 362FE       2023                             CALL    lcd_write_data
36C 00520       2024                             LD      s5, #character_space
36D 362FE       2025                             CALL    lcd_write_data
36E 00553       2026                             LD      s5, #_character_s
36F 362FE       2027                             CALL    lcd_write_data
370 00565       2028                             LD      s5, #character_e
371 362FE       2029                             CALL    lcd_write_data
372 00572       2030                             LD      s5, #character_r
373 362FE       2031                             CALL    lcd_write_data
374 00569       2032                             LD      s5, #character_i
375 362FE       2033                             CALL    lcd_write_data
376 00561       2034                             LD      s5, #character_a
377 362FE       2035                             CALL    lcd_write_data
378 0056C       2036                             LD      s5, #character_l
379 362FE       2037                             CALL    lcd_write_data
37A 00520       2038                             LD      s5, #character_space
37B 362FE       2039                             CALL    lcd_write_data
37C 0054E       2040                             LD      s5, #_character_n
37D 362FE       2041                             CALL    lcd_write_data
37E 0056F       2042                             LD      s5, #character_o
37F 362FE       2043                             CALL    lcd_write_data
380 0052E       2044                             LD      s5, #character_fullstop
381 362FE       2045                             CALL    lcd_write_data
382 24000       2046                             RET
                2047     ;
                2048     ;
                2049     ;
                2050     ;Display 'Authentication' on top line of the LCD
                2051     ;
                2052     ;
383 00511       2053     disp_authentication:    LD      s5, #0x11               ;Line 1 position 1
384 3633E       2054                             CALL    lcd_cursor
385 00541       2055                             LD      s5, #_character_a
386 362FE       2056                             CALL    lcd_write_data
387 00575       2057                             LD      s5, #character_u
388 362FE       2058                             CALL    lcd_write_data
389 00574       2059                             LD      s5, #character_t
38A 362FE       2060                             CALL    lcd_write_data
38B 00568       2061                             LD      s5, #character_h
38C 362FE       2062                             CALL    lcd_write_data
38D 00565       2063                             LD      s5, #character_e
38E 362FE       2064                             CALL    lcd_write_data
38F 0056E       2065                             LD      s5, #character_n
390 362FE       2066                             CALL    lcd_write_data
391 00574       2067                             LD      s5, #character_t
392 362FE       2068                             CALL    lcd_write_data
393 00569       2069                             LD      s5, #character_i
394 362FE       2070                             CALL    lcd_write_data
395 00563       2071                             LD      s5, #character_c
396 362FE       2072                             CALL    lcd_write_data
397 00561       2073                             LD      s5, #character_a
398 362FE       2074                             CALL    lcd_write_data
399 00574       2075                             LD      s5, #character_t
39A 362FE       2076                             CALL    lcd_write_data
39B 00569       2077                             LD      s5, #character_i
39C 362FE       2078                             CALL    lcd_write_data
39D 0056F       2079                             LD      s5, #character_o
39E 362FE       2080                             CALL    lcd_write_data
39F 0056E       2081                             LD      s5, #character_n
3A0 362FE       2082                             CALL    lcd_write_data
3A1 24000       2083                             RET
                2084     ;
                2085     ;
                2086     ;
                2087     ;
                2088     ;Display 'Passed' on lower line of the LCD
                2089     ;
                2090     ;
3A2 00525       2091     disp_passed:            LD      s5, #0x25               ;Line 2 position 5
3A3 3633E       2092                             CALL    lcd_cursor
3A4 00550       2093                             LD      s5, #_character_p
3A5 362FE       2094                             CALL    lcd_write_data
3A6 00561       2095                             LD      s5, #character_a
3A7 362FE       2096                             CALL    lcd_write_data
3A8 00573       2097                             LD      s5, #character_s
3A9 362FE       2098                             CALL    lcd_write_data
3AA 362FE       2099                             CALL    lcd_write_data
3AB 00565       2100                             LD      s5, #character_e
3AC 362FE       2101                             CALL    lcd_write_data
3AD 00564       2102                             LD      s5, #character_d
3AE 362FE       2103                             CALL    lcd_write_data
3AF 24000       2104                             RET
                2105     ;
                2106     ;
                2107     ;
                2108     ;
                2109     ;
                2110     ;Display 'Failed' on lower line of the LCD
                2111     ;
                2112     ;
3B0 00525       2113     disp_failed:            LD      s5, #0x25               ;Line 2 position 5
3B1 3633E       2114                             CALL    lcd_cursor
3B2 00546       2115                             LD      s5, #_character_f
3B3 362FE       2116                             CALL    lcd_write_data
3B4 00561       2117                             LD      s5, #character_a
3B5 362FE       2118                             CALL    lcd_write_data
3B6 00569       2119                             LD      s5, #character_i
3B7 362FE       2120                             CALL    lcd_write_data
3B8 0056C       2121                             LD      s5, #character_l
3B9 362FE       2122                             CALL    lcd_write_data
3BA 00565       2123                             LD      s5, #character_e
3BB 362FE       2124                             CALL    lcd_write_data
3BC 00564       2125                             LD      s5, #character_d
3BD 362FE       2126                             CALL    lcd_write_data
3BE 24000       2127                             RET
                2128     ;
                2129     ;
                2130     ;**************************************************************************************
                2131     ; Interrupt Service Routine (ISR)
                2132     ;**************************************************************************************
                2133     ;
                2134     ; Interrupts occur when the application processor is requesting a design authorisation
                2135     ; message. Therefore an interrupt results in a message being sent to the Link FIFO
                2136     ; depending on the authentication status.
                2137     ;
  003E5         2138     isr:                    ST      s0, isr_preserve_s0     ;save register contents
E: instruction not supported on the this device: STORE sX, ss.
                2139     ;
                2140                             FT      s0, authentication_status ;read authentication status
E: instruction not supported on the this device: FETCH sX, ss.
                2141                             CMP     s0, #_character_p       ;test for pass 'P' or fail 'F'
E: instruction not supported on the this device: COMPARE sX, kk.
3BF 353F2       2142                             JUMP    z, pass_token
                2143     ;
3C0 00046       2144                             LD      s0, #_character_f       ;send FAIL to link FIFO
3C1 22004       2145                             OUT     s0, link_fifo_write_port
3C2 00041       2146                             LD      s0, #_character_a
3C3 22004       2147                             OUT     s0, link_fifo_write_port
3C4 00049       2148                             LD      s0, #_character_i
3C5 22004       2149                             OUT     s0, link_fifo_write_port
3C6 0004C       2150                             LD      s0, #_character_l
3C7 22004       2151                             OUT     s0, link_fifo_write_port
3C8 343F8       2152                             JUMP    end_isr
                2153     ;
3C9 22004       2154     pass_token:             OUT     s0, link_fifo_write_port ;send PASS to link FIFO
3CA 00041       2155                             LD      s0, #_character_a
3CB 22004       2156                             OUT     s0, link_fifo_write_port
3CC 00053       2157                             LD      s0, #_character_s
3CD 22004       2158                             OUT     s0, link_fifo_write_port
3CE 22004       2159                             OUT     s0, link_fifo_write_port
                2160     ;
  003F8         2161     end_isr:                FT      s0, isr_preserve_s0     ;restore register contents
E: instruction not supported on the this device: FETCH sX, ss.
3CF 2C001       2162                             RETIE
                2163     ;
                2164     ;
                2165     ;**************************************************************************************
                2166     ; Interrupt Vector
                2167     ;**************************************************************************************
                2168     ;
  003FF         2169                             ORG     0x3ff
3FF 343E5       2170                             JUMP    isr
                2171     ;
                2172     ;
                2173     ;**************************************************************************************
                2174     ; End of Program
                2175     ;**************************************************************************************
                2176
