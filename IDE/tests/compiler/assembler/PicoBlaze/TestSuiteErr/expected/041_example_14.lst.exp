                   1                             ;KCPSM3 Program - UART programming of SPI Flash memory on Spartan-3E Starter Kit.
                   2                             ;
                   3                             ;
                   4                             ;Ken Chapman - Xilinx Ltd
                   5                             ;
                   6                             ;Version v1.00 - 11th November 2005
                   7                             ;
                   8                             ;This program uses a 115200 baud UART connection with XON/XOFF flow control
                   9                             ;to allow a standard MCS file for the configuration of a Spartan-3E device to
                  10                             ;be programmed into the ST Microelectronics M25P16 device on the board.
                  11                             ;
                  12                             ;
                  13                             ;
                  14                             ;As well as the port connections vital to communication with the UART and the SPI
                  15                             ;FLASH memory, there are additional port connections used to disable the other
                  16                             ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
                  17                             ;controlled at the hardware level, they are included in this code to aid
                  18                             ;future investigations of communication with the other SPI devices using PicoBlaze.
                  19                             ;
                  20                             ;
                  21                             ;
                  22                             ;
                  23                             ;Port definitions
                  24                             ;
                  25                             CONSTANT status_port, 00               ;UART and filter status input
                  26                             CONSTANT tx_data_present, 01           ;  Transmitter  data present - bit0
                  27                             CONSTANT tx_half_full, 02              ;    FIFO          half full - bit1
                  28                             CONSTANT tx_full, 04                   ;                       full - bit2
                  29                             CONSTANT rx_data_present, 08           ;               data present - bit3
                  30                             CONSTANT rx_half_full, 10              ;  Receiver        half full - bit4
                  31                             CONSTANT rx_full, 20                   ;    FIFO               full - bit5
                  32                             ;
                  33                             CONSTANT UART_read_port, 01            ;UART Rx data input
                  34                             ;
                  35                             CONSTANT UART_write_port, 10           ;UART Tx data output
                  36                             ;
                  37                             ;
                  38                             CONSTANT SPI_control_port, 08          ;SPI clock and chip selects
                  39                             CONSTANT SPI_sck, 01                   ;                  SCK - bit0
                  40                             CONSTANT SPI_rom_cs, 02                ;    serial rom select - bit1
                  41                             CONSTANT SPI_spare_control, 04         ;                spare - bit2
                  42                             CONSTANT SPI_amp_cs, 08                ;     amplifier select - bit3
                  43                             CONSTANT SPI_adc_conv, 10              ;          A/D convert - bit4
                  44                             CONSTANT SPI_dac_cs, 20                ;           D/A select - bit5
                  45                             CONSTANT SPI_amp_shdn, 40              ;       amplifier SHDN - bit6
                  46                             CONSTANT SPI_dac_clr, 80               ;            D/A clear - bit7
                  47                             ;
                  48                             CONSTANT SPI_output_port, 04           ;SPI data output
                  49                             CONSTANT SPI_sdo, 80                   ;   SDO - bit7
                  50                             ;
                  51                             CONSTANT SPI_input_port, 02            ;SPI data input
                  52                             CONSTANT SPI_sdi, 80                   ;             SDI - bit7
                  53                             CONSTANT SPI_amp_sdi, 40               ;   amplifier SDI - bit6
                  54                             ;
                  55                             ;
                  56                             ;
                  57                             ;
                  58                             ;Special Register usage
                  59                             ;
                  60                             NAMEREG sF, UART_data                  ;used to pass data to and from the UART
                  61                             ;
                  62                             ;
                  63                             ;Useful data constants
                  64                             ;
                  65                             ;
                  66                             ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                  67                             ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                  68                             ;calculation highly predictable. The '6' in the following equation even allows for
                  69                             ;'CALL delay_1us' instruction in the initiating code.
                  70                             ;
                  71                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                  72                             ;
                  73                             ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                  74                             ;For clock rates below 10MHz the value of 1 must be used and the operation will
                  75                             ;become lower than intended.
                  76                             ;
                  77                             CONSTANT delay_1us_constant, 0B
                  78                             ;
                  79                             ;
                  80                             ;Useful constants
                  81                             ;
                  82                             ;
                  83                             ;ASCII table
                  84                             ;
                  85                             CONSTANT character_a, 61
                  86                             CONSTANT character_b, 62
                  87                             CONSTANT character_c, 63
                  88                             CONSTANT character_d, 64
                  89                             CONSTANT character_e, 65
                  90                             CONSTANT character_f, 66
                  91                             CONSTANT character_g, 67
                  92                             CONSTANT character_h, 68
                  93                             CONSTANT character_i, 69
                  94                             CONSTANT character_j, 6A
E: identifier cannot start with a digit: `6A'.
E: unexpected end of line.
                  95                             CONSTANT character_k, 6B
E: identifier cannot start with a digit: `6B'.
E: unexpected end of line.
                  96                             CONSTANT character_l, 6C
E: identifier cannot start with a digit: `6C'.
E: unexpected end of line.
                  97                             CONSTANT character_m, 6D
                  98                             CONSTANT character_n, 6E
E: identifier cannot start with a digit: `6E'.
E: unexpected end of line.
                  99                             CONSTANT character_o, 6F
E: identifier cannot start with a digit: `6F'.
E: unexpected end of line.
                 100                             CONSTANT character_p, 70
                 101                             CONSTANT character_q, 71
                 102                             CONSTANT character_r, 72
                 103                             CONSTANT character_s, 73
                 104                             CONSTANT character_t, 74
                 105                             CONSTANT character_u, 75
                 106                             CONSTANT character_v, 76
                 107                             CONSTANT character_w, 77
                 108                             CONSTANT character_x, 78
                 109                             CONSTANT character_y, 79
                 110                             CONSTANT character_z, 7A
E: identifier cannot start with a digit: `7A'.
E: unexpected end of line.
                 111                             CONSTANT character_A, 41
                 112                             CONSTANT character_B, 42
                 113                             CONSTANT character_C, 43
                 114                             CONSTANT character_D, 44
                 115                             CONSTANT character_E, 45
                 116                             CONSTANT character_F, 46
                 117                             CONSTANT character_G, 47
                 118                             CONSTANT character_H, 48
                 119                             CONSTANT character_I, 49
                 120                             CONSTANT character_J, 4A
E: identifier cannot start with a digit: `4A'.
E: unexpected end of line.
                 121                             CONSTANT character_K, 4B
E: identifier cannot start with a digit: `4B'.
E: unexpected end of line.
                 122                             CONSTANT character_L, 4C
E: identifier cannot start with a digit: `4C'.
E: unexpected end of line.
                 123                             CONSTANT character_M, 4D
                 124                             CONSTANT character_N, 4E
E: identifier cannot start with a digit: `4E'.
E: unexpected end of line.
                 125                             CONSTANT character_O, 4F
E: identifier cannot start with a digit: `4F'.
E: unexpected end of line.
                 126                             CONSTANT character_P, 50
                 127                             CONSTANT character_Q, 51
                 128                             CONSTANT character_R, 52
                 129                             CONSTANT character_S, 53
                 130                             CONSTANT character_T, 54
                 131                             CONSTANT character_U, 55
                 132                             CONSTANT character_V, 56
                 133                             CONSTANT character_W, 57
                 134                             CONSTANT character_X, 58
                 135                             CONSTANT character_Y, 59
                 136                             CONSTANT character_Z, 5A
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
                 137                             CONSTANT character_0, 30
                 138                             CONSTANT character_1, 31
                 139                             CONSTANT character_2, 32
                 140                             CONSTANT character_3, 33
                 141                             CONSTANT character_4, 34
                 142                             CONSTANT character_5, 35
                 143                             CONSTANT character_6, 36
                 144                             CONSTANT character_7, 37
                 145                             CONSTANT character_8, 38
                 146                             CONSTANT character_9, 39
                 147                             CONSTANT character_colon, 3A
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                 148                             CONSTANT character_fullstop, 2E
E: identifier cannot start with a digit: `2E'.
E: unexpected end of line.
                 149                             CONSTANT character_semi_colon, 3B
E: identifier cannot start with a digit: `3B'.
E: unexpected end of line.
                 150                             CONSTANT character_minus, 2D
                 151                             CONSTANT character_plus, 2B
E: identifier cannot start with a digit: `2B'.
E: unexpected end of line.
                 152                             CONSTANT character_comma, 2C
E: identifier cannot start with a digit: `2C'.
E: unexpected end of line.
                 153                             CONSTANT character_less_than, 3C       ;'<'
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
                 154                             CONSTANT character_greater_than, 3E    ;'>'
E: identifier cannot start with a digit: `3E'.
E: unexpected end of line.
                 155                             CONSTANT character_open, 28            ;'('
                 156                             CONSTANT character_close, 29           ;')'
                 157                             CONSTANT character_divide, 2F          ;'/'
E: identifier cannot start with a digit: `2F'.
E: unexpected end of line.
                 158                             CONSTANT character_equals, 3D
                 159                             CONSTANT character_space, 20
                 160                             CONSTANT character_CR, 0D              ;carriage return
                 161                             CONSTANT character_LF, 0A              ;line feed
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 162                             CONSTANT character_question, 3F        ;'?'
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
                 163                             CONSTANT character_dollar, 24
                 164                             CONSTANT character_exclaim, 21         ;'!'
                 165                             CONSTANT character_BS, 08              ;Back Space command character
                 166                             CONSTANT character_XON, 11             ;Flow control ON
                 167                             CONSTANT character_XOFF, 13            ;Flow control OFF
                 168                             ;
                 169                             ;
                 170                             ;Scratch Pad Memory Locations
                 171                             ;
                 172                             ;
                 173                             CONSTANT ISR_preserve_s0, 00           ;preserve register during ISR
                 174                             ;
                 175                             CONSTANT page_address_h, 01            ;Remember page address for SPI boundary checking.
                 176                             CONSTANT page_address_m, 02            ;high, middle and low bytes
                 177                             CONSTANT page_address_l, 03
                 178                             ;
                 179                             CONSTANT SPI_control_status, 04        ;SPI status signals
                 180                             ;
                 181                             ;
                 182                             ;
                 183                             ;Store up to one line of an MCS file as bytes
                 184                             ;A typical data line consists of:-
                 185                             ;:     Start character which is not stored
                 186                             ;10    Number of data bytes included (16 in this case)
                 187                             ;aaaa  Lower 16-bits of the storage address
                 188                             ;00    Record type (data in this case)
                 189                             ;dddd...   Data bytes (typically 16 which is the maximum)
                 190                             ;cc    Checksum
                 191                             ;CR/LF Line will end in carriage return and/or line feed which is not stored.
                 192                             ;
                 193                             ;So a total of 21 could be stored before processing.
                 194                             ;
                 195                             CONSTANT line_start, 2B                ;21 bytes until end of memory
E: identifier cannot start with a digit: `2B'.
E: unexpected end of line.
                 196                             ;
                 197                             ;
                 198                             ;Initialise the system and welcome message
                 199                             ;
                 200                             ;
                 201                 cold_start: CALL SPI_init                          ;initialise SPI bus ports
                 202                             CALL delay_1s                          ;delay because UART is fast and JTAG startup sequence can be slow
                 203                             ENABLE INTERRUPT                       ;Interrupt is used for XON/XOFF flow control
                 204              welcome_start: CALL send_CR
                 205                             CALL send_welcome                      ;start up message and version number
                 206                             ;
                 207                             ;Main menu and command selection
                 208                             ;
                 209                             ;
                 210                             ;
                 211                 warm_start: CALL send_Menu                         ;Menu and command selection
                 212                     prompt: CALL send_CR
                 213                             CALL send_CR
                 214                             LOAD UART_data, character_greater_than ;prompt for input
                 215                             CALL send_to_UART
                 216                             CALL read_upper_case
                 217                             COMPARE s0, character_E                ;command test
                 218                             JUMP Z, erase_command
                 219                             COMPARE s0, character_S                ;command test
                 220                             JUMP Z, sector_erase_command
                 221                             COMPARE s0, character_P                ;command test
                 222                             JUMP Z, program_command
                 223                             COMPARE s0, character_R                ;command test
                 224                             JUMP Z, read_command
                 225                             COMPARE s0, character_I                ;command test
                 226                             JUMP Z, ID_command
                 227                             COMPARE s0, character_H                ;command test
                 228                             JUMP Z, welcome_start
                 229                             CALL send_CR                           ;no valid command input
                 230                             LOAD UART_data, character_question     ;display ???
                 231                             CALL send_to_UART
                 232                             CALL send_to_UART
                 233                             CALL send_to_UART
                 234                             JUMP prompt                            ;Try again!
                 235                             ;
                 236                             ;
                 237            read_upper_case: CALL read_from_UART                    ;read command character from UART
                 238                             CALL send_to_UART                      ;echo character
                 239                             LOAD s0, UART_data                     ;convert to upper case
                 240                             CALL upper_case
                 241                             RETURN
                 242                             ;
                 243                             ;**************************************************************************************
                 244                             ;ID Command - Read and display the ID for the SPI FLASH memory
                 245                             ;**************************************************************************************
                 246                             ;
                 247                             ;Normal response should be
                 248                             ;   s9 = Manufacturer Identification = 20 hex
                 249                             ;   s8 = Memory Type = 20 hex
                 250                             ;   s7 = Memory Capacity = 15 hex
                 251                             ;
                 252                 ID_command: CALL send_CR
                 253                             CALL read_spi_flash_ID
                 254                             CALL send_ID
                 255                             LOAD UART_data, character_equals
                 256                             CALL send_to_UART
                 257                             CALL send_space
                 258                             LOAD s0, s9
                 259                             CALL send_hex_byte
                 260                             CALL send_space
                 261                             LOAD s0, s8
                 262                             CALL send_hex_byte
                 263                             CALL send_space
                 264                             LOAD s0, s7
                 265                             CALL send_hex_byte
                 266                             CALL send_space
                 267                             CALL send_CR
                 268                             JUMP prompt
                 269                             ;
                 270                             ;**************************************************************************************
                 271                             ;Erase Command - Perform bulk erase of the SPI FLASH memory and display messages
                 272                             ;**************************************************************************************
                 273                             ;
                 274              erase_command: CALL send_CR
                 275                             CALL send_Confirm                      ;confirm command with a 'Y' which must be upper case
                 276                             CALL read_from_UART                    ;read command character from UART
                 277                             CALL send_to_UART                      ;echo input
                 278                             COMPARE UART_data, character_Y
                 279                             JUMP NZ, abort_erase
                 280                             CALL send_CR
                 281                             CALL send_Erase_in_progress
                 282                             CALL bulk_erase_spi
                 283                             CALL send_OK
                 284                             JUMP prompt
                 285                             ;
                 286                abort_erase: CALL send_Abort
                 287                             JUMP prompt
                 288                             ;
                 289                             ;
                 290                             ;**************************************************************************************
                 291                             ;Sector Erase Command - Performs erase of lowest 5 sectors SPI FLASH memory which
                 292                             ;covers the address range 000000 to 04FFFF in which the configuration for an XC3S500E
                 293                             ;would be able to fit.
                 294                             ;**************************************************************************************
                 295                             ;
                 296       sector_erase_command: CALL send_CR
                 297                             CALL send_Confirm                      ;confirm command with a 'Y' which must be upper case
                 298                             CALL read_from_UART                    ;read command character from UART
                 299                             CALL send_to_UART                      ;echo input
                 300                             COMPARE UART_data, character_Y
                 301                             JUMP NZ, abort_erase
                 302                             CALL send_CR
                 303                             CALL send_Erase_in_progress
                 304                             LOAD s9, 00                            ;any address inside sector 0
                 305                             CALL erase_spi_sector
                 306                             LOAD s9, 01                            ;any address inside sector 1
                 307                             CALL erase_spi_sector
                 308                             LOAD s9, 02                            ;any address inside sector 2
                 309                             CALL erase_spi_sector
                 310                             LOAD s9, 03                            ;any address inside sector 3
                 311                             CALL erase_spi_sector
                 312                             LOAD s9, 04                            ;any address inside sector 4
                 313                             CALL erase_spi_sector
                 314                             CALL send_OK
                 315                             JUMP prompt
                 316                             ;
                 317                             ;
                 318                             ;**************************************************************************************
                 319                             ;Program Command - Program SPI FLASH memory with MCS file
                 320                             ;**************************************************************************************
                 321                             ;
                 322            program_command: CALL send_CR
                 323                             CALL send_Waiting_MCS_file
                 324                             CALL program_MCS
                 325                             CALL send_OK
                 326                             JUMP prompt
                 327                             ;
                 328                             ;
                 329                             ;**************************************************************************************
                 330                             ;Read Command - Read one page of memory at specified address
                 331                             ;**************************************************************************************
                 332                             ;
                 333               read_command: CALL send_page_address                 ;obtain 24-bit address
                 334                             CALL obtain_8bits
                 335                             JUMP C, read_command                   ;bad input address
                 336                             COMPARE s0, 20                         ;test for address greater than 1FFFFF
                 337                             JUMP NC, read_command                  ;value too big
                 338                             LOAD s9, s0
                 339                             CALL obtain_8bits
                 340                             JUMP C, read_command                   ;bad input address
                 341                             LOAD s8, s0
                 342                             CALL obtain_8bits
                 343                             JUMP C, read_command                   ;bad input address
                 344                             LOAD s7, s0
                 345                             CALL send_CR
                 346                             CALL send_spi_page
                 347                             CALL send_OK
                 348                             JUMP prompt
                 349               obtain_8bits: CALL read_upper_case                   ;obtain one byte from UART
                 350                             LOAD s3, s0
                 351                             CALL read_upper_case
                 352                             LOAD s2, s0
                 353                             CALL ASCII_byte_to_hex
                 354                             RETURN
                 355                             ;
                 356                             ;
                 357                             ;
                 358                             ;**************************************************************************************
                 359                             ;Program SPI FLASH with MCS file
                 360                             ;**************************************************************************************
                 361                             ;
                 362                             ;Reads the MCS file from the UART and programs the SPI FLASH device at the locations.
                 363                             ;specified by the file contents.
                 364                             ;
                 365                             ;One important factor of programming the SPI FLASH for use as configuration
                 366                             ;memory is that the bits within each byte must be in reverse order. This
                 367                             ;is because an SPI device outputs data MSB first compared with a Xilinx
                 368                             ;serial PROM which outputs LSB first. Therefore this routine will swap
                 369                             ;the bits of each byte provided by the MCS file before programming.
                 370                             ;
                 371                             ;This routine will continue until an end of file record is detected.
                 372                             ;For each line of MCS received, the current address will be output so that
                 373                             ;progress can be monitored.
                 374                             ;
                 375                             ;Register sA is used to remember if a page is currently open (01) or closed (00)
                 376                             ;for writing on the SPI memory.
                 377                             ;
                 378                program_MCS: LOAD sA, 00                            ;page is closed
                 379             next_prog_line: CALL read_MCS_line                     ;read line
                 380                             CALL MCS_address                       ;find start address and record type
                 381                             COMPARE sB, 01                         ;test for end record
                 382                             JUMP Z, end_program_MCS
                 383                             CALL send_hex_3bytes                   ;send address for other lines
                 384                             CALL send_CR
                 385                             COMPARE sB, 04                         ;test for extended address record
                 386                             JUMP Z, MCS_address_boundary
                 387                             ;
                 388                             ;Assume data record type 00 now and program SPI page
                 389                             ;
                 390                             SUB sE, 01                             ;location of checksum just after last stored data byte
                 391                             LOAD sD, line_start                    ;Point to first data byte
                 392                             ADD sD, 04
                 393                             COMPARE sA, 00                         ;check if page is closed
                 394                             JUMP Z, program_byte                   ;jump if page needs to be opened
                 395                             FETCH s2, page_address_h               ;check new address is sequential
                 396                             COMPARE s2, s9
                 397                             JUMP NZ, addr_out_of_sequence
                 398                             FETCH s2, page_address_m               ;check new address is sequential
                 399                             COMPARE s2, s8
                 400                             JUMP NZ, addr_out_of_sequence
                 401                             FETCH s2, page_address_l               ;check new address is sequential
                 402                             COMPARE s2, s7
                 403                             JUMP Z, program_byte                   ;continue with open page
                 404       addr_out_of_sequence: CALL close_prog_page_spi               ;close page because address out of sequence
                 405                             LOAD sA, 00                            ;page is now closed
                 406               program_byte: COMPARE sA, 00                         ;check if page is closed
                 407                             JUMP NZ, page_is_open                  ;jump is page already open
                 408                             CALL open_prog_page_spi                ;open page with address [s9,s8,s7]
                 409                             LOAD sA, 01                            ;page is open
                 410               page_is_open: FETCH s1, (sD)                         ;fetch data byte
                 411                             LOAD s0, 08                            ;reverse order of bits
                 412                  swap_bits: SR0 s1
                 413                             SLA s2
                 414                             SUB s0, 01
                 415                             JUMP NZ, swap_bits                     ;swapped bits now in s2
                 416                             CALL SPI_FLASH_tx_rx                   ;program byte into SPI memory
                 417                             ADD s7, 01                             ;increment address to keep track
                 418                             ADDCY s8, 00
                 419                             ADDCY s9, 00
                 420                             COMPARE s7, 00                         ;test if crossing page boundary FF to 00
                 421                             JUMP NZ, byte_programmed
                 422                             CALL close_prog_page_spi
                 423                             LOAD sA, 00                            ;page is now closed
                 424            byte_programmed: ADD sD, 01                             ;move to next byte
                 425                             COMPARE sD, sE                         ;check for last on line
                 426                             JUMP NZ, program_byte                  ;fetch next byte to program
                 427                             STORE s9, page_address_h               ;remember next address in sequence
                 428                             STORE s8, page_address_m
                 429                             STORE s7, page_address_l
                 430                             JUMP next_prog_line                    ;read next line for programming
                 431       MCS_address_boundary: COMPARE sA, 00                         ;check if page needs to be closed
                 432                             JUMP Z, next_prog_line
                 433                             CALL close_prog_page_spi
                 434                             JUMP program_MCS
                 435            end_program_MCS: COMPARE sA, 00                         ;check if page needs to be closed
                 436                             RETURN Z
                 437                             CALL close_prog_page_spi
                 438                             RETURN
                 439                             ;
                 440                             ;**************************************************************************************
                 441                             ;Read one line of an MCS file into scratch pad memory
                 442                             ;**************************************************************************************
                 443                             ;
                 444                             ;Reads one line of MCS file format into scratch pad memory starting at location 'line_start'.
                 445                             ;
                 446                             ;The routine detects the line start character ':' ignoring any preceding characters. This
                 447                             ;will remove any additional CR or LF characters.
                 448                             ;
                 449                             ;It then reads each subsequent pair of ASCII characters, converts them to true hex in the
                 450                             ;range 00 to FF and stores them in scratch pad memory.
                 451                             ;
                 452                             ;The end of the line is determined by either a CR or LF character.
                 453                             ;
                 454                             ;The value last returned in register 'sE' will be the pointer to the location in
                 455                             ;scratch pad memory following the last byte for the line read.
                 456                             ;
                 457              read_MCS_line: LOAD sE, line_start                    ;initialise SPM memory pointer
                 458        wait_MCS_line_Start: CALL read_from_UART                    ;read character
                 459                             COMPARE UART_data, character_colon     ;test for start character
                 460                             JUMP NZ, wait_MCS_line_Start
                 461              read_MCS_byte: CALL read_from_UART                    ;read character
                 462                             COMPARE UART_data, character_CR        ;test for end of line
                 463                             RETURN Z
                 464                             COMPARE UART_data, character_LF        ;test for end of line
                 465                             RETURN Z
                 466                             LOAD s3, UART_data                     ;upper nibble character
                 467                             CALL read_from_UART                    ;read character
                 468                             LOAD s2, UART_data                     ;lower nibble character
                 469                             CALL ASCII_byte_to_hex                 ;convert to true hex value
                 470                             STORE s0, (sE)                         ;write to SPM
                 471                             ADD sE, 01                             ;increment pointer
                 472                             JUMP read_MCS_byte
                 473                             ;
                 474                             ;
                 475                             ;**************************************************************************************
                 476                             ;Determine the current address for the line of an MCS file in scratch pad memory
                 477                             ;**************************************************************************************
                 478                             ;
                 479                             ;Checks the existing line data stored in scratch pad memory starting at location
                 480                             ;'line_start' and determines the current address.
                 481                             ;
                 482                             ;The address is in the register set [s9,s8,s7] before and after this routine is
                 483                             ;executed because not all address bits are defined by a given line of MCS and
                 484                             ;the undefined bits remain constant.
                 485                             ;
                 486                             ;A record type of 04 will update [s9].
                 487                             ;A record type of 00 will update [s8,s7].
                 488                             ;
                 489                             ;On return, the register sB will contain the record type and
                 490                             ;register sC will indicate the number of data bytes stored.
                 491                             ;
                 492                MCS_address: LOAD sD, line_start                    ;initialise SPM memory pointer
                 493                             FETCH sC, (sD)                         ;read number of bytes on line
                 494                             ADD sD, 03                             ;move to record type
                 495                             FETCH sB, (sD)                         ;read record type
                 496                             COMPARE sB, 00                         ;test for data record
                 497                             JUMP Z, new_low_address
                 498                             COMPARE sB, 04                         ;test for data record
                 499                             RETURN NZ
                 500                             ADD sD, 02                             ;read upper 8-bits
                 501                             FETCH s9, (sD)
                 502                             RETURN
                 503            new_low_address: SUB sD, 01                             ;read lower 8-bits
                 504                             FETCH s7, (sD)
                 505                             SUB sD, 01                             ;read middle 8-bits
                 506                             FETCH s8, (sD)
                 507                             RETURN
                 508                             ;
                 509                             ;**************************************************************************************
                 510                             ;Read a page from SPI FLASH memory and display
                 511                             ;**************************************************************************************
                 512                             ;
                 513                             ;The start address should be provided in register set [s9,s8,s7].
                 514                             ;The display will be next 256 bytes displayed as 16 lines of 16 bytes
                 515                             ;with each line commencing with the address of the first byte.
                 516                             ;
                 517                             ;
                 518              send_spi_page: LOAD s6, 10                            ;16 lines to display
                 519              send_spi_line: CALL send_CR
                 520                             CALL send_hex_3bytes                   ;display address
                 521                             CALL send_space
                 522                             LOAD s5, 10                            ;16 lines to display
                 523              send_spi_byte: CALL send_space
                 524                             CALL read_spi_byte                     ;read byte into s2
                 525                             ADD s7, 01                             ;increment SPI FLASH address
                 526                             ADDCY s8, 00
                 527                             ADDCY s9, 00
                 528                             LOAD s0, s2                            ;display byte
                 529                             CALL send_hex_byte
                 530                             SUB s5, 01                             ;count bytes per line
                 531                             JUMP NZ, send_spi_byte
                 532                             SUB s6, 01                             ;count lines
                 533                             JUMP NZ, send_spi_line
                 534                             CALL send_CR
                 535                             RETURN
                 536                             ;
                 537                             ;**************************************************************************************
                 538                             ;Test of SPI FLASH memory operations
                 539                             ;**************************************************************************************
                 540                             ;
                 541                             ;Sector 18 (120000 to 12FFFF) is used.
                 542                             ;A page (123400 to 1234FF) is programmed with a test pattern 00 to FF.
                 543                             ;The pattern is verified and then the sector erased and a blank check performed.
                 544                             ;
                 545                             ;Note that the page used is already blank (all locations contain FF hex)
                 546                             ;as with any device supplied (initial delivery state).
                 547                             ;
                 548                             ;Program page with test pattern
                 549                             ;
                 550                memory_test: LOAD s9, 12                            ;select page address 123400
                 551                             LOAD s8, 34
                 552                             LOAD s7, 00
                 553                             CALL open_prog_page_spi                ; program test pattern 00 to FF
                 554               pattern_loop: LOAD s2, s7
                 555                             CALL SPI_FLASH_tx_rx
                 556                             ADD s7, 01
                 557                             JUMP NC, pattern_loop
                 558                             CALL close_prog_page_spi               ; program test pattern 00 to FF
                 559                             ;
                 560                             ;Verify test pattern by reading back page
                 561                             ;
                 562                             LOAD UART_data, character_p            ;p for pass
                 563                             LOAD s9, 12                            ;select page address 123400
                 564                             LOAD s8, 34
                 565                             LOAD s7, 00
                 566           verify_test_page: CALL read_spi_byte                     ;read byte into s2
                 567                             COMPARE s2, s7                         ;check test pattern data value
                 568                             JUMP NZ, memory_verify_fail
                 569                             ADD s7, 01                             ;next location
                 570                             JUMP NZ, verify_test_page              ;loop until roll over page
                 571                             JUMP memory_verify_result
                 572         memory_verify_fail: LOAD UART_data, character_f            ;f for fail
                 573       memory_verify_result: CALL send_to_UART
                 574                             RETURN
                 575                             ;
                 576                             ;Erase sector with test pattern and verify blank
                 577                             ;
                 578          erase_test_sector: LOAD s9, 12                            ;sector 18 start address 120000
                 579                             LOAD s8, 00
                 580                             LOAD s7, 00
                 581                             CALL erase_spi_sector
                 582                             LOAD UART_data, character_p            ;p for pass
                 583                             LOAD s9, 12                            ;select page address 123400
                 584                             LOAD s8, 34
                 585                             LOAD s7, 00
                 586          verify_blank_page: CALL read_spi_byte                     ;read byte into s2
                 587                             COMPARE s2, FF                         ;check blank 'FF'
                 588                             JUMP NZ, memory_blank_fail
                 589                             ADD s7, 01                             ;next location
                 590                             JUMP NZ, verify_blank_page             ;loop until roll over page
                 591                             JUMP memory_blank_result
                 592          memory_blank_fail: LOAD UART_data, character_f            ;f for fail
                 593        memory_blank_result: CALL send_to_UART
                 594                             RETURN
                 595                             ;
                 596                             ;
                 597                             ;
                 598                             ;**************************************************************************************
                 599                             ;Test of SPI FLASH memory communications
                 600                             ;**************************************************************************************
                 601                             ;Link must be installed in J11 to link ROM-CS to CSO_B
                 602                             ;
                 603                             ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 604                             ;and compare with expected response.
                 605                             ;   s9 = Manufacturer Identification = 20 hex
                 606                             ;   s8 = Memory Type = 20 hex
                 607                             ;   s7 = Memory Capacity = 15 hex
                 608                             ;
                 609          memory_comms_test: CALL read_spi_flash_ID
                 610                             LOAD UART_data, character_p            ;p for pass
                 611                             COMPARE s9, 20
                 612                             JUMP NZ, SPI_FLASH_ID_fail
                 613                             COMPARE s8, 20
                 614                             JUMP NZ, SPI_FLASH_ID_fail
                 615                             COMPARE s7, 15
                 616                             JUMP NZ, SPI_FLASH_ID_fail
                 617                             JUMP SPI_FLASH_ID_result
                 618          SPI_FLASH_ID_fail: LOAD UART_data, character_f            ;f for fail
                 619        SPI_FLASH_ID_result: CALL send_to_UART
                 620                             RETURN
                 621                             ;
                 622                             ;
                 623                             ;
                 624                             ;
                 625                             ;
                 626                             ;
                 627                             ;**************************************************************************************
                 628                             ;SPI FLASH memory routines
                 629                             ;**************************************************************************************
                 630                             ;
                 631                             ;These routines will work with two output ports and one input port which should be
                 632                             ;defined as follows using CONSTANT directives.
                 633                             ;   (replace 'pp' with appropriate port address in each case)
                 634                             ;In the list of CONSTANT directives, only the ones marked with a * are really required
                 635                             ;in an SPI FLASH memory system. The other directives are to control (disable) or
                 636                             ;communicate with the other SPI components on the same SPI bus of the Spartan-3E Starter Kit.
                 637                             ;
                 638                             ;
                 639                             ;
                 640                             ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects     *
                 641                             ;CONSTANT SPI_sck, 01                ;                  SCK - bit0   *
                 642                             ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1   *
                 643                             ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
                 644                             ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
                 645                             ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
                 646                             ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
                 647                             ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
                 648                             ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
                 649                             ;
                 650                             ;CONSTANT SPI_output_port, pp        ;SPI data output                *
                 651                             ;CONSTANT SPI_sdo, 80                ;   SDO - bit7                  *
                 652                             ;
                 653                             ;CONSTANT SPI_input_port, pp         ;SPI data input                 *
                 654                             ;CONSTANT SPI_sdi, 80                ;             SDI - bit7        *
                 655                             ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
                 656                             ;
                 657                             ;
                 658                             ;A single scratch pad memory location is also employed to remember the status of
                 659                             ;the SPI_control_port. This memory location must be defined as follows.
                 660                             ;   (replace 'ss' with appropriate memory location)
                 661                             ;
                 662                             ;CONSTANT SPI_control_status, ss       ;SPI status signals
                 663                             ;
                 664                             ;Not all the SPI routines will use this memory location because although they
                 665                             ;will change the bits on the control port, they will leave them in the same state
                 666                             ;as they were in when they started.
                 667                             ;
                 668                             ;
                 669                             ;
                 670                             ;
                 671                             ;Initialise SPI bus
                 672                             ;
                 673                             ;This routine should be used to initialise the SPI bus.
                 674                             ;The SCK clock is made low.
                 675                             ;Device selections are made inactive as follows
                 676                             ;   SPI_sck      = 0      Clock is Low (required)
                 677                             ;   SPI_rom_cs   = 1      Deselect ROM
                 678                             ;   spare        = 1      spare control bit
                 679                             ;   SPI_amp_cs   = 1      Deselect amplifier
                 680                             ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
                 681                             ;   SPI_dac_cs   = 1      Deselect D/A
                 682                             ;   SPI_amp_shdn = 0      Amplifier active and available
                 683                             ;   SPI_dac_clr  = 1      D/A clear off
                 684                             ;
                 685                   SPI_init: LOAD s0, AE                            ;normally AE
                 686                             OUTPUT s0, SPI_control_port
                 687                             STORE s0, SPI_control_status           ;preserve status
                 688                             RETURN
                 689                             ;
                 690                             ;
                 691                             ;Send and receive one byte to or from the SPI FLASH memory.
                 692                             ;
                 693                             ;The data supplied in register 's2' is transmitted to the SPI bus and
                 694                             ;at the same time any received byte is used to replace the value in 's2'.
                 695                             ;The SCK clock is generated by software and results in a communication rate of
                 696                             ;2.5Mbit/s with a 50MHz clock.
                 697                             ;
                 698                             ;Note that you must have previously selected the required device on the bus
                 699                             ;before attempting communication and you must subsequently deselect the device
                 700                             ;when appropriate.
                 701                             ;
                 702                             ;Entry to this routine assumes that SCK is already Low and the clock will be Low
                 703                             ;at the end of execution (provided in scratch pad memory location SPI_control_status).
                 704                             ;
                 705                             ;As a 'master' the signal sequence is as follows..
                 706                             ;   Receive data bit from SDI line (Flash transmits on previous falling edge)
                 707                             ;   Transmit data bit on SDO line
                 708                             ;   Drive SCK transition from low to high
                 709                             ;   Drive SCK transition from high to low.
                 710                             ;
                 711            SPI_FLASH_tx_rx: LOAD s1, 08                            ;8-bits to transmit and receive
                 712                             FETCH s0, SPI_control_status           ;read control status bits
                 713         next_SPI_FLASH_bit: OUTPUT s2, SPI_output_port             ;output data bit ready to be used on rising edge
                 714                             INPUT s3, SPI_input_port               ;read input bit
                 715                             TEST s3, SPI_sdi                       ;detect state of received bit
                 716                             SLA s2                                 ;shift new data into result and move to next transmit bit
                 717                             XOR s0, SPI_sck                        ;clock High (bit0)
                 718                             OUTPUT s0, SPI_control_port            ;drive clock High
                 719                             XOR s0, SPI_sck                        ;clock Low (bit0)
                 720                             OUTPUT s0, SPI_control_port            ;drive clock Low
                 721                             SUB s1, 01                             ;count bits
                 722                             JUMP NZ, next_SPI_FLASH_bit            ;repeat until finished
                 723                             RETURN
                 724                             ;
                 725                             ;
                 726                             ;Read status register from SPI FLASH memory (ST type M25P16)
                 727                             ;
                 728                             ;Transmits instruction 05hex and then receives one byte in response
                 729                             ;which is returned in register s2.
                 730                             ;
                 731                             ; bit    meaning
                 732                             ;  7    SRWD Status Register Write Protect
                 733                             ;  6    '0'
                 734                             ;  5    '0'
                 735                             ;  4    BP2 Block protect bit
                 736                             ;  3    BP1 Block protect bit
                 737                             ;  2    BP0 Block protect bit
                 738                             ;  1    WEL Write Enable Latch Bit
                 739                             ;  0    WIP Write In Progress
                 740                             ;
                 741                             ;
                 742      read_spi_flash_status: CALL SPI_init                          ;ensure known state of bus and s0 register
                 743                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 744                             OUTPUT s0, SPI_control_port
                 745                             STORE s0, SPI_control_status           ;preserve status
                 746                             LOAD s2, 05                            ;Read Status register instruction
                 747                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 748                             CALL SPI_FLASH_tx_rx                   ;Receive status register information
                 749                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 750                             OUTPUT s0, SPI_control_port
                 751                             STORE s0, SPI_control_status           ;preserve status
                 752                             RETURN
                 753                             ;
                 754                             ;Set write enable mode in SPI FLASH memory (ST type M25P16)
                 755                             ;
                 756                             ;Transmits instruction 06hex.
                 757                             ;
                 758         set_spi_flash_WREN: CALL SPI_init                          ;ensure known state of bus and s0 register
                 759                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 760                             OUTPUT s0, SPI_control_port
                 761                             STORE s0, SPI_control_status           ;preserve status
                 762                             LOAD s2, 06                            ;Set write enable mode instruction
                 763                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 764                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 765                             OUTPUT s0, SPI_control_port
                 766                             STORE s0, SPI_control_status           ;preserve status
                 767                             RETURN
                 768                             ;
                 769                             ;Reset the write enable mode in SPI FLASH memory (ST type M25P16)
                 770                             ;
                 771                             ;Transmits instruction 04hex.
                 772                             ;
                 773       reset_spi_flash_WREN: CALL SPI_init                          ;ensure known state of bus and s0 register
                 774                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 775                             OUTPUT s0, SPI_control_port
                 776                             STORE s0, SPI_control_status           ;preserve status
                 777                             LOAD s2, 04                            ;Reset write enable mode instruction
                 778                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 779                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 780                             OUTPUT s0, SPI_control_port
                 781                             STORE s0, SPI_control_status           ;preserve status
                 782                             RETURN
                 783                             ;
                 784                             ;Read the identification ID from SPI FLASH memory (ST type M25P16)
                 785                             ;
                 786                             ;Transmits instruction 9Fhex and then reads the 3 byte response into [s9,s8,s7]
                 787                             ;
                 788                             ;response should be
                 789                             ;   s9 = Manufacturer Identification = 20 hex
                 790                             ;   s8 = Memory Type = 20 hex
                 791                             ;   s7 = Memory Capacity = 15 hex
                 792                             ;
                 793          read_spi_flash_ID: CALL SPI_init                          ;ensure known state of bus and s0 register
                 794                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 795                             OUTPUT s0, SPI_control_port
                 796                             STORE s0, SPI_control_status           ;preserve status
                 797                             LOAD s2, 9F                            ;Read ID instruction
E: identifier cannot start with a digit: `9F'.
E: unexpected end of line.
                 798                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 799                             CALL SPI_FLASH_tx_rx                   ;receive Manufacturer ID
                 800                             LOAD s9, s2
                 801                             CALL SPI_FLASH_tx_rx                   ;receive Memory Type
                 802                             LOAD s8, s2
                 803                             CALL SPI_FLASH_tx_rx                   ;receive Memory Capacity
                 804                             LOAD s7, s2
                 805                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 806                             OUTPUT s0, SPI_control_port
                 807                             STORE s0, SPI_control_status           ;preserve status
                 808                             RETURN
                 809                             ;
                 810                             ;Read a single byte from the SPI FLASH memory (ST type M25P16)
                 811                             ;
                 812                             ;Transmits instruction 03hex followed by a 24-bit address which must be supplied in the
                 813                             ;register set [s9,s8,s7]. It then transmits a dummy byte to retrieve the memory data
                 814                             ;which is returned in register s2.
                 815                             ;
                 816              read_spi_byte: CALL SPI_init                          ;ensure known state of bus and s0 register
                 817                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 818                             OUTPUT s0, SPI_control_port
                 819                             STORE s0, SPI_control_status           ;preserve status
                 820                             LOAD s2, 03                            ;Read Data Bytes instruction
                 821                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 822                             LOAD s2, s9                            ;Transmit 24-bit address
                 823                             CALL SPI_FLASH_tx_rx
                 824                             LOAD s2, s8
                 825                             CALL SPI_FLASH_tx_rx
                 826                             LOAD s2, s7
                 827                             CALL SPI_FLASH_tx_rx
                 828                             CALL SPI_FLASH_tx_rx                   ;read data byte
                 829                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 830                             OUTPUT s0, SPI_control_port
                 831                             STORE s0, SPI_control_status           ;preserve status
                 832                             RETURN
                 833                             ;
                 834                             ;
                 835                             ;Erase a single sector from the SPI FLASH memory (ST type M25P16)
                 836                             ;
                 837                             ;Sets the WREN instruction and then transmits instruction D8 hex followed by a 24-bit
                 838                             ;address which must be supplied in the register set [s9,s8,s7]. The address must be
                 839                             ;at some location within the sector to be erased. A sector erase can take up to
                 840                             ;3 seconds to complete. The routine therefore reads the FLASH status and tests
                 841                             ;the write in progress (WIP) bit to test for completion
                 842                             ;
                 843           erase_spi_sector: CALL set_spi_flash_WREN                ;set write enable mode
                 844                             CALL SPI_init                          ;ensure known state of bus and s0 register
                 845                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 846                             OUTPUT s0, SPI_control_port
                 847                             STORE s0, SPI_control_status           ;preserve status
                 848                             LOAD s2, D8                            ;Sector erase mode
                 849                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 850                             LOAD s2, s9                            ;Transmit 24-bit address [s9,s8,s7].
                 851                             CALL SPI_FLASH_tx_rx
                 852                             LOAD s2, s8
                 853                             CALL SPI_FLASH_tx_rx
                 854                             LOAD s2, s7
                 855                             CALL SPI_FLASH_tx_rx
                 856                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 857                             OUTPUT s0, SPI_control_port
                 858                             STORE s0, SPI_control_status           ;preserve status
                 859          sector_erase_wait: CALL read_spi_flash_status             ;test WIP bit until finished
                 860                             TEST s2, 01
                 861                             JUMP NZ, sector_erase_wait
                 862                             RETURN
                 863                             ;
                 864                             ;
                 865                             ;
                 866                             ;Bulk erase the whole SPI FLASH memory (ST type M25P16)
                 867                             ;
                 868                             ;Sets the WREN instruction and then transmits instruction C7 hex.
                 869                             ;A bulk erase can take up to 40 seconds to complete. The routine therefore reads the
                 870                             ;FLASH status and tests the write in progress (WIP) bit to test for completion
                 871                             ;
                 872             bulk_erase_spi: CALL set_spi_flash_WREN                ;set write enable mode
                 873                             CALL SPI_init                          ;ensure known state of bus and s0 register
                 874                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 875                             OUTPUT s0, SPI_control_port
                 876                             STORE s0, SPI_control_status           ;preserve status
                 877                             LOAD s2, C7                            ;Sector erase mode
                 878                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 879                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 880                             OUTPUT s0, SPI_control_port
                 881                             STORE s0, SPI_control_status           ;preserve status
                 882            bulk_erase_wait: CALL read_spi_flash_status             ;test WIP bit until finished
                 883                             TEST s2, 01
                 884                             JUMP NZ, bulk_erase_wait
                 885                             RETURN
                 886                             ;
                 887                             ;
                 888                             ;
                 889                             ;Open a page for programming.
                 890                             ;The 24-bit start address to be supplied in the register set [s9,s8,s7].
                 891                             ;Note that s7=00 hex for normal page boundaries but you could start at any address.
                 892                             ;Caution : Exceeding s7=FF hex will result in the roll over to 00 hex but without
                 893                             ;incrementing to the next page.
                 894                             ;
                 895                             ;Transmits instruction 02hex followed by the 24-bit start address.
                 896                             ;It is then ready to transmit data bytes using the s2 register and the SPI_FLASH_tx_rx
                 897                             ;subroutine. After transmitting bytes, close the page with the close_prog_page_spi
                 898                             ;routine.
                 899                             ;
                 900         open_prog_page_spi: CALL set_spi_flash_WREN                ;set write enable mode
                 901                             CALL SPI_init                          ;ensure known state of bus and s0 register
                 902                             XOR s0, SPI_rom_cs                     ;select (Low) FLASH
                 903                             OUTPUT s0, SPI_control_port
                 904                             STORE s0, SPI_control_status           ;preserve status
                 905                             LOAD s2, 02                            ;Page program mode
                 906                             CALL SPI_FLASH_tx_rx                   ;transmit instruction
                 907                             LOAD s2, s9                            ;Transmit 24-bit address [s9,s8,s7].
                 908                             CALL SPI_FLASH_tx_rx
                 909                             LOAD s2, s8
                 910                             CALL SPI_FLASH_tx_rx
                 911                             LOAD s2, s7
                 912                             CALL SPI_FLASH_tx_rx
                 913                             RETURN
                 914                             ;
                 915                             ;
                 916                             ;This routine completes a page program operation started with
                 917                             ;open_prog_page_spi and data bytes sent with SPI_FLASH_tx_rx.
                 918                             ;
                 919                             ;A page program can take up to 5ms to complete. The routine therefore reads the
                 920                             ;FLASH status and tests the write in progress (WIP) bit to test for completion
                 921                             ;
                 922                             ;
                 923        close_prog_page_spi: FETCH s0, SPI_control_status           ;read control status bits
                 924                             XOR s0, SPI_rom_cs                     ;deselect (High) FLASH
                 925                             OUTPUT s0, SPI_control_port
                 926                             STORE s0, SPI_control_status           ;preserve status
                 927             page_prog_wait: CALL read_spi_flash_status             ;test WIP bit until finished
                 928                             TEST s2, 01
                 929                             JUMP NZ, page_prog_wait
                 930                             RETURN
                 931                             ;
                 932                             ;**************************************************************************************
                 933                             ;Software delay routines
                 934                             ;**************************************************************************************
                 935                             ;
                 936                             ;
                 937                             ;
                 938                             ;Delay of 1us.
                 939                             ;
                 940                             ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                 941                             ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                 942                             ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                 943                             ;
                 944                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 945                             ;
                 946                             ;Registers used s0
                 947                             ;
                 948                  delay_1us: LOAD s0, delay_1us_constant
                 949                   wait_1us: SUB s0, 01
                 950                             JUMP NZ, wait_1us
                 951                             RETURN
                 952                             ;
                 953                             ;Delay of 40us.
                 954                             ;
                 955                             ;Registers used s0, s1
                 956                             ;
                 957                 delay_40us: LOAD s1, 28                            ;40 x 1us = 40us
                 958                  wait_40us: CALL delay_1us
                 959                             SUB s1, 01
                 960                             JUMP NZ, wait_40us
                 961                             RETURN
                 962                             ;
                 963                             ;
                 964                             ;Delay of 1ms.
                 965                             ;
                 966                             ;Registers used s0, s1, s2
                 967                             ;
                 968                  delay_1ms: LOAD s2, 19                            ;25 x 40us = 1ms
                 969                   wait_1ms: CALL delay_40us
                 970                             SUB s2, 01
                 971                             JUMP NZ, wait_1ms
                 972                             RETURN
                 973                             ;
                 974                             ;Delay of 20ms.
                 975                             ;
                 976                             ;Delay of 20ms used during initialisation.
                 977                             ;
                 978                             ;Registers used s0, s1, s2, s3
                 979                             ;
                 980                 delay_20ms: LOAD s3, 14                            ;20 x 1ms = 20ms
                 981                  wait_20ms: CALL delay_1ms
                 982                             SUB s3, 01
                 983                             JUMP NZ, wait_20ms
                 984                             RETURN
                 985                             ;
                 986                             ;Delay of approximately 1 second.
                 987                             ;
                 988                             ;Registers used s0, s1, s2, s3, s4
                 989                             ;
                 990                   delay_1s: LOAD s4, 14                            ;50 x 20ms = 1000ms
                 991                    wait_1s: CALL delay_20ms
                 992                             SUB s4, 01
                 993                             JUMP NZ, wait_1s
                 994                             RETURN
                 995                             ;
                 996                             ;**************************************************************************************
                 997                             ;UART communication routines
                 998                             ;**************************************************************************************
                 999                             ;
                1000                             ;Read one character from the UART
                1001                             ;
                1002                             ;Character read will be returned in a register called 'UART_data'.
                1003                             ;
                1004                             ;The routine first tests the receiver FIFO buffer to see if data is present.
                1005                             ;If the FIFO is empty, the routine waits until there is a character to read.
                1006                             ;As this could take any amount of time the wait loop could include a call to a
                1007                             ;subroutine which performs a useful function.
                1008                             ;
                1009                             ;If the received character is an XOFF, then the routine will then wait
                1010                             ;for an XON to be received. This means that the rest of the program is held
                1011                             ;in suspense and therefore it can not transmit. Once an XON is received, it will
                1012                             ;again wait for a normal character before returning.
                1013                             ;
                1014                             ;NOTE: Characters between the XOFF and XON will be ignored in this version of the
                1015                             ;program!!!
                1016                             ;
                1017                             ;Interrupt is disabled during this routine to prevent a false situation. If the
                1018                             ;receiver half-full flag went High it should result in an interrupt transmitting
                1019                             ;an XOFF character. However, if this routine were able to read the receiver buffer
                1020                             ;at just about the same as the hardware detects the half-full flag, then it could
                1021                             ;think that an XON needs to be transmitted.
                1022                             ;
                1023                             ;
                1024                             ;Registers used s0 and UART_data
                1025                             ;
                1026             read_from_UART: DISABLE INTERRUPT
                1027          wait_Rx_character: INPUT s0, status_port                  ;test Rx_FIFO buffer
                1028                             TEST s0, rx_data_present
                1029                             JUMP NZ, read_character
                1030                             JUMP wait_Rx_character
                1031             read_character: INPUT UART_data, UART_read_port        ;read from FIFO
                1032                             COMPARE UART_data, character_XOFF      ;test for XOFF
                1033                             JUMP Z, wait_XON
                1034                             ENABLE INTERRUPT                       ;normal finish
                1035                             RETURN
                1036                   wait_XON: INPUT s0, status_port                  ;test Rx_FIFO buffer
                1037                             TEST s0, rx_data_present
                1038                             JUMP NZ, read_XON
                1039                             JUMP wait_XON
                1040                   read_XON: INPUT UART_data, UART_read_port        ;read from FIFO
                1041                             COMPARE UART_data, character_XON       ;test for XON
                1042                             JUMP Z, wait_Rx_character              ;now wait for normal character
                1043                             JUMP wait_XON                          ;continue to wait for XON
                1044                             ;
                1045                             ;
                1046                             ;
                1047                             ;Transmit one character to the UART
                1048                             ;
                1049                             ;Character supplied in register called 'UART_data'.
                1050                             ;
                1051                             ;The routine first tests the transmit FIFO buffer is empty.
                1052                             ;If the FIFO currently has any data, the routine waits until it is empty.
                1053                             ;Ultimately this means that only one character is sent at a time which
                1054                             ;could be important if the PC at the other end of the link transmits
                1055                             ;an XOFF and needs the flow of data to terminate as soon as possible.
                1056                             ;
                1057                             ;Registers used s0
                1058                             ;
                1059               send_to_UART: INPUT s0, status_port                  ;test Tx_FIFO buffer
                1060                             TEST s0, tx_data_present
                1061                             JUMP Z, UART_write
                1062                             JUMP send_to_UART
                1063                 UART_write: OUTPUT UART_data, UART_write_port
                1064                             RETURN
                1065                             ;
                1066                             ;Convert value provided in register s0 into ASCII characters
                1067                             ;
                1068                             ;The value provided must in the range 0 to 99 and will be converted into
                1069                             ;two ASCII characters.
                1070                             ;     The number of 'tens' will be represented by an ASCII character returned in register s1.
                1071                             ;     The number of 'units' will be represented by an ASCII character returned in register s0.
                1072                             ;
                1073                             ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
                1074                             ;the actual decimal value.
                1075                             ;
                1076                             ;Registers used s0 and s1.
                1077                             ;
                1078           decimal_to_ASCII: LOAD s1, 30                            ;load 'tens' counter with ASCII for '0'
                1079               test_for_ten: ADD s1, 01                             ;increment 'tens' value
                1080                             SUB s0, 0A                             ;try to subtract 10 from the supplied value
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                1081                             JUMP NC, test_for_ten                  ;repeat if subtraction was possible without underflow.
                1082                             SUB s1, 01                             ;'tens' value one less ten due to underflow
                1083                             ADD s0, 3A                             ;restore units value (the remainder) and convert to ASCII
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                1084                             RETURN
                1085                             ;
                1086                             ;
                1087                             ;
                1088                             ;Convert character to upper case
                1089                             ;
                1090                             ;The character supplied in register s0.
                1091                             ;If the character is in the range 'a' to 'z', it is converted
                1092                             ;to the equivalent upper case character in the range 'A' to 'Z'.
                1093                             ;All other characters remain unchanged.
                1094                             ;
                1095                             ;Registers used s0.
                1096                             ;
                1097                 upper_case: COMPARE s0, 61                         ;eliminate character codes below 'a' (61 hex)
                1098                             RETURN C
                1099                             COMPARE s0, 7B                         ;eliminate character codes above 'z' (7A hex)
E: identifier cannot start with a digit: `7B'.
E: unexpected end of line.
                1100                             RETURN NC
                1101                             AND s0, DF                             ;mask bit5 to convert to upper case
                1102                             RETURN
                1103                             ;
                1104                             ;
                1105                             ;Convert character '0' to '9' to numerical value in range 0 to 9
                1106                             ;
                1107                             ;The character supplied in register s0. If the character is in the
                1108                             ;range '0' to '9', it is converted to the equivalent decimal value.
                1109                             ;Characters not in the range '0' to '9' are signified by the return
                1110                             ;with the CARRY flag set.
                1111                             ;
                1112                             ;Registers used s0.
                1113                             ;
                1114             1char_to_value: ADD s0, C6                             ;reject character codes above '9' (39 hex)
E: identifier cannot start with a digit: `1char_to_value'.
E: unexpected :.
                1115                             RETURN C                               ;carry flag is set
                1116                             SUB s0, F6                             ;reject character codes below '0' (30 hex)
                1117                             RETURN                                 ;carry is set if value not in range
                1118                             ;
                1119                             ;
                1120                             ;Determine the numerical value of a two character decimal string held in
                1121                             ;scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
                1122                             ;
                1123                             ;The string must be stored in two consecutive memory locations and the
                1124                             ;location of the first (tens) character supplied in the s1 register.
                1125                             ;The result is provided in register s2. Strings not using characters in the
                1126                             ;range '0' to '9' are signified by the return with the CARRY flag set.
                1127                             ;
                1128                             ;Registers used s0, s1 and s2.
                1129                             ;
                1130             2char_to_value: FETCH s0, (s1)                         ;read 'tens' character
E: identifier cannot start with a digit: `2char_to_value'.
E: unexpected :.
                1131                             CALL 1char_to_value                    ;convert to numerical value
E: identifier cannot start with a digit: `1char_to_value'.
E: invalid number of operands, instruction CALL takes 1 or 2 operand(s).
000 39000       1132                             RETURN C                               ;bad character - CARRY set
001 00110       1133                             LOAD s2, s0
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
002 14106       1134                             SL0 s2                                 ;multiply 'tens' value by 10 (0A hex)
E: symbol not defined: `S2'.
003 14106       1135                             SL0 s2
E: symbol not defined: `S2'.
004 10110       1136                             ADD s2, s0
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
005 14106       1137                             SL0 s2
E: symbol not defined: `S2'.
006 10110       1138                             ADD s1, 01                             ;read 'units' character
E: symbol not defined: `S1'.
007 0B101       1139                             FETCH s0, (s1)
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                1140                             CALL 1char_to_value                    ;convert to numerical value
E: identifier cannot start with a digit: `1char_to_value'.
E: invalid number of operands, instruction CALL takes 1 or 2 operand(s).
008 39000       1141                             RETURN C                               ;bad character - CARRY set
009 10110       1142                             ADD s2, s0                             ;add units to result and clear CARRY flag
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
00A 25000       1143                             RETURN
                1144                             ;
                1145                             ;
                1146                             ;Convert hexadecimal value provided in register s0 into ASCII characters
                1147                             ;
                1148                             ;The value provided must can be any value in the range 00 to FF and will be converted into
                1149                             ;two ASCII characters.
                1150                             ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1151                             ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1152                             ;
                1153                             ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1154                             ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1155                             ;hexadecimal requiring a further addition of 07 to the 30 already added.
                1156                             ;
                1157                             ;Registers used s0, s1 and s2.
                1158                             ;
00B 00110       1159          hex_byte_to_ASCII: LOAD s1, s0                            ;remember value supplied
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
00C 1410E       1160                             SR0 s0                                 ;isolate upper nibble
E: symbol not defined: `S0'.
00D 1410E       1161                             SR0 s0
E: symbol not defined: `S0'.
00E 1410E       1162                             SR0 s0
E: symbol not defined: `S0'.
00F 1410E       1163                             SR0 s0
E: symbol not defined: `S0'.
010 20001       1164                             CALL hex_to_ASCII                      ;convert
E: symbol not defined: `HEX_TO_ASCII'.
011 00110       1165                             LOAD s2, s0                            ;upper nibble value in s2
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
012 00110       1166                             LOAD s0, s1                            ;restore complete value
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                1167                             AND s0, 0F                             ;isolate lower nibble
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
013 20001       1168                             CALL hex_to_ASCII                      ;convert
E: symbol not defined: `HEX_TO_ASCII'.
014 00110       1169                             LOAD s1, s0                            ;lower nibble value in s1
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
015 25000       1170                             RETURN
                1171                             ;
                1172                             ;Convert hexadecimal value provided in register s0 into ASCII character
                1173                             ;
                1174                             ;Register used s0
                1175                             ;
                1176               hex_to_ASCII: SUB s0, 0A                             ;test if value is in range 0 to 9
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
016 3A001       1177                             JUMP C, number_char
E: symbol not defined: `NUMBER_CHAR'.
017 10170       1178                             ADD s0, 07                             ;ASCII char A to F in range 41 to 46
E: symbol not defined: `S0'.
                1179                number_char: ADD s0, 3A                             ;ASCII char 0 to 9 in range 30 to 40
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
018 25000       1180                             RETURN
                1181                             ;
                1182                             ;
                1183                             ;Send the two character HEX value of the register contents 's0' to the UART
                1184                             ;
                1185                             ;Registers used s0, s1, s2
                1186                             ;
019 2000B       1187              send_hex_byte: CALL hex_byte_to_ASCII
01A 00110       1188                             LOAD UART_data, s2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `S2'.
01B 20001       1189                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
01C 00110       1190                             LOAD UART_data, s1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `S1'.
01D 20001       1191                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
01E 25000       1192                             RETURN
                1193                             ;
                1194                             ;
                1195                             ;
                1196                             ;Send the six character HEX value of the register contents [s9,s8,s7] to the UART
                1197                             ;
                1198                             ;Registers used s0, s1, s2
                1199                             ;
01F 00110       1200            send_hex_3bytes: LOAD s0, s9
E: symbol not defined: `S0'.
E: symbol not defined: `S9'.
020 20019       1201                             CALL send_hex_byte
021 00110       1202                             LOAD s0, s8
E: symbol not defined: `S0'.
E: symbol not defined: `S8'.
022 20019       1203                             CALL send_hex_byte
023 00110       1204                             LOAD s0, s7
E: symbol not defined: `S0'.
E: symbol not defined: `S7'.
024 20019       1205                             CALL send_hex_byte
025 25000       1206                             RETURN
                1207                             ;
                1208                             ;
                1209                             ;Convert the HEX ASCII characters contained in 's3' and 's2' into
                1210                             ;an equivalent hexadecimal value in register 's0'.
                1211                             ;     The upper nibble is represented by an ASCII character in register s3.
                1212                             ;     The lower nibble is represented by an ASCII character in register s2.
                1213                             ;
                1214                             ;Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1215                             ;will be set on return.
                1216                             ;
                1217                             ;Registers used s0, s2 and s3.
                1218                             ;
026 00110       1219          ASCII_byte_to_hex: LOAD s0, s3                            ;Take upper nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
027 20033       1220                             CALL ASCII_to_hex                      ;convert to value
028 39000       1221                             RETURN C                               ;reject if out of range
029 00110       1222                             LOAD s3, s0                            ;remember value
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
02A 14106       1223                             SL0 s3                                 ;multiply value by 16 to put in upper nibble
E: symbol not defined: `S3'.
02B 14106       1224                             SL0 s3
E: symbol not defined: `S3'.
02C 14106       1225                             SL0 s3
E: symbol not defined: `S3'.
02D 14106       1226                             SL0 s3
E: symbol not defined: `S3'.
02E 00110       1227                             LOAD s0, s2                            ;Take lower nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S2'.
02F 20033       1228                             CALL ASCII_to_hex                      ;convert to value
030 39000       1229                             RETURN C                               ;reject if out of range
031 04110       1230                             OR s0, s3                              ;merge in the upper nibble with CARRY reset
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
032 25000       1231                             RETURN
                1232                             ;
                1233                             ;
                1234                             ;Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1235                             ;
                1236                             ;If character is not valid for hex, then CARRY is set on return.
                1237                             ;
                1238                             ;Register used s0
                1239                             ;
033 10110       1240               ASCII_to_hex: ADD s0, B9                             ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
E: symbol not defined: `B9'.
034 39000       1241                             RETURN C
035 18110       1242                             SUB s0, E9                             ;normalise 0 to 9 with A-F in 11 to 16 hex
E: symbol not defined: `S0'.
E: symbol not defined: `E9'.
036 39000       1243                             RETURN C                               ;reject below ASCII code 30 ('0')
037 181B0       1244                             SUB s0, 11                             ;isolate A-F down to 00 to 05 hex
E: symbol not defined: `S0'.
038 3E001       1245                             JUMP NC, ASCII_letter
E: symbol not defined: `ASCII_LETTER'.
039 10170       1246                             ADD s0, 07                             ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
03A 39000       1247                             RETURN C
03B 18110       1248                             SUB s0, F6                             ;convert to range 00 to 09
E: symbol not defined: `S0'.
E: symbol not defined: `F6'.
03C 25000       1249                             RETURN
                1250               ASCII_letter: ADD s0, 0A                             ;convert to range 0A to 0F
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
03D 25000       1251                             RETURN
                1252                             ;
                1253                             ;
                1254                             ;
                1255                             ;Send Carriage Return to the UART
                1256                             ;
03E 00110       1257                    send_CR: LOAD UART_data, character_CR
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_CR'.
03F 20001       1258                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
040 25000       1259                             RETURN
                1260                             ;
                1261                             ;Send a space to the UART
                1262                             ;
041 00110       1263                 send_space: LOAD UART_data, character_space
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_SPACE'.
042 20001       1264                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
043 25000       1265                             RETURN
                1266                             ;
                1267                             ;
                1268                             ;**************************************************************************************
                1269                             ;Text messages
                1270                             ;**************************************************************************************
                1271                             ;
                1272                             ;
                1273                             ;Send 'PicoBlaze SPI FLASH Programmer' string to the UART
                1274                             ;
044 2003E       1275               send_welcome: CALL send_CR
045 2003E       1276                             CALL send_CR
046 00110       1277                             LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
047 20001       1278                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
048 00110       1279                             LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
049 20001       1280                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04A 00110       1281                             LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
04B 20001       1282                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04C 00110       1283                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
04D 20001       1284                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04E 00110       1285                             LOAD UART_data, character_B
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_B'.
04F 20001       1286                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
050 00110       1287                             LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
051 20001       1288                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
052 00110       1289                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
053 20001       1290                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
054 00110       1291                             LOAD UART_data, character_z
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_Z'.
055 20001       1292                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
056 00110       1293                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
057 20001       1294                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
058 20041       1295                             CALL send_space
059 00110       1296                             LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
05A 20001       1297                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05B 00110       1298                             LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
05C 20001       1299                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05D 00110       1300                             LOAD UART_data, character_I
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
05E 20001       1301                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05F 20041       1302                             CALL send_space
060 00110       1303                             LOAD UART_data, character_F
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_F'.
061 20001       1304                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
062 00110       1305                             LOAD UART_data, character_L
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
063 20001       1306                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
064 00110       1307                             LOAD UART_data, character_A
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
065 20001       1308                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
066 00110       1309                             LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
067 20001       1310                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
068 00110       1311                             LOAD UART_data, character_H
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_H'.
069 20001       1312                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06A 20041       1313                             CALL send_space
06B 00110       1314                             LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
06C 20001       1315                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06D 00110       1316                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
06E 20001       1317                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06F 00110       1318                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
070 20001       1319                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
071 00110       1320                             LOAD UART_data, character_g
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_G'.
072 20001       1321                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
073 00110       1322                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
074 20001       1323                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
075 00110       1324                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
076 20001       1325                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
077 00110       1326                             LOAD UART_data, character_m
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
078 20001       1327                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
079 00110       1328                             LOAD UART_data, character_m
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
07A 20001       1329                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07B 00110       1330                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
07C 20001       1331                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07D 00110       1332                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
07E 20001       1333                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07F 20041       1334                             CALL send_space
080 00110       1335                             LOAD UART_data, character_v
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_V'.
081 20001       1336                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
082 00110       1337                             LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
083 20001       1338                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
084 00110       1339                             LOAD UART_data, character_fullstop
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_FULLSTOP'.
085 20001       1340                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
086 00110       1341                             LOAD UART_data, character_0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_0'.
087 20001       1342                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
088 00110       1343                             LOAD UART_data, character_0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_0'.
089 20001       1344                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
08A 2003E       1345                             CALL send_CR
08B 2003E       1346                             CALL send_CR
08C 25000       1347                             RETURN
                1348                             ;
                1349                             ;
                1350                             ;
                1351                             ;Send 'Waiting_MCS_file' string to the UART
                1352                             ;
08D 00110       1353      send_Waiting_MCS_file: LOAD UART_data, character_W
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_W'.
08E 20001       1354                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
08F 00110       1355                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
090 20001       1356                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
091 00110       1357                             LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
092 20001       1358                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
093 00110       1359                             LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
094 20001       1360                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
095 00110       1361                             LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
096 20001       1362                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
097 00110       1363                             LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
098 20001       1364                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
099 00110       1365                             LOAD UART_data, character_g
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_G'.
09A 20001       1366                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
09B 20041       1367                             CALL send_space
09C 00110       1368                             LOAD UART_data, character_f
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_F'.
09D 20001       1369                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
09E 00110       1370                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
09F 20001       1371                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A0 00110       1372                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
0A1 20001       1373                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A2 20041       1374              send_MCS_file: CALL send_space
0A3 00110       1375                             LOAD UART_data, character_M
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
0A4 20001       1376                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A5 00110       1377                             LOAD UART_data, character_C
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
0A6 20001       1378                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A7 00110       1379                             LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
0A8 20001       1380                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A9 20041       1381                             CALL send_space
0AA 00110       1382                             LOAD UART_data, character_F
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_F'.
0AB 20001       1383                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0AC 00110       1384                             LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
0AD 20001       1385                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0AE 00110       1386                             LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
0AF 20001       1387                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B0 00110       1388                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
0B1 20001       1389                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B2 2003E       1390                             CALL send_CR
0B3 25000       1391                             RETURN
                1392                             ;
                1393                             ;
                1394                             ;Send 'Erase in progress' string to the UART
                1395                             ;
0B4 200CB       1396     send_Erase_in_progress: CALL send_Erase
0B5 00110       1397                             LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
0B6 20001       1398                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B7 00110       1399                             LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
0B8 20001       1400                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B9 20041       1401                             CALL send_space
0BA 00110       1402                             LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
0BB 20001       1403                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0BC 00110       1404                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
0BD 20001       1405                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0BE 00110       1406                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
0BF 20001       1407                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C0 00110       1408                             LOAD UART_data, character_g
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_G'.
0C1 20001       1409                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C2 00110       1410                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
0C3 20001       1411                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C4 00110       1412                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
0C5 20001       1413                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C6 00110       1414                             LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
0C7 20001       1415                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C8 20001       1416                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C9 2003E       1417                             CALL send_CR
0CA 25000       1418                             RETURN
                1419                             ;
                1420                             ;
                1421                             ;Send 'Erase ' string to the UART
                1422                             ;
0CB 00110       1423                 send_Erase: LOAD UART_data, character_E
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
0CC 20001       1424                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0CD 00110       1425                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
0CE 20001       1426                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0CF 00110       1427                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
0D0 20001       1428                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D1 00110       1429                             LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
0D2 20001       1430                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D3 00110       1431                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
0D4 20001       1432                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D5 20041       1433                             CALL send_space
0D6 25000       1434                             RETURN
                1435                             ;
                1436                             ;
                1437                             ;Send carriage return, 'OK' and carriage return to the UART
                1438                             ;
0D7 2003E       1439                    send_OK: CALL send_CR
0D8 00110       1440                             LOAD UART_data, character_O
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
0D9 20001       1441                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0DA 00110       1442                             LOAD UART_data, character_K
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_K'.
0DB 20001       1443                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0DC 2003E       1444                             CALL send_CR
0DD 25000       1445                             RETURN
                1446                             ;
                1447                             ;
                1448                             ;
                1449                             ;Send menu to the UART
                1450                             ;
0DE 2003E       1451                  send_Menu: CALL send_CR
0DF 00110       1452                             LOAD UART_data, character_E
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
0E0 20001       1453                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E1 00110       1454                             LOAD UART_data, character_minus
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_MINUS'.
0E2 20001       1455                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E3 200CB       1456                             CALL send_Erase
0E4 00110       1457                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
0E5 20001       1458                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E6 00110       1459                             LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
0E7 20001       1460                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E8 20001       1461                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E9 2003E       1462                             CALL send_CR
0EA 00110       1463                             LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
0EB 20001       1464                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0EC 00110       1465                             LOAD UART_data, character_minus
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_MINUS'.
0ED 20001       1466                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0EE 00110       1467                             LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
0EF 20001       1468                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F0 00110       1469                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
0F1 20001       1470                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F2 00110       1471                             LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
0F3 20001       1472                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F4 00110       1473                             LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
0F5 20001       1474                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F6 00110       1475                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
0F7 20001       1476                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F8 00110       1477                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
0F9 20001       1478                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0FA 20041       1479                             CALL send_space
0FB 200CB       1480                             CALL send_Erase
0FC 2003E       1481                             CALL send_CR
0FD 00110       1482                             LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
0FE 20001       1483                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0FF 00110       1484                             LOAD UART_data, character_minus
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_MINUS'.
100 20001       1485                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
101 00110       1486                             LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
102 20001       1487                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
103 00110       1488                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
104 20001       1489                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
105 00110       1490                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
106 20001       1491                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
107 00110       1492                             LOAD UART_data, character_g
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_G'.
108 20001       1493                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
109 00110       1494                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
10A 20001       1495                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10B 00110       1496                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
10C 20001       1497                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10D 00110       1498                             LOAD UART_data, character_m
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
10E 20001       1499                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10F 200A2       1500                             CALL send_MCS_file
110 00110       1501                             LOAD UART_data, character_R
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
111 20001       1502                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
112 00110       1503                             LOAD UART_data, character_minus
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_MINUS'.
113 20001       1504                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
114 00110       1505                             LOAD UART_data, character_R
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
115 20001       1506                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
116 00110       1507                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
117 20001       1508                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
118 00110       1509                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
119 20001       1510                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
11A 00110       1511                             LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
11B 20001       1512                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
11C 20041       1513                             CALL send_space
11D 20140       1514                             CALL send_page
11E 2003E       1515                             CALL send_CR
11F 00110       1516                             LOAD UART_data, character_I
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
120 20001       1517                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
121 00110       1518                             LOAD UART_data, character_minus
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_MINUS'.
122 20001       1519                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
123 00110       1520                             LOAD UART_data, character_D
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
124 20001       1521                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
125 00110       1522                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
126 20001       1523                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
127 00110       1524                             LOAD UART_data, character_v
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_V'.
128 20001       1525                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
129 00110       1526                             LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
12A 20001       1527                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
12B 00110       1528                             LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
12C 20001       1529                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
12D 00110       1530                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
12E 20001       1531                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
12F 20041       1532                             CALL send_space
130 20149       1533                             CALL send_ID
131 2003E       1534                             CALL send_CR
132 00110       1535                             LOAD UART_data, character_H
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_H'.
133 20001       1536                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
134 00110       1537                             LOAD UART_data, character_minus
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_MINUS'.
135 20001       1538                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
136 00110       1539                             LOAD UART_data, character_H
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_H'.
137 20001       1540                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
138 00110       1541                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
139 20001       1542                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
13A 00110       1543                             LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
13B 20001       1544                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
13C 00110       1545                             LOAD UART_data, character_p
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
13D 20001       1546                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
13E 2003E       1547                             CALL send_CR
13F 25000       1548                             RETURN
                1549                             ;
                1550                             ;
                1551                             ;Send 'page' to the UART
                1552                             ;
140 00110       1553                  send_page: LOAD UART_data, character_p
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
141 20001       1554                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
142 00110       1555                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
143 20001       1556                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
144 00110       1557                             LOAD UART_data, character_g
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_G'.
145 20001       1558                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
146 00110       1559                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
147 20001       1560                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
148 25000       1561                             RETURN
                1562                             ;
                1563                             ;Send 'ID' to the UART
                1564                             ;
149 00110       1565                    send_ID: LOAD UART_data, character_I
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
14A 20001       1566                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
14B 00110       1567                             LOAD UART_data, character_D
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
14C 20001       1568                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
14D 25000       1569                             RETURN
                1570                             ;
                1571                             ;
                1572                             ;Send 'Confirm Erase (Y/n) ' to the UART
                1573                             ;
14E 2003E       1574               send_Confirm: CALL send_CR
14F 00110       1575                             LOAD UART_data, character_C
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
150 20001       1576                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
151 00110       1577                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
152 20001       1578                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
153 00110       1579                             LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
154 20001       1580                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
155 00110       1581                             LOAD UART_data, character_f
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_F'.
156 20001       1582                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
157 00110       1583                             LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
158 20001       1584                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
159 00110       1585                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
15A 20001       1586                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
15B 00110       1587                             LOAD UART_data, character_m
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
15C 20001       1588                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
15D 20041       1589                             CALL send_space
15E 200CB       1590                             CALL send_Erase
15F 00110       1591                             LOAD UART_data, character_open
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_OPEN'.
160 20001       1592                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
161 00110       1593                             LOAD UART_data, character_Y
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_Y'.
162 20001       1594                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
163 00110       1595                             LOAD UART_data, character_divide
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_DIVIDE'.
164 20001       1596                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
165 00110       1597                             LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
166 20001       1598                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
167 00110       1599                             LOAD UART_data, character_close
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_CLOSE'.
168 20001       1600                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
169 20041       1601                             CALL send_space
16A 25000       1602                             RETURN
                1603                             ;
                1604                             ;
                1605                             ;Send 'Abort' to the UART
                1606                             ;
16B 2003E       1607                 send_Abort: CALL send_CR
16C 00110       1608                             LOAD UART_data, character_A
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
16D 20001       1609                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
16E 00110       1610                             LOAD UART_data, character_b
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_B'.
16F 20001       1611                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
170 00110       1612                             LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
171 20001       1613                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
172 00110       1614                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
173 20001       1615                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
174 00110       1616                             LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
175 20001       1617                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
176 2003E       1618                             CALL send_CR
177 25000       1619                             RETURN
                1620                             ;
                1621                             ;Send 'page address' to the UART
                1622                             ;
178 2003E       1623          send_page_address: CALL send_CR
179 20140       1624                             CALL send_page
17A 20041       1625                             CALL send_space
17B 00110       1626                             LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
17C 20001       1627                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
17D 00110       1628                             LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
17E 20001       1629                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
17F 20001       1630                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
180 00110       1631                             LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
181 20001       1632                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
182 00110       1633                             LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
183 20001       1634                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
184 00110       1635                             LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
185 20001       1636                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
186 20001       1637                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
187 00110       1638                             LOAD UART_data, character_equals
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_EQUALS'.
188 20001       1639                             CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
189 25000       1640                             RETURN
                1641                             ;
                1642                             ;
                1643                             ;**************************************************************************************
                1644                             ;Interrupt Service Routine (ISR)
                1645                             ;**************************************************************************************
                1646                             ;
                1647                             ;An interrupt occurs whenever the status of the UART receiver FIFO 'half_full' flag
                1648                             ;changes.
                1649                             ;
                1650                             ;A change from Low to High means that the buffer is becoming full and therefore
                1651                             ;an XOFF character must be transmitted.
                1652                             ;
                1653                             ;A change from High to Low means that the buffer is starting to empty and therefore
                1654                             ;an XON character can be transmitted to restart the flow of new characters.
                1655                             ;
                1656                             ;
                1657                             ADDRESS 3F5                            ;place at end of memory to keep separate
E: identifier cannot start with a digit: `3F5'.
E: directive ADDRESS requires a single argument.
18A 2F101       1658                        ISR: STORE s0, ISR_preserve_s0              ;preserve register contents
E: symbol not defined: `S0'.
E: symbol not defined: `ISR_PRESERVE_S0'.
18B 09101       1659                             INPUT s0, status_port                  ;test 'half_full' status of receiver buffer.
E: symbol not defined: `S0'.
E: symbol not defined: `STATUS_PORT'.
18C 0C110       1660                             TEST s0, rx_half_full
E: symbol not defined: `S0'.
E: symbol not defined: `RX_HALF_FULL'.
18D 32190       1661                             JUMP Z, isr_send_xon
18E 00110       1662                             LOAD s0, character_XOFF
E: symbol not defined: `S0'.
E: symbol not defined: `CHARACTER_XOFF'.
18F 22191       1663                             JUMP isr_send_character
190 00110       1664               isr_send_xon: LOAD s0, character_XON
E: symbol not defined: `S0'.
E: symbol not defined: `CHARACTER_XON'.
191 2D101       1665         isr_send_character: OUTPUT s0, UART_write_port
E: symbol not defined: `S0'.
E: symbol not defined: `UART_WRITE_PORT'.
192 0B101       1666                             FETCH s0, ISR_preserve_s0              ;restore register contents
E: symbol not defined: `S0'.
E: symbol not defined: `ISR_PRESERVE_S0'.
193 29001       1667                             RETURNI ENABLE
                1668                             ;
                1669                             ;
                1670                             ;**************************************************************************************
                1671                             ;Interrupt Vector
                1672                             ;**************************************************************************************
                1673                             ;
                1674                             ADDRESS 3FF
E: identifier cannot start with a digit: `3FF'.
E: directive ADDRESS requires a single argument.
194 2218A       1675                             JUMP ISR
                1676                             ;
                1677                             ;
