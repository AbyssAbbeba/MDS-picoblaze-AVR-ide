                   1                               ; KCPSM3 Program - Communication with DS2432 secure memory on the Spartan-3E Starter Kit.
                   2                               ;
                   3                               ; Ken Chapman - Xilinx Ltd
                   4                               ;
                   5                               ; Version v1.00 - 5th April 2006
                   6                               ;
                   7                               ; This program uses a 9600 baud UART connection to allow communication with the
                   8                               ; 1-wire interface of the DS2432 memory device from Dallas Semiconductor.
                   9                               ;
                  10                               ; The program only supports a limited number of the DS2432 commands but is intended
                  11                               ; to guide you through the state machine of the device as well as show how
                  12                               ; 1-wire communication is achieved. The DS2432 also uses 8 and 16 bits CRC checks and
                  13                               ; this program includes these calculations to validate the communications.
                  14                               ;
                  15                               ; Commands supported include read ROM, write scratchpad memory and read scratchpad
                  16                               ; memory. These allow you to confirm the ability to both read and write data but
                  17                               ; at no time modify the actual EEPROM secure memory or secret.
                  18                               ;
                  19                               ; There are then two manual commands which allow you to write any byte value that
                  20                               ; you enter and to read a byte from the DS2432 device. At this point you are free
                  21                               ; to experiment and this may result in the device contents being altered. You also
                  22                               ; become responsible for tracking the states but remember that a master reset will
                  23                               ; always return you to a known starting point again.
                  24                               ;
                  25                               ;
                  26                               ;**************************************************************************************
                  27                               ; Port definitions
                  28                               ;**************************************************************************************
                  29                               ;
                  30                               ;
                  31                               CONSTANT status_port, 00               ;UART status input
                  32                               CONSTANT tx_half_full, 01              ;  Transmitter     half full - bit0
                  33                               CONSTANT tx_full, 02                   ;    FIFO               full - bit1
                  34                               CONSTANT rx_data_present, 04           ;  Receiver     data present - bit2
                  35                               CONSTANT rx_half_full, 08              ;    FIFO          half full - bit3
                  36                               CONSTANT rx_full, 10                   ;                   full - bit4
                  37                               CONSTANT spare1, 20                    ;                  spare '0' - bit5
                  38                               CONSTANT spare2, 40                    ;                  spare '0' - bit6
                  39                               CONSTANT spare3, 80                    ;                  spare '0' - bit7
                  40                               ;
                  41                               CONSTANT UART_read_port, 01            ;UART Rx data input
                  42                               ;
                  43                               CONSTANT UART_write_port, 04           ;UART Tx data output
                  44                               ;
                  45                               ;
                  46                               CONSTANT DS_wire_in_port, 02           ;Read signal from DS2432 device
                  47                               CONSTANT DS_wire_out_port, 08          ;Drive signal to DS2432 device (open collector)
                  48                               CONSTANT DS_wire, 01                   ;       Signal is bit0 in both cases
                  49                               ;
                  50                               ;
                  51                               ;
                  52                               ;
                  53                               ;**************************************************************************************
                  54                               ; Special Register usage
                  55                               ;**************************************************************************************
                  56                               ;
                  57                               NAMEREG sF, UART_data                  ;used to pass data to and from the UART
                  58                               ;
                  59                               ;
                  60                               ;**************************************************************************************
                  61                               ; Scratch Pad Memory Locations
                  62                               ;**************************************************************************************
                  63                               ;
                  64                               ; Scratch pad memory provides 64 bytes in the address range 00 to 3F hex.
                  65                               ;
                  66                               ;
                  67                               ; Locations for device family code, serial number and 8-bit CRC value
                  68                               ;
                  69                               CONSTANT family_code, 00
                  70                               CONSTANT serial_number0, 01            ;48-bit serial number LS-Byte first
                  71                               CONSTANT serial_number1, 02
                  72                               CONSTANT serial_number2, 03
                  73                               CONSTANT serial_number3, 04
                  74                               CONSTANT serial_number4, 05
                  75                               CONSTANT serial_number5, 06
                  76                               CONSTANT read_ROM_CRC, 07              ;8-bit CRC
                  77                               ;
                  78                               ;
                  79                               ; Locations to store all bytes in a command communication for 16-bit CRC calculation
                  80                               ;
                  81                               CONSTANT command_start, 08
                  82                               ;
                  83                               ;
                  84                               ;**************************************************************************************
                  85                               ; Useful data constants
                  86                               ;**************************************************************************************
                  87                               ;
                  88                               ; Constant to define a software delay of 1us. This must be adjusted to reflect the
                  89                               ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                  90                               ; calculation highly predictable. The '6' in the following equation even allows for
                  91                               ; 'CALL delay_1us' instruction in the initiating code.
                  92                               ;
                  93                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                  94                               ;
                  95                               ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                  96                               ; For clock rates below 10MHz the value of 1 must be used and the operation will
                  97                               ; become lower than intended.
                  98                               ;
                  99                               CONSTANT delay_1us_constant, 0B
                 100                               ;
                 101                               ;
                 102                               ;
                 103                               ;ASCII table
                 104                               ;
                 105                               CONSTANT character_a, 61
                 106                               CONSTANT character_b, 62
                 107                               CONSTANT character_c, 63
                 108                               CONSTANT character_d, 64
                 109                               CONSTANT character_e, 65
                 110                               CONSTANT character_f, 66
                 111                               CONSTANT character_g, 67
                 112                               CONSTANT character_h, 68
                 113                               CONSTANT character_i, 69
                 114                               CONSTANT character_j, 6A
E: identifier cannot start with a digit: `6A'.
E: unexpected end of line.
                 115                               CONSTANT character_k, 6B
E: identifier cannot start with a digit: `6B'.
E: unexpected end of line.
                 116                               CONSTANT character_l, 6C
E: identifier cannot start with a digit: `6C'.
E: unexpected end of line.
                 117                               CONSTANT character_m, 6D
                 118                               CONSTANT character_n, 6E
E: identifier cannot start with a digit: `6E'.
E: unexpected end of line.
                 119                               CONSTANT character_o, 6F
E: identifier cannot start with a digit: `6F'.
E: unexpected end of line.
                 120                               CONSTANT character_p, 70
                 121                               CONSTANT character_q, 71
                 122                               CONSTANT character_r, 72
                 123                               CONSTANT character_s, 73
                 124                               CONSTANT character_t, 74
                 125                               CONSTANT character_u, 75
                 126                               CONSTANT character_v, 76
                 127                               CONSTANT character_w, 77
                 128                               CONSTANT character_x, 78
                 129                               CONSTANT character_y, 79
                 130                               CONSTANT character_z, 7A
E: identifier cannot start with a digit: `7A'.
E: unexpected end of line.
                 131                               CONSTANT character_A, 41
                 132                               CONSTANT character_B, 42
                 133                               CONSTANT character_C, 43
                 134                               CONSTANT character_D, 44
                 135                               CONSTANT character_E, 45
                 136                               CONSTANT character_F, 46
                 137                               CONSTANT character_G, 47
                 138                               CONSTANT character_H, 48
                 139                               CONSTANT character_I, 49
                 140                               CONSTANT character_J, 4A
E: identifier cannot start with a digit: `4A'.
E: unexpected end of line.
                 141                               CONSTANT character_K, 4B
E: identifier cannot start with a digit: `4B'.
E: unexpected end of line.
                 142                               CONSTANT character_L, 4C
E: identifier cannot start with a digit: `4C'.
E: unexpected end of line.
                 143                               CONSTANT character_M, 4D
                 144                               CONSTANT character_N, 4E
E: identifier cannot start with a digit: `4E'.
E: unexpected end of line.
                 145                               CONSTANT character_O, 4F
E: identifier cannot start with a digit: `4F'.
E: unexpected end of line.
                 146                               CONSTANT character_P, 50
                 147                               CONSTANT character_Q, 51
                 148                               CONSTANT character_R, 52
                 149                               CONSTANT character_S, 53
                 150                               CONSTANT character_T, 54
                 151                               CONSTANT character_U, 55
                 152                               CONSTANT character_V, 56
                 153                               CONSTANT character_W, 57
                 154                               CONSTANT character_X, 58
                 155                               CONSTANT character_Y, 59
                 156                               CONSTANT character_Z, 5A
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
                 157                               CONSTANT character_0, 30
                 158                               CONSTANT character_1, 31
                 159                               CONSTANT character_2, 32
                 160                               CONSTANT character_3, 33
                 161                               CONSTANT character_4, 34
                 162                               CONSTANT character_5, 35
                 163                               CONSTANT character_6, 36
                 164                               CONSTANT character_7, 37
                 165                               CONSTANT character_8, 38
                 166                               CONSTANT character_9, 39
                 167                               CONSTANT character_colon, 3A
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                 168                               CONSTANT character_fullstop, 2E
E: identifier cannot start with a digit: `2E'.
E: unexpected end of line.
                 169                               CONSTANT character_semi_colon, 3B
E: identifier cannot start with a digit: `3B'.
E: unexpected end of line.
                 170                               CONSTANT character_minus, 2D
                 171                               CONSTANT character_plus, 2B
E: identifier cannot start with a digit: `2B'.
E: unexpected end of line.
                 172                               CONSTANT character_comma, 2C
E: identifier cannot start with a digit: `2C'.
E: unexpected end of line.
                 173                               CONSTANT character_less_than, 3C       ;'<'
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
                 174                               CONSTANT character_greater_than, 3E    ;'>'
E: identifier cannot start with a digit: `3E'.
E: unexpected end of line.
                 175                               CONSTANT character_open, 28            ;'('
                 176                               CONSTANT character_close, 29           ;')'
                 177                               CONSTANT character_divide, 2F          ;'/'
E: identifier cannot start with a digit: `2F'.
E: unexpected end of line.
                 178                               CONSTANT character_equals, 3D
                 179                               CONSTANT character_space, 20
                 180                               CONSTANT character_CR, 0D              ;carriage return
                 181                               CONSTANT character_LF, 0A              ;line feed
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 182                               CONSTANT character_question, 3F        ;'?'
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
                 183                               CONSTANT character_dollar, 24
                 184                               CONSTANT character_exclaim, 21         ;'!'
                 185                               CONSTANT character_BS, 08              ;Back Space command character
                 186                               CONSTANT character_XON, 11             ;Flow control ON
                 187                               CONSTANT character_XOFF, 13            ;Flow control OFF
                 188                               ;
                 189                               ;
                 190                               ;**************************************************************************************
                 191                               ; Initialise the system and welcome message
                 192                               ;**************************************************************************************
                 193                               ;
                 194                   cold_start: CALL DS_wire_init                      ;Ensure DS_wire is not driven (pulled High)
                 195                               CALL delay_1s                          ;Allow everything to settle!
                 196                welcome_start: CALL send_welcome                      ;start up message and version number
                 197                               ;
                 198                               ;
                 199                               ;
                 200                               ; The main program guides the user to follow the command state machine of the
                 201                               ; DS2432 device by only offering those choices that are valid at each stage.
                 202                               ; This program only offers a limited choice and it is left as an exercise to
                 203                               ; the user to modify or expand this choice as required.
                 204                               ;
                 205                               ;**************************************************************************************
                 206                               ; Reset Main menu and command selection
                 207                               ;**************************************************************************************
                 208                               ;
                 209                               ; Initially the only action available is a master reset and test for a presence
                 210                               ; pulse response from the DS2432.
                 211                               ;
                 212                   reset_menu: CALL send_reset_menu                   ;Menu and command selection
                 213                               CALL send_CR
                 214                               ;
                 215                 reset_prompt: CALL menu_prompt                       ;prompt for user input
                 216                               COMPARE s0, character_H                ;test for commands and execute as required
                 217                               JUMP Z, reset_menu
                 218                               COMPARE s0, character_1
                 219                               JUMP Z, master_reset_regular
                 220                               CALL no_valid_input
                 221                               JUMP reset_prompt                      ;Try again!
                 222                               ;
                 223                               ; The master reset should result in a presence pulse.
                 224                               ; This will be reported and control passed to the appropriate
                 225                               ; menu in the sequence.
                 226                               ;
                 227         master_reset_regular: CALL send_CR
                 228                               CALL DS_init_regular_mode
                 229                               JUMP NC, reset_passed                  ;test for presence pulse
                 230                               CALL send_Fail
                 231                               JUMP reset_menu                        ;fail stays in reset menu
                 232                 reset_passed: CALL send_Pass                         ;pass progresses to ROM menu
                 233                               JUMP ROM_menu
                 234                               ;
                 235                               ; After a valid master reset, the only commands available are the ROM
                 236                               ; commands of which only Read ROM and Skip ROM are currently supported.
                 237                               ; Another master reset can be issued is so desired.
                 238                               ;
                 239                     ROM_menu: CALL send_ROM_menu                     ;Menu and command selection
                 240                               CALL send_CR
                 241                               ;
                 242                   ROM_prompt: CALL menu_prompt                       ;prompt for user input
                 243                               COMPARE s0, character_H                ;test for commands and execute as required
                 244                               JUMP Z, ROM_menu
                 245                               COMPARE s0, character_1
                 246                               JUMP Z, master_reset_regular           ;repeat reset as before
                 247                               COMPARE s0, character_2
                 248                               JUMP Z, read_ROM_command
                 249                               COMPARE s0, character_3
                 250                               JUMP Z, skip_ROM_command
                 251                               CALL no_valid_input
                 252                               JUMP ROM_prompt                        ;Try again!
                 253                               ;
                 254                               ;
                 255                               ;
                 256                               ; After a valid ROM command the DS2432 specific memory commands and SHA-1
                 257                               ; functions become accessible. Each of these end with the DS2432 returned
                 258                               ; back to the waiting for ROM command state completing the menu sequence.
                 259                               ;
                 260                  DS2432_menu: CALL send_DS2432_menu                  ;Menu and command selection
                 261                               CALL send_CR
                 262                               ;
                 263                DS2432_prompt: CALL menu_prompt                       ;prompt for user input
                 264                               COMPARE s0, character_H                ;test for commands and execute as required
                 265                               JUMP Z, DS2432_menu
                 266                               COMPARE s0, character_1
                 267                               JUMP Z, master_reset_regular           ;repeat reset as before
                 268                               COMPARE s0, character_2
                 269                               JUMP Z, read_memory_command
                 270                               COMPARE s0, character_3
                 271                               JUMP Z, write_scratchpad_command
                 272                               COMPARE s0, character_4
                 273                               JUMP Z, read_scratchpad_command
                 274                               COMPARE s0, character_5
                 275                               JUMP Z, write_byte_command
                 276                               COMPARE s0, character_6
                 277                               JUMP Z, read_byte_command
                 278                               CALL no_valid_input
                 279                               JUMP DS2432_prompt                     ;Try again!
                 280                               ;
                 281                               ;
                 282                               ;
                 283                               ;
                 284                               ;
                 285                               ;**************************************************************************************
                 286                               ; Prompt and selection tasks used in menus.
                 287                               ;**************************************************************************************
                 288                               ;
                 289                               ; Prompts for input with > character and waits for key stroke which is
                 290                               ; returned in upper case in register s0
                 291                               ;
                 292                  menu_prompt: CALL send_CR
                 293                               CALL send_CR
                 294                               LOAD UART_data, character_greater_than ;prompt for input
                 295                               CALL send_to_UART
                 296                               CALL read_upper_case
                 297                               RETURN
                 298                               ;
                 299               no_valid_input: CALL send_CR                           ;no valid command input
                 300                               LOAD UART_data, character_question     ;display ???
                 301                               CALL send_to_UART
                 302                               CALL send_to_UART
                 303                               CALL send_to_UART
                 304                               RETURN
                 305                               ;
                 306                               ;
                 307                               ;**************************************************************************************
                 308                               ; DS2432 Read ROM Command.
                 309                               ;**************************************************************************************
                 310                               ;
                 311                               ; The read ROM command (33 hex) allows the 8-bit family code, 48-bit unique serial
                 312                               ; number and 8-bit CRC to be read from the DS2432 device.
                 313                               ;
                 314                               ; This routine reads the values and places them in KCPSM3 scratch pad memory
                 315                               ; locations for future reference. These locations should be defined with constants
                 316                               ; as follows and MUST be in consecutive ascending locations.
                 317                               ;
                 318                               ;  family_code
                 319                               ;     Location to store family code which should be 33 hex
                 320                               ;  serial_number0 to serial_number5
                 321                               ;     6 bytes to hold 48-bit serial number (LS-byte first).
                 322                               ;  read_ROM_CRC
                 323                               ;     8-bit CRC value for the above data.
                 324                               ;
                 325                               ;
                 326                               ; The routine also displays the values read and performs a verification of the
                 327                               ; 8-bit CRC displaying a 'pass' or 'fail' message as appropriate.
                 328                               ;
                 329             read_ROM_command: LOAD s3, 33                            ;Read ROM Command
                 330                               CALL write_byte_slow                   ;transmit command
                 331                               LOAD s5, family_code                   ;memory pointer
                 332                read_ROM_loop: CALL read_byte_slow                    ;read response into s3
                 333                               STORE s3, (s5)                         ;store value
                 334                               COMPARE s5, read_ROM_CRC               ;8-bytes to read
                 335                               JUMP Z, display_ROM
                 336                               ADD s5, 01
                 337                               JUMP read_ROM_loop
                 338                  display_ROM: CALL send_CR
                 339                               CALL send_code                         ;'code=' to display family code
                 340                               FETCH s0, family_code
                 341                               CALL send_hex_byte
                 342                               CALL send_CR
                 343                               CALL send_serial                       ;'serial=' to display family code
                 344                               LOAD s5, serial_number5                ;memory pointer starting MS-byte first
                 345             disp_serial_loop: FETCH s0, (s5)
                 346                               CALL send_hex_byte
                 347                               COMPARE s5, serial_number0
                 348                               JUMP Z, end_serial
                 349                               SUB s5, 01
                 350                               JUMP disp_serial_loop
                 351                   end_serial: CALL send_CR
                 352                               CALL send_CRC                          ;'CRC=' to display CRC value
                 353                               FETCH s0, read_ROM_CRC
                 354                               CALL send_hex_byte
                 355                               CALL send_CR
                 356                               CALL compute_CRC8                      ;compute CRC value in s0
                 357                               FETCH s1, read_ROM_CRC                 ;compare with received value
                 358                               COMPARE s0, s1
                 359                               JUMP NZ, crc8_fail
                 360                               CALL send_Pass
                 361                               JUMP DS2432_menu                       ;now in memory and SHA-1 functions level
                 362                    crc8_fail: CALL send_Fail
                 363                               JUMP ROM_menu                          ;can not proceed to next level
                 364                               ;
                 365                               ;
                 366                               ;
                 367                               ;**************************************************************************************
                 368                               ; DS2432 Skip ROM Command.
                 369                               ;**************************************************************************************
                 370                               ;
                 371                               ; The skip ROM command (CC hex) is a short cut to the memory commands and SHA-1
                 372                               ; functions which means that the 64 bit ROM contents do not have to be read.
                 373                               ;
                 374                               ;
                 375             skip_ROM_command: LOAD s3, CC                            ;Skip ROM Command
                 376                               CALL write_byte_slow                   ;transmit command
                 377                               CALL send_OK
                 378                               JUMP DS2432_menu
                 379                               ;
                 380                               ;
                 381                               ;
                 382                               ;**************************************************************************************
                 383                               ; DS2432 Read Memory Command.
                 384                               ;**************************************************************************************
                 385                               ;
                 386                               ; The read memory command (F0 hex) allows the entire memory contents to be read
                 387                               ; except for the secret. This routine displays the address followed by 8 bytes
                 388                               ; of data on each line until the address 0097 is reached.
                 389                               ;
                 390                               ; The initial 'F0' command must be followed by the 16-bit start address transmitted
                 391                               ; LS-byte first. Then reads must continue until address 0097 has been read for the
                 392                               ; command to complete naturally (otherwise a master reset is required).
                 393                               ;
                 394                               ;
                 395                               ;
                 396          read_memory_command: LOAD s3, F0                            ;read memory Command
                 397                               CALL write_byte_slow                   ;transmit command
                 398                               LOAD s5, 00                            ;initial address in [s5,s4]=0000
                 399                               LOAD s4, 00
                 400                               LOAD s3, s4                            ;transmit address
                 401                               CALL write_byte_slow
                 402                               LOAD s3, s5
                 403                               CALL write_byte_slow
                 404                rmc_line_loop: CALL send_CR
                 405                               LOAD s0, s5                            ;display 16-bit address
                 406                               CALL send_hex_byte
                 407                               LOAD s0, s4
                 408                               CALL send_hex_byte
                 409                               CALL send_space
                 410                               CALL send_space
                 411                rmc_data_loop: CALL send_space
                 412                               CALL read_byte_slow                    ;read data into s3
                 413                               LOAD s0, s3                            ;display byte
                 414                               CALL send_hex_byte
                 415                               ADD s4, 01                             ;increment address
                 416                               ADDCY s5, 00
                 417                               TEST s4, 07                            ;test for 8-byte boundary
                 418                               JUMP NZ, rmc_data_loop
                 419                               COMPARE s4, 98                         ;test for last address
                 420                               JUMP NZ, rmc_line_loop
                 421                               CALL send_OK
                 422                               JUMP reset_menu                        ;needs master reset next
                 423                               ;
                 424                               ;
                 425                               ;**************************************************************************************
                 426                               ; DS2432 Write Scratchpad Memory Command.
                 427                               ;**************************************************************************************
                 428                               ;
                 429                               ; The write scratchpad memory command (0F hex) allows 8-bytes of data to be written
                 430                               ; together with a target address for final storage in the main memory map.
                 431                               ;
                 432                               ; The DS2432 provides an initial confirmation of the write by returning a 16-bit CRC
                 433                               ; value which KCPSM3 tests. The CRC is computed based on the command, address and
                 434                               ; data transmitted (11 bytes). To achieve this, all bytes transmitted to the DS2432
                 435                               ; are recorded in KCPSM3 scratch pad memory in ascending locations starting at
                 436                               ; the location defined by constant 'command_start'.
                 437                               ;
                 438                               ; This routine prompts the user to enter the 16-bit target address is to be loaded
                 439                               ; into the target address registers TA2 and TA1 in the DS2432 device. Note that only
                 440                               ; address values below 0090 hex are valid. If the address is too high, then the
                 441                               ; DS2432 aborts the command and this routine will too.
                 442                               ;
                 443                               ; Also note that the address will be forced internally to the DS2432 to match an
                 444                               ; 8-byte boundary address in which the least significant 3-bits are reset to '000'
                 445                               ; regardless of the address provided. The CRC still reflects the transmitted address.
                 446                               ;
                 447                               ; After providing a valid address, the routine then prompts the user to enter
                 448                               ; 8 bytes of data which are written to the DS2432.
                 449                               ;
                 450                               ;
                 451                               ;
                 452     write_scratchpad_command: LOAD sE, command_start                 ;pointer to memory
                 453                               LOAD s3, 0F                            ;write scratchpad memory Command
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
                 454                               STORE s3, (sE)                         ;record command sequence
                 455                               ADD sE, 01                             ;increment pointer
                 456                               CALL write_byte_slow                   ;transmit command
                 457                wsc_addr_loop: CALL send_address                      ;obtain 16-bit address 0000 to FFFF in [s5,s4]
                 458                               CALL obtain_8bits
                 459                               JUMP C, wsc_addr_loop                  ;bad input address
                 460                               LOAD s5, s0
                 461                               CALL obtain_8bits
                 462                               JUMP C, wsc_addr_loop                  ;bad input address
                 463                               LOAD s4, s0
                 464                               LOAD s3, s4                            ;transmit target address TA1 (LS-Byte)
                 465                               STORE s3, (sE)                         ;record command sequence
                 466                               ADD sE, 01                             ;increment pointer
                 467                               CALL write_byte_slow
                 468                               LOAD s3, s5                            ;transmit target address TA2 (MS-Byte)
                 469                               STORE s3, (sE)                         ;record command sequence
                 470                               ADD sE, 01                             ;increment pointer
                 471                               CALL write_byte_slow
                 472                               COMPARE s5, 00                         ;check address less than 0090 hex
                 473                               JUMP NZ, end_write_scratchpad          ;DS2432 aborts command and so
                 474                               COMPARE s4, 90                         ;no need to read data bytes.
                 475                               JUMP NC, end_write_scratchpad
                 476                               LOAD s4, 00                            ;initialise byte counter
                 477                wsc_data_loop: CALL send_data                         ;obtain a byte of data
                 478                               LOAD UART_data, s4                     ;display which byte requested
                 479                               ADD UART_data, character_0             ;convert to ASCII
                 480                               CALL send_to_UART
                 481                               CALL send_equals
                 482                               CALL obtain_8bits
                 483                               JUMP C, wsc_data_loop                  ;bad input data
                 484                               LOAD s3, s0                            ;transmit byte
                 485                               STORE s3, (sE)                         ;record command sequence
                 486                               ADD sE, 01                             ;increment pointer
                 487                               CALL write_byte_slow
                 488                               ADD s4, 01                             ;count bytes
                 489                               COMPARE s4, 08
                 490                               JUMP NZ, wsc_data_loop
                 491                               CALL read_byte_slow                    ;read back the 16-bit CRC into [s5,s4]
                 492                               LOAD s4, s3
                 493                               CALL read_byte_slow
                 494                               LOAD s5, s3
                 495                               STORE s4, (sE)                         ;record command sequence
                 496                               ADD sE, 01                             ;increment pointer
                 497                               STORE s5, (sE)                         ;record command sequence
                 498                               CALL send_CR
                 499                               CALL send_CRC                          ;'CRC=' to display CRC value
                 500                               LOAD s0, s5
                 501                               CALL send_hex_byte
                 502                               LOAD s0, s4
                 503                               CALL send_hex_byte
                 504                               CALL send_CR
                 505                               LOAD s2, 0B                            ;11 (0B hex) bytes transmitted in this command
                 506                               CALL compute_CRC16                     ;compute CRC value in [s1,s0]
                 507                               FETCH s5, (sE)                         ;compare with received value
                 508                               SUB sE, 01
                 509                               FETCH s4, (sE)                         ;compare with received value
                 510                               COMPARE s5, s1
                 511                               JUMP NZ, wsc_crc16_fail
                 512                               COMPARE s4, s0
                 513                               JUMP NZ, wsc_crc16_fail
                 514                               CALL send_Pass
                 515                               JUMP reset_menu                        ;needs master reset next
                 516               wsc_crc16_fail: CALL send_Fail
                 517         end_write_scratchpad: JUMP reset_menu                        ;needs master reset next
                 518                               ;
                 519                               ;
                 520                               ;
                 521                               ;**************************************************************************************
                 522                               ; Write Byte Command.
                 523                               ;**************************************************************************************
                 524                               ;
                 525                               ; This routine simply allows you to specify any byte and write it to the DS2432 device.
                 526                               ; Apart from checking that the value is in the range 00 to FF hex, there is no checking
                 527                               ; of the meaning of the value to the DS2432 device and all attempts to track the
                 528                               ; state machine will be lost.
                 529                               ;
                 530                               ;
                 531           write_byte_command: CALL send_CR
                 532                               CALL send_Byte                         ;obtain a byte of data
                 533                               CALL send_equals
                 534                               CALL obtain_8bits
                 535                               JUMP C, write_byte_command             ;bad input data
                 536                               LOAD s3, s0                            ;transmit byte
                 537                               CALL write_byte_slow                   ;transmit byte
                 538                               CALL send_OK
                 539                               JUMP DS2432_menu                       ;remain in memory and function menu
                 540                               ;
                 541                               ;
                 542                               ;
                 543                               ;**************************************************************************************
                 544                               ; Read Byte Command.
                 545                               ;**************************************************************************************
                 546                               ;
                 547                               ; This routine will attempt to read a single byte from the DS2432 device.
                 548                               ; The results will be displayed on the terminal. There is no checking of the meaning
                 549                               ; of the value received from the DS2432 device and all attempts to track the
                 550                               ; state machine will be lost.
                 551                               ;
                 552                               ;
                 553            read_byte_command: CALL send_CR
                 554                               CALL send_Byte                         ;obtain a byte of data
                 555                               CALL send_equals
                 556                               CALL read_byte_slow                    ;receive byte
                 557                               LOAD s0, s3                            ;display value
                 558                               CALL send_hex_byte
                 559                               CALL send_OK
                 560                               JUMP DS2432_menu                       ;remain in memory and function menu
                 561                               ;
                 562                               ;
                 563                               ;
                 564                               ;
                 565                               ;**************************************************************************************
                 566                               ; DS2432 Read Scratchpad Memory Command.
                 567                               ;**************************************************************************************
                 568                               ;
                 569                               ; The read scratchpad memory command (AA hex) allows the 8-bytes of data previously
                 570                               ; to be written into the scratchpad memory to be read back for verification together with
                 571                               ; the target address, a transfer status register and a 16-bit CRC value.
                 572                               ;
                 573                               ; The 16-bit CRC is formed of the command byte, address TA1 and TA2, E/S byte and 8 data
                 574                               ; bytes as transmitted (12 bytes). These may not be the same as the values provided
                 575                               ; during a previous write to scratchpad memory. All these bytes are recorded in KCPSM3
                 576                               ; scratch pad memory in ascending locations starting at the location defined by
                 577                               ; constant 'command_start'.
                 578                               ;
                 579                               ;
                 580      read_scratchpad_command: LOAD sE, command_start                 ;pointer to memory
                 581                               LOAD s3, AA                            ;read scratchpad memory Command
                 582                               STORE s3, (sE)                         ;record command sequence
                 583                               ADD sE, 01                             ;increment pointer
                 584                               CALL write_byte_slow                   ;transmit command
                 585                               CALL send_address                      ;display 'Address='
                 586                               CALL read_byte_slow                    ;read address into [s5,s4]
                 587                               LOAD s4, s3
                 588                               CALL read_byte_slow
                 589                               LOAD s5, s3
                 590                               STORE s4, (sE)                         ;record sequence
                 591                               ADD sE, 01                             ;increment pointer
                 592                               STORE s5, (sE)                         ;record sequence
                 593                               ADD sE, 01                             ;increment pointer
                 594                               LOAD s0, s5                            ;display address
                 595                               CALL send_hex_byte
                 596                               LOAD s0, s4
                 597                               CALL send_hex_byte
                 598                               CALL send_ES                           ;display 'E/S='
                 599                               CALL read_byte_slow                    ;read E/S register
                 600                               STORE s3, (sE)                         ;record sequence
                 601                               ADD sE, 01                             ;increment pointer
                 602                               LOAD s0, s3                            ;display value
                 603                               CALL send_hex_byte
                 604                               CALL send_data                         ;display 'Data='
                 605                               CALL send_equals
                 606                               LOAD s4, 08                            ;8 bytes to read
                 607                     rsc_loop: CALL send_space
                 608                               CALL read_byte_slow                    ;read data byte
                 609                               STORE s3, (sE)                         ;record sequence
                 610                               ADD sE, 01                             ;increment pointer
                 611                               LOAD s0, s3                            ;display value
                 612                               CALL send_hex_byte
                 613                               SUB s4, 01                             ;count bytes
                 614                               JUMP NZ, rsc_loop
                 615                               CALL read_byte_slow                    ;read 16-bit CRC into [s5,s4]
                 616                               LOAD s4, s3
                 617                               CALL read_byte_slow
                 618                               LOAD s5, s3
                 619                               STORE s4, (sE)                         ;record command sequence
                 620                               ADD sE, 01                             ;increment pointer
                 621                               STORE s5, (sE)                         ;record command sequence
                 622                               CALL send_CR
                 623                               CALL send_CRC                          ;'CRC=' to display CRC value
                 624                               LOAD s0, s5
                 625                               CALL send_hex_byte
                 626                               LOAD s0, s4
                 627                               CALL send_hex_byte
                 628                               CALL send_CR
                 629                               LOAD s2, 0C                            ;12 (0C hex) bytes in this command
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
                 630                               CALL compute_CRC16                     ;compute CRC value in [s1,s0]
                 631                               FETCH s5, (sE)                         ;compare with received value
                 632                               SUB sE, 01
                 633                               FETCH s4, (sE)                         ;compare with received value
                 634                               COMPARE s5, s1
                 635                               JUMP NZ, rsc_crc16_fail
                 636                               COMPARE s4, s0
                 637                               JUMP NZ, rsc_crc16_fail
                 638                               CALL send_Pass
                 639                               JUMP reset_menu                        ;needs master reset next
                 640               rsc_crc16_fail: CALL send_Fail
                 641                               JUMP reset_menu                        ;needs master reset next
                 642                               ;
                 643                               ;
                 644                               ;
                 645                               ;**************************************************************************************
                 646                               ; Compute 8-bit CRC used by DS2432.
                 647                               ;**************************************************************************************
                 648                               ;
                 649                               ; The DS2432 computes an 8-bit CRC using the polynomial X8 + X5 + X4 + 1.
                 650                               ; See the DS2432 data sheet for full details.
                 651                               ;
                 652                               ; Test input value of value 00 00 00 01 B8 1C 02
                 653                               ; should produce CRC=A2.
                 654                               ;
                 655                               ; This routine computes the same CRC based on the values stored in the KCPSM3
                 656                               ; scratch pad memory by the read ROM command. The result is returned in register s0.
                 657                               ;
                 658                               ; Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9
                 659                               ;
                 660                               ;
                 661                               ;Start by loading family code and serial number (56-bits) into
                 662                               ;register set [s9,s8,s7,s6,s5,s4,s3] so they can be shifted out
                 663                               ;LSB first.
                 664                               ;
                 665                 compute_CRC8: FETCH s3, family_code
                 666                               FETCH s4, serial_number0
                 667                               FETCH s5, serial_number1
                 668                               FETCH s6, serial_number2
                 669                               FETCH s7, serial_number3
                 670                               FETCH s8, serial_number4
                 671                               FETCH s9, serial_number5
                 672                               LOAD s2, 38                            ;56 bits to shift (38 hex)
                 673                               LOAD s0, 00                            ;clear CRC value
                 674                    crc8_loop: LOAD s1, s0                            ;copy current CRC value
                 675                               XOR s1, s3                             ;Need to know LSB XOR next input bit
                 676                               TEST s1, 01                            ;test result of XOR in LSB
                 677                               JUMP NC, crc8_shift
                 678                               XOR s0, 18                             ;compliment bits 3 and 4 of CRC
                 679                   crc8_shift: SR0 s1                                 ;Carry gets LSB XOR next input bit
                 680                               SRA s0                                 ;shift Carry into MSB to form new CRC value
                 681                               SR0 s9                                 ;shift input value
                 682                               SRA s8
                 683                               SRA s7
                 684                               SRA s6
                 685                               SRA s5
                 686                               SRA s4
                 687                               SRA s3
                 688                               SUB s2, 01                             ;count iterations
                 689                               JUMP NZ, crc8_loop
                 690                               RETURN
                 691                               ;
                 692                               ;
                 693                               ;
                 694                               ;**************************************************************************************
                 695                               ; Compute 16-bit CRC used by DS2432.
                 696                               ;**************************************************************************************
                 697                               ;
                 698                               ; The DS2432 computes a 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                 699                               ; See the DS2432 data sheet for full details.
                 700                               ;
                 701                               ; Note that the value formed in the CRC shift register is inverted to give the
                 702                               ; same value as that sent from the DS2432 during scratchpad write, scratchpad read
                 703                               ; and read auth page commands.
                 704                               ;
                 705                               ; This routine computes the CRC based on the values stored in the KCPSM3
                 706                               ; scratch pad memory starting at address defined by constant 'command_start'.
                 707                               ; register 's2' must specify how many bytes are to be used in the calculation
                 708                               ; and the CRC is returned in register pair [s1,s0] once it has been inverted.
                 709                               ;
                 710                               ; Registers used s0,s1,s2,s3,s4,s5,s6
                 711                               ;
                 712                               ;
                 713                               ;Start by loading family code and serial number (56-bits) into
                 714                               ;register set [s9,s8,s7,s6,s5,s4,s3] so they can be shifted out
                 715                               ;LSB first.
                 716                               ;
                 717                compute_CRC16: LOAD s5, command_start                 ;memory pointer
                 718                               LOAD s0, 00                            ;clear CRC value
                 719                               LOAD s1, 00
                 720              crc16_byte_loop: FETCH s4, (s5)                         ;read input byte
                 721                               LOAD s3, 08                            ;8-bits to shift
                 722               crc16_bit_loop: LOAD s6, s0                            ;copy current CRC value
                 723                               XOR s6, s4                             ;Need to know LSB XOR next input bit
                 724                               TEST s6, 01                            ;test result of XOR in LSB
                 725                               JUMP NC, crc16_shift
                 726                               XOR s0, 02                             ;compliment bit 1 of CRC
                 727                               XOR s1, 40                             ;compliment bit 14 of CRC
                 728                  crc16_shift: SR0 s6                                 ;Carry gets LSB XOR next input bit
                 729                               SRA s1                                 ;shift Carry into MSB to form new CRC value
                 730                               SRA s0
                 731                               SR0 s4                                 ;shift input value
                 732                               SUB s3, 01                             ;count bits
                 733                               JUMP NZ, crc16_bit_loop                ;next bit
                 734                               ADD s5, 01                             ;increment memory pointer
                 735                               SUB s2, 01                             ;count bytes
                 736                               JUMP NZ, crc16_byte_loop               ;next byte
                 737                               XOR s0, FF                             ;1's complement of CRC value
                 738                               XOR s1, FF
                 739                               RETURN
                 740                               ;
                 741                               ;
                 742                               ;**************************************************************************************
                 743                               ; Initialise the DS2432 1-wire interface.
                 744                               ;**************************************************************************************
                 745                               ;
                 746                               ; The 1-wire interface is an open-collector communication scheme employing an external
                 747                               ; pull-up resistor of 680 Ohms.
                 748                               ;
                 749                               ; The hardware section of this translates the one bit signal from PicoBlaze such that
                 750                               ; when this signal is Low the output is driven Low, but when it is High, it turns off
                 751                               ; the output buffer and the signal is pulled High externally.
                 752                               ;
                 753                               ; This initialisation routine simply ensures that the line is High after configuration.
                 754                               ; It is vital that DS_wire is generally in the High state because it is the only way in
                 755                               ; which the DS2432 device derives power to operate.
                 756                               ;
                 757                               ; Registers used s0
                 758                               ;
                 759                 DS_wire_init: LOAD s0, DS_wire
                 760                               OUTPUT s0, DS_wire_out_port
                 761                               RETURN
                 762                               ;
                 763                               ;
                 764                               ;**************************************************************************************
                 765                               ; DS2432 initialisation - Regular Speed.
                 766                               ;**************************************************************************************
                 767                               ;
                 768                               ; The initialisation sequence must be performed before any communication can be
                 769                               ; made with the DS2432 device. This involves the application of an active Low master
                 770                               ; reset pulse.
                 771                               ;
                 772                               ; The regular (slow) speed communication is established by transmitting an active
                 773                               ; Low reset pulse for a duration of at least 480us. This design generates a 500us pulse.
                 774                               ;
                 775                               ; The DS2432 acknowledges the reset and the setting of regular mode by generating an
                 776                               ; active Low 'Rx Presence Pulse'. This presence pulse can start 15 to 60us after the
                 777                               ; reset pulse and will end between 120 and 300us after the reset pulse.
                 778                               ;
                 779                               ; To confirm that regular mode has been set, this routine confirms that the presence pulse
                 780                               ; is active only after 60us have elapsed since the reset pulse. This ensures that the
                 781                               ; faster presence pulse of overdrive mode can not be detected.
                 782                               ;
                 783                               ; The carry flag will be set if no valid presence pulse was received (wire remained High) and
                 784                               ; can be used to indicate an initialisation failure or success.
                 785                               ;
                 786                               ; The routine only completes 300us after the presence pulse to ensure the DS2432 has
                 787                               ; completed the presence pulse and is ready for the first operation.
                 788                               ;
                 789                               ; Registers used s0,s1,s2
                 790                               ;
                 791         DS_init_regular_mode: LOAD s0, 00                            ;transmit reset pulse
                 792                               OUTPUT s0, DS_wire_out_port
                 793                               ;Delay of 500us is equivalent to 12500 instructions at 50MHz.
                 794                               ;This delay loop is formed of 28 instructions requiring 446 repetitions.
                 795                               LOAD s2, 01                            ;[s3,s2]=445 decimal (01BD hex)
                 796                               LOAD s1, BD
                 797                rm_wait_500us: CALL delay_1us                         ;25 instructions including CALL
                 798                               SUB s1, 01                             ;decrement delay counter
                 799                               SUBCY s2, 00
                 800                               JUMP NC, rm_wait_500us                 ;repeat until -1
                 801                               LOAD s0, 01                            ;end of regular reset pulse
                 802                               OUTPUT s0, DS_wire_out_port
                 803                               ;Delay of 60us is equivalent to 1500 instructions at 50MHz.
                 804                               ;This delay and is formed of 27 instructions requiring 56 repetitions.
                 805                               LOAD s1, 38                            ;56 (38 hex)
                 806                 rm_wait_60us: CALL delay_1us                         ;25 instructions including CALL
                 807                               SUB s1, 01                             ;decrement delay counter
                 808                               JUMP NZ, rm_wait_60us                  ;repeat until zero
                 809                               ;The DS_wire is now checked at approximately 1us intervals for the next 240us looking
                 810                               ;to detect an active Low presence pulse. The 240us is equivalent to 6000 instructions
                 811                               ;at 50MHz and this polling loop is formed of 33 instructions requiring 182 repetitions.
                 812                               LOAD s2, 01                            ;set bit which will be reset by a presence pulse
                 813                               LOAD s1, B6                            ;182 (B6 hex)
                 814                rm_poll_240us: CALL delay_1us                         ;25 instructions including CALL
                 815                               CALL read_DS_wire                      ;read wire - 5 instructions including CALL
                 816                               AND s2, s0                             ;clear flag if DS_wire was Low
                 817                               SUB s1, 01                             ;decrement delay counter
                 818                               JUMP NZ, rm_poll_240us                 ;repeat until zero
                 819                               TEST s2, 01                            ;set carry flag if no pulse detected
                 820                               RETURN
                 821                               ;
                 822                               ;
                 823                               ;**************************************************************************************
                 824                               ; Read the DS_wire
                 825                               ;**************************************************************************************
                 826                               ;
                 827                               ; The DS_wire signal is read and returned in bit0 of register 's0'.
                 828                               ; Additionally the carry flag is set if the signal is High and reset if Low
                 829                               ;
                 830                               ; Registers used s0
                 831                               ;
                 832                 read_DS_wire: INPUT s0, DS_wire_in_port
                 833                               AND s0, DS_wire                        ;ensure only bit0 is active
                 834                               TEST s0, DS_wire                       ;set carry flag if DS_wire is High
                 835                               RETURN
                 836                               ;
                 837                               ;
                 838                               ;
                 839                               ;**************************************************************************************
                 840                               ; Write a byte to DS2432 in regular speed mode.
                 841                               ;**************************************************************************************
                 842                               ;
                 843                               ; Bytes are written to the DS2432 with LSB first.
                 844                               ;
                 845                               ; The byte to be written should be provided in register 's3' and this will be preserved.
                 846                               ;
                 847                               ; Registers used s0,s1,s2,s3
                 848                               ;
                 849              write_byte_slow: LOAD s2, 08                            ;8 bits to transmit
                 850                     wbs_loop: RR s3                                  ;test next bit LSB first
                 851                               JUMP C, wbs1                           ;transmit '0' or '1'
                 852                               CALL write_Low_slow
                 853                               JUMP next_slow_bit
                 854                         wbs1: CALL write_High_slow
                 855                next_slow_bit: SUB s2, 01                             ;count bits
                 856                               JUMP NZ, wbs_loop                      ;repeat until 8-bits transmitted
                 857                               RETURN
                 858                               ;
                 859                               ;
                 860                               ;
                 861                               ;**************************************************************************************
                 862                               ; Write a '0' to DS_wire in regular speed mode.
                 863                               ;**************************************************************************************
                 864                               ;
                 865                               ; To write a '0' to the DS_wire the signal must be Low for 60 to 120us. This design
                 866                               ; generates a 78us active Low pulse.
                 867                               ;
                 868                               ; The DS2432 then requires at least 1us of recovery time for which this routine
                 869                               ; provides a 2us delay such that the entire write Low process (slot time) is 80us.
                 870                               ; A recovery time of 1us was also found to be marginal in practice probably due
                 871                               ; to the rise time of the DS_wire via the external pull up resistor.
                 872                               ;
                 873                               ; Registers used s0,s1
                 874                               ;
                 875               write_Low_slow: LOAD s0, 00                            ;transmit Low pulse
                 876                               OUTPUT s0, DS_wire_out_port
                 877                               ;Delay of 78us is equivalent to 1950 instructions at 50MHz.
                 878                               ;This delay loop is formed of 27 instructions requiring 72 repetitions.
                 879                               LOAD s1, 48                            ;72 (48 hex)
                 880                wls_wait_78us: CALL delay_1us                         ;25 instructions including CALL
                 881                               SUB s1, 01                             ;decrement delay counter
                 882                               JUMP NZ, wls_wait_78us                 ;repeat until zero
                 883                               LOAD s0, 01                            ;end of Low pulse
                 884                               OUTPUT s0, DS_wire_out_port
                 885                               CALL delay_1us                         ;2us recovery time
                 886                               CALL delay_1us
                 887                               RETURN
                 888                               ;
                 889                               ;
                 890                               ;**************************************************************************************
                 891                               ; Write a '1' to DS_wire in regular speed mode.
                 892                               ;**************************************************************************************
                 893                               ;
                 894                               ; To write a '1' to the DS_wire the signal must be Low for 1 to 15us to instigate the
                 895                               ; write of the data. This design generates an 8us active Low pulse for this purpose.
                 896                               ;
                 897                               ; Then the output must be High for 53 to 114us to provide the '1' for the DS2432 to
                 898                               ; read and then provide recovery time. This design implements a 72us delay such that
                 899                               ; the entire write High process (slot time) is 80us
                 900                               ;
                 901                               ; Registers used s0,s1
                 902                               ;
                 903              write_High_slow: LOAD s0, 00                            ;transmit Low pulse
                 904                               OUTPUT s0, DS_wire_out_port
                 905                               ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                 906                               ;This delay loop is formed of 27 instructions requiring 8 repetitions.
                 907                               LOAD s1, 08                            ;8 (08 hex)
                 908                 whs_wait_8us: CALL delay_1us                         ;25 instructions including CALL
                 909                               SUB s1, 01                             ;decrement delay counter
                 910                               JUMP NZ, whs_wait_8us                  ;repeat until zero
                 911                               LOAD s0, 01                            ;end of Low pulse
                 912                               OUTPUT s0, DS_wire_out_port
                 913                               ;Delay of 72us is equivalent to 1800 instructions at 50MHz.
                 914                               ;This delay loop is formed of 27 instructions requiring 67 repetitions.
                 915                               LOAD s1, 43                            ;67 (43 hex)
                 916                whs_wait_72us: CALL delay_1us                         ;25 instructions including CALL
                 917                               SUB s1, 01                             ;decrement delay counter
                 918                               JUMP NZ, whs_wait_72us                 ;repeat until zero
                 919                               RETURN
                 920                               ;
                 921                               ;
                 922                               ;
                 923                               ;**************************************************************************************
                 924                               ; Read a byte from DS2432 in regular speed mode.
                 925                               ;**************************************************************************************
                 926                               ;
                 927                               ; Bytes are read from the DS2432 with LSB first.
                 928                               ;
                 929                               ; The byte read will be returned in register 's3'.
                 930                               ;
                 931                               ; Registers used s0,s1,s2,s3
                 932                               ;
                 933               read_byte_slow: LOAD s2, 08                            ;8 bits to receive
                 934                     rbs_loop: CALL read_bit_slow                     ;read next bit LSB first
                 935                               SUB s2, 01                             ;count bits
                 936                               JUMP NZ, rbs_loop                      ;repeat until 8-bits received
                 937                               RETURN
                 938                               ;
                 939                               ;
                 940                               ;
                 941                               ;
                 942                               ;**************************************************************************************
                 943                               ; Read a data bit sent from the DS2432 in regular speed mode.
                 944                               ;**************************************************************************************
                 945                               ;
                 946                               ; To read a bit, PicoBlaze must initiate the processed with an active Low pulse of
                 947                               ; 1 to 15us. This design generates a 4us active Low pulse for this purpose.
                 948                               ;
                 949                               ; Then DS2432 responds to the Low pulse by diving DS_wire in two differet ways
                 950                               ; depending on the logic level it is trying to send back.
                 951                               ;
                 952                               ; For a logic '0' the DS2432 will drive the DS-wire Low for up to 15us after
                 953                               ; the start of the instigating pulse. Therefore PicoBlaze must read the DS-wire
                 954                               ; before this time has elapsed but only after it has itself released the wire.
                 955                               ;
                 956                               ; For a logic '1' the DS2432 will do nothing and hence the DS-wire will be pulled
                 957                               ; High by the external resistor after PicoBlaze has released the wire. PicoBlaze
                 958                               ; will sample the wire and detect the High level.
                 959                               ;
                 960                               ; In this design, PicoBlaze needs to detect the logic state of the wire after
                 961                               ; releasing the wire at 4us. Sampling the wire too quickly would not provide
                 962                               ; adequate time for a High signal to be formed by the pull up resistor. However, it
                 963                               ; must sample the wire before 15us have elapsed and any potential Low is removed.
                 964                               ; This design samples the wire at 12us which is 8us after the initiation pulse ends.
                 965                               ;
                 966                               ; A further delay of 68us is then allowed for the DS2432 to stop transmitting and
                 967                               ; to recover. This also mean that the entire read process (slot time) is 80us.
                 968                               ;
                 969                               ; The received data bit is SHIFTED into the MSB of register 's3'. In this way
                 970                               ; the reception of 8-bits will shift the first bit into the LSB position of 's3'.
                 971                               ;
                 972                               ; Registers used s0,s1,s3
                 973                               ;
                 974                read_bit_slow: LOAD s0, 00                            ;transmit Low pulse
                 975                               OUTPUT s0, DS_wire_out_port
                 976                               ;Delay of 4us is equivalent to 100 instructions at 50MHz.
                 977                               ;This delay loop is formed of 27 instructions requiring 4 repetitions.
                 978                               LOAD s1, 04                            ;4 (04 hex)
                 979                 rbs_wait_4us: CALL delay_1us                         ;25 instructions including CALL
                 980                               SUB s1, 01                             ;decrement delay counter
                 981                               JUMP NZ, rbs_wait_4us                  ;repeat until zero
                 982                               LOAD s0, 01                            ;end of Low pulse
                 983                               OUTPUT s0, DS_wire_out_port
                 984                               ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                 985                               ;This delay loop is formed of 27 instructions requiring 8 repetitions.
                 986                               LOAD s1, 08                            ;8 (08 hex)
                 987                 rbs_wait_8us: CALL delay_1us                         ;25 instructions including CALL
                 988                               SUB s1, 01                             ;decrement delay counter
                 989                               JUMP NZ, rbs_wait_8us                  ;repeat until zero
                 990                               CALL read_DS_wire                      ;sample wire (carry = state)
                 991                               SRA s3                                 ;shift received bit into MSB of s3
                 992                               ;Delay of 68us is equivalent to 1700 instructions at 50MHz.
                 993                               ;This delay loop is formed of 27 instructions requiring 63 repetitions.
                 994                               LOAD s1, 3F                            ;63 (3F hex)
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
                 995                rbs_wait_68us: CALL delay_1us                         ;25 instructions including CALL
                 996                               SUB s1, 01                             ;decrement delay counter
                 997                               JUMP NZ, rbs_wait_68us                 ;repeat until zero
                 998                               RETURN
                 999                               ;
                1000                               ;
                1001                               ;**************************************************************************************
                1002                               ; Software delay routines
                1003                               ;**************************************************************************************
                1004                               ;
                1005                               ; Delay of 1us.
                1006                               ;
                1007                               ; Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1008                               ; executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1009                               ; the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1010                               ;
                1011                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1012                               ;
                1013                               ; Register used s0
                1014                               ;
                1015                    delay_1us: LOAD s0, delay_1us_constant
                1016                     wait_1us: SUB s0, 01
                1017                               JUMP NZ, wait_1us
                1018                               RETURN
                1019                               ;
                1020                               ; Delay of 40us.
                1021                               ;
                1022                               ; Registers used s0, s1
                1023                               ;
                1024                   delay_40us: LOAD s1, 28                            ;40 x 1us = 40us
                1025                    wait_40us: CALL delay_1us
                1026                               SUB s1, 01
                1027                               JUMP NZ, wait_40us
                1028                               RETURN
                1029                               ;
                1030                               ;
                1031                               ; Delay of 1ms.
                1032                               ;
                1033                               ; Registers used s0, s1, s2
                1034                               ;
                1035                    delay_1ms: LOAD s2, 19                            ;25 x 40us = 1ms
                1036                     wait_1ms: CALL delay_40us
                1037                               SUB s2, 01
                1038                               JUMP NZ, wait_1ms
                1039                               RETURN
                1040                               ;
                1041                               ; Delay of 20ms.
                1042                               ;
                1043                               ; Registers used s0, s1, s2, s3
                1044                               ;
                1045                   delay_20ms: LOAD s3, 14                            ;20 x 1ms = 20ms
                1046                    wait_20ms: CALL delay_1ms
                1047                               SUB s3, 01
                1048                               JUMP NZ, wait_20ms
                1049                               RETURN
                1050                               ;
                1051                               ; Delay of approximately 1 second.
                1052                               ;
                1053                               ; Registers used s0, s1, s2, s3, s4
                1054                               ;
                1055                     delay_1s: LOAD s4, 14                            ;50 x 20ms = 1000ms
                1056                      wait_1s: CALL delay_20ms
                1057                               SUB s4, 01
                1058                               JUMP NZ, wait_1s
                1059                               RETURN
                1060                               ;
                1061                               ;
                1062                               ;**************************************************************************************
                1063                               ; UART communication routines
                1064                               ;**************************************************************************************
                1065                               ;
                1066                               ; Read one character from the UART
                1067                               ;
                1068                               ; Character read will be returned in a register called 'UART_data'.
                1069                               ;
                1070                               ; The routine first tests the receiver FIFO buffer to see if data is present.
                1071                               ; If the FIFO is empty, the routine waits until there is a character to read.
                1072                               ; As this could take any amount of time the wait loop could include a call to a
                1073                               ; subroutine which performs a useful function.
                1074                               ;
                1075                               ;
                1076                               ; Registers used s0 and UART_data
                1077                               ;
                1078               read_from_UART: INPUT s0, status_port                  ;test Rx_FIFO buffer
                1079                               TEST s0, rx_data_present               ;wait if empty
                1080                               JUMP NZ, read_character
                1081                               JUMP read_from_UART
                1082               read_character: INPUT UART_data, UART_read_port        ;read from FIFO
                1083                               RETURN
                1084                               ;
                1085                               ;
                1086                               ;
                1087                               ; Transmit one character to the UART
                1088                               ;
                1089                               ; Character supplied in register called 'UART_data'.
                1090                               ;
                1091                               ; The routine first tests the transmit FIFO buffer to see if it is full.
                1092                               ; If the FIFO is full, then the routine waits until it there is space.
                1093                               ;
                1094                               ; Registers used s0
                1095                               ;
                1096                 send_to_UART: INPUT s0, status_port                  ;test Tx_FIFO buffer
                1097                               TEST s0, tx_full                       ;wait if full
                1098                               JUMP Z, UART_write
                1099                               JUMP send_to_UART
                1100                   UART_write: OUTPUT UART_data, UART_write_port
                1101                               RETURN
                1102                               ;
                1103                               ;
                1104                               ;**************************************************************************************
                1105                               ; Useful ASCII conversion and handling routines
                1106                               ;**************************************************************************************
                1107                               ;
                1108                               ; Convert value provided in register s0 into ASCII characters
                1109                               ;
                1110                               ; The value provided must in the range 0 to 99 and will be converted into
                1111                               ; two ASCII characters.
                1112                               ;     The number of 'tens' will be represented by an ASCII character returned in register s1.
                1113                               ;     The number of 'units' will be represented by an ASCII character returned in register s0.
                1114                               ;
                1115                               ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
                1116                               ; the actual decimal value.
                1117                               ;
                1118                               ; Registers used s0 and s1.
                1119                               ;
                1120             decimal_to_ASCII: LOAD s1, 30                            ;load 'tens' counter with ASCII for '0'
                1121                 test_for_ten: ADD s1, 01                             ;increment 'tens' value
                1122                               SUB s0, 0A                             ;try to subtract 10 from the supplied value
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                1123                               JUMP NC, test_for_ten                  ;repeat if subtraction was possible without underflow.
                1124                               SUB s1, 01                             ;'tens' value one less ten due to underflow
                1125                               ADD s0, 3A                             ;restore units value (the remainder) and convert to ASCII
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                1126                               RETURN
                1127                               ;
                1128                               ;
                1129                               ;
                1130                               ; Convert character to upper case
                1131                               ;
                1132                               ; The character supplied in register s0.
                1133                               ; If the character is in the range 'a' to 'z', it is converted
                1134                               ; to the equivalent upper case character in the range 'A' to 'Z'.
                1135                               ; All other characters remain unchanged.
                1136                               ;
                1137                               ; Registers used s0.
                1138                               ;
                1139                   upper_case: COMPARE s0, 61                         ;eliminate character codes below 'a' (61 hex)
                1140                               RETURN C
                1141                               COMPARE s0, 7B                         ;eliminate character codes above 'z' (7A hex)
E: identifier cannot start with a digit: `7B'.
E: unexpected end of line.
                1142                               RETURN NC
                1143                               AND s0, DF                             ;mask bit5 to convert to upper case
                1144                               RETURN
                1145                               ;
                1146                               ;
                1147                               ; Convert character '0' to '9' to numerical value in range 0 to 9
                1148                               ;
                1149                               ; The character supplied in register s0. If the character is in the
                1150                               ; range '0' to '9', it is converted to the equivalent decimal value.
                1151                               ; Characters not in the range '0' to '9' are signified by the return
                1152                               ; with the CARRY flag set.
                1153                               ;
                1154                               ; Registers used s0.
                1155                               ;
                1156               1char_to_value: ADD s0, C6                             ;reject character codes above '9' (39 hex)
E: identifier cannot start with a digit: `1char_to_value'.
E: unexpected :.
                1157                               RETURN C                               ;carry flag is set
                1158                               SUB s0, F6                             ;reject character codes below '0' (30 hex)
                1159                               RETURN                                 ;carry is set if value not in range
                1160                               ;
                1161                               ;
                1162                               ; Determine the numerical value of a two character decimal string held in
                1163                               ; scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
                1164                               ;
                1165                               ; The string must be stored in two consecutive memory locations and the
                1166                               ; location of the first (tens) character supplied in the s1 register.
                1167                               ; The result is provided in register s2. Strings not using characters in the
                1168                               ; range '0' to '9' are signified by the return with the CARRY flag set.
                1169                               ;
                1170                               ; Registers used s0, s1 and s2.
                1171                               ;
                1172               2char_to_value: FETCH s0, (s1)                         ;read 'tens' character
E: identifier cannot start with a digit: `2char_to_value'.
E: unexpected :.
                1173                               CALL 1char_to_value                    ;convert to numerical value
E: identifier cannot start with a digit: `1char_to_value'.
E: invalid number of operands, instruction CALL takes 1 or 2 operand(s).
000 39000       1174                               RETURN C                               ;bad character - CARRY set
001 00110       1175                               LOAD s2, s0
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
002 14106       1176                               SL0 s2                                 ;multiply 'tens' value by 10 (0A hex)
E: symbol not defined: `S2'.
003 14106       1177                               SL0 s2
E: symbol not defined: `S2'.
004 10110       1178                               ADD s2, s0
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
005 14106       1179                               SL0 s2
E: symbol not defined: `S2'.
006 10110       1180                               ADD s1, 01                             ;read 'units' character
E: symbol not defined: `S1'.
007 0B101       1181                               FETCH s0, (s1)
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                1182                               CALL 1char_to_value                    ;convert to numerical value
E: identifier cannot start with a digit: `1char_to_value'.
E: invalid number of operands, instruction CALL takes 1 or 2 operand(s).
008 39000       1183                               RETURN C                               ;bad character - CARRY set
009 10110       1184                               ADD s2, s0                             ;add units to result and clear CARRY flag
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
00A 25000       1185                               RETURN
                1186                               ;
                1187                               ;
                1188                               ; Convert hexadecimal value provided in register s0 into ASCII characters
                1189                               ;
                1190                               ; The value provided must can be any value in the range 00 to FF and will be converted into
                1191                               ; two ASCII characters.
                1192                               ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1193                               ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1194                               ;
                1195                               ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1196                               ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1197                               ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1198                               ;
                1199                               ; Registers used s0, s1 and s2.
                1200                               ;
00B 00110       1201            hex_byte_to_ASCII: LOAD s1, s0                            ;remember value supplied
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
00C 1410E       1202                               SR0 s0                                 ;isolate upper nibble
E: symbol not defined: `S0'.
00D 1410E       1203                               SR0 s0
E: symbol not defined: `S0'.
00E 1410E       1204                               SR0 s0
E: symbol not defined: `S0'.
00F 1410E       1205                               SR0 s0
E: symbol not defined: `S0'.
010 20001       1206                               CALL hex_to_ASCII                      ;convert
E: symbol not defined: `HEX_TO_ASCII'.
011 00110       1207                               LOAD s2, s0                            ;upper nibble value in s2
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
012 00110       1208                               LOAD s0, s1                            ;restore complete value
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                1209                               AND s0, 0F                             ;isolate lower nibble
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
013 20001       1210                               CALL hex_to_ASCII                      ;convert
E: symbol not defined: `HEX_TO_ASCII'.
014 00110       1211                               LOAD s1, s0                            ;lower nibble value in s1
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
015 25000       1212                               RETURN
                1213                               ;
                1214                               ; Convert hexadecimal value provided in register s0 into ASCII character
                1215                               ;
                1216                               ;Register used s0
                1217                               ;
                1218                 hex_to_ASCII: SUB s0, 0A                             ;test if value is in range 0 to 9
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
016 3A001       1219                               JUMP C, number_char
E: symbol not defined: `NUMBER_CHAR'.
017 10170       1220                               ADD s0, 07                             ;ASCII char A to F in range 41 to 46
E: symbol not defined: `S0'.
                1221                  number_char: ADD s0, 3A                             ;ASCII char 0 to 9 in range 30 to 40
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
018 25000       1222                               RETURN
                1223                               ;
                1224                               ;
                1225                               ; Send the two character HEX value of the register contents 's0' to the UART
                1226                               ;
                1227                               ; Registers used s0, s1, s2
                1228                               ;
019 2000B       1229                send_hex_byte: CALL hex_byte_to_ASCII
01A 00110       1230                               LOAD UART_data, s2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `S2'.
01B 20001       1231                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
01C 00110       1232                               LOAD UART_data, s1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `S1'.
01D 20001       1233                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
01E 25000       1234                               RETURN
                1235                               ;
                1236                               ;
                1237                               ;
                1238                               ; Send the six character HEX value of the register contents [s9,s8,s7] to the UART
                1239                               ;
                1240                               ; Registers used s0, s1, s2
                1241                               ;
01F 00110       1242              send_hex_3bytes: LOAD s0, s9
E: symbol not defined: `S0'.
E: symbol not defined: `S9'.
020 20019       1243                               CALL send_hex_byte
021 00110       1244                               LOAD s0, s8
E: symbol not defined: `S0'.
E: symbol not defined: `S8'.
022 20019       1245                               CALL send_hex_byte
023 00110       1246                               LOAD s0, s7
E: symbol not defined: `S0'.
E: symbol not defined: `S7'.
024 20019       1247                               CALL send_hex_byte
025 25000       1248                               RETURN
                1249                               ;
                1250                               ;
                1251                               ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                1252                               ; an equivalent hexadecimal value in register 's0'.
                1253                               ;     The upper nibble is represented by an ASCII character in register s3.
                1254                               ;     The lower nibble is represented by an ASCII character in register s2.
                1255                               ;
                1256                               ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1257                               ; will be set on return.
                1258                               ;
                1259                               ; Registers used s0, s2 and s3.
                1260                               ;
026 00110       1261            ASCII_byte_to_hex: LOAD s0, s3                            ;Take upper nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
027 20033       1262                               CALL ASCII_to_hex                      ;convert to value
028 39000       1263                               RETURN C                               ;reject if out of range
029 00110       1264                               LOAD s3, s0                            ;remember value
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
02A 14106       1265                               SL0 s3                                 ;multiply value by 16 to put in upper nibble
E: symbol not defined: `S3'.
02B 14106       1266                               SL0 s3
E: symbol not defined: `S3'.
02C 14106       1267                               SL0 s3
E: symbol not defined: `S3'.
02D 14106       1268                               SL0 s3
E: symbol not defined: `S3'.
02E 00110       1269                               LOAD s0, s2                            ;Take lower nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S2'.
02F 20033       1270                               CALL ASCII_to_hex                      ;convert to value
030 39000       1271                               RETURN C                               ;reject if out of range
031 04110       1272                               OR s0, s3                              ;merge in the upper nibble with CARRY reset
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
032 25000       1273                               RETURN
                1274                               ;
                1275                               ;
                1276                               ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1277                               ;
                1278                               ; If character is not valid for hex, then CARRY is set on return.
                1279                               ;
                1280                               ; Register used s0
                1281                               ;
033 10110       1282                 ASCII_to_hex: ADD s0, B9                             ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
E: symbol not defined: `B9'.
034 39000       1283                               RETURN C
035 18110       1284                               SUB s0, E9                             ;normalise 0 to 9 with A-F in 11 to 16 hex
E: symbol not defined: `S0'.
E: symbol not defined: `E9'.
036 39000       1285                               RETURN C                               ;reject below ASCII code 30 ('0')
037 181B0       1286                               SUB s0, 11                             ;isolate A-F down to 00 to 05 hex
E: symbol not defined: `S0'.
038 3E001       1287                               JUMP NC, ASCII_letter
E: symbol not defined: `ASCII_LETTER'.
039 10170       1288                               ADD s0, 07                             ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
03A 39000       1289                               RETURN C
03B 18110       1290                               SUB s0, F6                             ;convert to range 00 to 09
E: symbol not defined: `S0'.
E: symbol not defined: `F6'.
03C 25000       1291                               RETURN
                1292                 ASCII_letter: ADD s0, 0A                             ;convert to range 0A to 0F
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
03D 25000       1293                               RETURN
                1294                               ;
                1295                               ;
                1296                               ; Read one character from UART and echo.
                1297                               ; Convert to upper case and return.
                1298                               ;
                1299                               ;
03E 20001       1300              read_upper_case: CALL read_from_UART                    ;read command character from UART
E: symbol not defined: `READ_FROM_UART'.
03F 20001       1301                               CALL send_to_UART                      ;echo character
E: symbol not defined: `SEND_TO_UART'.
040 00110       1302                               LOAD s0, UART_data                     ;convert to upper case
E: symbol not defined: `S0'.
E: symbol not defined: `UART_DATA'.
041 20001       1303                               CALL upper_case
E: symbol not defined: `UPPER_CASE'.
042 25000       1304                               RETURN
                1305                               ;
                1306                               ;
                1307                               ; Read two hex characters from UART and convert to single byte data
                1308                               ;
043 2003E       1309                 obtain_8bits: CALL read_upper_case                   ;obtain one byte from UART
044 00110       1310                               LOAD s3, s0
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
045 2003E       1311                               CALL read_upper_case
046 00110       1312                               LOAD s2, s0
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
047 20026       1313                               CALL ASCII_byte_to_hex
048 25000       1314                               RETURN
                1315                               ;
                1316                               ;**************************************************************************************
                1317                               ; Text messages
                1318                               ;**************************************************************************************
                1319                               ;
                1320                               ;
                1321                               ; Send Carriage Return to the UART
                1322                               ;
049 00110       1323                      send_CR: LOAD UART_data, character_CR
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_CR'.
04A 20001       1324                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04B 25000       1325                               RETURN
                1326                               ;
                1327                               ; Send a space to the UART
                1328                               ;
04C 00110       1329                   send_space: LOAD UART_data, character_space
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_SPACE'.
04D 20001       1330                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04E 25000       1331                               RETURN
                1332                               ;
                1333                               ;
                1334                               ; Send a minus sign to the UART
                1335                               ;
04F 00110       1336                   send_minus: LOAD UART_data, character_minus
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_MINUS'.
050 20001       1337                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
051 25000       1338                               RETURN
                1339                               ;
                1340                               ;
                1341                               ; Send 'PicoBlaze DS2432 Communicator v1.00' string to the UART
                1342                               ;
052 20049       1343                 send_welcome: CALL send_CR
053 20049       1344                               CALL send_CR
054 00110       1345                               LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
055 20001       1346                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
056 00110       1347                               LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
057 20001       1348                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
058 00110       1349                               LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
059 20001       1350                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05A 00110       1351                               LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
05B 20001       1352                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05C 00110       1353                               LOAD UART_data, character_B
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_B'.
05D 20001       1354                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05E 00110       1355                               LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
05F 20001       1356                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
060 00110       1357                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
061 20001       1358                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
062 00110       1359                               LOAD UART_data, character_z
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_Z'.
063 20001       1360                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
064 00110       1361                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
065 20001       1362                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
066 2004C       1363                               CALL send_space
067 00110       1364                               LOAD UART_data, character_D
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
068 20001       1365                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
069 00110       1366                               LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
06A 20001       1367                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06B 00110       1368                               LOAD UART_data, character_2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_2'.
06C 20001       1369                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06D 00110       1370                               LOAD UART_data, character_4
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_4'.
06E 20001       1371                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06F 00110       1372                               LOAD UART_data, character_3
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_3'.
070 20001       1373                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
071 00110       1374                               LOAD UART_data, character_2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_2'.
072 20001       1375                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
073 2004C       1376                               CALL send_space
074 00110       1377                               LOAD UART_data, character_C
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
075 20001       1378                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
076 00110       1379                               LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
077 20001       1380                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
078 00110       1381                               LOAD UART_data, character_m
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
079 20001       1382                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07A 20001       1383                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07B 00110       1384                               LOAD UART_data, character_u
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_U'.
07C 20001       1385                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07D 00110       1386                               LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
07E 20001       1387                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07F 00110       1388                               LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
080 20001       1389                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
081 00110       1390                               LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
082 20001       1391                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
083 00110       1392                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
084 20001       1393                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
085 00110       1394                               LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
086 20001       1395                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
087 00110       1396                               LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
088 20001       1397                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
089 00110       1398                               LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
08A 20001       1399                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
08B 2004C       1400                               CALL send_space
08C 00110       1401                               LOAD UART_data, character_v
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_V'.
08D 20001       1402                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
08E 00110       1403                               LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
08F 20001       1404                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
090 00110       1405                               LOAD UART_data, character_fullstop
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_FULLSTOP'.
091 20001       1406                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
092 00110       1407                               LOAD UART_data, character_0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_0'.
093 20001       1408                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
094 00110       1409                               LOAD UART_data, character_0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_0'.
095 20001       1410                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
096 20049       1411                               CALL send_CR
097 20049       1412                               CALL send_CR
098 25000       1413                               RETURN
                1414                               ;
                1415                               ;
                1416                               ;
                1417                               ; Send reset menu to the UART
                1418                               ;
099 20049       1419              send_reset_menu: CALL send_CR
09A 20049       1420                               CALL send_CR
09B 200FA       1421                               CALL send_HHelp
09C 00110       1422                               LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
09D 20001       1423                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
09E 2004F       1424                               CALL send_minus
09F 20131       1425                               CALL send_Master_Reset
0A0 20049       1426                               CALL send_CR
0A1 25000       1427                               RETURN
                1428                               ;
                1429                               ;
                1430                               ;
                1431                               ;
                1432                               ;
                1433                               ;
                1434                               ; Send ROM menu to the UART
                1435                               ;
0A2 20049       1436                send_ROM_menu: CALL send_CR
0A3 20049       1437                               CALL send_CR
0A4 200FA       1438                               CALL send_HHelp
0A5 00110       1439                               LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
0A6 20001       1440                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A7 2004F       1441                               CALL send_minus
0A8 20131       1442                               CALL send_Master_Reset
0A9 20049       1443                               CALL send_CR
0AA 00110       1444                               LOAD UART_data, character_2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_2'.
0AB 20001       1445                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0AC 2004F       1446                               CALL send_minus
0AD 2015B       1447                               CALL send_Read
0AE 2004C       1448                               CALL send_space
0AF 20108       1449                               CALL send_ROM
0B0 2004C       1450                               CALL send_space
0B1 20180       1451                               CALL send_Command
0B2 20049       1452                               CALL send_CR
0B3 00110       1453                               LOAD UART_data, character_3
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_3'.
0B4 20001       1454                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B5 2004F       1455                               CALL send_minus
0B6 20152       1456                               CALL send_Skip
0B7 2004C       1457                               CALL send_space
0B8 20108       1458                               CALL send_ROM
0B9 2004C       1459                               CALL send_space
0BA 20180       1460                               CALL send_Command
0BB 20049       1461                               CALL send_CR
0BC 25000       1462                               RETURN
                1463                               ;
                1464                               ;
                1465                               ;
                1466                               ; Send DS2432 menu to the UART
                1467                               ;
0BD 20049       1468             send_DS2432_menu: CALL send_CR
0BE 20049       1469                               CALL send_CR
0BF 200FA       1470                               CALL send_HHelp
0C0 00110       1471                               LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
0C1 20001       1472                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C2 2004F       1473                               CALL send_minus
0C3 20131       1474                               CALL send_Master_Reset
0C4 20049       1475                               CALL send_CR
0C5 00110       1476                               LOAD UART_data, character_2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_2'.
0C6 20001       1477                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C7 2004F       1478                               CALL send_minus
0C8 2015B       1479                               CALL send_Read
0C9 2004C       1480                               CALL send_space
0CA 2010F       1481                               CALL send_Memory
0CB 2004C       1482                               CALL send_space
0CC 20180       1483                               CALL send_Command
0CD 20049       1484                               CALL send_CR
0CE 00110       1485                               LOAD UART_data, character_3
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_3'.
0CF 20001       1486                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D0 2004F       1487                               CALL send_minus
0D1 20164       1488                               CALL send_Write
0D2 2004C       1489                               CALL send_space
0D3 2011C       1490                               CALL send_Scratchpad
0D4 2004C       1491                               CALL send_space
0D5 2010F       1492                               CALL send_Memory
0D6 2004C       1493                               CALL send_space
0D7 20180       1494                               CALL send_Command
0D8 20049       1495                               CALL send_CR
0D9 00110       1496                               LOAD UART_data, character_4
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_4'.
0DA 20001       1497                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0DB 2004F       1498                               CALL send_minus
0DC 2015B       1499                               CALL send_Read
0DD 2004C       1500                               CALL send_space
0DE 2011C       1501                               CALL send_Scratchpad
0DF 2004C       1502                               CALL send_space
0E0 2010F       1503                               CALL send_Memory
0E1 2004C       1504                               CALL send_space
0E2 20180       1505                               CALL send_Command
0E3 20049       1506                               CALL send_CR
0E4 00110       1507                               LOAD UART_data, character_5
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_5'.
0E5 20001       1508                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E6 2004F       1509                               CALL send_minus
0E7 20164       1510                               CALL send_Write
0E8 2004C       1511                               CALL send_space
0E9 20149       1512                               CALL send_Byte
0EA 20049       1513                               CALL send_CR
0EB 00110       1514                               LOAD UART_data, character_6
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_6'.
0EC 20001       1515                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0ED 2004F       1516                               CALL send_minus
0EE 2015B       1517                               CALL send_Read
0EF 2004C       1518                               CALL send_space
0F0 20149       1519                               CALL send_Byte
0F1 20049       1520                               CALL send_CR
0F2 25000       1521                               RETURN
                1522                               ;
                1523                               ;
                1524                               ;
                1525                               ; Send carriage return, 'OK' and carriage return to the UART
                1526                               ;
0F3 20049       1527                      send_OK: CALL send_CR
0F4 00110       1528                               LOAD UART_data, character_O
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
0F5 20001       1529                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F6 00110       1530                               LOAD UART_data, character_K
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_K'.
0F7 20001       1531                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F8 20049       1532                               CALL send_CR
0F9 25000       1533                               RETURN
                1534                               ;
                1535                               ;
                1536                               ; Send 'H-Help'menu to the UART
                1537                               ;
0FA 20049       1538                   send_HHelp: CALL send_CR
0FB 00110       1539                               LOAD UART_data, character_H
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_H'.
0FC 20001       1540                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0FD 2004F       1541                               CALL send_minus
0FE 00110       1542                               LOAD UART_data, character_H
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_H'.
0FF 20001       1543                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
100 00110       1544                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
101 20001       1545                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
102 00110       1546                               LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
103 20001       1547                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
104 00110       1548                               LOAD UART_data, character_p
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
105 20001       1549                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
106 20049       1550                               CALL send_CR
107 25000       1551                               RETURN
                1552                               ;
                1553                               ;
                1554                               ; Send 'ROM' to the UART
                1555                               ;
108 00110       1556                     send_ROM: LOAD UART_data, character_R
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
109 20001       1557                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10A 00110       1558                               LOAD UART_data, character_O
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
10B 20001       1559                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10C 00110       1560                               LOAD UART_data, character_M
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
10D 20001       1561                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10E 25000       1562                               RETURN
                1563                               ;
                1564                               ;
                1565                               ; Send 'Memory' to the UART
                1566                               ;
10F 00110       1567                  send_Memory: LOAD UART_data, character_M
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
110 20001       1568                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
111 00110       1569                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
112 20001       1570                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
113 00110       1571                               LOAD UART_data, character_m
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
114 20001       1572                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
115 00110       1573                               LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
116 20001       1574                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
117 00110       1575                               LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
118 20001       1576                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
119 00110       1577                               LOAD UART_data, character_y
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_Y'.
11A 20001       1578                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
11B 25000       1579                               RETURN
                1580                               ;
                1581                               ;
                1582                               ; Send 'Scratchpad' to the UART
                1583                               ;
11C 00110       1584              send_Scratchpad: LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
11D 20001       1585                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
11E 00110       1586                               LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
11F 20001       1587                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
120 00110       1588                               LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
121 20001       1589                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
122 00110       1590                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
123 20001       1591                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
124 00110       1592                               LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
125 20001       1593                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
126 00110       1594                               LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
127 20001       1595                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
128 00110       1596                               LOAD UART_data, character_h
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_H'.
129 20001       1597                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
12A 00110       1598                               LOAD UART_data, character_p
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
12B 20001       1599                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
12C 00110       1600                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
12D 20001       1601                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
12E 00110       1602                               LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
12F 20001       1603                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
130 25000       1604                               RETURN
                1605                               ;
                1606                               ;
                1607                               ; Send 'Master Reset' to the UART
                1608                               ;
131 00110       1609            send_Master_Reset: LOAD UART_data, character_M
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
132 20001       1610                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
133 00110       1611                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
134 20001       1612                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
135 00110       1613                               LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
136 20001       1614                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
137 00110       1615                               LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
138 20001       1616                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
139 00110       1617                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
13A 20001       1618                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
13B 00110       1619                               LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
13C 20001       1620                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
13D 2004C       1621                               CALL send_space
13E 00110       1622                               LOAD UART_data, character_R
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
13F 20001       1623                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
140 00110       1624                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
141 20001       1625                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
142 00110       1626                               LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
143 20001       1627                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
144 00110       1628                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
145 20001       1629                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
146 00110       1630                               LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
147 20001       1631                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
148 25000       1632                               RETURN
                1633                               ;
                1634                               ;
                1635                               ; Send 'Byte' to the UART
                1636                               ;
149 00110       1637                    send_Byte: LOAD UART_data, character_B
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_B'.
14A 20001       1638                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
14B 00110       1639                               LOAD UART_data, character_y
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_Y'.
14C 20001       1640                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
14D 00110       1641                               LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
14E 20001       1642                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
14F 00110       1643                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
150 20001       1644                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
151 25000       1645                               RETURN
                1646                               ;
                1647                               ;
                1648                               ; Send 'Skip' to the UART
                1649                               ;
152 00110       1650                    send_Skip: LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
153 20001       1651                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
154 00110       1652                               LOAD UART_data, character_k
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_K'.
155 20001       1653                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
156 00110       1654                               LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
157 20001       1655                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
158 00110       1656                               LOAD UART_data, character_p
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
159 20001       1657                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
15A 25000       1658                               RETURN
                1659                               ;
                1660                               ;
                1661                               ; Send 'Read' to the UART
                1662                               ;
15B 00110       1663                    send_Read: LOAD UART_data, character_R
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
15C 20001       1664                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
15D 00110       1665                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
15E 20001       1666                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
15F 00110       1667                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
160 20001       1668                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
161 00110       1669                               LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
162 20001       1670                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
163 25000       1671                               RETURN
                1672                               ;
                1673                               ;
                1674                               ; Send 'Write' to the UART
                1675                               ;
164 00110       1676                   send_Write: LOAD UART_data, character_W
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_W'.
165 20001       1677                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
166 00110       1678                               LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
167 20001       1679                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
168 00110       1680                               LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
169 20001       1681                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
16A 00110       1682                               LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
16B 20001       1683                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
16C 00110       1684                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
16D 20001       1685                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
16E 25000       1686                               RETURN
                1687                               ;
                1688                               ;
                1689                               ; Send 'Pass' to the UART
                1690                               ;
16F 00110       1691                    send_Pass: LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
170 20001       1692                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
171 00110       1693                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
172 20001       1694                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
173 00110       1695                               LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
174 20001       1696                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
175 20001       1697                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
176 25000       1698                               RETURN
                1699                               ;
                1700                               ;
                1701                               ; Send 'Fail' to the UART
                1702                               ;
177 00110       1703                    send_Fail: LOAD UART_data, character_F
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_F'.
178 20001       1704                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
179 00110       1705                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
17A 20001       1706                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
17B 00110       1707                               LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
17C 20001       1708                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
17D 00110       1709                               LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
17E 20001       1710                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
17F 25000       1711                               RETURN
                1712                               ;
                1713                               ;
                1714                               ; Send 'Command' to the UART
                1715                               ;
180 00110       1716                 send_Command: LOAD UART_data, character_C
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
181 20001       1717                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
182 00110       1718                               LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
183 20001       1719                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
184 00110       1720                               LOAD UART_data, character_m
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
185 20001       1721                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
186 20001       1722                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
187 00110       1723                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
188 20001       1724                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
189 00110       1725                               LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
18A 20001       1726                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
18B 00110       1727                               LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
18C 20001       1728                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
18D 25000       1729                               RETURN
                1730                               ;
                1731                               ;
                1732                               ; Send 'address=' to the UART
                1733                               ;
18E 20049       1734                 send_address: CALL send_CR
18F 00110       1735                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
190 20001       1736                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
191 00110       1737                               LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
192 20001       1738                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
193 20001       1739                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
194 00110       1740                               LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
195 20001       1741                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
196 00110       1742                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
197 20001       1743                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
198 00110       1744                               LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
199 20001       1745                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
19A 20001       1746                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
19B 00110       1747                  send_equals: LOAD UART_data, character_equals
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_EQUALS'.
19C 20001       1748                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
19D 25000       1749                               RETURN
                1750                               ;
                1751                               ;
                1752                               ; Send 'data' to the UART
                1753                               ;
19E 20049       1754                    send_data: CALL send_CR
19F 00110       1755                               LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
1A0 20001       1756                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1A1 00110       1757                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
1A2 20001       1758                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1A3 00110       1759                               LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
1A4 20001       1760                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1A5 00110       1761                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
1A6 20001       1762                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1A7 25000       1763                               RETURN
                1764                               ;
                1765                               ;
                1766                               ; Send 'E/S=' to the UART
                1767                               ;
1A8 20049       1768                      send_ES: CALL send_CR
1A9 00110       1769                               LOAD UART_data, character_E
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
1AA 20001       1770                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1AB 00110       1771                               LOAD UART_data, character_divide
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_DIVIDE'.
1AC 20001       1772                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1AD 00110       1773                               LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
1AE 20001       1774                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1AF 2219B       1775                               JUMP send_equals
                1776                               ;
                1777                               ;
                1778                               ; Send 'code=' to the UART
                1779                               ;
1B0 00110       1780                    send_code: LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
1B1 20001       1781                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1B2 00110       1782                               LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
1B3 20001       1783                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1B4 00110       1784                               LOAD UART_data, character_d
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_D'.
1B5 20001       1785                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1B6 00110       1786                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
1B7 20001       1787                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1B8 2219B       1788                               JUMP send_equals
                1789                               ;
                1790                               ;
                1791                               ; Send 'serial=' to the UART
                1792                               ;
1B9 00110       1793                  send_serial: LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
1BA 20001       1794                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1BB 00110       1795                               LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
1BC 20001       1796                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1BD 00110       1797                               LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
1BE 20001       1798                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1BF 00110       1799                               LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
1C0 20001       1800                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1C1 00110       1801                               LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
1C2 20001       1802                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1C3 00110       1803                               LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
1C4 20001       1804                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1C5 2219B       1805                               JUMP send_equals
                1806                               ;
                1807                               ;
                1808                               ; Send 'CRC=' to the UART
                1809                               ;
1C6 00110       1810                     send_CRC: LOAD UART_data, character_C
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
1C7 20001       1811                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1C8 00110       1812                               LOAD UART_data, character_R
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
1C9 20001       1813                               CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
1CA 00110       1814                               LOAD UART_data, character_C
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
1CB 2219B       1815                               JUMP send_equals
                1816                               ;
                1817                               ;
                1818                               ;**************************************************************************************
                1819                               ; Interrupt Service Routine (ISR)
                1820                               ;**************************************************************************************
                1821                               ;
                1822                               ; Interrupts are not used in this design. This is a place keeper only.
                1823                               ;
                1824                               ADDRESS 3FE
E: identifier cannot start with a digit: `3FE'.
E: directive ADDRESS requires a single argument.
1CC 29001       1825                          ISR: RETURNI ENABLE
                1826                               ;
                1827                               ;
                1828                               ;**************************************************************************************
                1829                               ; Interrupt Vector
                1830                               ;**************************************************************************************
                1831                               ;
                1832                               ADDRESS 3FF
E: identifier cannot start with a digit: `3FF'.
E: directive ADDRESS requires a single argument.
1CD 221CC       1833                               JUMP ISR
                1834                               ;
                1835                               ;
