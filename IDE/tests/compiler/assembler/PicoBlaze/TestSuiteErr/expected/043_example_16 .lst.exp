                   1                          ; KCPSM3 Program - Program to test line stores using the Spartan-3E Starter Kit.
                   2                          ;
                   3                          ; Ken Chapman - Xilinx Ltd
                   4                          ;
                   5                          ; Version v1.00 - 26th June 2006
                   6                          ;
                   7                          ; PicoBlaze communicates via the UART to control the value applied to the inputs of
                   8                          ; line stores and enable them for a specified number of clock cycles. The outputs of
                   9                          ; all the line stores are then displayed.
                  10                          ;
                  11                          ;**************************************************************************************
                  12                          ; Port definitions
                  13                          ;**************************************************************************************
                  14                          ;
                  15                          ;
                  16                          ;
                  17                          CONSTANT LED_port, 80                  ;8 simple LEDs
                  18                          CONSTANT LED0, 01                      ;     LED 0 - bit0
                  19                          CONSTANT LED1, 02                      ;         1 - bit1
                  20                          CONSTANT LED2, 04                      ;         2 - bit2
                  21                          CONSTANT LED3, 08                      ;         3 - bit3
                  22                          CONSTANT LED4, 10                      ;         4 - bit4
                  23                          CONSTANT LED5, 20                      ;         5 - bit5
                  24                          CONSTANT LED6, 40                      ;         6 - bit6
                  25                          CONSTANT LED7, 80                      ;         7 - bit7
                  26                          ;
                  27                          ;
                  28                          ;UART ports
                  29                          ;
                  30                          CONSTANT status_port, 00               ;UART status input
                  31                          CONSTANT tx_half_full, 01              ;  Transmitter     half full - bit0
                  32                          CONSTANT tx_full, 02                   ;    FIFO               full - bit1
                  33                          CONSTANT rx_data_present, 04           ;  Receiver     data present - bit2
                  34                          CONSTANT rx_half_full, 08              ;    FIFO          half full - bit3
                  35                          CONSTANT rx_full, 10                   ;                   full - bit4
                  36                          ;
                  37                          CONSTANT UART_read_port, 01            ;UART Rx data input
                  38                          ;
                  39                          CONSTANT UART_write_port, 40           ;UART Tx data output
                  40                          ;
                  41                          ;
                  42                          ;The first line store input is 18-bits and requires 3 bytes
                  43                          ;to be written to a holding register. Then when required,
                  44                          ;the whole 18-bit value can be stored in the line store
                  45                          ;using a dummy write (data not used) to a forth port.
                  46                          ;
                  47                          ;
                  48                          CONSTANT line_store_input_L, 01        ;Line Store input bits [7:0]
                  49                          CONSTANT line_store_input_M, 02        ;Line Store input bits [15:8]
                  50                          CONSTANT line_store_input_H, 04        ;Line Store input bits [17:16]
                  51                          CONSTANT line_store_write_en, 08       ;Line Store clock enable (dummy write)
                  52                          ;
                  53                          ;
                  54                          ;
                  55                          ;The first line store 768x24 and requires 3 bytes to be read.
                  56                          ;
                  57                          CONSTANT line_store1_output_L, 02      ;Line Store output bits [7:0]
                  58                          CONSTANT line_store1_output_M, 03      ;Line Store output bits [15:8]
                  59                          CONSTANT line_store1_output_H, 04      ;Line Store output bits [23:16]
                  60                          ;
                  61                          ;
                  62                          ;The second line store 1024x18 and requires 3 bytes to be read.
                  63                          ;
                  64                          CONSTANT line_store2_output_L, 05      ;Line Store output bits [7:0]
                  65                          CONSTANT line_store2_output_M, 06      ;Line Store output bits [15:8]
                  66                          CONSTANT line_store2_output_H, 07      ;Line Store output bits [17:16]
                  67                          ;
                  68                          ;
                  69                          ;The third line store 1280x13 and requires 2 bytes to be read.
                  70                          ;
                  71                          CONSTANT line_store3_output_L, 08      ;Line Store output bits [7:0]
                  72                          CONSTANT line_store3_output_H, 09      ;Line Store output bits [12:8]
                  73                          ;
                  74                          ;
                  75                          ;The forth line store is 1280x72 so to make it more manageable it has been
                  76                          ;folded to make it 3 times longer and only 24-bits wide. This requires 3 bytes
                  77                          ;to be read at each 1280 delay tapping point.
                  78                          ;
                  79                          CONSTANT line_store4a_output_L, 0A     ;Line Store output bits [7:0]   First tap
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                  80                          CONSTANT line_store4a_output_M, 0B     ;Line Store output bits [15:8]
                  81                          CONSTANT line_store4a_output_H, 0C     ;Line Store output bits [23:16]
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
                  82                          ;
                  83                          CONSTANT line_store4b_output_L, 0D     ;Line Store output bits [31:24] Second tap
                  84                          CONSTANT line_store4b_output_M, 0E     ;Line Store output bits [39:32]
E: identifier cannot start with a digit: `0E'.
E: unexpected end of line.
                  85                          CONSTANT line_store4b_output_H, 0F     ;Line Store output bits [47:40]
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
                  86                          ;
                  87                          CONSTANT line_store4c_output_L, 10     ;Line Store output bits [55:48] Third tap
                  88                          CONSTANT line_store4c_output_M, 11     ;Line Store output bits [63:56]
                  89                          CONSTANT line_store4c_output_H, 12     ;Line Store output bits [71:64]
                  90                          ;
                  91                          ;
                  92                          ;The fifth line store 1536x12 and requires 2 bytes to be read.
                  93                          ;
                  94                          CONSTANT line_store5_output_L, 13      ;Line Store output bits [7:0]
                  95                          CONSTANT line_store5_output_H, 14      ;Line Store output bits [11:8]
                  96                          ;
                  97                          ;
                  98                          ;The sixth line store 1920x9 and requires 2 bytes to be read.
                  99                          ;
                 100                          CONSTANT line_store6_output_L, 15      ;Line Store output bits [7:0]
                 101                          CONSTANT line_store6_output_H, 16      ;Line Store output bit [8]
                 102                          ;
                 103                          ;
                 104                          ;The seventh line store is 1920x48 so to make it more manageable it has been
                 105                          ;folded to make it 2 times longer and only 24-bits wide. This requires 3 bytes
                 106                          ;to be read at each 1920 delay tapping point.
                 107                          ;
                 108                          CONSTANT line_store7a_output_L, 17     ;Line Store output bits [7:0]   First tap
                 109                          CONSTANT line_store7a_output_M, 18     ;Line Store output bits [15:8]
                 110                          CONSTANT line_store7a_output_H, 19     ;Line Store output bits [23:16]
                 111                          ;
                 112                          CONSTANT line_store7b_output_L, 1A     ;Line Store output bits [31:24] Second tap
E: identifier cannot start with a digit: `1A'.
E: unexpected end of line.
                 113                          CONSTANT line_store7b_output_M, 1B     ;Line Store output bits [39:32]
                 114                          CONSTANT line_store7b_output_H, 1C     ;Line Store output bits [47:40]
E: identifier cannot start with a digit: `1C'.
E: unexpected end of line.
                 115                          ;
                 116                          ;
                 117                          ;**************************************************************************************
                 118                          ; Special Register usage
                 119                          ;**************************************************************************************
                 120                          ;
                 121                          NAMEREG sF, UART_data                  ;used to pass data to and from the UART
                 122                          ;
                 123                          ;
                 124                          ;
                 125                          ;**************************************************************************************
                 126                          ;Scratch Pad Memory Locations
                 127                          ;**************************************************************************************
                 128                          ;
                 129                          CONSTANT step_counter0, 00             ;decimal count of line store write operations
                 130                          CONSTANT step_counter1, 01
                 131                          CONSTANT step_counter2, 02
                 132                          CONSTANT step_counter3, 03
                 133                          CONSTANT step_counter4, 04
                 134                          ;
                 135                          CONSTANT test_data_in0, 05             ;24-bit data applied to line store input
                 136                          CONSTANT test_data_in1, 06
                 137                          CONSTANT test_data_in2, 07
                 138                          ;
                 139                          CONSTANT n_count0, 08                  ;decimal count cycles to count in command
                 140                          CONSTANT n_count1, 09
                 141                          CONSTANT n_count2, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 142                          CONSTANT n_count3, 0B
                 143                          ;
                 144                          ;
                 145                          CONSTANT auto_inc, 0C                  ;Determines if auto increment is active
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
                 146                          ;
                 147                          CONSTANT fast_mode, 0D                 ;Determines if fast mode is active
                 148                          ;
                 149                          ;UART character strings will be stored in scratch pad memory ending in carriage return.
                 150                          ;A string can be up to 16 characters with the start location defined by this constant.
                 151                          ;
                 152                          CONSTANT string_start, 30
                 153                          ;
                 154                          ;
                 155                          ;
                 156                          ;**************************************************************************************
                 157                          ;Useful data constants
                 158                          ;**************************************************************************************
                 159                          ;
                 160                          ;
                 161                          ;
                 162                          ;
                 163                          ;ASCII table
                 164                          ;
                 165                          CONSTANT character_a, 61
                 166                          CONSTANT character_b, 62
                 167                          CONSTANT character_c, 63
                 168                          CONSTANT character_d, 64
                 169                          CONSTANT character_e, 65
                 170                          CONSTANT character_f, 66
                 171                          CONSTANT character_g, 67
                 172                          CONSTANT character_h, 68
                 173                          CONSTANT character_i, 69
                 174                          CONSTANT character_j, 6A
E: identifier cannot start with a digit: `6A'.
E: unexpected end of line.
                 175                          CONSTANT character_k, 6B
E: identifier cannot start with a digit: `6B'.
E: unexpected end of line.
                 176                          CONSTANT character_l, 6C
E: identifier cannot start with a digit: `6C'.
E: unexpected end of line.
                 177                          CONSTANT character_m, 6D
                 178                          CONSTANT character_n, 6E
E: identifier cannot start with a digit: `6E'.
E: unexpected end of line.
                 179                          CONSTANT character_o, 6F
E: identifier cannot start with a digit: `6F'.
E: unexpected end of line.
                 180                          CONSTANT character_p, 70
                 181                          CONSTANT character_q, 71
                 182                          CONSTANT character_r, 72
                 183                          CONSTANT character_s, 73
                 184                          CONSTANT character_t, 74
                 185                          CONSTANT character_u, 75
                 186                          CONSTANT character_v, 76
                 187                          CONSTANT character_w, 77
                 188                          CONSTANT character_x, 78
                 189                          CONSTANT character_y, 79
                 190                          CONSTANT character_z, 7A
E: identifier cannot start with a digit: `7A'.
E: unexpected end of line.
                 191                          CONSTANT character_A, 41
                 192                          CONSTANT character_B, 42
                 193                          CONSTANT character_C, 43
                 194                          CONSTANT character_D, 44
                 195                          CONSTANT character_E, 45
                 196                          CONSTANT character_F, 46
                 197                          CONSTANT character_G, 47
                 198                          CONSTANT character_H, 48
                 199                          CONSTANT character_I, 49
                 200                          CONSTANT character_J, 4A
E: identifier cannot start with a digit: `4A'.
E: unexpected end of line.
                 201                          CONSTANT character_K, 4B
E: identifier cannot start with a digit: `4B'.
E: unexpected end of line.
                 202                          CONSTANT character_L, 4C
E: identifier cannot start with a digit: `4C'.
E: unexpected end of line.
                 203                          CONSTANT character_M, 4D
                 204                          CONSTANT character_N, 4E
E: identifier cannot start with a digit: `4E'.
E: unexpected end of line.
                 205                          CONSTANT character_O, 4F
E: identifier cannot start with a digit: `4F'.
E: unexpected end of line.
                 206                          CONSTANT character_P, 50
                 207                          CONSTANT character_Q, 51
                 208                          CONSTANT character_R, 52
                 209                          CONSTANT character_S, 53
                 210                          CONSTANT character_T, 54
                 211                          CONSTANT character_U, 55
                 212                          CONSTANT character_V, 56
                 213                          CONSTANT character_W, 57
                 214                          CONSTANT character_X, 58
                 215                          CONSTANT character_Y, 59
                 216                          CONSTANT character_Z, 5A
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
                 217                          CONSTANT character_0, 30
                 218                          CONSTANT character_1, 31
                 219                          CONSTANT character_2, 32
                 220                          CONSTANT character_3, 33
                 221                          CONSTANT character_4, 34
                 222                          CONSTANT character_5, 35
                 223                          CONSTANT character_6, 36
                 224                          CONSTANT character_7, 37
                 225                          CONSTANT character_8, 38
                 226                          CONSTANT character_9, 39
                 227                          CONSTANT character_colon, 3A
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                 228                          CONSTANT character_stop, 2E
E: identifier cannot start with a digit: `2E'.
E: unexpected end of line.
                 229                          CONSTANT character_semi_colon, 3B
E: identifier cannot start with a digit: `3B'.
E: unexpected end of line.
                 230                          CONSTANT character_minus, 2D
                 231                          CONSTANT character_divide, 2F          ;'/'
E: identifier cannot start with a digit: `2F'.
E: unexpected end of line.
                 232                          CONSTANT character_plus, 2B
E: identifier cannot start with a digit: `2B'.
E: unexpected end of line.
                 233                          CONSTANT character_comma, 2C
E: identifier cannot start with a digit: `2C'.
E: unexpected end of line.
                 234                          CONSTANT character_less_than, 3C
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
                 235                          CONSTANT character_greater_than, 3E
E: identifier cannot start with a digit: `3E'.
E: unexpected end of line.
                 236                          CONSTANT character_equals, 3D
                 237                          CONSTANT character_space, 20
                 238                          CONSTANT character_CR, 0D              ;carriage return
                 239                          CONSTANT character_question, 3F        ;'?'
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
                 240                          CONSTANT character_dollar, 24
                 241                          CONSTANT character_exclaim, 21         ;'!'
                 242                          CONSTANT character_BS, 08              ;Back Space command character
                 243                          ;
                 244                          ;
                 245                          ;
                 246                          ;
                 247                          ;
                 248                          ;**************************************************************************************
                 249                          ;Initialise the system
                 250                          ;**************************************************************************************
                 251                          ;
                 252                          ;
                 253              cold_start: LOAD s0, LED0
                 254                          OUTPUT s0, LED_port
                 255                          ;
                 256                          CALL send_welcome                      ;Write welcome message to UART
                 257                          ;
                 258                          LOAD s0, 00                            ;clear counter
                 259                          STORE s0, step_counter4
                 260                          STORE s0, step_counter3
                 261                          STORE s0, step_counter2
                 262                          STORE s0, step_counter1
                 263                          STORE s0, step_counter0
                 264                          ;
                 265                          OUTPUT s0, line_store_input_L          ;Clear input to line store
                 266                          OUTPUT s0, line_store_input_M
                 267                          OUTPUT s0, line_store_input_H
                 268                          STORE s0, test_data_in0
                 269                          STORE s0, test_data_in1
                 270                          STORE s0, test_data_in2
                 271                          ;
                 272                          ;
                 273                          LOAD s2, 0F                            ;purge line stores with 4000 writes of zero
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
                 274                          LOAD s1, A0
                 275              purge_loop: OUTPUT s0, line_store_write_en         ;dummy write to enable line store
                 276                          SUB s1, 01
                 277                          JUMP NC, purge_loop
                 278                          SUB s2, 01
                 279                          JUMP NC, purge_loop
                 280                          ;
                 281                          ;
                 282                          STORE s0, fast_mode                    ;turn off fast mode by default
                 283                          ;
                 284                          LOAD s0, 01                            ;default first value is 000001 hex
                 285                          OUTPUT s0, line_store_input_L
                 286                          STORE s0, test_data_in0
                 287                          ;
                 288                          STORE s0, auto_inc                     ;turn auto increment on by default
                 289                          ;
                 290                          ;**************************************************************************************
                 291                          ; Main program
                 292                          ;**************************************************************************************
                 293                          ;
                 294                          ; Provides a prompt to which an input with one of the following formats is expected...
                 295                          ;
                 296                          ;     set hhhhhh     - Set value to be written into line store.
                 297                          ;                      'hhhhhh' is a 6 digit hex value.
                 298                          ;
                 299                          ;     cycle n        - drive line store with 'n' cycles and display results.
                 300                          ;                      'n' is a decimal number up to 9999.
                 301                          ;
                 302                          ;     reset          - Clears the counter and also purges all line store of all values.
                 303                          ;
                 304                          ;     auto on        - Turns on the auto increment of the set value so that each
                 305                          ;                      seccessive write of data will be different and useful for
                 306                          ;                      determining the delay length.
                 307                          ;
                 308                          ;     auto off       - Turns off the auto increment function so that all successive writes
                 309                          ;                      to the line stores will be identical.
                 310                          ;
                 311                          ;
                 312                          ;     fast on        - Turns on the fast execute mode in which the output to the
                 313                          ;                      display via the UART is turned off during multi-cycle operations.
                 314                          ;                      This results in much greater speed.
                 315                          ;
                 316                          ;     fast off       - Turns off fast execution mode allowing all data to be displayed.
                 317                          ;
                 318                          ; The input allows a degree of editing to be performed and upper and lower case letters
                 319                          ; to be used.
                 320                          ;
                 321              warm_start: FETCH s0, auto_inc                     ;use LED0 to display state of auto increment
                 322                          FETCH s1, fast_mode                    ;use LED1 to display state of fast mode
                 323                          COMPARE s1, 00
                 324                          JUMP Z, set_LEDs
                 325                          OR s0, LED1
                 326                set_LEDs: OUTPUT s0, LED_port
                 327                          ;
                 328                          CALL send_prompt                       ;Prompt 'KCPSM3>'
                 329                          CALL receive_string                    ;obtain input string of up to 16 characters
                 330                          CALL upper_case_string                 ;convert string to upper case
                 331                          ;
                 332                          LOAD sE, string_start                  ;sE is memory pointer
                 333                          FETCH s0, (sE)                         ;test for carriage return
                 334                          COMPARE s0, character_CR
                 335                          JUMP Z, warm_start
                 336                          COMPARE s0, character_S                ;test for 'S' of 'SET' command
                 337                          JUMP Z, SET_command
                 338                          COMPARE s0, character_C                ;test for 'C' of 'CYCLE' command
                 339                          JUMP Z, CYCLE_command
                 340                          COMPARE s0, character_R                ;test for 'R' of 'RESET' command
                 341                          JUMP Z, RESET_command
                 342                          COMPARE s0, character_A                ;test for 'A' of 'AUTO' command
                 343                          JUMP Z, AUTO_command
                 344                          COMPARE s0, character_F                ;test for 'F' of 'FAST' command
                 345                          JUMP Z, FAST_command
                 346             bad_command: CALL send_CR                           ;no valid command entered
                 347                          CALL send_Error
                 348                          JUMP warm_start
                 349                          ;
                 350                          ;Processing potential 'RESET' command
                 351                          ;
                 352           RESET_command: CALL read_next_char                    ;test for 'E' of 'RESET' command
                 353                          COMPARE s0, character_E
                 354                          JUMP NZ, bad_command
                 355                          CALL read_next_char                    ;test for 'S' of 'RESET' command
                 356                          COMPARE s0, character_S
                 357                          JUMP NZ, bad_command
                 358                          CALL read_next_char                    ;test for 'E' of 'RESET' command
                 359                          COMPARE s0, character_E
                 360                          JUMP NZ, bad_command
                 361                          CALL read_next_char                    ;test for 'T' of 'RESET' command
                 362                          COMPARE s0, character_T
                 363                          JUMP NZ, bad_command
                 364                          CALL read_next_char                    ;test for a carriage return
                 365                          COMPARE s0, character_CR
                 366                          JUMP NZ, bad_command
                 367                          JUMP cold_start
                 368                          ;
                 369                          ;Processing potential 'SET' command
                 370                          ;
                 371             SET_command: CALL read_next_char                    ;test for 'E' of 'SET' command
                 372                          COMPARE s0, character_E
                 373                          JUMP NZ, bad_command
                 374                          CALL read_next_char                    ;test for 'T' of 'SET' command
                 375                          COMPARE s0, character_T
                 376                          JUMP NZ, bad_command
                 377                          CALL read_next_char                    ;test for a space
                 378                          COMPARE s0, character_space
                 379                          JUMP NZ, bad_command
                 380                          ;read value into register set [sC,sB,sA]
                 381                          CALL read_next_char                    ;read two character hex value
                 382                          LOAD s3, s0
                 383                          CALL read_next_char
                 384                          LOAD s2, s0
                 385                          CALL ASCII_byte_to_hex                 ;convert to value in s0
                 386                          JUMP C, bad_command
                 387                          LOAD sC, s0                            ;remember value
                 388                          CALL read_next_char                    ;read two character hex value
                 389                          LOAD s3, s0
                 390                          CALL read_next_char
                 391                          LOAD s2, s0
                 392                          CALL ASCII_byte_to_hex                 ;convert to value in s0
                 393                          JUMP C, bad_command
                 394                          LOAD sB, s0                            ;remember value
                 395                          CALL read_next_char                    ;read two character hex value
                 396                          LOAD s3, s0
                 397                          CALL read_next_char
                 398                          LOAD s2, s0
                 399                          CALL ASCII_byte_to_hex                 ;convert to value in s0
                 400                          JUMP C, bad_command
                 401                          LOAD sA, s0                            ;remember value
                 402                          CALL read_next_char                    ;test for carriage return to end command
                 403                          COMPARE s0, character_CR
                 404                          JUMP NZ, bad_command
                 405                          STORE sA, test_data_in0                ;store new line store input value
                 406                          STORE sB, test_data_in1
                 407                          STORE sC, test_data_in2
                 408                          OUTPUT sA, line_store_input_L          ;Write data to register driving line store
                 409                          OUTPUT sB, line_store_input_M
                 410                          OUTPUT sC, line_store_input_H
                 411                          CALL send_OK
                 412                          JUMP warm_start
                 413                          ;
                 414                          ;Processing potential 'AUTO' command
                 415                          ;
                 416            AUTO_command: CALL read_next_char
                 417                          COMPARE s0, character_U                ;test for 'U' of 'AUTO' command
                 418                          JUMP NZ, bad_command
                 419                          CALL read_next_char
                 420                          COMPARE s0, character_T                ;test for 'T' of 'AUTO' command
                 421                          JUMP NZ, bad_command
                 422                          CALL read_next_char
                 423                          COMPARE s0, character_O                ;test for 'O' of 'AUTO' command
                 424                          JUMP NZ, bad_command
                 425                          CALL read_next_char                    ;test for a space
                 426                          COMPARE s0, character_space
                 427                          JUMP NZ, bad_command
                 428                          CALL read_next_char
                 429                          COMPARE s0, character_O                ;test for 'O' of 'ON' or 'OFF'
                 430                          JUMP NZ, bad_command
                 431                          CALL read_next_char
                 432                          COMPARE s0, character_N                ;test for 'N' of 'ON'
                 433                          JUMP Z, test_auto_ON
                 434                          COMPARE s0, character_F                ;test for 'F' of 'OFF'
                 435                          JUMP NZ, bad_command
                 436                          CALL read_next_char
                 437                          COMPARE s0, character_F                ;test for 'F' of 'OFF'
                 438                          JUMP NZ, bad_command
                 439                          CALL read_next_char
                 440                          COMPARE s0, character_CR               ;test for carriage return
                 441                          JUMP NZ, bad_command
                 442                          LOAD s0, 00                            ;turn off auto increment
                 443                          JUMP update_auto
                 444            test_auto_ON: CALL read_next_char
                 445                          COMPARE s0, character_CR               ;test for carriage return
                 446                          JUMP NZ, bad_command
                 447                          LOAD s0, 01                            ;turn on auto increment
                 448             update_auto: STORE s0, auto_inc
                 449                          CALL send_OK
                 450                          JUMP warm_start
                 451                          ;
                 452                          ;Processing potential 'FAST' command
                 453                          ;
                 454            FAST_command: CALL read_next_char
                 455                          COMPARE s0, character_A                ;test for 'A' of 'FAST' command
                 456                          JUMP NZ, bad_command
                 457                          CALL read_next_char
                 458                          COMPARE s0, character_S                ;test for 'S' of 'FAST' command
                 459                          JUMP NZ, bad_command
                 460                          CALL read_next_char
                 461                          COMPARE s0, character_T                ;test for 'T' of 'FAST' command
                 462                          JUMP NZ, bad_command
                 463                          CALL read_next_char                    ;test for a space
                 464                          COMPARE s0, character_space
                 465                          JUMP NZ, bad_command
                 466                          CALL read_next_char
                 467                          COMPARE s0, character_O                ;test for 'O' of 'ON' or 'OFF'
                 468                          JUMP NZ, bad_command
                 469                          CALL read_next_char
                 470                          COMPARE s0, character_N                ;test for 'N' of 'ON'
                 471                          JUMP Z, test_fast_ON
                 472                          COMPARE s0, character_F                ;test for 'F' of 'OFF'
                 473                          JUMP NZ, bad_command
                 474                          CALL read_next_char
                 475                          COMPARE s0, character_F                ;test for 'F' of 'OFF'
                 476                          JUMP NZ, bad_command
                 477                          CALL read_next_char
                 478                          COMPARE s0, character_CR               ;test for carriage return
                 479                          JUMP NZ, bad_command
                 480                          LOAD s0, 00                            ;turn off fast mode
                 481                          JUMP update_fast
                 482            test_fast_ON: CALL read_next_char
                 483                          COMPARE s0, character_CR               ;test for carriage return
                 484                          JUMP NZ, bad_command
                 485                          LOAD s0, 01                            ;turn on fast mode
                 486             update_fast: STORE s0, fast_mode
                 487                          CALL send_OK
                 488                          JUMP warm_start
                 489                          ;
                 490                          ;Processing potential 'CYCLE' command
                 491                          ;
                 492           CYCLE_command: CALL read_next_char
                 493                          COMPARE s0, character_Y                ;test for 'Y' of 'CYCLE' command
                 494                          JUMP NZ, bad_command
                 495                          CALL read_next_char
                 496                          COMPARE s0, character_C                ;test for 'C' of 'CYCLE' command
                 497                          JUMP NZ, bad_command
                 498                          CALL read_next_char
                 499                          COMPARE s0, character_L                ;test for 'L' of 'CYCLE' command
                 500                          JUMP NZ, bad_command
                 501                          CALL read_next_char
                 502                          COMPARE s0, character_E                ;test for 'E' of 'CYCLE' command
                 503                          JUMP NZ, bad_command
                 504                          CALL read_next_char                    ;test for a space
                 505                          COMPARE s0, character_space
                 506                          JUMP NZ, bad_command
                 507                          CALL read_next_char                    ;determine decimal value of 'n' in [s9,s8,s7,s6]
                 508                          COMPARE s0, character_CR
                 509                          JUMP Z, bad_command                    ;need at least 1 digit
                 510                          CALL ASCII_to_decimal                  ;convert to decimal and test
                 511                          JUMP C, bad_command
                 512                          LOAD s6, s0
                 513                          LOAD s7, 00
                 514                          LOAD s8, 00
                 515                          LOAD s9, 00
                 516                          CALL read_next_char
                 517                          COMPARE s0, character_CR
                 518                          JUMP Z, store_n
                 519                          CALL ASCII_to_decimal
                 520                          JUMP C, bad_command
                 521                          LOAD s7, s6
                 522                          LOAD s6, s0
                 523                          CALL read_next_char
                 524                          COMPARE s0, character_CR
                 525                          JUMP Z, store_n
                 526                          CALL ASCII_to_decimal
                 527                          JUMP C, bad_command
                 528                          LOAD s8, s7
                 529                          LOAD s7, s6
                 530                          LOAD s6, s0
                 531                          CALL read_next_char
                 532                          COMPARE s0, character_CR
                 533                          JUMP Z, store_n
                 534                          CALL ASCII_to_decimal
                 535                          JUMP C, bad_command
                 536                          LOAD s9, s8
                 537                          LOAD s8, s7
                 538                          LOAD s7, s6
                 539                          LOAD s6, s0
                 540                          CALL read_next_char
                 541                          COMPARE s0, character_CR
                 542                          JUMP NZ, bad_command                   ;only 4 digits supported so must be a CR next
                 543                 store_n: STORE s6, n_count0                     ;store value of 'n'
                 544                          STORE s7, n_count1
                 545                          STORE s8, n_count2
                 546                          STORE s9, n_count3
                 547                          CALL send_CR
                 548                  n_loop: FETCH s6, n_count0                     ;Execute cycle command 'n' times
                 549                          FETCH s7, n_count1
                 550                          FETCH s8, n_count2
                 551                          FETCH s9, n_count3
                 552                          SUB s6, 01                             ;decrement counter
                 553                          JUMP NC, update_n
                 554                          LOAD s6, 09
                 555                          SUB s7, 01
                 556                          JUMP NC, update_n
                 557                          LOAD s7, 09
                 558                          SUB s8, 01
                 559                          JUMP NC, update_n
                 560                          LOAD s8, 09
                 561                          SUB s9, 01
                 562                          JUMP NC, update_n
                 563                          JUMP end_cycle                         ;roll under to 9999 signifies end of command
                 564                update_n: STORE s6, n_count0                     ;updated stored value of 'n'
                 565                          STORE s7, n_count1
                 566                          STORE s8, n_count2
                 567                          STORE s9, n_count3
                 568                          FETCH sE, fast_mode                    ;determine display mode
                 569                          COMPARE sE, 00                         ;display active if fast mode is off
                 570                          JUMP Z, step_test
                 571                          LOAD sE, 01                            ;turn display off for fast mode on
                 572                          COMPARE s6, 00                         ;but display last line of cycle command
                 573                          JUMP NZ, step_test
                 574                          COMPARE s7, 00
                 575                          JUMP NZ, step_test
                 576                          COMPARE s8, 00
                 577                          JUMP NZ, step_test
                 578                          COMPARE s9, 00
                 579                          JUMP NZ, step_test
                 580                          LOAD sE, 00
                 581               step_test: CALL step_line_store                   ;execute one test step of the line store
                 582                          JUMP n_loop
                 583               end_cycle: CALL send_index                        ;display index card for data
                 584                          CALL send_OK
                 585                          JUMP warm_start
                 586                          ;
                 587                          ;
                 588                          ;Read next character from scratch pad memory
                 589                          ;
                 590          read_next_char: ADD sE, 01
                 591                          FETCH s0, (sE)                         ;test for space
                 592                          RETURN
                 593                          ;
                 594                          ;
                 595                          ;
                 596                          ;**************************************************************************************
                 597                          ; Line Store step
                 598                          ;**************************************************************************************
                 599                          ;
                 600                          ; Performs one step of the line stores in which the following sequence is followed.
                 601                          ;
                 602                          ; 1) The cycle counter is incremented and then displayed.
                 603                          ; 2) Display the value about to be stored.
                 604                          ; 3) The current output from each line store is read and displayed.
                 605                          ;       This is representative of the value which would be captured on the next rising clock.
                 606                          ; 4) The clock enable to the line stores is activated storing the value held in the
                 607                          ;       line_store_input register.
                 608                          ; 5) Increment the value to be stored next time if function has been turned on.
                 609                          ;
                 610                          ; The display output is suppressed when register 'sE' is not zero.
                 611                          ;
                 612                          ;
                 613         step_line_store: FETCH s9, step_counter4                ;increment step counter
                 614                          FETCH s8, step_counter3
                 615                          FETCH s7, step_counter2
                 616                          FETCH s6, step_counter1
                 617                          FETCH s5, step_counter0
                 618                          ADD s5, 01
                 619                          COMPARE s5, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 620                          JUMP NZ, store_step_count
                 621                          LOAD s5, 00
                 622                          ADD s6, 01
                 623                          COMPARE s6, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 624                          JUMP NZ, store_step_count
                 625                          LOAD s6, 00
                 626                          ADD s7, 01
                 627                          COMPARE s7, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 628                          JUMP NZ, store_step_count
                 629                          LOAD s7, 00
                 630                          ADD s8, 01
                 631                          COMPARE s8, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 632                          JUMP NZ, store_step_count
                 633                          LOAD s8, 00
                 634                          ADD s9, 01
                 635                          COMPARE s9, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 636                          JUMP NZ, store_step_count
                 637                          LOAD s9, 00
                 638        store_step_count: STORE s9, step_counter4
                 639                          STORE s8, step_counter3
                 640                          STORE s7, step_counter2
                 641                          STORE s6, step_counter1
                 642                          STORE s5, step_counter0
                 643                          COMPARE sE, 00                         ;suppress display
                 644                          JUMP NZ, skip_display
                 645                          LOAD UART_data, s9                     ;display step counter
                 646                          ADD UART_data, 30
                 647                          CALL send_to_UART
                 648                          LOAD UART_data, s8
                 649                          ADD UART_data, 30
                 650                          CALL send_to_UART
                 651                          LOAD UART_data, s7
                 652                          ADD UART_data, 30
                 653                          CALL send_to_UART
                 654                          LOAD UART_data, s6
                 655                          ADD UART_data, 30
                 656                          CALL send_to_UART
                 657                          LOAD UART_data, s5
                 658                          ADD UART_data, 30
                 659                          CALL send_to_UART
                 660                          CALL send_space
                 661                          CALL send_space
                 662                          CALL send_space
                 663                          FETCH sA, test_data_in0                ;Read set value into [sC,sB,sA]
                 664                          FETCH sB, test_data_in1
                 665                          FETCH sC, test_data_in2
                 666                          FETCH s0, auto_inc
                 667                          LOAD s0, sC                            ;display value being input to line store
                 668                          CALL send_hex_byte
                 669                          LOAD s0, sB
                 670                          CALL send_hex_byte
                 671                          LOAD s0, sA
                 672                          CALL send_hex_byte
                 673                          CALL send_space
                 674                          CALL send_space
                 675                          INPUT s0, line_store1_output_H         ;read 24-bit line store 1 output and display
                 676                          CALL send_hex_byte
                 677                          INPUT s0, line_store1_output_M
                 678                          CALL send_hex_byte
                 679                          INPUT s0, line_store1_output_L
                 680                          CALL send_hex_byte
                 681                          CALL send_space
                 682                          CALL send_space
                 683                          INPUT s0, line_store2_output_H         ;read 18-bit line store 2 output and display
                 684                          CALL send_nibble
                 685                          INPUT s0, line_store2_output_M
                 686                          CALL send_hex_byte
                 687                          INPUT s0, line_store2_output_L
                 688                          CALL send_hex_byte
                 689                          CALL send_space
                 690                          CALL send_space
                 691                          INPUT s0, line_store3_output_H         ;read 13-bit line store 3 output and display
                 692                          CALL send_hex_byte
                 693                          INPUT s0, line_store3_output_L
                 694                          CALL send_hex_byte
                 695                          CALL send_space
                 696                          CALL send_space
                 697                          INPUT s0, line_store4a_output_H        ;read 24-bit line store 4 output 'A' and display
                 698                          CALL send_hex_byte
                 699                          INPUT s0, line_store4a_output_M
                 700                          CALL send_hex_byte
                 701                          INPUT s0, line_store4a_output_L
                 702                          CALL send_hex_byte
                 703                          CALL send_space
                 704                          INPUT s0, line_store4b_output_H        ;read 24-bit line store 4 output 'B' and display
                 705                          CALL send_hex_byte
                 706                          INPUT s0, line_store4b_output_M
                 707                          CALL send_hex_byte
                 708                          INPUT s0, line_store4b_output_L
                 709                          CALL send_hex_byte
                 710                          CALL send_space
                 711                          INPUT s0, line_store4c_output_H        ;read 24-bit line store 4 output 'C' and display
                 712                          CALL send_hex_byte
                 713                          INPUT s0, line_store4c_output_M
                 714                          CALL send_hex_byte
                 715                          INPUT s0, line_store4c_output_L
                 716                          CALL send_hex_byte
                 717                          CALL send_space
                 718                          CALL send_space
                 719                          INPUT s0, line_store5_output_H         ;read 12-bit line store 5 output and display
                 720                          CALL send_nibble
                 721                          INPUT s0, line_store5_output_L
                 722                          CALL send_hex_byte
                 723                          CALL send_space
                 724                          CALL send_space
                 725                          INPUT s0, line_store6_output_H         ;read 9-bit line store 6 output and display
                 726                          CALL send_nibble
                 727                          INPUT s0, line_store6_output_L
                 728                          CALL send_hex_byte
                 729                          CALL send_space
                 730                          CALL send_space
                 731                          INPUT s0, line_store7a_output_H        ;read 24-bit line store 7 output 'A' and display
                 732                          CALL send_hex_byte
                 733                          INPUT s0, line_store7a_output_M
                 734                          CALL send_hex_byte
                 735                          INPUT s0, line_store7a_output_L
                 736                          CALL send_hex_byte
                 737                          CALL send_space
                 738                          INPUT s0, line_store7b_output_H        ;read 24-bit line store 7 output 'B' and display
                 739                          CALL send_hex_byte
                 740                          INPUT s0, line_store7b_output_M
                 741                          CALL send_hex_byte
                 742                          INPUT s0, line_store7b_output_L
                 743                          CALL send_hex_byte
                 744                          CALL send_CR
                 745                          ;
                 746                          ;
                 747            skip_display: OUTPUT s0, line_store_write_en         ;dummy write to enable line stores
                 748                          FETCH s0, auto_inc                     ;increment input value if auto is 'on'
                 749                          ADD sA, s0
                 750                          ADDCY sB, 00
                 751                          ADDCY sC, 00
                 752                          STORE sA, test_data_in0                ;store new line store input value
                 753                          STORE sB, test_data_in1
                 754                          STORE sC, test_data_in2
                 755                          OUTPUT sA, line_store_input_L          ;Write data to register driving line store
                 756                          OUTPUT sB, line_store_input_M
                 757                          OUTPUT sC, line_store_input_H
                 758                          RETURN
                 759                          ;
                 760                          ;
                 761                          ;**************************************************************************************
                 762                          ; UART communication routines
                 763                          ;**************************************************************************************
                 764                          ;
                 765                          ; Read one character from the UART
                 766                          ;
                 767                          ; Character read will be returned in a register called 'UART_data'.
                 768                          ;
                 769                          ; The routine first tests the receiver FIFO buffer to see if data is present.
                 770                          ; If the FIFO is empty, the routine waits until there is a character to read.
                 771                          ; As this could take any amount of time the wait loop could include a call to a
                 772                          ; subroutine which performs a useful function.
                 773                          ;
                 774                          ;
                 775                          ; Registers used s0 and UART_data
                 776                          ;
                 777          read_from_UART: INPUT s0, status_port                  ;test Rx_FIFO buffer
                 778                          TEST s0, rx_data_present               ;wait if empty
                 779                          JUMP NZ, read_character
                 780                          JUMP read_from_UART
                 781          read_character: INPUT UART_data, UART_read_port        ;read from FIFO
                 782                          RETURN
                 783                          ;
                 784                          ;
                 785                          ;
                 786                          ; Transmit one character to the UART
                 787                          ;
                 788                          ; Character supplied in register called 'UART_data'.
                 789                          ;
                 790                          ; The routine first tests the transmit FIFO buffer to see if it is full.
                 791                          ; If the FIFO is full, then the routine waits until it there is space.
                 792                          ;
                 793                          ; Registers used s0
                 794                          ;
                 795            send_to_UART: INPUT s0, status_port                  ;test Tx_FIFO buffer
                 796                          TEST s0, tx_full                       ;wait if full
                 797                          JUMP Z, UART_write
                 798                          JUMP send_to_UART
                 799              UART_write: OUTPUT UART_data, UART_write_port
                 800                          RETURN
                 801                          ;
                 802                          ;
                 803                          ;**************************************************************************************
                 804                          ; Receive ASCII string from UART
                 805                          ;**************************************************************************************
                 806                          ;
                 807                          ;An ASCII string will be read from the UART and stored in scratch pad memory
                 808                          ;commencing at the location specified by a constant named 'string_start'.
                 809                          ;The string will have a maximum length of 16 characters including a
                 810                          ;carriage return (0D) denoting the end of the string.
                 811                          ;
                 812                          ;As each character is read, it is echoed to the UART transmitter.
                 813                          ;Some minor editing is supported using backspace (BS=08) which is used
                 814                          ;to adjust what is stored in scratch pad memory and adjust the display
                 815                          ;on the terminal screen using characters sent to the UART transmitter.
                 816                          ;
                 817                          ;A test is made for the receiver FIFO becoming full. A full status is treated as
                 818                          ;a potential error situation and will result in a 'Overflow Error' message being
                 819                          ;transmitted to the UART, the receiver FIFO being purged of all data and an
                 820                          ;empty string being stored (carriage return at first location).
                 821                          ;
                 822                          ;Registers used s0, s1, s2 and 'UART_data'.
                 823                          ;
                 824          receive_string: LOAD s1, string_start                  ;locate start of string
                 825                          LOAD s2, s1                            ;compute 16 character address
                 826                          ADD s2, 10
                 827       receive_full_test: INPUT s0, status_port                  ;test Rx_FIFO buffer for full
                 828                          TEST s0, rx_full
                 829                          JUMP NZ, read_error
                 830                          CALL read_from_UART                    ;obtain and echo character
                 831                          CALL send_to_UART
                 832                          STORE UART_data, (s1)                  ;write to memory
                 833                          COMPARE UART_data, character_CR        ;test for end of string
                 834                          RETURN Z
                 835                          COMPARE UART_data, character_BS        ;test for back space
                 836                          JUMP Z, BS_edit
                 837                          ADD s1, 01                             ;increment memory pointer
                 838                          COMPARE s1, s2                         ;test for pointer exceeding 16 characters
                 839                          JUMP NZ, receive_full_test             ;next character
                 840                          CALL send_backspace                    ;hold end of string position on terminal display
                 841                 BS_edit: SUB s1, 01                             ;memory pointer back one
                 842                          COMPARE s1, string_start               ;test for under flow
                 843                          JUMP C, string_start_again
                 844                          CALL send_space                        ;clear character at current position
                 845                          CALL send_backspace                    ;position cursor
                 846                          JUMP receive_full_test                 ;next character
                 847      string_start_again: CALL send_greater_than                 ;restore '>' at prompt
                 848                          JUMP receive_string                    ;begin again
                 849                          ;Receiver buffer overflow condition
                 850              read_error: CALL send_CR                           ;Transmit error message
                 851                          STORE UART_data, string_start          ;empty string in memory (start with CR)
                 852                          CALL send_Overflow_Error
                 853                          CALL send_CR
                 854      clear_UART_Rx_loop: INPUT s0, status_port                  ;test Rx_FIFO buffer for data
                 855                          TEST s0, rx_data_present
                 856                          RETURN Z                               ;finish when buffer is empty
                 857                          INPUT UART_data, UART_read_port        ;read from FIFO and ignore
                 858                          JUMP clear_UART_Rx_loop
                 859                          ;
                 860                          ;
                 861                          ;**************************************************************************************
                 862                          ; Useful ASCII conversion and handling routines
                 863                          ;**************************************************************************************
                 864                          ;
                 865                          ;
                 866                          ;
                 867                          ; Convert character to upper case
                 868                          ;
                 869                          ; The character supplied in register s0.
                 870                          ; If the character is in the range 'a' to 'z', it is converted
                 871                          ; to the equivalent upper case character in the range 'A' to 'Z'.
                 872                          ; All other characters remain unchanged.
                 873                          ;
                 874                          ; Registers used s0.
                 875                          ;
                 876              upper_case: COMPARE s0, 61                         ;eliminate character codes below 'a' (61 hex)
                 877                          RETURN C
                 878                          COMPARE s0, 7B                         ;eliminate character codes above 'z' (7A hex)
E: identifier cannot start with a digit: `7B'.
E: unexpected end of line.
                 879                          RETURN NC
                 880                          AND s0, DF                             ;mask bit5 to convert to upper case
                 881                          RETURN
                 882                          ;
                 883                          ;
                 884                          ;
                 885                          ; Convert string held in scratch pad memory to upper case.
                 886                          ;
                 887                          ; Registers used s0, s1
                 888                          ;
                 889       upper_case_string: LOAD s1, string_start
                 890                ucs_loop: FETCH s0, (s1)
                 891                          COMPARE s0, character_CR
                 892                          RETURN Z
                 893                          CALL upper_case
                 894                          STORE s0, (s1)
                 895                          ADD s1, 01
                 896                          JUMP ucs_loop
                 897                          ;
                 898                          ;
                 899                          ; Convert character '0' to '9' to numerical value in range 0 to 9
                 900                          ;
                 901                          ; The character supplied in register s0. If the character is in the
                 902                          ; range '0' to '9', it is converted to the equivalent decimal value.
                 903                          ; Characters not in the range '0' to '9' are signified by the return
                 904                          ; with the CARRY flag set.
                 905                          ;
                 906                          ; Registers used s0.
                 907                          ;
                 908          1char_to_value: ADD s0, C6                             ;reject character codes above '9' (39 hex)
E: identifier cannot start with a digit: `1char_to_value'.
E: unexpected :.
000 39000        909                          RETURN C                               ;carry flag is set
001 18110        910                          SUB s0, F6                             ;reject character codes below '0' (30 hex)
E: symbol not defined: `S0'.
E: symbol not defined: `F6'.
002 25000        911                          RETURN                                 ;carry is set if value not in range
                 912                          ;
                 913                          ;
                 914                          ;
                 915                          ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                 916                          ; an equivalent hexadecimal value in register 's0'.
                 917                          ;     The upper nibble is represented by an ASCII character in register s3.
                 918                          ;     The lower nibble is represented by an ASCII character in register s2.
                 919                          ;
                 920                          ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                 921                          ; will be set on return.
                 922                          ;
                 923                          ; Registers used s0, s2 and s3.
                 924                          ;
003 00110        925       ASCII_byte_to_hex: LOAD s0, s3                            ;Take upper nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
004 20010        926                          CALL ASCII_to_hex                      ;convert to value
005 39000        927                          RETURN C                               ;reject if out of range
006 00110        928                          LOAD s3, s0                            ;remember value
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
007 14106        929                          SL0 s3                                 ;multiply value by 16 to put in upper nibble
E: symbol not defined: `S3'.
008 14106        930                          SL0 s3
E: symbol not defined: `S3'.
009 14106        931                          SL0 s3
E: symbol not defined: `S3'.
00A 14106        932                          SL0 s3
E: symbol not defined: `S3'.
00B 00110        933                          LOAD s0, s2                            ;Take lower nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S2'.
00C 20010        934                          CALL ASCII_to_hex                      ;convert to value
00D 39000        935                          RETURN C                               ;reject if out of range
00E 04110        936                          OR s0, s3                              ;merge in the upper nibble with CARRY reset
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
00F 25000        937                          RETURN
                 938                          ;
                 939                          ;
                 940                          ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                 941                          ;
                 942                          ; If character is not valid for hex, then CARRY is set on return.
                 943                          ;
                 944                          ; Register used s0
                 945                          ;
010 10110        946            ASCII_to_hex: ADD s0, B9                             ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
E: symbol not defined: `B9'.
011 39000        947                          RETURN C
012 18110        948                          SUB s0, E9                             ;normalise 0 to 9 with A-F in 11 to 16 hex
E: symbol not defined: `S0'.
E: symbol not defined: `E9'.
013 39000        949                          RETURN C                               ;reject below ASCII code 30 ('0')
014 181B0        950                          SUB s0, 11                             ;isolate A-F down to 00 to 05 hex
E: symbol not defined: `S0'.
015 3E001        951                          JUMP NC, ASCII_letter
E: symbol not defined: `ASCII_LETTER'.
016 10170        952                          ADD s0, 07                             ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
017 39000        953                          RETURN C
018 18110        954                          SUB s0, F6                             ;convert to range 00 to 09
E: symbol not defined: `S0'.
E: symbol not defined: `F6'.
019 25000        955                          RETURN
                 956            ASCII_letter: ADD s0, 0A                             ;convert to range 0A to 0F
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
01A 25000        957                          RETURN
                 958                          ;
                 959                          ;
                 960                          ;
                 961                          ;
                 962                          ; Routine to convert ASCII data in 's0' to an equivalent DECIMAL value.
                 963                          ;
                 964                          ; If character is not valid for decimal, then CARRY is set on return.
                 965                          ;
                 966                          ; Register used s0
                 967                          ;
01B 10110        968        ASCII_to_decimal: ADD s0, C6                             ;test for above ASCII code 39 ('9')
E: symbol not defined: `S0'.
E: symbol not defined: `C6'.
01C 39000        969                          RETURN C
01D 18110        970                          SUB s0, F6                             ;normalise to 0 to 9
E: symbol not defined: `S0'.
E: symbol not defined: `F6'.
01E 25000        971                          RETURN                                 ;carry set for ASCII code below 30 ('0')
                 972                          ;
                 973                          ;
                 974                          ;
                 975                          ; Convert hexadecimal value provided in register s0 into ASCII characters
                 976                          ;
                 977                          ; The value provided must can be any value in the range 00 to FF and will be converted into
                 978                          ; two ASCII characters.
                 979                          ;     The upper nibble will be represented by an ASCII character returned in register s2.
                 980                          ;     The lower nibble will be represented by an ASCII character returned in register s1.
                 981                          ;
                 982                          ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                 983                          ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                 984                          ; hexadecimal requiring a further addition of 07 to the 30 already added.
                 985                          ;
                 986                          ; Registers used s0, s1 and s2.
                 987                          ;
01F 00110        988       hex_byte_to_ASCII: LOAD s1, s0                            ;remember value supplied
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
020 1410E        989                          SR0 s0                                 ;isolate upper nibble
E: symbol not defined: `S0'.
021 1410E        990                          SR0 s0
E: symbol not defined: `S0'.
022 1410E        991                          SR0 s0
E: symbol not defined: `S0'.
023 1410E        992                          SR0 s0
E: symbol not defined: `S0'.
024 20001        993                          CALL hex_to_ASCII                      ;convert
E: symbol not defined: `HEX_TO_ASCII'.
025 00110        994                          LOAD s2, s0                            ;upper nibble value in s2
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
026 00110        995                          LOAD s0, s1                            ;restore complete value
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                 996                          AND s0, 0F                             ;isolate lower nibble
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
027 20001        997                          CALL hex_to_ASCII                      ;convert
E: symbol not defined: `HEX_TO_ASCII'.
028 00110        998                          LOAD s1, s0                            ;lower nibble value in s1
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
029 25000        999                          RETURN
                1000                          ;
                1001                          ; Convert hexadecimal value provided in register s0 into ASCII character
                1002                          ;
                1003                          ;Register used s0
                1004                          ;
                1005            hex_to_ASCII: SUB s0, 0A                             ;test if value is in range 0 to 9
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
02A 3A001       1006                          JUMP C, number_char
E: symbol not defined: `NUMBER_CHAR'.
02B 10170       1007                          ADD s0, 07                             ;ASCII char A to F in range 41 to 46
E: symbol not defined: `S0'.
                1008             number_char: ADD s0, 3A                             ;ASCII char 0 to 9 in range 30 to 40
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
02C 25000       1009                          RETURN
                1010                          ;
                1011                          ;
                1012                          ; Send the two character HEX value of the register contents 's0' to the UART
                1013                          ;
                1014                          ; Registers used s0, s1, s2
                1015                          ;
02D 2001F       1016           send_hex_byte: CALL hex_byte_to_ASCII
02E 00110       1017                          LOAD UART_data, s2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `S2'.
02F 20001       1018                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
030 00110       1019                          LOAD UART_data, s1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `S1'.
031 20001       1020                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
032 25000       1021                          RETURN
                1022                          ;
                1023                          ;
                1024                          ;
                1025                          ; Send the single HEX value representing the lower 4-bits of the register 's0'
                1026                          ; to the UART
                1027                          ;
                1028                          ; Registers used s0, s1, s2
                1029                          ;
033 20001       1030             send_nibble: CALL hex_to_ASCII
E: symbol not defined: `HEX_TO_ASCII'.
034 00110       1031                          LOAD UART_data, s0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `S0'.
035 20001       1032                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
036 25000       1033                          RETURN
                1034                          ;
                1035                          ;
                1036                          ;
                1037                          ;**************************************************************************************
                1038                          ; Text messages
                1039                          ;**************************************************************************************
                1040                          ;
                1041                          ;
                1042                          ; Send Carriage Return to the UART
                1043                          ;
037 00110       1044                 send_CR: LOAD UART_data, character_CR
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_CR'.
038 20001       1045                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
039 25000       1046                          RETURN
                1047                          ;
                1048                          ; Send a space to the UART
                1049                          ;
03A 00110       1050              send_space: LOAD UART_data, character_space
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_SPACE'.
03B 20001       1051                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
03C 25000       1052                          RETURN
                1053                          ;
                1054                          ;
                1055                          ;
                1056                          ;Send a back space to the UART
                1057                          ;
03D 00110       1058          send_backspace: LOAD UART_data, character_BS
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_BS'.
03E 20001       1059                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
03F 25000       1060                          RETURN
                1061                          ;
                1062                          ;
                1063                          ; Send 'PicoBlaze Servo Control' string to the UART
                1064                          ;
040 20037       1065            send_welcome: CALL send_CR
041 20037       1066                          CALL send_CR
042 00110       1067                          LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
043 20001       1068                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
044 00110       1069                          LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
045 20001       1070                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
046 00110       1071                          LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
047 20001       1072                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
048 00110       1073                          LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
049 20001       1074                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04A 00110       1075                          LOAD UART_data, character_B
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_B'.
04B 20001       1076                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04C 00110       1077                          LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
04D 20001       1078                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
04E 00110       1079                          LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
04F 20001       1080                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
050 00110       1081                          LOAD UART_data, character_z
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_Z'.
051 20001       1082                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
052 00110       1083                          LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
053 20001       1084                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
054 2003A       1085                          CALL send_space
055 00110       1086                          LOAD UART_data, character_L
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
056 20001       1087                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
057 00110       1088                          LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
058 20001       1089                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
059 00110       1090                          LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
05A 20001       1091                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05B 00110       1092                          LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
05C 20001       1093                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
05D 2003A       1094                          CALL send_space
05E 00110       1095                          LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
05F 20001       1096                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
060 00110       1097                          LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
061 20001       1098                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
062 00110       1099                          LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
063 20001       1100                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
064 00110       1101                          LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
065 20001       1102                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
066 00110       1103                          LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
067 20001       1104                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
068 2003A       1105                          CALL send_space
069 00110       1106                          LOAD UART_data, character_T
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
06A 20001       1107                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06B 00110       1108                          LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
06C 20001       1109                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06D 00110       1110                          LOAD UART_data, character_s
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
06E 20001       1111                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
06F 00110       1112                          LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
070 20001       1113                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
071 00110       1114                          LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
072 20001       1115                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
073 00110       1116                          LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
074 20001       1117                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
075 20037       1118                          CALL send_CR
076 20037       1119                          CALL send_CR
077 25000       1120                          RETURN
                1121                          ;
                1122                          ;
                1123                          ;Send 'KCPSM3>' prompt to the UART
                1124                          ;
078 20037       1125             send_prompt: CALL send_CR                           ;start new line
079 00110       1126                          LOAD UART_data, character_K
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_K'.
07A 20001       1127                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07B 00110       1128                          LOAD UART_data, character_C
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
07C 20001       1129                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07D 00110       1130                          LOAD UART_data, character_P
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
07E 20001       1131                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
07F 00110       1132                          LOAD UART_data, character_S
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_S'.
080 20001       1133                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
081 00110       1134                          LOAD UART_data, character_M
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_M'.
082 20001       1135                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
083 00110       1136                          LOAD UART_data, character_3
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_3'.
084 20001       1137                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
                1138                          ;
                1139                          ;Send '>' character to the UART
                1140                          ;
085 00110       1141       send_greater_than: LOAD UART_data, character_greater_than
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_GREATER_THAN'.
086 20001       1142                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
087 25000       1143                          RETURN
                1144                          ;
                1145                          ;
                1146                          ;Send 'Overflow Error' to the UART
                1147                          ;
088 00110       1148     send_Overflow_Error: LOAD UART_data, character_O
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
089 20001       1149                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
08A 00110       1150                          LOAD UART_data, character_v
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_V'.
08B 20001       1151                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
08C 00110       1152                          LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
08D 20001       1153                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
08E 00110       1154                          LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
08F 20001       1155                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
090 00110       1156                          LOAD UART_data, character_f
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_F'.
091 20001       1157                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
092 00110       1158                          LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
093 20001       1159                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
094 00110       1160                          LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
095 20001       1161                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
096 00110       1162                          LOAD UART_data, character_w
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_W'.
097 20001       1163                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
098 2003A       1164        send_space_Error: CALL send_space
                1165                          ;
                1166                          ;Send 'Error' to the UART
                1167                          ;
099 00110       1168              send_Error: LOAD UART_data, character_E
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
09A 20001       1169                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
09B 00110       1170                          LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
09C 20001       1171                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
09D 20001       1172                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
09E 00110       1173                          LOAD UART_data, character_o
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
09F 20001       1174                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A0 00110       1175                          LOAD UART_data, character_r
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_R'.
0A1 20001       1176                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A2 22037       1177                          JUMP send_CR
                1178                          ;
                1179                          ;
                1180                          ;Send 'OK' to the UART
                1181                          ;
0A3 20037       1182                 send_OK: CALL send_CR
0A4 20037       1183                          CALL send_CR
0A5 00110       1184                          LOAD UART_data, character_O
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_O'.
0A6 20001       1185                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A7 00110       1186                          LOAD UART_data, character_K
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_K'.
0A8 20001       1187                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0A9 22037       1188                          JUMP send_CR
                1189                          ;
                1190                          ;
                1191                          ;Send index to data being displayed
                1192                          ;
0AA 20037       1193              send_index: CALL send_CR
0AB 00110       1194                          LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
0AC 20001       1195                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0AD 00110       1196                          LOAD UART_data, character_y
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_Y'.
0AE 20001       1197                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0AF 00110       1198                          LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
0B0 20001       1199                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B1 00110       1200                          LOAD UART_data, character_l
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_L'.
0B2 20001       1201                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B3 00110       1202                          LOAD UART_data, character_e
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_E'.
0B4 20001       1203                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0B5 2003A       1204                          CALL send_space
0B6 2003A       1205                          CALL send_space
0B7 2003A       1206                          CALL send_space
0B8 2003A       1207                          CALL send_space
0B9 00110       1208                          LOAD UART_data, character_i
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_I'.
0BA 20001       1209                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0BB 00110       1210                          LOAD UART_data, character_n
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_N'.
0BC 20001       1211                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0BD 00110       1212                          LOAD UART_data, character_p
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_P'.
0BE 20001       1213                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0BF 00110       1214                          LOAD UART_data, character_u
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_U'.
0C0 20001       1215                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C1 00110       1216                          LOAD UART_data, character_t
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_T'.
0C2 20001       1217                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0C3 2003A       1218                          CALL send_space
0C4 2003A       1219                          CALL send_space
0C5 2003A       1220                          CALL send_space
0C6 2003A       1221                          CALL send_space
0C7 2003A       1222                          CALL send_space
0C8 00110       1223                          LOAD UART_data, character_7
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_7'.
0C9 20001       1224                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0CA 00110       1225                          LOAD UART_data, character_6
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_6'.
0CB 20001       1226                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0CC 00110       1227                          LOAD UART_data, character_8
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_8'.
0CD 20001       1228                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0CE 2003A       1229                          CALL send_space
0CF 2003A       1230                          CALL send_space
0D0 2003A       1231                          CALL send_space
0D1 00110       1232                          LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
0D2 20001       1233                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D3 00110       1234                          LOAD UART_data, character_0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_0'.
0D4 20001       1235                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D5 00110       1236                          LOAD UART_data, character_2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_2'.
0D6 20001       1237                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D7 00110       1238                          LOAD UART_data, character_4
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_4'.
0D8 20001       1239                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0D9 2003A       1240                          CALL send_space
0DA 2003A       1241                          CALL send_space
0DB 20104       1242                          CALL send_1280
0DC 2003A       1243                          CALL send_space
0DD 2003A       1244                          CALL send_space
0DE 2003A       1245                          CALL send_space
0DF 20104       1246                          CALL send_1280
0E0 00110       1247                          LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
0E1 20001       1248                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E2 2003A       1249                          CALL send_space
0E3 2003A       1250                          CALL send_space
0E4 20104       1251                          CALL send_1280
0E5 00110       1252                          LOAD UART_data, character_b
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_B'.
0E6 20001       1253                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0E7 2003A       1254                          CALL send_space
0E8 2003A       1255                          CALL send_space
0E9 20104       1256                          CALL send_1280
0EA 00110       1257                          LOAD UART_data, character_c
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_C'.
0EB 20001       1258                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0EC 2003A       1259                          CALL send_space
0ED 00110       1260                          LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
0EE 20001       1261                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0EF 00110       1262                          LOAD UART_data, character_5
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_5'.
0F0 20001       1263                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F1 00110       1264                          LOAD UART_data, character_3
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_3'.
0F2 20001       1265                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F3 00110       1266                          LOAD UART_data, character_6
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_6'.
0F4 20001       1267                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0F5 2003A       1268                          CALL send_space
0F6 2010D       1269                          CALL send_1920
0F7 2003A       1270                          CALL send_space
0F8 2003A       1271                          CALL send_space
0F9 2003A       1272                          CALL send_space
0FA 2010D       1273                          CALL send_1920
0FB 00110       1274                          LOAD UART_data, character_a
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_A'.
0FC 20001       1275                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
0FD 2003A       1276                          CALL send_space
0FE 2003A       1277                          CALL send_space
0FF 2010D       1278                          CALL send_1920
100 00110       1279                          LOAD UART_data, character_b
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_B'.
101 20001       1280                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
102 20037       1281                          CALL send_CR
103 25000       1282                          RETURN
                1283                          ;
104 00110       1284               send_1280: LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
105 20001       1285                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
106 00110       1286                          LOAD UART_data, character_2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_2'.
107 20001       1287                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
108 00110       1288                          LOAD UART_data, character_8
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_8'.
109 20001       1289                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10A 00110       1290                          LOAD UART_data, character_0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_0'.
10B 20001       1291                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10C 25000       1292                          RETURN
                1293                          ;
10D 00110       1294               send_1920: LOAD UART_data, character_1
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_1'.
10E 20001       1295                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
10F 00110       1296                          LOAD UART_data, character_9
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_9'.
110 20001       1297                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
111 00110       1298                          LOAD UART_data, character_2
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_2'.
112 20001       1299                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
113 00110       1300                          LOAD UART_data, character_0
E: symbol not defined: `UART_DATA'.
E: symbol not defined: `CHARACTER_0'.
114 20001       1301                          CALL send_to_UART
E: symbol not defined: `SEND_TO_UART'.
115 25000       1302                          RETURN
                1303                          ;
                1304                          ;**************************************************************************************
                1305                          ; Interrupt Service Routine (ISR)
                1306                          ;**************************************************************************************
                1307                          ;
                1308                          ; Interrupts are not used in this program.
                1309                          ;
116 29001       1310                     ISR: RETURNI ENABLE
                1311                          ;
                1312                          ;
                1313                          ;**************************************************************************************
                1314                          ; Interrupt Vector
                1315                          ;**************************************************************************************
                1316                          ;
                1317                          ADDRESS 3FF
E: identifier cannot start with a digit: `3FF'.
E: directive ADDRESS requires a single argument.
117 22116       1318                          JUMP ISR
                1319                          ;
                1320                          ;
