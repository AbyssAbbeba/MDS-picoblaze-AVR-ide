                   1                                ; KCPSM3 Program - Implementation of the SHA-1 algorithm for use with the
                   2                                ;                  DS2432 secure memory on the Spartan-3E Starter Kit.
                   3                                ;
                   4                                ; Ken Chapman - Xilinx Ltd
                   5                                ;
                   6                                ; Version v1.00 - 19th April 2006
                   7                                ;
                   8                                ;
                   9                                ; IMPORTANT - This design builds on the reference design called "PicoBlaze
                  10                                ;             DS2432 communicator". It is highly recommend that you look at that
                  11                                ;             design before proceeding with this one.
                  12                                ;
                  13                                ;
                  14                                ; This program uses a 9600 baud UART connection to allow communication with the
                  15                                ; 1-wire interface of the DS2432 memory device from Dallas Semiconductor.
                  16                                ;
                  17                                ; The program only supports a limited number of the DS2432 commands to focus on
                  18                                ; those aspects which use the SHA-1 algorithm.
                  19                                ;
                  20                                ; Note that the code performing the SHA-1 algorithm interacts with the hardware of
                  21                                ; this complete reference design. The hardware provides a 16 word (32-bit) buffer
                  22                                ; combined used in the initialisation of the algorithm and subsequent computation
                  23                                ; of the Wt words.
                  24                                ;
                  25                                ;
                  26                                ; The DS2432 should be programmed with a 64-bit secret. The following constants
                  27                                ; define the secret which will be used. Obviously this would be be changed in a
                  28                                ; real application and further measures taken to prevent it easily being found.
                  29                                ; The secret is 64-bits formed of 8 bytes. 'secret0' would be stored at address
                  30                                ; 0080 of the DS2432 and 'secret7' at address 0087. The write buffer and load
                  31                                ; first secret commands allow you to set any secret into the DS2432 device but
                  32                                ; this program always uses the secret defined in these constants such that you can
                  33                                ; experiment with secrets which do and do not match.
                  34                                ;
                  35                                ;
  00001           36                                CONSTANT secret0, 01
  00017           37                                CONSTANT secret1, 23
  0002D           38                                CONSTANT secret2, 45
  00043           39                                CONSTANT secret3, 67
  00059           40                                CONSTANT secret4, 89
  00001           41                                CONSTANT secret5, AB
E: symbol not defined: `AB'.
  00001           42                                CONSTANT secret6, CD
E: symbol not defined: `CD'.
  00001           43                                CONSTANT secret7, EF
E: symbol not defined: `EF'.
                  44                                ;
                  45                                ;
                  46                                ; Bytes 4, 5 and 6 of the DS2432 scratch pad memory are used in the SHA-1 algorithm.
                  47                                ; These should be set using the write scratchpad memory command before using the
                  48                                ; read authenticated page command. HOWEVER, it is also important that you also use
                  49                                ; the read scratchpad command BEFORE using the read authenticated page command. This
                  50                                ; is because this program only copies the bytes 4, 5 and 6 during a read such that
                  51                                ; they are can be used by the PicoBlaze SHA-1 algorithm. This limitation is deliberate
                  52                                ; so that you can experiment and prove that the SHA-1 results will not match if
                  53                                ; the same 'challenge' bytes are not used.
                  54                                ;
                  55                                ;
                  56                                ;**************************************************************************************
                  57                                ; Port definitions
                  58                                ;**************************************************************************************
                  59                                ;
                  60                                ;
  00028           61                                CONSTANT status_port, 40                ;UART status input
  00001           62                                CONSTANT tx_half_full, 01               ;  Transmitter     half full - bit0
  00002           63                                CONSTANT tx_full, 02                    ;    FIFO               full - bit1
  00004           64                                CONSTANT rx_data_present, 04            ;  Receiver     data present - bit2
  00008           65                                CONSTANT rx_half_full, 08               ;    FIFO          half full - bit3
  0000A           66                                CONSTANT rx_full, 10                    ;                   full - bit4
  00014           67                                CONSTANT spare1, 20                     ;                  spare '0' - bit5
  00028           68                                CONSTANT spare2, 40                     ;                  spare '0' - bit6
  00050           69                                CONSTANT spare3, 80                     ;                  spare '0' - bit7
                  70                                ;
  00050           71                                CONSTANT UART_read_port, 80             ;UART Rx data input
                  72                                ;
  00004           73                                CONSTANT UART_write_port, 04            ;UART Tx data output
                  74                                ;
                  75                                ;
  00001           76                                CONSTANT DS_wire_in_port, C0            ;Read signal from DS2432 device
E: symbol not defined: `C0'.
  00008           77                                CONSTANT DS_wire_out_port, 08           ;Drive signal to DS2432 device (open collector)
  00001           78                                CONSTANT DS_wire, 01                    ;       Signal is bit0 in both cases
                  79                                ;
                  80                                ;
                  81                                ;
                  82                                ; The following ports access the 'Wt' word buffer. This buffer holds 16 words
                  83                                ; of 32-bits organised as a 64-byte shift register. Hence each word is stored
                  84                                ; by writing 4 bytes. As each byte is written, all bytes shift along such that
                  85                                ; older Wt values can be read from consistent port addresses.
                  86                                ;
  0000A           87                                CONSTANT W_word_write_port, 10          ;Write byte to Wt buffer
                  88                                ;
  00008           89                                CONSTANT Wt_minus3_byte0_read_port, 08  ;Read of Wt-3
  00009           90                                CONSTANT Wt_minus3_byte1_read_port, 09
                  91                                CONSTANT Wt_minus3_byte2_read_port, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
  00000           92                                CONSTANT Wt_minus3_byte3_read_port, 0B
                  93                                ;
                  94                                CONSTANT Wt_minus8_byte0_read_port, 1C  ;Read of Wt-8
E: identifier cannot start with a digit: `1C'.
E: unexpected end of line.
  00001           95                                CONSTANT Wt_minus8_byte1_read_port, 1D
                  96                                CONSTANT Wt_minus8_byte2_read_port, 1E
E: identifier cannot start with a digit: `1E'.
E: unexpected end of line.
                  97                                CONSTANT Wt_minus8_byte3_read_port, 1F
E: identifier cannot start with a digit: `1F'.
E: unexpected end of line.
                  98                                ;
  00022           99                                CONSTANT Wt_minus14_byte0_read_port, 34 ;Read of Wt-14
  00023          100                                CONSTANT Wt_minus14_byte1_read_port, 35
  00024          101                                CONSTANT Wt_minus14_byte2_read_port, 36
  00025          102                                CONSTANT Wt_minus14_byte3_read_port, 37
                 103                                ;
                 104                                CONSTANT Wt_minus16_byte0_read_port, 3C ;Read of Wt-16
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
  00003          105                                CONSTANT Wt_minus16_byte1_read_port, 3D
                 106                                CONSTANT Wt_minus16_byte2_read_port, 3E
E: identifier cannot start with a digit: `3E'.
E: unexpected end of line.
                 107                                CONSTANT Wt_minus16_byte3_read_port, 3F
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
                 108                                ;
                 109                                ;
                 110                                ;**************************************************************************************
                 111                                ; Special Register usage
                 112                                ;**************************************************************************************
                 113                                ;
  00001          114                                NAMEREG sF, UART_data                   ;used to pass data to and from the UART
E: symbol not defined: `SF'.
                 115                                ;
                 116                                ;
                 117                                ;**************************************************************************************
                 118                                ; Scratch Pad Memory Locations
                 119                                ;**************************************************************************************
                 120                                ;
                 121                                ; Scratch pad memory provides 64 bytes in the address range 00 to 3F hex.
                 122                                ;
                 123                                ;
                 124                                ; Locations for device family code, serial number and 8-bit CRC value
                 125                                ;
  00000          126                                CONSTANT family_code, 00
  00001          127                                CONSTANT serial_number0, 01             ;48-bit serial number LS-Byte first
  00002          128                                CONSTANT serial_number1, 02
  00003          129                                CONSTANT serial_number2, 03
  00004          130                                CONSTANT serial_number3, 04
  00005          131                                CONSTANT serial_number4, 05
  00006          132                                CONSTANT serial_number5, 06
  00007          133                                CONSTANT read_ROM_CRC, 07               ;8-bit CRC
                 134                                ;
                 135                                ;
                 136                                ; Locations for variables used in SHA-1 algorithm.
                 137                                ; Each variable is 32-bits and requires 4 bytes to store.
                 138                                ; '0' indicates the least significant byte and '3' the most significant byte.
                 139                                ;
                 140                                ; Note that the concatenation of 'A', 'B', 'C', 'D' and 'E' will be the 160-bit MAC.
                 141                                ;
  00008          142                                CONSTANT var_A0, 08                     ;Variable 'A'
  00009          143                                CONSTANT var_A1, 09
                 144                                CONSTANT var_A2, 0A
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
  00000          145                                CONSTANT var_A3, 0B
                 146                                ;
                 147                                CONSTANT var_B0, 0C                     ;Variable 'B'
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
  00000          148                                CONSTANT var_B1, 0D
                 149                                CONSTANT var_B2, 0E
E: identifier cannot start with a digit: `0E'.
E: unexpected end of line.
                 150                                CONSTANT var_B3, 0F
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
                 151                                ;
  0000A          152                                CONSTANT var_C0, 10                     ;Variable 'C'
  0000B          153                                CONSTANT var_C1, 11
  0000C          154                                CONSTANT var_C2, 12
  0000D          155                                CONSTANT var_C3, 13
                 156                                ;
  0000E          157                                CONSTANT var_D0, 14                     ;Variable 'D'
  0000F          158                                CONSTANT var_D1, 15
  00010          159                                CONSTANT var_D2, 16
  00011          160                                CONSTANT var_D3, 17
                 161                                ;
  00012          162                                CONSTANT var_E0, 18                     ;Variable 'E'
  00013          163                                CONSTANT var_E1, 19
                 164                                CONSTANT var_E2, 1A
E: identifier cannot start with a digit: `1A'.
E: unexpected end of line.
  00001          165                                CONSTANT var_E3, 1B
                 166                                ;
                 167                                ;
                 168                                ; Copy of data in the scratchpad memory of the DS2432.
                 169                                ; This is only updated by the read scratchpad memory command.
                 170                                ; '0' indicates the data in the least significant location.
                 171                                ;
                 172                                CONSTANT scratchpad0, 1C
E: identifier cannot start with a digit: `1C'.
E: unexpected end of line.
  00001          173                                CONSTANT scratchpad1, 1D
                 174                                CONSTANT scratchpad2, 1E
E: identifier cannot start with a digit: `1E'.
E: unexpected end of line.
                 175                                CONSTANT scratchpad3, 1F
E: identifier cannot start with a digit: `1F'.
E: unexpected end of line.
  00014          176                                CONSTANT scratchpad4, 20
  00015          177                                CONSTANT scratchpad5, 21
  00016          178                                CONSTANT scratchpad6, 22
  00017          179                                CONSTANT scratchpad7, 23
                 180                                ;
                 181                                ;
                 182                                ;
                 183                                ;**************************************************************************************
                 184                                ; Useful data constants
                 185                                ;**************************************************************************************
                 186                                ;
                 187                                ; Constant to define a software delay of 1us. This must be adjusted to reflect the
                 188                                ; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 189                                ; calculation highly predictable. The '6' in the following equation even allows for
                 190                                ; 'CALL delay_1us' instruction in the initiating code.
                 191                                ;
                 192                                ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 193                                ;
                 194                                ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 195                                ; For clock rates below 10MHz the value of 1 must be used and the operation will
                 196                                ; become lower than intended.
                 197                                ;
  00000          198                                CONSTANT delay_1us_constant, 0B
                 199                                ;
                 200                                ;
                 201                                ;
                 202                                ;ASCII table
                 203                                ;
  0003D          204                                CONSTANT character_a, 61
  0003E          205                                CONSTANT character_b, 62
  0003F          206                                CONSTANT character_c, 63
  00040          207                                CONSTANT character_d, 64
  00041          208                                CONSTANT character_e, 65
  00042          209                                CONSTANT character_f, 66
  00043          210                                CONSTANT character_g, 67
  00044          211                                CONSTANT character_h, 68
  00045          212                                CONSTANT character_i, 69
                 213                                CONSTANT character_j, 6A
E: identifier cannot start with a digit: `6A'.
E: unexpected end of line.
                 214                                CONSTANT character_k, 6B
E: identifier cannot start with a digit: `6B'.
E: unexpected end of line.
                 215                                CONSTANT character_l, 6C
E: identifier cannot start with a digit: `6C'.
E: unexpected end of line.
  00006          216                                CONSTANT character_m, 6D
                 217                                CONSTANT character_n, 6E
E: identifier cannot start with a digit: `6E'.
E: unexpected end of line.
                 218                                CONSTANT character_o, 6F
E: identifier cannot start with a digit: `6F'.
E: unexpected end of line.
  00046          219                                CONSTANT character_p, 70
  00047          220                                CONSTANT character_q, 71
  00048          221                                CONSTANT character_r, 72
  00049          222                                CONSTANT character_s, 73
  0004A          223                                CONSTANT character_t, 74
  0004B          224                                CONSTANT character_u, 75
  0004C          225                                CONSTANT character_v, 76
  0004D          226                                CONSTANT character_w, 77
  0004E          227                                CONSTANT character_x, 78
  0004F          228                                CONSTANT character_y, 79
                 229                                CONSTANT character_z, 7A
E: identifier cannot start with a digit: `7A'.
E: unexpected end of line.
                 230                                CONSTANT character_A, 41
E: symbol already defined: "CHARACTER_A".
                 231                                CONSTANT character_B, 42
E: symbol already defined: "CHARACTER_B".
                 232                                CONSTANT character_C, 43
E: symbol already defined: "CHARACTER_C".
                 233                                CONSTANT character_D, 44
E: symbol already defined: "CHARACTER_D".
                 234                                CONSTANT character_E, 45
E: symbol already defined: "CHARACTER_E".
                 235                                CONSTANT character_F, 46
E: symbol already defined: "CHARACTER_F".
                 236                                CONSTANT character_G, 47
E: symbol already defined: "CHARACTER_G".
                 237                                CONSTANT character_H, 48
E: symbol already defined: "CHARACTER_H".
                 238                                CONSTANT character_I, 49
E: symbol already defined: "CHARACTER_I".
                 239                                CONSTANT character_J, 4A
E: identifier cannot start with a digit: `4A'.
E: unexpected end of line.
                 240                                CONSTANT character_K, 4B
E: identifier cannot start with a digit: `4B'.
E: unexpected end of line.
                 241                                CONSTANT character_L, 4C
E: identifier cannot start with a digit: `4C'.
E: unexpected end of line.
                 242                                CONSTANT character_M, 4D
E: symbol already defined: "CHARACTER_M".
                 243                                CONSTANT character_N, 4E
E: identifier cannot start with a digit: `4E'.
E: unexpected end of line.
                 244                                CONSTANT character_O, 4F
E: identifier cannot start with a digit: `4F'.
E: unexpected end of line.
                 245                                CONSTANT character_P, 50
E: symbol already defined: "CHARACTER_P".
                 246                                CONSTANT character_Q, 51
E: symbol already defined: "CHARACTER_Q".
                 247                                CONSTANT character_R, 52
E: symbol already defined: "CHARACTER_R".
                 248                                CONSTANT character_S, 53
E: symbol already defined: "CHARACTER_S".
                 249                                CONSTANT character_T, 54
E: symbol already defined: "CHARACTER_T".
                 250                                CONSTANT character_U, 55
E: symbol already defined: "CHARACTER_U".
                 251                                CONSTANT character_V, 56
E: symbol already defined: "CHARACTER_V".
                 252                                CONSTANT character_W, 57
E: symbol already defined: "CHARACTER_W".
                 253                                CONSTANT character_X, 58
E: symbol already defined: "CHARACTER_X".
                 254                                CONSTANT character_Y, 59
E: symbol already defined: "CHARACTER_Y".
                 255                                CONSTANT character_Z, 5A
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
  0001E          256                                CONSTANT character_0, 30
  0001F          257                                CONSTANT character_1, 31
  00020          258                                CONSTANT character_2, 32
  00021          259                                CONSTANT character_3, 33
  00022          260                                CONSTANT character_4, 34
  00023          261                                CONSTANT character_5, 35
  00024          262                                CONSTANT character_6, 36
  00025          263                                CONSTANT character_7, 37
  00026          264                                CONSTANT character_8, 38
  00027          265                                CONSTANT character_9, 39
                 266                                CONSTANT character_colon, 3A
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                 267                                CONSTANT character_fullstop, 2E
E: identifier cannot start with a digit: `2E'.
E: unexpected end of line.
                 268                                CONSTANT character_semi_colon, 3B
E: identifier cannot start with a digit: `3B'.
E: unexpected end of line.
  00002          269                                CONSTANT character_minus, 2D
                 270                                CONSTANT character_plus, 2B
E: identifier cannot start with a digit: `2B'.
E: unexpected end of line.
                 271                                CONSTANT character_comma, 2C
E: identifier cannot start with a digit: `2C'.
E: unexpected end of line.
                 272                                CONSTANT character_less_than, 3C        ;'<'
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
                 273                                CONSTANT character_greater_than, 3E     ;'>'
E: identifier cannot start with a digit: `3E'.
E: unexpected end of line.
  0001C          274                                CONSTANT character_open, 28             ;'('
  0001D          275                                CONSTANT character_close, 29            ;')'
                 276                                CONSTANT character_divide, 2F           ;'/'
E: identifier cannot start with a digit: `2F'.
E: unexpected end of line.
  00003          277                                CONSTANT character_equals, 3D
  00014          278                                CONSTANT character_space, 20
  00000          279                                CONSTANT character_CR, 0D               ;carriage return
                 280                                CONSTANT character_LF, 0A               ;line feed
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 281                                CONSTANT character_question, 3F         ;'?'
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
  00018          282                                CONSTANT character_dollar, 24
  00015          283                                CONSTANT character_exclaim, 21          ;'!'
  00008          284                                CONSTANT character_BS, 08               ;Back Space command character
  0000B          285                                CONSTANT character_XON, 11              ;Flow control ON
  0000D          286                                CONSTANT character_XOFF, 13             ;Flow control OFF
                 287                                ;
                 288                                ;
                 289                                ;**************************************************************************************
                 290                                ; Initialise the system and welcome message
                 291                                ;**************************************************************************************
                 292                                ;
000 20226        293                    cold_start: CALL DS_wire_init                       ;Ensure DS_wire is not driven (pulled High)
001 2028F        294                                CALL delay_1s                           ;Allow everything to settle!
002 202FA        295                 welcome_start: CALL send_welcome                       ;start up message and version number
                 296                                ;
                 297                                ;
                 298                                ;**************************************************************************************
                 299                                ; Reset Main menu and command selection
                 300                                ;**************************************************************************************
                 301                                ;
                 302                                ; The main program allows you to use four of the DS2432 memory and SHA function
                 303                                ; commands. A simple menu is displayed and you are guided to enter more information
                 304                                ; when required. All the communication and protocol required to get the DS2432 ready
                 305                                ; to receive memory and SHA function commands has been automated although information
                 306                                ; is displayed to indicate the procedures being executed.
                 307                                ;
                 308                                ; Before any memory and function commands are available a master reset and read ROM
                 309                                ; command must be issued.
                 310                                ;
003 202DC        311                    warm_start: CALL send_CR
004 202DC        312                                CALL send_CR
005 20229        313                                CALL DS_init_regular_mode               ;master reset
006 3A003        314                                JUMP C, warm_start                      ;repeat reset if no presence pulse detected
007 2001D        315                                CALL read_ROM_command                   ;read ROM command and display results
                 316                                ;
                 317                                ; After a valid ROM command the DS2432 specific memory commands and SHA-1
                 318                                ; functions become accessible. This program assumes that the ROM command did
                 319                                ; 'Pass' so you will need to check yourself. If this program automatically
                 320                                ; reset the DS2432 and tried again and there was a fault it would just cause
                 321                                ; the display to roll continuously and not be very informative!
                 322                                ;
                 323                                ; Each of the DS2432 commands selected from the menu will require the master reset
                 324                                ; and read ROM command to be repeated before being able to proceed with the next
                 325                                ; memory or SHA-1 function. This is automated by the program.
                 326                                ;
                 327                                ;
008 20334        328                   DS2432_menu: CALL send_DS2432_menu                   ;Menu and command selection
009 202DC        329                                CALL send_CR
                 330                                ;
00A 202DC        331                 DS2432_prompt: CALL send_CR                            ;prompt for user input
00B 202DC        332                                CALL send_CR
00C 00110        333                                LOAD UART_data, character_greater_than  ;prompt for input
E: symbol not defined: `CHARACTER_GREATER_THAN'.
00D 2029A        334                                CALL send_to_UART
00E 202D1        335                                CALL read_upper_case
00F 1C1F0        336                                COMPARE s0, character_1                 ;test for commands and execute as required
E: symbol not defined: `S0'.
W: value out of range: 0x1f, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xf.
010 32051        337                                JUMP Z, write_scratchpad_command
011 1C100        338                                COMPARE s0, character_2
E: symbol not defined: `S0'.
W: value out of range: 0x20, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
012 32076        339                                JUMP Z, read_scratchpad_command
013 1C110        340                                COMPARE s0, character_3
E: symbol not defined: `S0'.
W: value out of range: 0x21, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
014 32001        341                                JUMP Z, load_first_secret_command
E: symbol not defined: `LOAD_FIRST_SECRET_COMMAND'.
015 1C120        342                                COMPARE s0, character_4
E: symbol not defined: `S0'.
W: value out of range: 0x22, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
016 3209A        343                                JUMP Z, read_auth_page_command
017 202DC        344                                CALL send_CR                            ;no valid command input
018 00110        345                                LOAD UART_data, character_question      ;display ???
E: symbol not defined: `CHARACTER_QUESTION'.
019 2029A        346                                CALL send_to_UART
01A 2029A        347                                CALL send_to_UART
01B 2029A        348                                CALL send_to_UART
01C 2200A        349                                JUMP DS2432_prompt                      ;Try again!
                 350                                ;
                 351                                ;
                 352                                ;
                 353                                ;
                 354                                ;**************************************************************************************
                 355                                ; DS2432 Read ROM Command.
                 356                                ;**************************************************************************************
                 357                                ;
                 358                                ; The read ROM command (33 hex) allows the 8-bit family code, 48-bit unique serial
                 359                                ; number and 8-bit CRC to be read from the DS2432 device.
                 360                                ;
                 361                                ; This routine reads the values and places them in KCPSM3 scratch pad memory
                 362                                ; locations for future reference. These locations should be defined with constants
                 363                                ; as follows and MUST be in consecutive ascending locations.
                 364                                ;
                 365                                ;  family_code
                 366                                ;     Location to store family code which should be 33 hex
                 367                                ;  serial_number0 to serial_number5
                 368                                ;     6 bytes to hold 48-bit serial number (LS-byte first).
                 369                                ;  read_ROM_CRC
                 370                                ;     8-bit CRC value for the above data.
                 371                                ;
                 372                                ;
                 373                                ; The routine also displays the values read and performs a verification of the
                 374                                ; 8-bit CRC displaying a 'Pass' or 'Fail' message as appropriate.
                 375                                ;
01D 00110        376              read_ROM_command: LOAD s3, 33                             ;Read ROM Command
E: symbol not defined: `S3'.
W: value out of range: 0x21, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
01E 20244        377                                CALL write_byte_slow                    ;transmit command
01F 00100        378                                LOAD s5, family_code                    ;memory pointer
E: symbol not defined: `S5'.
020 20265        379                 read_ROM_loop: CALL read_byte_slow                     ;read response into s3
021 2F101        380                                STORE s3, (s5)                          ;store value
E: symbol not defined: `S3'.
E: symbol not defined: `S5'.
022 1C170        381                                COMPARE s5, read_ROM_CRC                ;8-bytes to read
E: symbol not defined: `S5'.
023 32026        382                                JUMP Z, display_ROM
024 10110        383                                ADD s5, 01
E: symbol not defined: `S5'.
025 22020        384                                JUMP read_ROM_loop
026 202DC        385                   display_ROM: CALL send_CR
027 203C6        386                                CALL send_code                          ;'code=' to display family code
028 0B100        387                                FETCH s0, family_code
E: symbol not defined: `S0'.
029 202B3        388                                CALL send_hex_byte
02A 202DC        389                                CALL send_CR
02B 203CC        390                                CALL send_sn                            ;'s/n=' to display family code
02C 00160        391                                LOAD s5, serial_number5                 ;memory pointer starting MS-byte first
E: symbol not defined: `S5'.
02D 0B101        392              disp_serial_loop: FETCH s0, (s5)
E: symbol not defined: `S0'.
E: symbol not defined: `S5'.
02E 202B3        393                                CALL send_hex_byte
02F 1C110        394                                COMPARE s5, serial_number0
E: symbol not defined: `S5'.
030 32033        395                                JUMP Z, end_serial
031 18110        396                                SUB s5, 01
E: symbol not defined: `S5'.
032 2202D        397                                JUMP disp_serial_loop
033 202DC        398                    end_serial: CALL send_CR
034 203D2        399                                CALL send_crc                           ;'CRC=' to display CRC value
035 0B107        400                                FETCH s0, read_ROM_CRC
E: symbol not defined: `S0'.
036 202B3        401                                CALL send_hex_byte
037 202DC        402                                CALL send_CR
038 201E7        403                                CALL compute_CRC8                       ;compute CRC value in s0
039 0B107        404                                FETCH s1, read_ROM_CRC                  ;compare with received value
E: symbol not defined: `S1'.
03A 1C110        405                                COMPARE s0, s1
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
03B 3603E        406                                JUMP NZ, crc8_fail
03C 2039D        407                                CALL send_Pass
03D 25000        408                                RETURN
03E 203A4        409                     crc8_fail: CALL send_Fail
03F 25000        410                                RETURN
                 411                                ;
                 412                                ;
                 413                                ;
                 414                                ;**************************************************************************************
                 415                                ; DS2432 Load First Secret Command.
                 416                                ;**************************************************************************************
                 417                                ;
                 418                                ; This command will only be valid if the write scratchpad memory command has previously
                 419                                ; been used to define the new secret to be stored at address 0080.
                 420                                ;
                 421                                ; The Load First Secret Command (5A hex) will only copy the scratchpad contents into                           ;
                 422                                ; the EEPROM array of the DS2432 if the address was correctly specified in the
                 423                                ; write scratchpad command. This routine will assume that the address specified
                 424                                ; was 0080. If everything is OK with the programming of the secret, the DS2432 responds
                 425                                ; with 'AA' hex after the command and this routine will report 'Pass'. You can further
                 426                                ; check using a read scratchpad command and look to see if E/S has changed from '5F'
                 427                                ; to 'DF' which indicates the successful write.
                 428                                ;
                 429                                ; Note that this program defines the secret to be used by the PicoBlaze SHA-1 algorithm
                 430                                ; in the constants 'secret0' through to 'secret7'. Only if you program the DS2432
                 431                                ; with a matching secret will the read authenticated message command result in a
                 432                                ; 'Pass' being reported for the MAC. This Load First Secret Command routine deliberately
                 433                                ; does not update the secret used by the PicoBlaze SHA-1 algorithm so that you can
                 434                                ; prove that only a DS2432 with the matching secret will generate matching MAC
                 435                                ; responses.
                 436                                ;
                 437                                ;
                 438                                ;
                 439     load_first_secret_command: LOAD s3, 5A                             ;Load First Secret Command
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
040 20244        440                                CALL write_byte_slow                    ;transmit command
041 00100        441                                LOAD s3, 80                             ;TA1 value for secret = 80 hex
E: symbol not defined: `S3'.
W: value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
042 20244        442                                CALL write_byte_slow
043 00100        443                                LOAD s3, 00                             ;TA2 value for secret = 00 hex
E: symbol not defined: `S3'.
044 20244        444                                CALL write_byte_slow
                 445                                LOAD s3, 5F                             ;E/S value before writing = 5F hex
E: identifier cannot start with a digit: `5F'.
E: unexpected end of line.
045 20244        446                                CALL write_byte_slow
046 2028A        447                                CALL delay_20ms                         ;write takes place in 10ms
047 202DC        448                                CALL send_CR
048 20381        449                                CALL send_secret
049 202DF        450                                CALL send_space
04A 20265        451                                CALL read_byte_slow                     ;read data into s3
04B 1C110        452                                COMPARE s3, AA                          ;test response
E: symbol not defined: `S3'.
E: symbol not defined: `AA'.
04C 3204F        453                                JUMP Z, secret_pass
04D 203A4        454                                CALL send_Fail
04E 22003        455                                JUMP warm_start
04F 2039D        456                   secret_pass: CALL send_Pass
050 22003        457                                JUMP warm_start
                 458                                ;
                 459                                ;
                 460                                ;**************************************************************************************
                 461                                ; DS2432 Write Scratchpad Memory Command.
                 462                                ;**************************************************************************************
                 463                                ;
                 464                                ; The write scratchpad memory command (0F hex) allows 8-bytes of data to be written
                 465                                ; together with a target address for final storage in the main memory map. The
                 466                                ; DS2432 scratch pad is also used to define a 3 byte 'challenge' used in the
                 467                                ; SHA-1 algorithm.
                 468                                ;
                 469                                ; The DS2432 provides an initial confirmation of the write by returning a 16-bit CRC
                 470                                ; value which KCPSM3 tests. The CRC is computed based on the command, address and
                 471                                ; data transmitted (11 bytes). PicoBlaze also computes the CRC and and tests this
                 472                                ; against the value received from the DS2432.
                 473                                ;
                 474                                ; This routine prompts the user to enter the 16-bit target address is to be loaded
                 475                                ; into the target address registers TA2 and TA1 in the DS2432 device. Note that only
                 476                                ; address values below 0090 hex are valid. If the address is too high, then the
                 477                                ; DS2432 aborts the command and this routine will too.
                 478                                ;
                 479                                ; Also note that the address will be forced internally to the DS2432 to match an
                 480                                ; 8-byte boundary address in which the least significant 3-bits are reset to '000'
                 481                                ; regardless of the address provided. The CRC still reflects the transmitted address.
                 482                                ;
                 483                                ; After providing a valid address, the routine then prompts the user to enter
                 484                                ; 8 bytes of data which are written to the DS2432.
                 485                                ;
                 486                                ;
                 487                                ;
051 20201        488      write_scratchpad_command: CALL clear_CRC16                        ;prepare CRC registers [sE,sD]
                 489                                LOAD s3, 0F                             ;write scratchpad memory Command
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
052 20244        490                                CALL write_byte_slow                    ;transmit command
053 20204        491                                CALL compute_CRC16                      ;compute CRC for value in 's3'
054 203AD        492                 wsc_addr_loop: CALL send_address                       ;obtain 16-bit address 0000 to FFFF in [s5,s4]
055 202D6        493                                CALL obtain_8bits
056 3A054        494                                JUMP C, wsc_addr_loop                   ;bad input address
057 00110        495                                LOAD s5, s0
E: symbol not defined: `S5'.
E: symbol not defined: `S0'.
058 202D6        496                                CALL obtain_8bits
059 3A054        497                                JUMP C, wsc_addr_loop                   ;bad input address
05A 00110        498                                LOAD s4, s0
E: symbol not defined: `S4'.
E: symbol not defined: `S0'.
05B 00110        499                                LOAD s3, s4                             ;transmit target address TA1 (LS-Byte)
E: symbol not defined: `S3'.
E: symbol not defined: `S4'.
05C 20244        500                                CALL write_byte_slow
05D 20204        501                                CALL compute_CRC16                      ;compute CRC for value in 's3'
05E 00110        502                                LOAD s3, s5                             ;transmit target address TA2 (MS-Byte)
E: symbol not defined: `S3'.
E: symbol not defined: `S5'.
05F 20244        503                                CALL write_byte_slow
060 20204        504                                CALL compute_CRC16                      ;compute CRC for value in 's3'
061 1C100        505                                COMPARE s5, 00                          ;check address less than 0090 hex
E: symbol not defined: `S5'.
062 36003        506                                JUMP NZ, warm_start                     ;DS2432 aborts command and so do we!
063 1C1A0        507                                COMPARE s4, 90                          ;no need to read data bytes.
E: symbol not defined: `S4'.
W: value out of range: 0x5a, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xa.
064 3E003        508                                JUMP NC, warm_start
065 00100        509                                LOAD s4, 00                             ;initialise byte counter
E: symbol not defined: `S4'.
066 203B8        510                 wsc_data_loop: CALL send_data                          ;obtain a byte of data
067 00110        511                                LOAD UART_data, s4                      ;display which byte requested
E: symbol not defined: `S4'.
068 101E0        512                                ADD UART_data, character_0              ;convert to ASCII
W: value out of range: 0x1e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
069 2029A        513                                CALL send_to_UART
06A 203B5        514                                CALL send_equals
06B 202D6        515                                CALL obtain_8bits
06C 3A066        516                                JUMP C, wsc_data_loop                   ;bad input data
06D 00110        517                                LOAD s3, s0                             ;transmit byte
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
06E 20244        518                                CALL write_byte_slow
06F 20204        519                                CALL compute_CRC16                      ;compute CRC for value in 's3'
070 10110        520                                ADD s4, 01                              ;count bytes
E: symbol not defined: `S4'.
071 1C180        521                                COMPARE s4, 08
E: symbol not defined: `S4'.
072 36066        522                                JUMP NZ, wsc_data_loop
073 202DC        523                                CALL send_CR
074 20212        524                                CALL read_send_test_CRC16               ;read, display and test CRC value
075 22003        525                                JUMP warm_start
                 526                                ;
                 527                                ;
                 528                                ;
                 529                                ;**************************************************************************************
                 530                                ; DS2432 Read Scratchpad Memory Command.
                 531                                ;**************************************************************************************
                 532                                ;
                 533                                ; The read scratchpad memory command (AA hex) allows the 8-bytes of data previously
                 534                                ; to be written into the scratchpad memory to be read back for verification together with
                 535                                ; the target address, a transfer status register (E/S) and a 16-bit CRC value.
                 536                                ;
                 537                                ; The 16-bit CRC is formed of the command byte, address TA1 and TA2, E/S byte and 8 data
                 538                                ; bytes as transmitted (12 bytes). These may not be the same as the values provided
                 539                                ; during a previous write to scratchpad memory. PicoBlaze also computes the CRC and
                 540                                ; and tests this against the value received from the DS2432.
                 541                                ;
                 542                                ; The 8 bytes of data are also copied to PicoBlaze memory at locations defined by the
                 543                                ; constants 'scratchpad0' to 'scratchpad7'. Three bytes are used as a 'challenge'
                 544                                ; by the SHA-1 algorithm.
                 545                                ;
                 546                                ;
                 547                                ;
076 20201        548       read_scratchpad_command: CALL clear_CRC16                        ;prepare CRC registers [sE,sD]
077 00110        549                                LOAD s3, AA                             ;read scratchpad memory Command
E: symbol not defined: `S3'.
E: symbol not defined: `AA'.
078 20244        550                                CALL write_byte_slow                    ;transmit command
079 20204        551                                CALL compute_CRC16                      ;compute CRC for value in 's3'
07A 203AD        552                                CALL send_address                       ;display 'Address='
07B 20265        553                                CALL read_byte_slow                     ;read address into [s5,s4]
07C 20204        554                                CALL compute_CRC16                      ;compute CRC for value in 's3'
07D 00110        555                                LOAD s4, s3
E: symbol not defined: `S4'.
E: symbol not defined: `S3'.
07E 20265        556                                CALL read_byte_slow
07F 20204        557                                CALL compute_CRC16                      ;compute CRC for value in 's3'
080 00110        558                                LOAD s5, s3
E: symbol not defined: `S5'.
E: symbol not defined: `S3'.
081 00110        559                                LOAD s0, s5                             ;display address
E: symbol not defined: `S0'.
E: symbol not defined: `S5'.
082 202B3        560                                CALL send_hex_byte
083 00110        561                                LOAD s0, s4
E: symbol not defined: `S0'.
E: symbol not defined: `S4'.
084 202B3        562                                CALL send_hex_byte
085 203BE        563                                CALL send_ES                            ;display 'E/S='
086 20265        564                                CALL read_byte_slow                     ;read E/S register
087 20204        565                                CALL compute_CRC16                      ;compute CRC for value in 's3'
088 00110        566                                LOAD s0, s3                             ;display value
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
089 202B3        567                                CALL send_hex_byte
08A 203B8        568                                CALL send_data                          ;display 'Data='
08B 203B5        569                                CALL send_equals
08C 00110        570                                LOAD s4, scratchpad0                    ;pointer to memory and byte counter
E: symbol not defined: `S4'.
E: symbol not defined: `SCRATCHPAD0'.
08D 202DF        571                      rsc_loop: CALL send_space
08E 20265        572                                CALL read_byte_slow                     ;read data byte
08F 20204        573                                CALL compute_CRC16                      ;compute CRC for value in 's3'
090 2F101        574                                STORE s3, (s4)                          ;store value in memory
E: symbol not defined: `S3'.
E: symbol not defined: `S4'.
091 00110        575                                LOAD s0, s3                             ;display value
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
092 202B3        576                                CALL send_hex_byte
093 1C170        577                                COMPARE s4, scratchpad7                 ;count bytes
E: symbol not defined: `S4'.
W: value out of range: 0x17, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x7.
094 32097        578                                JUMP Z, end_rsc_data_loop
095 10110        579                                ADD s4, 01
E: symbol not defined: `S4'.
096 2208D        580                                JUMP rsc_loop
097 202DC        581             end_rsc_data_loop: CALL send_CR
098 20212        582                                CALL read_send_test_CRC16               ;read, display and test CRC value
099 22003        583                                JUMP warm_start
                 584                                ;
                 585                                ;
                 586                                ;
                 587                                ;
                 588                                ;
                 589                                ;**************************************************************************************
                 590                                ; DS2432 Read Authenticated Page Command.
                 591                                ;**************************************************************************************
                 592                                ;
                 593                                ; The read authenticated page command (A5 hex) allows the 8-byte secret to be tested
                 594                                ; without it actually being read (which would obviously give away the secret!).
                 595                                ;
                 596                                ; This routine has been written to work with page 0 but could easily be changed and
                 597                                ; is documented below. During the first part of the command, the 32 bytes
                 598                                ; contained in the page are read back from the DS2432 and these are used in
                 599                                ; the preparation of the table required for the for SHA-1 algorithm. Other values
                 600                                ; stored in the table are the secret, serial number of the DS2432, family code, some
                 601                                ; constants, 4-bits of the page address and a 3 byte 'challenge' currently set into
                 602                                ; the DS2432 scratchpad memory.
                 603                                ;
                 604                                ; NOTE - The read scratchpad command must be executed before this routine in order
                 605                                ; that the 3 byte 'challenge' of scratchpad memory is known to PicoBlaze.
                 606                                ;
                 607                                ; During this command, two 16-bit CRC values are generated which PicoBlaze also
                 608                                ; computes and tests. The first is formed of the command byte, address TA1 and TA2,
                 609                                ; all the bytes of the page read and an 'FF' byte. The second is formed of the 20
                 610                                ; bytes of the 160-but message authentication code (MAC).
                 611                                ;
                 612                                ;
                 613                                ; Preparing the table.
                 614                                ;
                 615                                ; The table is stored in the external 'Wt' buffer and must first be initialised with the
                 616                                ; 16 'M' words (32-bit words each requiring 4 bytes). This is achieved by shifting in
                 617                                ; each word in sequence. Storing each word most significant byte first is a natural
                 618                                ; fit with the reading of the page data from the DS2432 and the way each 'M' word
                 619                                ; is organised. Notice how this causes least significant bytes to be swapped with most
                 620                                ; significant bytes!
                 621                                ;
                 622                                ;          [31:24]      [23:16]      [15:8]       [7:0]
                 623                                ;
                 624                                ;   M0 = [secret0    , secret1    , secret2    , secret3    ]
                 625                                ;   M1 = [page_data0 , page_data1 , page_data2 , page_data3 ]
                 626                                ;   M2 = [page_data4 , page_data5 , page_data6 , page_data7 ]
                 627                                ;   M3 = [page_data8 , page_data9 , page_data10, page_data11]
                 628                                ;   M4 = [page_data12, page_data13, page_data14, page_data15]
                 629                                ;   M5 = [page_data16, page_data17, page_data18, page_data19]
                 630                                ;   M6 = [page_data20, page_data21, page_data22, page_data23]
                 631                                ;   M7 = [page_data24, page_data25, page_data26, page_data27]
                 632                                ;   M8 = [page_data28, page_data29, page_data30, page_data31]
                 633                                ;   M9 = [   FF      ,    FF      ,    FF      ,    FF      ]
                 634                                ;  M10 = [   40      ,    33      , serial_num0, serial_num1]
                 635                                ;  M11 = [serial_num2, serial_num3, serial_num4, serial_num5]
                 636                                ;  M12 = [secret4    , secret5    , secret6    , secret7    ]
                 637                                ;  M13 = [scratchpad4, scratchpad5, scratchpad6,    80      ]
                 638                                ;  M14 = [   00      ,    00      ,    00      ,    00      ]
                 639                                ;  M15 = [   00      ,    00      ,    01      ,    B8      ]
                 640                                ;
                 641                                ; In M10, the '33' is the family code and the '40' is made up of a constant bit
                 642                                ; pattern '0100' and then bits [8:5] of the page address. This gives 4 possible values
                 643                                ; for this byte during a Read Authenticated Page Command, but this routine is currently
                 644                                ; fixed to work with page 0 only.
                 645                                ;        40 - page 0
                 646                                ;        41 - page 1
                 647                                ;        42 - page 2
                 648                                ;        43 - page 3
                 649                                ;
                 650                                ; M13 contains the 3 byte challenge from the scratch pad memory. This assumes that a
                 651                                ; read scratchpad command has previously been used and the bytes held in the DS2432
                 652                                ; scratchpad match those held in the PicoBlaze memory.
                 653                                ;
                 654                                ;
                 655                                ; The 160-bit Message Authentication Code (MAC) is computed from the table using the SHA-1
                 656                                ; algorithm. This algorithm actually results in 5 variables 'A', 'B', 'C', 'D' and 'E'
                 657                                ; which are 32-bit values each formed of 4 bytes. The MAC is the concatenation of
                 658                                ; the variables. To match the same order in which the Read Authenticated Page Command
                 659                                ; sends the MAC, the variables must be read in the order 'E', 'D', 'C', 'B' and 'A' and
                 660                                ; with the least significant byte of each variable first.
                 661                                ;
                 662                                ;
                 663                                ;
                 664                                ;
                 665                                ;
09A 00110        666        read_auth_page_command: LOAD s0, secret0                        ;store M0 (secret 0, 1, 2 and 3) in Wt buffer.
E: symbol not defined: `S0'.
09B 2D10A        667                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
09C 00170        668                                LOAD s0, secret1
E: symbol not defined: `S0'.
W: value out of range: 0x17, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x7.
09D 2D10A        669                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
09E 001D0        670                                LOAD s0, secret2
E: symbol not defined: `S0'.
W: value out of range: 0x2d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
09F 2D10A        671                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0A0 00130        672                                LOAD s0, secret3
E: symbol not defined: `S0'.
W: value out of range: 0x43, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
0A1 2D10A        673                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
                 674                                ;
                 675                                ;Start of DS2432 command
                 676                                ;
0A2 20201        677                                CALL clear_CRC16                        ;prepare CRC registers [sE,sD]
0A3 00110        678                                LOAD s3, A5                             ;read authenticated page command
E: symbol not defined: `S3'.
E: symbol not defined: `A5'.
0A4 20244        679                                CALL write_byte_slow                    ;transmit command
0A5 20204        680                                CALL compute_CRC16                      ;compute CRC for value in 's3'
0A6 00100        681                                LOAD s5, 00                             ;set address for page 0
E: symbol not defined: `S5'.
0A7 00100        682                                LOAD s4, 00                             ;  [TA2,TA1]=0000 hex
E: symbol not defined: `S4'.
0A8 00110        683                                LOAD s3, s4                             ;transmit TA1
E: symbol not defined: `S3'.
E: symbol not defined: `S4'.
0A9 20244        684                                CALL write_byte_slow
0AA 20204        685                                CALL compute_CRC16                      ;compute CRC for value in 's3'
0AB 00110        686                                LOAD s3, s5                             ;transmit TA2
E: symbol not defined: `S3'.
E: symbol not defined: `S5'.
0AC 20244        687                                CALL write_byte_slow
0AD 20204        688                                CALL compute_CRC16                      ;compute CRC for value in 's3'
                 689                                ;
                 690                                ;Read 32-bytes of data associated with page 0
                 691                                ;Store these as M1 through to M8
                 692                                ;
0AE 202DC        693                rapc_line_loop: CALL send_CR
0AF 00110        694                                LOAD s0, s5                             ;display 16-bit address
E: symbol not defined: `S0'.
E: symbol not defined: `S5'.
0B0 202B3        695                                CALL send_hex_byte
0B1 00110        696                                LOAD s0, s4
E: symbol not defined: `S0'.
E: symbol not defined: `S4'.
0B2 202B3        697                                CALL send_hex_byte
0B3 202DF        698                                CALL send_space
0B4 202DF        699                                CALL send_space
0B5 202DF        700                rapc_data_loop: CALL send_space
0B6 20265        701                                CALL read_byte_slow                     ;read data into s3
0B7 20204        702                                CALL compute_CRC16                      ;compute CRC for value in 's3'
0B8 2D10A        703                                OUTPUT s3, W_word_write_port            ;store as 'M' word
E: symbol not defined: `S3'.
0B9 00110        704                                LOAD s0, s3                             ;display byte
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
0BA 202B3        705                                CALL send_hex_byte
0BB 10110        706                                ADD s4, 01                              ;increment address
E: symbol not defined: `S4'.
0BC 12100        707                                ADDCY s5, 00
E: symbol not defined: `S5'.
0BD 0C170        708                                TEST s4, 07                             ;test for 8-byte boundary
E: symbol not defined: `S4'.
0BE 360B5        709                                JUMP NZ, rapc_data_loop
0BF 1C140        710                                COMPARE s4, 20                          ;test for last address
E: symbol not defined: `S4'.
W: value out of range: 0x14, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
0C0 360AE        711                                JUMP NZ, rapc_line_loop
0C1 202DC        712                                CALL send_CR
                 713                                ;
                 714                                ;Read one byte that should be value FF hex
                 715                                ;
0C2 20265        716                                CALL read_byte_slow                     ;read data into s3
0C3 20204        717                                CALL compute_CRC16                      ;compute CRC for value in 's3'
0C4 00110        718                                LOAD s0, s3                             ;display byte
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
0C5 202B3        719                                CALL send_hex_byte
0C6 202DC        720                                CALL send_CR
0C7 20212        721                                CALL read_send_test_CRC16               ;read, display and test CRC value
                 722                                ;
                 723                                ;Complete table by stroring M9 through to M15
                 724                                ;
0C8 00110        725                                LOAD s0, FF                             ;W9 = FF FF FF FF
E: symbol not defined: `S0'.
E: symbol not defined: `FF'.
0C9 00140        726                                LOAD s1, 04
E: symbol not defined: `S1'.
0CA 2D10A        727                      store_W9: OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0CB 18110        728                                SUB s1, 01
E: symbol not defined: `S1'.
0CC 360CA        729                                JUMP NZ, store_W9
                 730                                ;
0CD 00180        731                                LOAD s0, 40                             ;W10 begins with 40 for page 0
E: symbol not defined: `S0'.
W: value out of range: 0x28, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x8.
0CE 2D10A        732                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
                 733                                ;
                 734                                ;W10 ends with family code and serial number 0 and 1.
                 735                                ;W11 is formed of serial number 2, 3, 4 and 5.
                 736                                ;All of this information is in PicoBlaze memory having been read by the
                 737                                ;read ROM command.
                 738                                ;
0CF 00100        739                                LOAD s1, family_code                    ;pointer to memory
E: symbol not defined: `S1'.
0D0 00170        740                                LOAD s2, 07                             ;7 bytes to read and store
E: symbol not defined: `S2'.
0D1 0B101        741                  next_M10_M11: FETCH s0, (s1)
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
0D2 2D10A        742                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0D3 10110        743                                ADD s1, 01                              ;increment pointer
E: symbol not defined: `S1'.
0D4 18110        744                                SUB s2, 01
E: symbol not defined: `S2'.
0D5 360D1        745                                JUMP NZ, next_M10_M11
                 746                                ;
0D6 00190        747                                LOAD s0, secret4                        ;store M12 (secret 4, 5, 6 and 7) in Wt buffer
E: symbol not defined: `S0'.
W: value out of range: 0x59, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
0D7 2D10A        748                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0D8 00110        749                                LOAD s0, secret5
E: symbol not defined: `S0'.
0D9 2D10A        750                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0DA 00110        751                                LOAD s0, secret6
E: symbol not defined: `S0'.
0DB 2D10A        752                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0DC 00110        753                                LOAD s0, secret7
E: symbol not defined: `S0'.
0DD 2D10A        754                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
                 755                                ;
0DE 0B114        756                                FETCH s0, scratchpad4                   ;M13 uses scratchpad 4, 5, and 6 and '80' hex
E: symbol not defined: `S0'.
0DF 2D10A        757                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0E0 0B115        758                                FETCH s0, scratchpad5
E: symbol not defined: `S0'.
0E1 2D10A        759                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0E2 0B116        760                                FETCH s0, scratchpad6
E: symbol not defined: `S0'.
0E3 2D10A        761                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0E4 00100        762                                LOAD s0, 80
E: symbol not defined: `S0'.
W: value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
0E5 2D10A        763                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
                 764                                ;
0E6 00100        765                                LOAD s0, 00                             ;W14 = 00 00 00 00   W15 = 00 00 01 B8
E: symbol not defined: `S0'.
0E7 00160        766                                LOAD s1, 06
E: symbol not defined: `S1'.
0E8 2D10A        767                 store_W14_W15: OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0E9 18110        768                                SUB s1, 01
E: symbol not defined: `S1'.
0EA 360E8        769                                JUMP NZ, store_W14_W15
0EB 00110        770                                LOAD s0, 01
E: symbol not defined: `S0'.
0EC 2D10A        771                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
0ED 00110        772                                LOAD s0, B8
E: symbol not defined: `S0'.
E: symbol not defined: `B8'.
0EE 2D10A        773                                OUTPUT s0, W_word_write_port
E: symbol not defined: `S0'.
                 774                                ;
                 775                                ;Compute the SHA-1 algorithm at the same time that the DS2432 is also computing (2ms).
                 776                                ;
0EF 20112        777                                CALL compute_sha1
                 778                                ;
                 779                                ;The 160-bit Message Authentication Code is read from the DS2432 as 20 bytes
                 780                                ;and compared with the concatenation of variables E, D, C, B and A in that order
                 781                                ;with each variable received from the DS2432 least significant byte first.
                 782                                ;Each received byte is also used to form a 16-bit CRC value which is tested to
                 783                                ;reveal any communication errors.
                 784                                ;
                 785                                ;
0F0 203D7        786                                CALL send_mac                           ;display 'mac='
0F1 20201        787                                CALL clear_CRC16                        ;prepare CRC registers [sE,sD]
0F2 00100        788                                LOAD sC, 00                             ;Clear byte match counter
E: symbol not defined: `SC'.
0F3 00120        789                                LOAD sB, var_E0                         ;start match with LS-Byte of variable 'E'
E: symbol not defined: `SB'.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
0F4 00140        790                 mac_match_var: LOAD sA, 04                             ;4 bytes to match in each variable
E: symbol not defined: `SA'.
0F5 0B101        791                mac_match_byte: FETCH s9, (sB)                          ;read variable byte from local SHA-1
E: symbol not defined: `S9'.
E: symbol not defined: `SB'.
0F6 20265        792                                CALL read_byte_slow                     ;read DS2432 byte into s3
0F7 20204        793                                CALL compute_CRC16                      ;compute CRC for value in 's3'
0F8 1C110        794                                COMPARE s3, s9                          ;compare MAC values
E: symbol not defined: `S3'.
E: symbol not defined: `S9'.
0F9 360FB        795                                JUMP NZ, display_mac_byte               ;count matching bytes
0FA 10110        796                                ADD sC, 01                              ;decrement match counter
E: symbol not defined: `SC'.
0FB 00110        797              display_mac_byte: LOAD s0, s3                             ;display byte
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
0FC 202B3        798                                CALL send_hex_byte
0FD 202DF        799                                CALL send_space
0FE 18110        800                                SUB sA, 01                              ;counts bytes per variable
E: symbol not defined: `SA'.
0FF 32102        801                                JUMP Z, next_mac_var
100 10110        802                                ADD sB, 01
E: symbol not defined: `SB'.
101 220F5        803                                JUMP mac_match_byte
102 1C100        804                  next_mac_var: COMPARE sB, var_A3                      ;test for last byte
E: symbol not defined: `SB'.
103 32106        805                                JUMP Z, report_mac
104 18170        806                                SUB sB, 07                              ;point to next variable
E: symbol not defined: `SB'.
105 220F4        807                                JUMP mac_match_var
                 808                                ;
                 809                                ;MAC has passed if all 20 bytes matched
                 810                                ;
106 202DC        811                    report_mac: CALL send_CR
107 1C1E0        812                                COMPARE sC, 14                          ;20 bytes should have matched
E: symbol not defined: `SC'.
108 3610B        813                                JUMP NZ, mac_fail
109 2039D        814                                CALL send_Pass
10A 2210C        815                                JUMP read_mac_CRC
10B 203A4        816                      mac_fail: CALL send_Fail
                 817                                ;
                 818                                ;Next two bytes received are the 16-bit CRC
                 819                                ;Read 16-bit CRC into [s5,s4] and send value to UART
                 820                                ;
10C 20212        821                  read_mac_CRC: CALL read_send_test_CRC16               ;read, display and test CRC value
                 822                                ;
                 823                                ;Read one byte that should be value AA hex.
                 824                                ;  Would actually read AA hex continuously until master reset
                 825                                ;
10D 20265        826                                CALL read_byte_slow                     ;read data into s3
10E 00110        827                                LOAD s0, s3                             ;display byte
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
10F 202B3        828                                CALL send_hex_byte
110 202DC        829                                CALL send_CR
                 830                                ;
111 22003        831                                JUMP warm_start
                 832                                ;
                 833                                ;
                 834                                ;**************************************************************************************
                 835                                ; Compute SHA-1 Algorithm.
                 836                                ;**************************************************************************************
                 837                                ;
                 838                                ; Computes the SHA-1 algorithm based on the initial table of values (M0 through to M15)
                 839                                ; which are stored in the external Wt buffer.
                 840                                ;
                 841                                ; The SHA-1 algorithms uses 5 variables called 'A', 'B', 'C', 'D' and 'E'. Each variable
                 842                                ; is 32-bits and stored as 4 bytes in PicoBlaze scratch pad memory. The locations must
                 843                                ; be defined using constants 'var_A0' thought to 'var_E3' in ascending locations.
                 844                                ;
                 845                                ; Constants must also be used to define access to the external Wt buffer.
                 846                                ;
                 847                                ; During this process, register 'sE' is used to count iterations from 0 to 79 (4F hex).
                 848                                ; Other registers are consistently grouped as follows to support 32-bit operations.
                 849                                ;
                 850                                ; Register set [s5,s4,s3,s2] is used as a temporary 32-bit word
                 851                                ; Register set [s9,s8,s7,s6] is used as a temporary 32-bit word
                 852                                ; Register set [sD,sC,sB,sA] is used as a temporary 32-bit word
                 853                                ;
                 854                                ;
                 855                                ; Initialise the 32-bit variables
                 856                                ;
                 857                                ;
112 00110        858                  compute_sha1: LOAD s0, 01                             ;A=67452301
E: symbol not defined: `S0'.
113 2F108        859                                STORE s0, var_A0
E: symbol not defined: `S0'.
114 00170        860                                LOAD s0, 23
E: symbol not defined: `S0'.
W: value out of range: 0x17, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x7.
115 2F109        861                                STORE s0, var_A1
E: symbol not defined: `S0'.
116 001D0        862                                LOAD s0, 45
E: symbol not defined: `S0'.
W: value out of range: 0x2d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
117 2F101        863                                STORE s0, var_A2
E: symbol not defined: `S0'.
E: symbol not defined: `VAR_A2'.
118 00130        864                                LOAD s0, 67
E: symbol not defined: `S0'.
W: value out of range: 0x43, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
119 2F100        865                                STORE s0, var_A3
E: symbol not defined: `S0'.
11A 00190        866                                LOAD s0, 89                             ;B=EFCDAB89
E: symbol not defined: `S0'.
W: value out of range: 0x59, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
11B 2F101        867                                STORE s0, var_B0
E: symbol not defined: `S0'.
E: symbol not defined: `VAR_B0'.
11C 00110        868                                LOAD s0, AB
E: symbol not defined: `S0'.
E: symbol not defined: `AB'.
11D 2F100        869                                STORE s0, var_B1
E: symbol not defined: `S0'.
11E 00110        870                                LOAD s0, CD
E: symbol not defined: `S0'.
E: symbol not defined: `CD'.
11F 2F101        871                                STORE s0, var_B2
E: symbol not defined: `S0'.
E: symbol not defined: `VAR_B2'.
120 00110        872                                LOAD s0, EF
E: symbol not defined: `S0'.
E: symbol not defined: `EF'.
121 2F101        873                                STORE s0, var_B3
E: symbol not defined: `S0'.
E: symbol not defined: `VAR_B3'.
122 00110        874                                LOAD s0, FE                             ;C=98BADCFE
E: symbol not defined: `S0'.
E: symbol not defined: `FE'.
123 2F10A        875                                STORE s0, var_C0
E: symbol not defined: `S0'.
124 00110        876                                LOAD s0, DC
E: symbol not defined: `S0'.
E: symbol not defined: `DC'.
125 2F10B        877                                STORE s0, var_C1
E: symbol not defined: `S0'.
126 00110        878                                LOAD s0, BA
E: symbol not defined: `S0'.
E: symbol not defined: `BA'.
127 2F10C        879                                STORE s0, var_C2
E: symbol not defined: `S0'.
128 00120        880                                LOAD s0, 98
E: symbol not defined: `S0'.
W: value out of range: 0x62, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
129 2F10D        881                                STORE s0, var_C3
E: symbol not defined: `S0'.
12A 001C0        882                                LOAD s0, 76                             ;D=10325476
E: symbol not defined: `S0'.
W: value out of range: 0x4c, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xc.
12B 2F10E        883                                STORE s0, var_D0
E: symbol not defined: `S0'.
12C 00160        884                                LOAD s0, 54
E: symbol not defined: `S0'.
W: value out of range: 0x36, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
12D 2F10F        885                                STORE s0, var_D1
E: symbol not defined: `S0'.
12E 00100        886                                LOAD s0, 32
E: symbol not defined: `S0'.
W: value out of range: 0x20, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
12F 2F110        887                                STORE s0, var_D2
E: symbol not defined: `S0'.
130 001A0        888                                LOAD s0, 10
E: symbol not defined: `S0'.
131 2F111        889                                STORE s0, var_D3
E: symbol not defined: `S0'.
132 00110        890                                LOAD s0, F0                             ;E=C3D2E1F0
E: symbol not defined: `S0'.
E: symbol not defined: `F0'.
133 2F112        891                                STORE s0, var_E0
E: symbol not defined: `S0'.
134 00110        892                                LOAD s0, E1
E: symbol not defined: `S0'.
E: symbol not defined: `E1'.
135 2F113        893                                STORE s0, var_E1
E: symbol not defined: `S0'.
136 00110        894                                LOAD s0, D2
E: symbol not defined: `S0'.
E: symbol not defined: `D2'.
137 2F101        895                                STORE s0, var_E2
E: symbol not defined: `S0'.
E: symbol not defined: `VAR_E2'.
138 00110        896                                LOAD s0, C3
E: symbol not defined: `S0'.
E: symbol not defined: `C3'.
139 2F101        897                                STORE s0, var_E3
E: symbol not defined: `S0'.
                 898                                ;
                 899                                ;
13A 00100        900                                LOAD sE, 00                             ;reset iteration counter
E: symbol not defined: `SE'.
                 901                                ;
                 902                                ;
                 903                                ;Compute ft(B,C,D) in register set [s5,s4,s3,s2] and then add constant Kt.
                 904                                ;
                 905                                ;Iterations 0 to 19 - process type 1
                 906                                ;   ft = (B and C) or ((not B) and D)
                 907                                ;  Then the constant Kt=5A827999 will be added
                 908                                ;
                 909                                ;Iterations 20 to 39  and iterations 60 to 79  - process type 2
                 910                                ;   ft = B xor C xor D
                 911                                ;  Then the constant Kt=6ED9EBA1 will be added for iterations 20 to 39
                 912                                ;  Then the constant Kt=CA62C1D6 will be added for iterations 60 to 79
                 913                                ;
                 914                                ;Iterations 40 to 59  - process type 3
                 915                                ;   ft = (B and C) or (B and D) or (C and D)
                 916                                ;  Then the constant Kt=8F1BBCDC will be added
                 917                                ;
13B 0B101        918           next_sha1_iteration: FETCH s5, var_B3                        ;B in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `VAR_B3'.
13C 0B101        919                                FETCH s4, var_B2
E: symbol not defined: `S4'.
E: symbol not defined: `VAR_B2'.
13D 0B100        920                                FETCH s3, var_B1
E: symbol not defined: `S3'.
13E 0B101        921                                FETCH s2, var_B0
E: symbol not defined: `S2'.
E: symbol not defined: `VAR_B0'.
13F 2016F        922                                CALL fetch_C                            ;C in [s9,s8,s7,s6]
140 0B111        923                                FETCH sD, var_D3                        ;D in [sD,sC,sB,sA]
E: symbol not defined: `SD'.
141 0B110        924                                FETCH sC, var_D2
E: symbol not defined: `SC'.
142 0B10F        925                                FETCH sB, var_D1
E: symbol not defined: `SB'.
143 0B10E        926                                FETCH sA, var_D0
E: symbol not defined: `SA'.
                 927                                ;
                 928                                ;Determine process type
                 929                                ;
144 1C1E0        930                                COMPARE sE, 14                          ;set carry flag for iterations <20
E: symbol not defined: `SE'.
145 3A15B        931                                JUMP C, ft_type1
146 1C1C0        932                                COMPARE sE, 28                          ;set carry flag for iterations <40
E: symbol not defined: `SE'.
W: value out of range: 0x1c, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xc.
147 3A149        933                                JUMP C, ft_type2
                 934                                COMPARE sE, 3C                          ;set carry flag for iterations <60
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
148 3A174        935                                JUMP C, ft_type3
                 936                                ;
                 937                                ;   ft = B xor C xor D
                 938                                ;
                 939                                ;       B xor C     =        B       xor       C
                 940                                ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [s9,s8,s7,s6]
                 941                                ;
                 942                                ;   B xor C xor D   =    (B xor C)   xor       D
                 943                                ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [sD,sC,sB,sA]
                 944                                ;
                 945                                ;
149 06110        946                      ft_type2: XOR s5, s9                              ;B xor C in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `S9'.
14A 06110        947                                XOR s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
14B 06110        948                                XOR s3, s7
E: symbol not defined: `S3'.
E: symbol not defined: `S7'.
14C 06110        949                                XOR s2, s6
E: symbol not defined: `S2'.
E: symbol not defined: `S6'.
14D 06110        950                                XOR s5, sD                              ;(B xor C) xor D in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `SD'.
14E 06110        951                                XOR s4, sC
E: symbol not defined: `S4'.
E: symbol not defined: `SC'.
14F 06110        952                                XOR s3, sB
E: symbol not defined: `S3'.
E: symbol not defined: `SB'.
150 06110        953                                XOR s2, sA
E: symbol not defined: `S2'.
E: symbol not defined: `SA'.
                 954                                COMPARE sE, 3C                          ;set carry flag for iterations <60
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
151 3E156        955                                JUMP NC, Kt_CA62C1D6
152 10110        956                                ADD s2, A1                              ;add Kt=6ED9EBA1
E: symbol not defined: `S2'.
E: symbol not defined: `A1'.
153 12110        957                                ADDCY s3, EB
E: symbol not defined: `S3'.
E: symbol not defined: `EB'.
154 12110        958                                ADDCY s4, D9
E: symbol not defined: `S4'.
E: symbol not defined: `D9'.
                 959                                ADDCY s5, 6E
E: identifier cannot start with a digit: `6E'.
E: unexpected end of line.
155 2218C        960                                JUMP compute_TMP
156 10110        961                   Kt_CA62C1D6: ADD s2, D6                              ;add Kt=CA62C1D6
E: symbol not defined: `S2'.
E: symbol not defined: `D6'.
157 12110        962                                ADDCY s3, C1
E: symbol not defined: `S3'.
E: symbol not defined: `C1'.
158 121E0        963                                ADDCY s4, 62
E: symbol not defined: `S4'.
W: value out of range: 0x3e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
159 12110        964                                ADDCY s5, CA
E: symbol not defined: `S5'.
E: symbol not defined: `CA'.
15A 2218C        965                                JUMP compute_TMP
                 966                                ;
                 967                                ;   ft = (B and C) or ((not B) and D)
                 968                                ;
                 969                                ;       B and C     =        C       and       B
                 970                                ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                 971                                ;
                 972                                ;       not B       =        B       xor   FFFFFFFF
                 973                                ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] xor [FF,FF,FF,FF]
                 974                                ;
                 975                                ;   (not B) and D   =    (not B)     and       D
                 976                                ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                 977                                ;
                 978                                ;   ;(B and C) or ((not B) and D)  =  ((not B) and D)  or   (B and C)
                 979                                ;            [s5,s4,s3,s2]         =   [s5,s4,s3,s2]   or  [s9,s8,s7,s6]
                 980                                ;
15B 02110        981                      ft_type1: AND s9, s5                              ;B and C in [s9,s8,s7,s6]
E: symbol not defined: `S9'.
E: symbol not defined: `S5'.
15C 02110        982                                AND s8, s4
E: symbol not defined: `S8'.
E: symbol not defined: `S4'.
15D 02110        983                                AND s7, s3
E: symbol not defined: `S7'.
E: symbol not defined: `S3'.
15E 02110        984                                AND s6, s2
E: symbol not defined: `S6'.
E: symbol not defined: `S2'.
15F 06110        985                                XOR s5, FF                              ;(not B) in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `FF'.
160 06110        986                                XOR s4, FF
E: symbol not defined: `S4'.
E: symbol not defined: `FF'.
161 06110        987                                XOR s3, FF
E: symbol not defined: `S3'.
E: symbol not defined: `FF'.
162 06110        988                                XOR s2, FF
E: symbol not defined: `S2'.
E: symbol not defined: `FF'.
163 02110        989                                AND s5, sD                              ;((not B) and D) in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `SD'.
164 02110        990                                AND s4, sC
E: symbol not defined: `S4'.
E: symbol not defined: `SC'.
165 02110        991                                AND s3, sB
E: symbol not defined: `S3'.
E: symbol not defined: `SB'.
166 02110        992                                AND s2, sA
E: symbol not defined: `S2'.
E: symbol not defined: `SA'.
167 04110        993                                OR s5, s9                               ;(B and C) or ((not B) and D) in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `S9'.
168 04110        994                                OR s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
169 04110        995                                OR s3, s7
E: symbol not defined: `S3'.
E: symbol not defined: `S7'.
16A 04110        996                                OR s2, s6
E: symbol not defined: `S2'.
E: symbol not defined: `S6'.
16B 10130        997                                ADD s2, 99                              ;add Kt=5A827999
E: symbol not defined: `S2'.
W: value out of range: 0x63, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
16C 121F0        998                                ADDCY s3, 79
E: symbol not defined: `S3'.
W: value out of range: 0x4f, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xf.
16D 12120        999                                ADDCY s4, 82
E: symbol not defined: `S4'.
W: value out of range: 0x52, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
                1000                                ADDCY s5, 5A
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
16E 2218C       1001                                JUMP compute_TMP
                1002                                ;
                1003                                ;Routine to fetch variable 'C' into register set [s9,s8,s7,s6]
                1004                                ;
16F 0B10D       1005                       fetch_C: FETCH s9, var_C3
E: symbol not defined: `S9'.
170 0B10C       1006                                FETCH s8, var_C2
E: symbol not defined: `S8'.
171 0B10B       1007                                FETCH s7, var_C1
E: symbol not defined: `S7'.
172 0B10A       1008                                FETCH s6, var_C0
E: symbol not defined: `S6'.
173 25000       1009                                RETURN
                1010                                ;
                1011                                ;   ft = (B and C) or (B and D) or (C and D)
                1012                                ;
                1013                                ;       B and C     =        C       and       B
                1014                                ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [s5,s4,s3,s2]
                1015                                ;
                1016                                ;       B and D     =        B       and       D
                1017                                ;   [s5,s4,s3,s2]   =  [s5,s4,s3,s2] and [sD,sC,sB,sA]
                1018                                ;
                1019                                ;  (B and C) or (B and D)   =    (B and D)    or    (B and C)
                1020                                ;      [s5,s4,s3,s2]        =  [s5,s4,s3,s2]  or  [s9,s8,s7,s6]
                1021                                ;
                1022                                ;     read C again into [s9,s8,s7,s6]
                1023                                ;
                1024                                ;       C and D     =        C       and       D
                1025                                ;   [s9,s8,s7,s6]   =  [s9,s8,s7,s6] and [sD,sC,sB,sA]
                1026                                ;
                1027                                ;  ((B and C) or (B and D)) or (C and D)   =    ((B and C) or (B and D)) or   (C and D)
                1028                                ;               [s5,s4,s3,s2]              =           [s5,s4,s3,s2]     or  [s9,s8,s7,s6]
                1029                                ;
174 02110       1030                      ft_type3: AND s9, s5                              ;(B and C) in [s9,s8,s7,s6]
E: symbol not defined: `S9'.
E: symbol not defined: `S5'.
175 02110       1031                                AND s8, s4
E: symbol not defined: `S8'.
E: symbol not defined: `S4'.
176 02110       1032                                AND s7, s3
E: symbol not defined: `S7'.
E: symbol not defined: `S3'.
177 02110       1033                                AND s6, s2
E: symbol not defined: `S6'.
E: symbol not defined: `S2'.
178 02110       1034                                AND s5, sD                              ;(B and D) in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `SD'.
179 02110       1035                                AND s4, sC
E: symbol not defined: `S4'.
E: symbol not defined: `SC'.
17A 02110       1036                                AND s3, sB
E: symbol not defined: `S3'.
E: symbol not defined: `SB'.
17B 02110       1037                                AND s2, sA
E: symbol not defined: `S2'.
E: symbol not defined: `SA'.
17C 04110       1038                                OR s5, s9                               ;(B and C) or (B and D) in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `S9'.
17D 04110       1039                                OR s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
17E 04110       1040                                OR s3, s7
E: symbol not defined: `S3'.
E: symbol not defined: `S7'.
17F 04110       1041                                OR s2, s6
E: symbol not defined: `S2'.
E: symbol not defined: `S6'.
180 2016F       1042                                CALL fetch_C                            ;C in [s9,s8,s7,s6]
181 02110       1043                                AND s9, sD                              ;(C and D) in [s9,s8,s7,s6]
E: symbol not defined: `S9'.
E: symbol not defined: `SD'.
182 02110       1044                                AND s8, sC
E: symbol not defined: `S8'.
E: symbol not defined: `SC'.
183 02110       1045                                AND s7, sB
E: symbol not defined: `S7'.
E: symbol not defined: `SB'.
184 02110       1046                                AND s6, sA
E: symbol not defined: `S6'.
E: symbol not defined: `SA'.
185 04110       1047                                OR s5, s9                               ;(B and C) or (B and D) or (C and D) in [s5,s4,s3,s2]
E: symbol not defined: `S5'.
E: symbol not defined: `S9'.
186 04110       1048                                OR s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
187 04110       1049                                OR s3, s7
E: symbol not defined: `S3'.
E: symbol not defined: `S7'.
188 04110       1050                                OR s2, s6
E: symbol not defined: `S2'.
E: symbol not defined: `S6'.
189 10110       1051                                ADD s2, DC                              ;add Kt=8F1BBCDC
E: symbol not defined: `S2'.
E: symbol not defined: `DC'.
18A 12110       1052                                ADDCY s3, BC
E: symbol not defined: `S3'.
E: symbol not defined: `BC'.
18B 12110       1053                                ADDCY s4, 1B
E: symbol not defined: `S4'.
                1054                                ADDCY s5, 8F
E: identifier cannot start with a digit: `8F'.
E: unexpected end of line.
                1055                                ;
                1056                                ;Add variable 'E' to [s5,s4,s3,s2]
                1057                                ;
18C 0B112       1058                   compute_TMP: FETCH s0, var_E0
E: symbol not defined: `S0'.
18D 10110       1059                                ADD s2, s0
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
18E 0B113       1060                                FETCH s0, var_E1
E: symbol not defined: `S0'.
18F 12110       1061                                ADDCY s3, s0
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
190 0B101       1062                                FETCH s0, var_E2
E: symbol not defined: `S0'.
E: symbol not defined: `VAR_E2'.
191 12110       1063                                ADDCY s4, s0
E: symbol not defined: `S4'.
E: symbol not defined: `S0'.
192 0B101       1064                                FETCH s0, var_E3
E: symbol not defined: `S0'.
193 12110       1065                                ADDCY s5, s0
E: symbol not defined: `S5'.
E: symbol not defined: `S0'.
                1066                                ;
                1067                                ;Add variable 'A' rotated left 5 places
                1068                                ;
194 0B100       1069                                FETCH s9, var_A3                        ;A in [s9,s8,s7,s6]
E: symbol not defined: `S9'.
195 0B101       1070                                FETCH s8, var_A2
E: symbol not defined: `S8'.
E: symbol not defined: `VAR_A2'.
196 0B109       1071                                FETCH s7, var_A1
E: symbol not defined: `S7'.
197 0B108       1072                                FETCH s6, var_A0
E: symbol not defined: `S6'.
198 00150       1073                                LOAD s0, 05                             ;rotate left 5 places
E: symbol not defined: `S0'.
199 201DD       1074                                CALL rotate_word_left_N_places
19A 10110       1075                                ADD s2, s6                              ;add to TMP
E: symbol not defined: `S2'.
E: symbol not defined: `S6'.
19B 12110       1076                                ADDCY s3, s7
E: symbol not defined: `S3'.
E: symbol not defined: `S7'.
19C 12110       1077                                ADDCY s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
19D 12110       1078                                ADDCY s5, s9
E: symbol not defined: `S5'.
E: symbol not defined: `S9'.
                1079                                ;
                1080                                ;
                1081                                ;Compute Wt in register set [s9,s8,s7,s6]
                1082                                ;  Value computed is also stored back in the external buffer for
                1083                                ;  use in later iterations as well as being added to TMP.
                1084                                ;
                1085                                ;Iterations 0 to 15
                1086                                ;  Wt = Mt
                1087                                ; This only requires Wt-16 to be read and then shifted back into the buffer again.
                1088                                ;
                1089                                ;Iterations 0 to 15
                1090                                ;  Wt = rotate_left_1_place(Wt-3 xor Wt-8 xor Wt-14 xor Wt-16)
                1091                                ; This requires all data values to be read first. Then XORed and rotated before
                1092                                ; shifting the new Wt word into the buffer.
                1093                                ;
                1094                                ;
19E 09101       1095                                INPUT s9, Wt_minus16_byte3_read_port    ;Read Wt-16 value
E: symbol not defined: `S9'.
E: symbol not defined: `WT_MINUS16_BYTE3_READ_PORT'.
19F 09101       1096                                INPUT s8, Wt_minus16_byte2_read_port
E: symbol not defined: `S8'.
E: symbol not defined: `WT_MINUS16_BYTE2_READ_PORT'.
1A0 09103       1097                                INPUT s7, Wt_minus16_byte1_read_port
E: symbol not defined: `S7'.
1A1 09101       1098                                INPUT s6, Wt_minus16_byte0_read_port
E: symbol not defined: `S6'.
E: symbol not defined: `WT_MINUS16_BYTE0_READ_PORT'.
1A2 1C1A0       1099                                COMPARE sE, 10                          ;set carry flag for iterations 0 to 15
E: symbol not defined: `SE'.
1A3 3A1BD       1100                                JUMP C, store_Wt
                1101                                ;
                1102                                ;Read other Wt words and perform XOR
                1103                                ;
1A4 09125       1104                                INPUT s0, Wt_minus14_byte3_read_port    ;XOR with Wt-14 value
E: symbol not defined: `S0'.
1A5 06110       1105                                XOR s9, s0
E: symbol not defined: `S9'.
E: symbol not defined: `S0'.
1A6 09124       1106                                INPUT s0, Wt_minus14_byte2_read_port
E: symbol not defined: `S0'.
1A7 06110       1107                                XOR s8, s0
E: symbol not defined: `S8'.
E: symbol not defined: `S0'.
1A8 09123       1108                                INPUT s0, Wt_minus14_byte1_read_port
E: symbol not defined: `S0'.
1A9 06110       1109                                XOR s7, s0
E: symbol not defined: `S7'.
E: symbol not defined: `S0'.
1AA 09122       1110                                INPUT s0, Wt_minus14_byte0_read_port
E: symbol not defined: `S0'.
1AB 06110       1111                                XOR s6, s0
E: symbol not defined: `S6'.
E: symbol not defined: `S0'.
1AC 09101       1112                                INPUT s0, Wt_minus8_byte3_read_port     ;XOR with Wt-8 value
E: symbol not defined: `S0'.
E: symbol not defined: `WT_MINUS8_BYTE3_READ_PORT'.
1AD 06110       1113                                XOR s9, s0
E: symbol not defined: `S9'.
E: symbol not defined: `S0'.
1AE 09101       1114                                INPUT s0, Wt_minus8_byte2_read_port
E: symbol not defined: `S0'.
E: symbol not defined: `WT_MINUS8_BYTE2_READ_PORT'.
1AF 06110       1115                                XOR s8, s0
E: symbol not defined: `S8'.
E: symbol not defined: `S0'.
1B0 09101       1116                                INPUT s0, Wt_minus8_byte1_read_port
E: symbol not defined: `S0'.
1B1 06110       1117                                XOR s7, s0
E: symbol not defined: `S7'.
E: symbol not defined: `S0'.
1B2 09101       1118                                INPUT s0, Wt_minus8_byte0_read_port
E: symbol not defined: `S0'.
E: symbol not defined: `WT_MINUS8_BYTE0_READ_PORT'.
1B3 06110       1119                                XOR s6, s0
E: symbol not defined: `S6'.
E: symbol not defined: `S0'.
1B4 09100       1120                                INPUT s0, Wt_minus3_byte3_read_port     ;XOR with Wt-3 value
E: symbol not defined: `S0'.
1B5 06110       1121                                XOR s9, s0
E: symbol not defined: `S9'.
E: symbol not defined: `S0'.
1B6 09101       1122                                INPUT s0, Wt_minus3_byte2_read_port
E: symbol not defined: `S0'.
E: symbol not defined: `WT_MINUS3_BYTE2_READ_PORT'.
1B7 06110       1123                                XOR s8, s0
E: symbol not defined: `S8'.
E: symbol not defined: `S0'.
1B8 09109       1124                                INPUT s0, Wt_minus3_byte1_read_port
E: symbol not defined: `S0'.
1B9 06110       1125                                XOR s7, s0
E: symbol not defined: `S7'.
E: symbol not defined: `S0'.
1BA 09108       1126                                INPUT s0, Wt_minus3_byte0_read_port
E: symbol not defined: `S0'.
1BB 06110       1127                                XOR s6, s0
E: symbol not defined: `S6'.
E: symbol not defined: `S0'.
1BC 201E1       1128                                CALL rotate_word_left                   ;rotate XORed word left by one place
                1129                                ;
                1130                                ;Store new Wt value in external buffer
                1131                                ;
1BD 2D10A       1132                      store_Wt: OUTPUT s9, W_word_write_port
E: symbol not defined: `S9'.
1BE 2D10A       1133                                OUTPUT s8, W_word_write_port
E: symbol not defined: `S8'.
1BF 2D10A       1134                                OUTPUT s7, W_word_write_port
E: symbol not defined: `S7'.
1C0 2D10A       1135                                OUTPUT s6, W_word_write_port
E: symbol not defined: `S6'.
                1136                                ;
                1137                                ;Add new computed Wt value to TMP in [s5,s4,s3,s2]
                1138                                ;
1C1 10110       1139                                ADD s2, s6
E: symbol not defined: `S2'.
E: symbol not defined: `S6'.
1C2 12110       1140                                ADDCY s3, s7
E: symbol not defined: `S3'.
E: symbol not defined: `S7'.
1C3 12110       1141                                ADDCY s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
1C4 12110       1142                                ADDCY s5, s9
E: symbol not defined: `S5'.
E: symbol not defined: `S9'.
                1143                                ;
                1144                                ;TMP is now complete in [s5,s4,s3,s2]
                1145                                ;
                1146                                ;
                1147                                ;copy values
                1148                                ;  E <= D
                1149                                ;  D <= C
                1150                                ;  C <= B (this will need to be rotated 30 places afterwards)
                1151                                ;  B <= A
                1152                                ;
1C5 00140       1153                                LOAD sD, 04                             ;4 bytes per word to copy
E: symbol not defined: `SD'.
1C6 00110       1154                 copy_var_loop: LOAD sC, var_E3
E: symbol not defined: `SC'.
1C7 00110       1155                                LOAD sB, var_E2
E: symbol not defined: `SB'.
E: symbol not defined: `VAR_E2'.
1C8 0B101       1156                 move_var_loop: FETCH sA, (sB)
E: symbol not defined: `SA'.
E: symbol not defined: `SB'.
1C9 2F101       1157                                STORE sA, (sC)
E: symbol not defined: `SA'.
E: symbol not defined: `SC'.
1CA 18110       1158                                SUB sC, 01
E: symbol not defined: `SC'.
1CB 18110       1159                                SUB sB, 01
E: symbol not defined: `SB'.
1CC 1C180       1160                                COMPARE sC, var_A0
E: symbol not defined: `SC'.
1CD 361C8       1161                                JUMP NZ, move_var_loop
1CE 18110       1162                                SUB sD, 01
E: symbol not defined: `SD'.
1CF 361C6       1163                                JUMP NZ, copy_var_loop
                1164                                ;
                1165                                ;rotate 'C' (the previous 'B') left 30 places
                1166                                ;
1D0 2016F       1167                                CALL fetch_C                            ;C in [s9,s8,s7,s6]
                1168                                LOAD s0, 1E                             ;rotate left 30 places
E: identifier cannot start with a digit: `1E'.
E: unexpected end of line.
1D1 201DD       1169                                CALL rotate_word_left_N_places
1D2 2F10D       1170                                STORE s9, var_C3
E: symbol not defined: `S9'.
1D3 2F10C       1171                                STORE s8, var_C2
E: symbol not defined: `S8'.
1D4 2F10B       1172                                STORE s7, var_C1
E: symbol not defined: `S7'.
1D5 2F10A       1173                                STORE s6, var_C0
E: symbol not defined: `S6'.
                1174                                ;
                1175                                ;  A <= TMP
                1176                                ;
1D6 2F100       1177                                STORE s5, var_A3
E: symbol not defined: `S5'.
1D7 2F101       1178                                STORE s4, var_A2
E: symbol not defined: `S4'.
E: symbol not defined: `VAR_A2'.
1D8 2F109       1179                                STORE s3, var_A1
E: symbol not defined: `S3'.
1D9 2F108       1180                                STORE s2, var_A0
E: symbol not defined: `S2'.
                1181                                ;
                1182                                ;count iterations
                1183                                ;
                1184                                COMPARE sE, 4F                          ;test for last iteration = 79 decimal (4F hex)
E: identifier cannot start with a digit: `4F'.
E: unexpected end of line.
1DA 31000       1185                                RETURN Z
1DB 10110       1186                                ADD sE, 01
E: symbol not defined: `SE'.
1DC 2213B       1187                                JUMP next_sha1_iteration
                1188                                ;
                1189                                ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1190                                ; by the number of places specified in register 's0'.
                1191                                ;
1DD 201E1       1192     rotate_word_left_N_places: CALL rotate_word_left
1DE 18110       1193                                SUB s0, 01
E: symbol not defined: `S0'.
1DF 361DD       1194                                JUMP NZ, rotate_word_left_N_places
1E0 25000       1195                                RETURN
                1196                                ;
                1197                                ; Routine to rotate left the contents of Register set [s9,s8,s7,s6]
                1198                                ; by one place.
                1199                                ;
1E1 0C100       1200              rotate_word_left: TEST s9, 80                             ;test MSB of word
E: symbol not defined: `S9'.
W: value out of range: 0x50, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
1E2 14100       1201                                SLA s6
E: symbol not defined: `S6'.
1E3 14100       1202                                SLA s7
E: symbol not defined: `S7'.
1E4 14100       1203                                SLA s8
E: symbol not defined: `S8'.
1E5 14100       1204                                SLA s9
E: symbol not defined: `S9'.
1E6 25000       1205                                RETURN
                1206                                ;
                1207                                ;**************************************************************************************
                1208                                ; Compute 8-bit CRC used by DS2432.
                1209                                ;**************************************************************************************
                1210                                ;
                1211                                ; The DS2432 computes an 8-bit CRC using the polynomial X8 + X5 + X4 + 1.
                1212                                ; See the DS2432 data sheet for full details.
                1213                                ;
                1214                                ; Test input value of value 00 00 00 01 B8 1C 02
                1215                                ; should produce CRC=A2.
                1216                                ;
                1217                                ; This routine computes the same CRC based on the values stored in the KCPSM3
                1218                                ; scratch pad memory by the read ROM command. The result is returned in register s0.
                1219                                ;
                1220                                ; Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9
                1221                                ;
                1222                                ;
                1223                                ; Start by loading family code and serial number (56-bits) into register set
                1224                                ; [s9,s8,s7,s6,s5,s4,s3] so that it can be shifted out LSB first.
                1225                                ;
                1226                                ;
1E7 0B100       1227                  compute_CRC8: FETCH s3, family_code
E: symbol not defined: `S3'.
1E8 0B101       1228                                FETCH s4, serial_number0
E: symbol not defined: `S4'.
1E9 0B102       1229                                FETCH s5, serial_number1
E: symbol not defined: `S5'.
1EA 0B103       1230                                FETCH s6, serial_number2
E: symbol not defined: `S6'.
1EB 0B104       1231                                FETCH s7, serial_number3
E: symbol not defined: `S7'.
1EC 0B105       1232                                FETCH s8, serial_number4
E: symbol not defined: `S8'.
1ED 0B106       1233                                FETCH s9, serial_number5
E: symbol not defined: `S9'.
1EE 00160       1234                                LOAD s2, 38                             ;56 bits to shift (38 hex)
E: symbol not defined: `S2'.
W: value out of range: 0x26, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
1EF 00100       1235                                LOAD s0, 00                             ;clear CRC value
E: symbol not defined: `S0'.
1F0 00110       1236                     crc8_loop: LOAD s1, s0                             ;copy current CRC value
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
1F1 06110       1237                                XOR s1, s3                              ;Need to know LSB XOR next input bit
E: symbol not defined: `S1'.
E: symbol not defined: `S3'.
1F2 0C110       1238                                TEST s1, 01                             ;test result of XOR in LSB
E: symbol not defined: `S1'.
1F3 3E1F5       1239                                JUMP NC, crc8_shift
1F4 06120       1240                                XOR s0, 18                              ;compliment bits 3 and 4 of CRC
E: symbol not defined: `S0'.
W: value out of range: 0x12, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
1F5 1410E       1241                    crc8_shift: SR0 s1                                  ;Carry gets LSB XOR next input bit
E: symbol not defined: `S1'.
1F6 14108       1242                                SRA s0                                  ;shift Carry into MSB to form new CRC value
E: symbol not defined: `S0'.
1F7 1410E       1243                                SR0 s9                                  ;shift input value
E: symbol not defined: `S9'.
1F8 14108       1244                                SRA s8
E: symbol not defined: `S8'.
1F9 14108       1245                                SRA s7
E: symbol not defined: `S7'.
1FA 14108       1246                                SRA s6
E: symbol not defined: `S6'.
1FB 14108       1247                                SRA s5
E: symbol not defined: `S5'.
1FC 14108       1248                                SRA s4
E: symbol not defined: `S4'.
1FD 14108       1249                                SRA s3
E: symbol not defined: `S3'.
1FE 18110       1250                                SUB s2, 01                              ;count iterations
E: symbol not defined: `S2'.
1FF 361F0       1251                                JUMP NZ, crc8_loop
200 25000       1252                                RETURN
                1253                                ;
                1254                                ;
                1255                                ;
                1256                                ;**************************************************************************************
                1257                                ; Clear or Compute 16-bit CRC used by DS2432.
                1258                                ;**************************************************************************************
                1259                                ;
                1260                                ; The DS2432 computes a 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                1261                                ; See the DS2432 data sheet for full details.
                1262                                ;
                1263                                ; Note that the value formed in the CRC shift register MUST BE INVERTED to give the
                1264                                ; same value as that sent from the DS2432 during scratchpad write, scratchpad read
                1265                                ; and read auth page commands.
                1266                                ;
                1267                                ; The 16-bit CRC is computed using a different number of bytes depending on the
                1268                                ; command. This routine has been written such that the CRC can be computed one
                1269                                ; byte at a time. The byte to be processed should be provided in register 's3'
                1270                                ; and the contents of this register are preserved.
                1271                                ;
                1272                                ; This routine computes the 16-bit CRC in the register pair [sE,sD] and these
                1273                                ; registers must not be disturbed between calls of this routine.
                1274                                ;
                1275                                ; Before starting a CRC computation the 'clear_CRC16' should be used.
                1276                                ;
                1277                                ; Registers used s0,s1,s3,sD,sE
                1278                                ;    s3 is preserved.
                1279                                ;    sD and sE should not be disturbed between calls if CRC value is required.
                1280                                ;
                1281                                ;
201 00100       1282                   clear_CRC16: LOAD sE, 00                             ;[sE,sD]=0000
E: symbol not defined: `SE'.
202 00100       1283                                LOAD sD, 00
E: symbol not defined: `SD'.
203 25000       1284                                RETURN
                1285                                ;
204 00180       1286                 compute_CRC16: LOAD s1, 08                             ;8-bits to shift
E: symbol not defined: `S1'.
205 00110       1287                    crc16_loop: LOAD s0, sD                             ;copy current CRC value
E: symbol not defined: `S0'.
E: symbol not defined: `SD'.
206 06110       1288                                XOR s0, s3                              ;Need to know LSB XOR next input bit
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
207 0C110       1289                                TEST s0, 01                             ;test result of XOR in LSB
E: symbol not defined: `S0'.
208 3E20B       1290                                JUMP NC, crc16_shift
209 06120       1291                                XOR sD, 02                              ;compliment bit 1 of CRC
E: symbol not defined: `SD'.
20A 06180       1292                                XOR sE, 40                              ;compliment bit 14 of CRC
E: symbol not defined: `SE'.
W: value out of range: 0x28, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x8.
20B 1410E       1293                   crc16_shift: SR0 s0                                  ;Carry gets LSB XOR next input bit
E: symbol not defined: `S0'.
20C 14108       1294                                SRA sE                                  ;shift Carry into MSB to form new CRC value
E: symbol not defined: `SE'.
20D 14108       1295                                SRA sD
E: symbol not defined: `SD'.
20E 1410C       1296                                RR s3                                   ;shift input value
E: symbol not defined: `S3'.
20F 18110       1297                                SUB s1, 01                              ;count bits
E: symbol not defined: `S1'.
210 36205       1298                                JUMP NZ, crc16_loop                     ;next bit
211 25000       1299                                RETURN
                1300                                ;
                1301                                ;
                1302                                ;**************************************************************************************
                1303                                ; Read 16-bit CRC from DS2432, send value received to UART and test result.
                1304                                ;**************************************************************************************
                1305                                ;
                1306                                ; The computed CRC value for comparison must be in register pair [sE,sD]
                1307                                ;
212 20265       1308          read_send_test_CRC16: CALL read_byte_slow                     ;read 16-bit CRC into [s5,s4]
213 00110       1309                                LOAD s4, s3
E: symbol not defined: `S4'.
E: symbol not defined: `S3'.
214 20265       1310                                CALL read_byte_slow
215 00110       1311                                LOAD s5, s3
E: symbol not defined: `S5'.
E: symbol not defined: `S3'.
216 203D2       1312                                CALL send_crc                           ;'crc=' to display CRC value
217 00110       1313                                LOAD s0, s5
E: symbol not defined: `S0'.
E: symbol not defined: `S5'.
218 202B3       1314                                CALL send_hex_byte
219 00110       1315                                LOAD s0, s4
E: symbol not defined: `S0'.
E: symbol not defined: `S4'.
21A 202B3       1316                                CALL send_hex_byte
21B 202DC       1317                                CALL send_CR
21C 06110       1318                                XOR sD, FF                              ;1's complement the computed CRC value
E: symbol not defined: `SD'.
E: symbol not defined: `FF'.
21D 06110       1319                                XOR sE, FF
E: symbol not defined: `SE'.
E: symbol not defined: `FF'.
21E 1C110       1320                                COMPARE s4, sD                          ;test received value with computed value
E: symbol not defined: `S4'.
E: symbol not defined: `SD'.
21F 36224       1321                                JUMP NZ, crc16_fail
220 1C110       1322                                COMPARE s5, sE
E: symbol not defined: `S5'.
E: symbol not defined: `SE'.
221 36224       1323                                JUMP NZ, crc16_fail
222 2039D       1324                                CALL send_Pass                          ;display 'Pass' with carriage return
223 25000       1325                                RETURN
224 203A4       1326                    crc16_fail: CALL send_Fail                          ;display 'Fail' with carriage return
225 25000       1327                                RETURN
                1328                                ;
                1329                                ;
                1330                                ;**************************************************************************************
                1331                                ; Initialise the DS2432 1-wire interface.
                1332                                ;**************************************************************************************
                1333                                ;
                1334                                ; The 1-wire interface is an open-collector communication scheme employing an external
                1335                                ; pull-up resistor of 680 Ohms.
                1336                                ;
                1337                                ; The hardware section of this translates the one bit signal from PicoBlaze such that
                1338                                ; when this signal is Low the output is driven Low, but when it is High, it turns off
                1339                                ; the output buffer and the signal is pulled High externally.
                1340                                ;
                1341                                ; This initialisation routine simply ensures that the line is High after configuration.
                1342                                ; It is vital that DS_wire is generally in the High state because it is the only way in
                1343                                ; which the DS2432 device derives power to operate.
                1344                                ;
                1345                                ; Registers used s0
                1346                                ;
226 00110       1347                  DS_wire_init: LOAD s0, DS_wire
E: symbol not defined: `S0'.
227 2D108       1348                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
228 25000       1349                                RETURN
                1350                                ;
                1351                                ;
                1352                                ;**************************************************************************************
                1353                                ; DS2432 initialisation - Regular Speed.
                1354                                ;**************************************************************************************
                1355                                ;
                1356                                ; The initialisation sequence must be performed before any communication can be
                1357                                ; made with the DS2432 device. This involves the application of an active Low master
                1358                                ; reset pulse.
                1359                                ;
                1360                                ; The regular (slow) speed communication is established by transmitting an active
                1361                                ; Low reset pulse for a duration of at least 480us. This design generates a 500us pulse.
                1362                                ;
                1363                                ; The DS2432 acknowledges the reset and the setting of regular mode by generating an
                1364                                ; active Low 'Rx Presence Pulse'. This presence pulse can start 15 to 60us after the
                1365                                ; reset pulse and will end between 120 and 300us after the reset pulse.
                1366                                ;
                1367                                ; To confirm that regular mode has been set, this routine confirms that the presence pulse
                1368                                ; is active only after 60us have elapsed since the reset pulse. This ensures that the
                1369                                ; faster presence pulse of overdrive mode can not be detected.
                1370                                ;
                1371                                ; The carry flag will be set if no valid presence pulse was received (wire remained High) and
                1372                                ; can be used to indicate an initialisation failure or success.
                1373                                ;
                1374                                ; The routine only completes 300us after the presence pulse to ensure the DS2432 has
                1375                                ; completed the presence pulse and is ready for the first operation.
                1376                                ;
                1377                                ; Registers used s0,s1,s2
                1378                                ;
229 00100       1379          DS_init_regular_mode: LOAD s0, 00                             ;transmit reset pulse
E: symbol not defined: `S0'.
22A 2D108       1380                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
                1381                                ;Delay of 500us is equivalent to 12500 instructions at 50MHz.
                1382                                ;This delay loop is formed of 28 instructions requiring 446 repetitions.
22B 00110       1383                                LOAD s2, 01                             ;[s3,s2]=445 decimal (01BD hex)
E: symbol not defined: `S2'.
22C 00110       1384                                LOAD s1, BD
E: symbol not defined: `S1'.
E: symbol not defined: `BD'.
22D 2027C       1385                 rm_wait_500us: CALL delay_1us                          ;25 instructions including CALL
22E 18110       1386                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
22F 1A100       1387                                SUBCY s2, 00
E: symbol not defined: `S2'.
230 3E22D       1388                                JUMP NC, rm_wait_500us                  ;repeat until -1
231 00110       1389                                LOAD s0, 01                             ;end of regular reset pulse
E: symbol not defined: `S0'.
232 2D108       1390                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
                1391                                ;Delay of 60us is equivalent to 1500 instructions at 50MHz.
                1392                                ;This delay and is formed of 27 instructions requiring 56 repetitions.
233 00160       1393                                LOAD s1, 38                             ;56 (38 hex)
E: symbol not defined: `S1'.
W: value out of range: 0x26, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
234 2027C       1394                  rm_wait_60us: CALL delay_1us                          ;25 instructions including CALL
235 18110       1395                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
236 36234       1396                                JUMP NZ, rm_wait_60us                   ;repeat until zero
                1397                                ;The DS_wire is now checked at approximately 1us intervals for the next 240us looking
                1398                                ;to detect an active Low presence pulse. The 240us is equivalent to 6000 instructions
                1399                                ;at 50MHz and this polling loop is formed of 33 instructions requiring 182 repetitions.
237 00110       1400                                LOAD s2, 01                             ;set bit which will be reset by a presence pulse
E: symbol not defined: `S2'.
238 00110       1401                                LOAD s1, B6                             ;182 (B6 hex)
E: symbol not defined: `S1'.
E: symbol not defined: `B6'.
239 2027C       1402                 rm_poll_240us: CALL delay_1us                          ;25 instructions including CALL
23A 20240       1403                                CALL read_DS_wire                       ;read wire - 5 instructions including CALL
23B 02110       1404                                AND s2, s0                              ;clear flag if DS_wire was Low
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
23C 18110       1405                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
23D 36239       1406                                JUMP NZ, rm_poll_240us                  ;repeat until zero
23E 0C110       1407                                TEST s2, 01                             ;set carry flag if no pulse detected
E: symbol not defined: `S2'.
23F 25000       1408                                RETURN
                1409                                ;
                1410                                ;
                1411                                ;**************************************************************************************
                1412                                ; Read the DS_wire
                1413                                ;**************************************************************************************
                1414                                ;
                1415                                ; The DS_wire signal is read and returned in bit0 of register 's0'.
                1416                                ; Additionally the carry flag is set if the signal is High and reset if Low
                1417                                ;
                1418                                ; Registers used s0
                1419                                ;
240 09101       1420                  read_DS_wire: INPUT s0, DS_wire_in_port
E: symbol not defined: `S0'.
241 02110       1421                                AND s0, DS_wire                         ;ensure only bit0 is active
E: symbol not defined: `S0'.
242 0C110       1422                                TEST s0, DS_wire                        ;set carry flag if DS_wire is High
E: symbol not defined: `S0'.
243 25000       1423                                RETURN
                1424                                ;
                1425                                ;
                1426                                ;
                1427                                ;**************************************************************************************
                1428                                ; Write a byte to DS2432 in regular speed mode.
                1429                                ;**************************************************************************************
                1430                                ;
                1431                                ; Bytes are written to the DS2432 with LSB first.
                1432                                ;
                1433                                ; The byte to be written should be provided in register 's3' and this will be preserved.
                1434                                ;
                1435                                ; Registers used s0,s1,s2,s3
                1436                                ;
244 00180       1437               write_byte_slow: LOAD s2, 08                             ;8 bits to transmit
E: symbol not defined: `S2'.
245 1410C       1438                      wbs_loop: RR s3                                   ;test next bit LSB first
E: symbol not defined: `S3'.
246 3A249       1439                                JUMP C, wbs1                            ;transmit '0' or '1'
247 2024D       1440                                CALL write_Low_slow
248 2224A       1441                                JUMP next_slow_bit
249 20258       1442                          wbs1: CALL write_High_slow
24A 18110       1443                 next_slow_bit: SUB s2, 01                              ;count bits
E: symbol not defined: `S2'.
24B 36245       1444                                JUMP NZ, wbs_loop                       ;repeat until 8-bits transmitted
24C 25000       1445                                RETURN
                1446                                ;
                1447                                ;
                1448                                ;
                1449                                ;**************************************************************************************
                1450                                ; Write a '0' to DS_wire in regular speed mode.
                1451                                ;**************************************************************************************
                1452                                ;
                1453                                ; To write a '0' to the DS_wire the signal must be Low for 60 to 120us. This design
                1454                                ; generates a 78us active Low pulse.
                1455                                ;
                1456                                ; The DS2432 then requires at least 1us of recovery time for which this routine
                1457                                ; provides a 2us delay such that the entire write Low process (slot time) is 80us.
                1458                                ; A recovery time of 1us was also found to be marginal in practice probably due
                1459                                ; to the rise time of the DS_wire via the external pull up resistor.
                1460                                ;
                1461                                ; Registers used s0,s1
                1462                                ;
24D 00100       1463                write_Low_slow: LOAD s0, 00                             ;transmit Low pulse
E: symbol not defined: `S0'.
24E 2D108       1464                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
                1465                                ;Delay of 78us is equivalent to 1950 instructions at 50MHz.
                1466                                ;This delay loop is formed of 27 instructions requiring 72 repetitions.
24F 00100       1467                                LOAD s1, 48                             ;72 (48 hex)
E: symbol not defined: `S1'.
W: value out of range: 0x30, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
250 2027C       1468                 wls_wait_78us: CALL delay_1us                          ;25 instructions including CALL
251 18110       1469                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
252 36250       1470                                JUMP NZ, wls_wait_78us                  ;repeat until zero
253 00110       1471                                LOAD s0, 01                             ;end of Low pulse
E: symbol not defined: `S0'.
254 2D108       1472                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
255 2027C       1473                                CALL delay_1us                          ;2us recovery time
256 2027C       1474                                CALL delay_1us
257 25000       1475                                RETURN
                1476                                ;
                1477                                ;
                1478                                ;**************************************************************************************
                1479                                ; Write a '1' to DS_wire in regular speed mode.
                1480                                ;**************************************************************************************
                1481                                ;
                1482                                ; To write a '1' to the DS_wire the signal must be Low for 1 to 15us to instigate the
                1483                                ; write of the data. This design generates an 8us active Low pulse for this purpose.
                1484                                ;
                1485                                ; Then the output must be High for 53 to 114us to provide the '1' for the DS2432 to
                1486                                ; read and then provide recovery time. This design implements a 72us delay such that
                1487                                ; the entire write High process (slot time) is 80us
                1488                                ;
                1489                                ; Registers used s0,s1
                1490                                ;
258 00100       1491               write_High_slow: LOAD s0, 00                             ;transmit Low pulse
E: symbol not defined: `S0'.
259 2D108       1492                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
                1493                                ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1494                                ;This delay loop is formed of 27 instructions requiring 8 repetitions.
25A 00180       1495                                LOAD s1, 08                             ;8 (08 hex)
E: symbol not defined: `S1'.
25B 2027C       1496                  whs_wait_8us: CALL delay_1us                          ;25 instructions including CALL
25C 18110       1497                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
25D 3625B       1498                                JUMP NZ, whs_wait_8us                   ;repeat until zero
25E 00110       1499                                LOAD s0, 01                             ;end of Low pulse
E: symbol not defined: `S0'.
25F 2D108       1500                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
                1501                                ;Delay of 72us is equivalent to 1800 instructions at 50MHz.
                1502                                ;This delay loop is formed of 27 instructions requiring 67 repetitions.
260 001B0       1503                                LOAD s1, 43                             ;67 (43 hex)
E: symbol not defined: `S1'.
W: value out of range: 0x2b, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xb.
261 2027C       1504                 whs_wait_72us: CALL delay_1us                          ;25 instructions including CALL
262 18110       1505                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
263 36261       1506                                JUMP NZ, whs_wait_72us                  ;repeat until zero
264 25000       1507                                RETURN
                1508                                ;
                1509                                ;
                1510                                ;
                1511                                ;**************************************************************************************
                1512                                ; Read a byte from DS2432 in regular speed mode.
                1513                                ;**************************************************************************************
                1514                                ;
                1515                                ; Bytes are read from the DS2432 with LSB first.
                1516                                ;
                1517                                ; The byte read will be returned in register 's3'.
                1518                                ;
                1519                                ; Registers used s0,s1,s2,s3
                1520                                ;
265 00180       1521                read_byte_slow: LOAD s2, 08                             ;8 bits to receive
E: symbol not defined: `S2'.
266 2026A       1522                      rbs_loop: CALL read_bit_slow                      ;read next bit LSB first
267 18110       1523                                SUB s2, 01                              ;count bits
E: symbol not defined: `S2'.
268 36266       1524                                JUMP NZ, rbs_loop                       ;repeat until 8-bits received
269 25000       1525                                RETURN
                1526                                ;
                1527                                ;
                1528                                ;
                1529                                ;
                1530                                ;**************************************************************************************
                1531                                ; Read a data bit sent from the DS2432 in regular speed mode.
                1532                                ;**************************************************************************************
                1533                                ;
                1534                                ; To read a bit, PicoBlaze must initiate the processed with an active Low pulse of
                1535                                ; 1 to 15us. This design generates a 4us active Low pulse for this purpose.
                1536                                ;
                1537                                ; Then DS2432 responds to the Low pulse by diving DS_wire in two different ways
                1538                                ; depending on the logic level it is trying to send back.
                1539                                ;
                1540                                ; For a logic '0' the DS2432 will drive the DS-wire Low for up to 15us after
                1541                                ; the start of the instigating pulse. Therefore PicoBlaze must read the DS-wire
                1542                                ; before this time has elapsed but only after it has itself released the wire.
                1543                                ;
                1544                                ; For a logic '1' the DS2432 will do nothing and hence the DS-wire will be pulled
                1545                                ; High by the external resistor after PicoBlaze has released the wire. PicoBlaze
                1546                                ; will sample the wire and detect the High level.
                1547                                ;
                1548                                ; In this design, PicoBlaze needs to detect the logic state of the wire after
                1549                                ; releasing the wire at 4us. Sampling the wire too quickly would not provide
                1550                                ; adequate time for a High signal to be formed by the pull up resistor. However, it
                1551                                ; must sample the wire before 15us have elapsed and any potential Low is removed.
                1552                                ; This design samples the wire at 12us which is 8us after the initiation pulse ends.
                1553                                ;
                1554                                ; A further delay of 68us is then allowed for the DS2432 to stop transmitting and
                1555                                ; to recover. This also mean that the entire read process (slot time) is 80us.
                1556                                ;
                1557                                ; The received data bit is SHIFTED into the MSB of register 's3'. In this way
                1558                                ; the reception of 8-bits will shift the first bit into the LSB position of 's3'.
                1559                                ;
                1560                                ; Registers used s0,s1,s3
                1561                                ;
26A 00100       1562                 read_bit_slow: LOAD s0, 00                             ;transmit Low pulse
E: symbol not defined: `S0'.
26B 2D108       1563                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
                1564                                ;Delay of 4us is equivalent to 100 instructions at 50MHz.
                1565                                ;This delay loop is formed of 27 instructions requiring 4 repetitions.
26C 00140       1566                                LOAD s1, 04                             ;4 (04 hex)
E: symbol not defined: `S1'.
26D 2027C       1567                  rbs_wait_4us: CALL delay_1us                          ;25 instructions including CALL
26E 18110       1568                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
26F 3626D       1569                                JUMP NZ, rbs_wait_4us                   ;repeat until zero
270 00110       1570                                LOAD s0, 01                             ;end of Low pulse
E: symbol not defined: `S0'.
271 2D108       1571                                OUTPUT s0, DS_wire_out_port
E: symbol not defined: `S0'.
                1572                                ;Delay of 8us is equivalent to 200 instructions at 50MHz.
                1573                                ;This delay loop is formed of 27 instructions requiring 8 repetitions.
272 00180       1574                                LOAD s1, 08                             ;8 (08 hex)
E: symbol not defined: `S1'.
273 2027C       1575                  rbs_wait_8us: CALL delay_1us                          ;25 instructions including CALL
274 18110       1576                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
275 36273       1577                                JUMP NZ, rbs_wait_8us                   ;repeat until zero
276 20240       1578                                CALL read_DS_wire                       ;sample wire (carry = state)
277 14108       1579                                SRA s3                                  ;shift received bit into MSB of s3
E: symbol not defined: `S3'.
                1580                                ;Delay of 68us is equivalent to 1700 instructions at 50MHz.
                1581                                ;This delay loop is formed of 27 instructions requiring 63 repetitions.
                1582                                LOAD s1, 3F                             ;63 (3F hex)
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
278 2027C       1583                 rbs_wait_68us: CALL delay_1us                          ;25 instructions including CALL
279 18110       1584                                SUB s1, 01                              ;decrement delay counter
E: symbol not defined: `S1'.
27A 36278       1585                                JUMP NZ, rbs_wait_68us                  ;repeat until zero
27B 25000       1586                                RETURN
                1587                                ;
                1588                                ;
                1589                                ;**************************************************************************************
                1590                                ; Software delay routines
                1591                                ;**************************************************************************************
                1592                                ;
                1593                                ; Delay of 1us.
                1594                                ;
                1595                                ; Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1596                                ; executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1597                                ; the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1598                                ;
                1599                                ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1600                                ;
                1601                                ; Register used s0
                1602                                ;
27C 00100       1603                     delay_1us: LOAD s0, delay_1us_constant
E: symbol not defined: `S0'.
27D 18110       1604                      wait_1us: SUB s0, 01
E: symbol not defined: `S0'.
27E 3627D       1605                                JUMP NZ, wait_1us
27F 25000       1606                                RETURN
                1607                                ;
                1608                                ; Delay of 40us.
                1609                                ;
                1610                                ; Registers used s0, s1
                1611                                ;
280 001C0       1612                    delay_40us: LOAD s1, 28                             ;40 x 1us = 40us
E: symbol not defined: `S1'.
W: value out of range: 0x1c, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xc.
281 2027C       1613                     wait_40us: CALL delay_1us
282 18110       1614                                SUB s1, 01
E: symbol not defined: `S1'.
283 36281       1615                                JUMP NZ, wait_40us
284 25000       1616                                RETURN
                1617                                ;
                1618                                ;
                1619                                ; Delay of 1ms.
                1620                                ;
                1621                                ; Registers used s0, s1, s2
                1622                                ;
285 00130       1623                     delay_1ms: LOAD s2, 19                             ;25 x 40us = 1ms
E: symbol not defined: `S2'.
W: value out of range: 0x13, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
286 20280       1624                      wait_1ms: CALL delay_40us
287 18110       1625                                SUB s2, 01
E: symbol not defined: `S2'.
288 36286       1626                                JUMP NZ, wait_1ms
289 25000       1627                                RETURN
                1628                                ;
                1629                                ; Delay of 20ms.
                1630                                ;
                1631                                ; Registers used s0, s1, s2, s3
                1632                                ;
28A 001E0       1633                    delay_20ms: LOAD s3, 14                             ;20 x 1ms = 20ms
E: symbol not defined: `S3'.
28B 20285       1634                     wait_20ms: CALL delay_1ms
28C 18110       1635                                SUB s3, 01
E: symbol not defined: `S3'.
28D 3628B       1636                                JUMP NZ, wait_20ms
28E 25000       1637                                RETURN
                1638                                ;
                1639                                ; Delay of approximately 1 second.
                1640                                ;
                1641                                ; Registers used s0, s1, s2, s3, s4
                1642                                ;
28F 001E0       1643                      delay_1s: LOAD s4, 14                             ;50 x 20ms = 1000ms
E: symbol not defined: `S4'.
290 2028A       1644                       wait_1s: CALL delay_20ms
291 18110       1645                                SUB s4, 01
E: symbol not defined: `S4'.
292 36290       1646                                JUMP NZ, wait_1s
293 25000       1647                                RETURN
                1648                                ;
                1649                                ;
                1650                                ;**************************************************************************************
                1651                                ; UART communication routines
                1652                                ;**************************************************************************************
                1653                                ;
                1654                                ; Read one character from the UART
                1655                                ;
                1656                                ; Character read will be returned in a register called 'UART_data'.
                1657                                ;
                1658                                ; The routine first tests the receiver FIFO buffer to see if data is present.
                1659                                ; If the FIFO is empty, the routine waits until there is a character to read.
                1660                                ; As this could take any amount of time the wait loop could include a call to a
                1661                                ; subroutine which performs a useful function.
                1662                                ;
                1663                                ;
                1664                                ; Registers used s0 and UART_data
                1665                                ;
294 09128       1666                read_from_UART: INPUT s0, status_port                   ;test Rx_FIFO buffer
E: symbol not defined: `S0'.
295 0C140       1667                                TEST s0, rx_data_present                ;wait if empty
E: symbol not defined: `S0'.
296 36298       1668                                JUMP NZ, read_character
297 22294       1669                                JUMP read_from_UART
298 09150       1670                read_character: INPUT UART_data, UART_read_port         ;read from FIFO
299 25000       1671                                RETURN
                1672                                ;
                1673                                ;
                1674                                ;
                1675                                ; Transmit one character to the UART
                1676                                ;
                1677                                ; Character supplied in register called 'UART_data'.
                1678                                ;
                1679                                ; The routine first tests the transmit FIFO buffer to see if it is full.
                1680                                ; If the FIFO is full, then the routine waits until it there is space.
                1681                                ;
                1682                                ; Registers used s0
                1683                                ;
29A 09128       1684                  send_to_UART: INPUT s0, status_port                   ;test Tx_FIFO buffer
E: symbol not defined: `S0'.
29B 0C120       1685                                TEST s0, tx_full                        ;wait if full
E: symbol not defined: `S0'.
29C 3229E       1686                                JUMP Z, UART_write
29D 2229A       1687                                JUMP send_to_UART
29E 2D104       1688                    UART_write: OUTPUT UART_data, UART_write_port
29F 25000       1689                                RETURN
                1690                                ;
                1691                                ;
                1692                                ;**************************************************************************************
                1693                                ; Useful ASCII conversion and handling routines
                1694                                ;**************************************************************************************
                1695                                ;
                1696                                ;
                1697                                ; Convert character to upper case
                1698                                ;
                1699                                ; The character supplied in register s0.
                1700                                ; If the character is in the range 'a' to 'z', it is converted
                1701                                ; to the equivalent upper case character in the range 'A' to 'Z'.
                1702                                ; All other characters remain unchanged.
                1703                                ;
                1704                                ; Registers used s0.
                1705                                ;
2A0 1C1D0       1706                    upper_case: COMPARE s0, 61                          ;eliminate character codes below 'a' (61 hex)
E: symbol not defined: `S0'.
W: value out of range: 0x3d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
2A1 39000       1707                                RETURN C
                1708                                COMPARE s0, 7B                          ;eliminate character codes above 'z' (7A hex)
E: identifier cannot start with a digit: `7B'.
E: unexpected end of line.
2A2 3D000       1709                                RETURN NC
2A3 02110       1710                                AND s0, DF                              ;mask bit5 to convert to upper case
E: symbol not defined: `S0'.
E: symbol not defined: `DF'.
2A4 25000       1711                                RETURN
                1712                                ;
                1713                                ;
                1714                                ; Convert hexadecimal value provided in register s0 into ASCII characters
                1715                                ;
                1716                                ; The value provided must can be any value in the range 00 to FF and will be converted into
                1717                                ; two ASCII characters.
                1718                                ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1719                                ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1720                                ;
                1721                                ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1722                                ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1723                                ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1724                                ;
                1725                                ; Registers used s0, s1 and s2.
                1726                                ;
2A5 00110       1727             hex_byte_to_ASCII: LOAD s1, s0                             ;remember value supplied
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
2A6 1410E       1728                                SR0 s0                                  ;isolate upper nibble
E: symbol not defined: `S0'.
2A7 1410E       1729                                SR0 s0
E: symbol not defined: `S0'.
2A8 1410E       1730                                SR0 s0
E: symbol not defined: `S0'.
2A9 1410E       1731                                SR0 s0
E: symbol not defined: `S0'.
2AA 20001       1732                                CALL hex_to_ASCII                       ;convert
E: symbol not defined: `HEX_TO_ASCII'.
2AB 00110       1733                                LOAD s2, s0                             ;upper nibble value in s2
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
2AC 00110       1734                                LOAD s0, s1                             ;restore complete value
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                1735                                AND s0, 0F                              ;isolate lower nibble
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
2AD 20001       1736                                CALL hex_to_ASCII                       ;convert
E: symbol not defined: `HEX_TO_ASCII'.
2AE 00110       1737                                LOAD s1, s0                             ;lower nibble value in s1
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
2AF 25000       1738                                RETURN
                1739                                ;
                1740                                ; Convert hexadecimal value provided in register s0 into ASCII character
                1741                                ;
                1742                                ;Register used s0
                1743                                ;
                1744                  hex_to_ASCII: SUB s0, 0A                              ;test if value is in range 0 to 9
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
2B0 3A001       1745                                JUMP C, number_char
E: symbol not defined: `NUMBER_CHAR'.
2B1 10170       1746                                ADD s0, 07                              ;ASCII char A to F in range 41 to 46
E: symbol not defined: `S0'.
                1747                   number_char: ADD s0, 3A                              ;ASCII char 0 to 9 in range 30 to 40
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
2B2 25000       1748                                RETURN
                1749                                ;
                1750                                ;
                1751                                ; Send the two character HEX value of the register contents 's0' to the UART
                1752                                ;
                1753                                ; Registers used s0, s1, s2
                1754                                ;
2B3 202A5       1755                 send_hex_byte: CALL hex_byte_to_ASCII
2B4 00110       1756                                LOAD UART_data, s2
E: symbol not defined: `S2'.
2B5 2029A       1757                                CALL send_to_UART
2B6 00110       1758                                LOAD UART_data, s1
E: symbol not defined: `S1'.
2B7 2029A       1759                                CALL send_to_UART
2B8 25000       1760                                RETURN
                1761                                ;
                1762                                ;
                1763                                ;
                1764                                ; Convert the HEX ASCII characters contained in 's3' and 's2' into
                1765                                ; an equivalent hexadecimal value in register 's0'.
                1766                                ;     The upper nibble is represented by an ASCII character in register s3.
                1767                                ;     The lower nibble is represented by an ASCII character in register s2.
                1768                                ;
                1769                                ; Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
                1770                                ; will be set on return.
                1771                                ;
                1772                                ; Registers used s0, s2 and s3.
                1773                                ;
2B9 00110       1774             ASCII_byte_to_hex: LOAD s0, s3                             ;Take upper nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
2BA 202C6       1775                                CALL ASCII_to_hex                       ;convert to value
2BB 39000       1776                                RETURN C                                ;reject if out of range
2BC 00110       1777                                LOAD s3, s0                             ;remember value
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
2BD 14106       1778                                SL0 s3                                  ;multiply value by 16 to put in upper nibble
E: symbol not defined: `S3'.
2BE 14106       1779                                SL0 s3
E: symbol not defined: `S3'.
2BF 14106       1780                                SL0 s3
E: symbol not defined: `S3'.
2C0 14106       1781                                SL0 s3
E: symbol not defined: `S3'.
2C1 00110       1782                                LOAD s0, s2                             ;Take lower nibble
E: symbol not defined: `S0'.
E: symbol not defined: `S2'.
2C2 202C6       1783                                CALL ASCII_to_hex                       ;convert to value
2C3 39000       1784                                RETURN C                                ;reject if out of range
2C4 04110       1785                                OR s0, s3                               ;merge in the upper nibble with CARRY reset
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
2C5 25000       1786                                RETURN
                1787                                ;
                1788                                ;
                1789                                ; Routine to convert ASCII data in 's0' to an equivalent HEX value.
                1790                                ;
                1791                                ; If character is not valid for hex, then CARRY is set on return.
                1792                                ;
                1793                                ; Register used s0
                1794                                ;
2C6 10110       1795                  ASCII_to_hex: ADD s0, B9                              ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
E: symbol not defined: `B9'.
2C7 39000       1796                                RETURN C
2C8 18110       1797                                SUB s0, E9                              ;normalise 0 to 9 with A-F in 11 to 16 hex
E: symbol not defined: `S0'.
E: symbol not defined: `E9'.
2C9 39000       1798                                RETURN C                                ;reject below ASCII code 30 ('0')
2CA 181B0       1799                                SUB s0, 11                              ;isolate A-F down to 00 to 05 hex
E: symbol not defined: `S0'.
2CB 3E001       1800                                JUMP NC, ASCII_letter
E: symbol not defined: `ASCII_LETTER'.
2CC 10170       1801                                ADD s0, 07                              ;test for above ASCII code 46 ('F')
E: symbol not defined: `S0'.
2CD 39000       1802                                RETURN C
2CE 18110       1803                                SUB s0, F6                              ;convert to range 00 to 09
E: symbol not defined: `S0'.
E: symbol not defined: `F6'.
2CF 25000       1804                                RETURN
                1805                  ASCII_letter: ADD s0, 0A                              ;convert to range 0A to 0F
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
2D0 25000       1806                                RETURN
                1807                                ;
                1808                                ;
                1809                                ; Read one character from UART and echo.
                1810                                ; Convert to upper case and return.
                1811                                ;
                1812                                ;
2D1 20294       1813               read_upper_case: CALL read_from_UART                     ;read command character from UART
2D2 2029A       1814                                CALL send_to_UART                       ;echo character
2D3 00110       1815                                LOAD s0, UART_data                      ;convert to upper case
E: symbol not defined: `S0'.
2D4 202A0       1816                                CALL upper_case
2D5 25000       1817                                RETURN
                1818                                ;
                1819                                ;
                1820                                ; Read two hex characters from UART and convert to single byte data
                1821                                ;
2D6 202D1       1822                  obtain_8bits: CALL read_upper_case                    ;obtain one byte from UART
2D7 00110       1823                                LOAD s3, s0
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
2D8 202D1       1824                                CALL read_upper_case
2D9 00110       1825                                LOAD s2, s0
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
2DA 202B9       1826                                CALL ASCII_byte_to_hex
2DB 25000       1827                                RETURN
                1828                                ;
                1829                                ;**************************************************************************************
                1830                                ; Text messages
                1831                                ;**************************************************************************************
                1832                                ;
                1833                                ;
                1834                                ; Send Carriage Return to the UART
                1835                                ;
2DC 00100       1836                       send_CR: LOAD UART_data, character_CR
2DD 2029A       1837                                CALL send_to_UART
2DE 25000       1838                                RETURN
                1839                                ;
                1840                                ; Send a space to the UART
                1841                                ;
2DF 00140       1842                    send_space: LOAD UART_data, character_space
W: value out of range: 0x14, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
2E0 2029A       1843                                CALL send_to_UART
2E1 25000       1844                                RETURN
                1845                                ;
                1846                                ;
                1847                                ; Send a minus sign to the UART
                1848                                ;
2E2 00120       1849                    send_minus: LOAD UART_data, character_minus
2E3 2029A       1850                                CALL send_to_UART
2E4 25000       1851                                RETURN
                1852                                ;
                1853                                ;
                1854                                ; Send the letter 't' to the UART
                1855                                ;
2E5 001A0       1856                        send_t: LOAD UART_data, character_t
W: value out of range: 0x4a, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xa.
2E6 2029A       1857                                CALL send_to_UART
2E7 25000       1858                                RETURN
                1859                                ;
                1860                                ; Send the letter 'e' to the UART
                1861                                ;
2E8 00110       1862                        send_e: LOAD UART_data, character_e
W: value out of range: 0x41, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
2E9 2029A       1863                                CALL send_to_UART
2EA 25000       1864                                RETURN
                1865                                ;
                1866                                ; Send the letter 'a' to the UART
                1867                                ;
2EB 001D0       1868                        send_a: LOAD UART_data, character_a
W: value out of range: 0x3d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
2EC 2029A       1869                                CALL send_to_UART
2ED 25000       1870                                RETURN
                1871                                ;
                1872                                ;
                1873                                ; Send the letter 'd' to the UART
                1874                                ;
2EE 00100       1875                        send_d: LOAD UART_data, character_d
W: value out of range: 0x40, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
2EF 2029A       1876                                CALL send_to_UART
2F0 25000       1877                                RETURN
                1878                                ;
                1879                                ;
                1880                                ; Send the letter 'r' to the UART
                1881                                ;
2F1 00180       1882                        send_r: LOAD UART_data, character_r
W: value out of range: 0x48, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x8.
2F2 2029A       1883                                CALL send_to_UART
2F3 25000       1884                                RETURN
                1885                                ;
                1886                                ;
                1887                                ; Send the letter 's' to the UART
                1888                                ;
2F4 00190       1889                        send_s: LOAD UART_data, character_s
W: value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
2F5 2029A       1890                                CALL send_to_UART
2F6 25000       1891                                RETURN
                1892                                ;
                1893                                ;
                1894                                ; Send the letter 'c' to the UART
                1895                                ;
2F7 001F0       1896                        send_c: LOAD UART_data, character_c
W: value out of range: 0x3f, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xf.
2F8 2029A       1897                                CALL send_to_UART
2F9 25000       1898                                RETURN
                1899                                ;
                1900                                ;
                1901                                ; Send 'PicoBlaze SHA-1 Algorithm v1.00' string to the UART
                1902                                ;
2FA 202DC       1903                  send_welcome: CALL send_CR
2FB 202DC       1904                                CALL send_CR
2FC 00160       1905                                LOAD UART_data, character_P
W: value out of range: 0x46, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
2FD 2029A       1906                                CALL send_to_UART
2FE 00150       1907                                LOAD UART_data, character_i
W: value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
2FF 2029A       1908                                CALL send_to_UART
300 202F7       1909                                CALL send_c
301 00110       1910                                LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
302 2029A       1911                                CALL send_to_UART
303 001E0       1912                                LOAD UART_data, character_B
W: value out of range: 0x3e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
304 2029A       1913                                CALL send_to_UART
305 00110       1914                                LOAD UART_data, character_l
E: symbol not defined: `CHARACTER_L'.
306 2029A       1915                                CALL send_to_UART
307 202EB       1916                                CALL send_a
308 00110       1917                                LOAD UART_data, character_z
E: symbol not defined: `CHARACTER_Z'.
309 2029A       1918                                CALL send_to_UART
30A 202E8       1919                                CALL send_e
30B 202DF       1920                                CALL send_space
30C 00190       1921                                LOAD UART_data, character_S
W: value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
30D 2029A       1922                                CALL send_to_UART
30E 00140       1923                                LOAD UART_data, character_H
W: value out of range: 0x44, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
30F 2029A       1924                                CALL send_to_UART
310 001D0       1925                                LOAD UART_data, character_A
W: value out of range: 0x3d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
311 2029A       1926                                CALL send_to_UART
312 202E2       1927                                CALL send_minus
313 001F0       1928                                LOAD UART_data, character_1
W: value out of range: 0x1f, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xf.
314 2029A       1929                                CALL send_to_UART
315 202DF       1930                                CALL send_space
316 001D0       1931                                LOAD UART_data, character_A
W: value out of range: 0x3d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
317 2029A       1932                                CALL send_to_UART
318 00110       1933                                LOAD UART_data, character_l
E: symbol not defined: `CHARACTER_L'.
319 2029A       1934                                CALL send_to_UART
31A 00130       1935                                LOAD UART_data, character_g
W: value out of range: 0x43, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
31B 2029A       1936                                CALL send_to_UART
31C 00110       1937                                LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
31D 2029A       1938                                CALL send_to_UART
31E 202F1       1939                                CALL send_r
31F 00150       1940                                LOAD UART_data, character_i
W: value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
320 2029A       1941                                CALL send_to_UART
321 202E5       1942                                CALL send_t
322 00140       1943                                LOAD UART_data, character_h
W: value out of range: 0x44, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
323 2029A       1944                                CALL send_to_UART
324 00160       1945                                LOAD UART_data, character_m
325 2029A       1946                                CALL send_to_UART
326 202DF       1947                                CALL send_space
327 001C0       1948                                LOAD UART_data, character_v
W: value out of range: 0x4c, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xc.
328 2029A       1949                                CALL send_to_UART
329 001F0       1950                                LOAD UART_data, character_1
W: value out of range: 0x1f, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xf.
32A 2029A       1951                                CALL send_to_UART
32B 00110       1952                                LOAD UART_data, character_fullstop
E: symbol not defined: `CHARACTER_FULLSTOP'.
32C 2029A       1953                                CALL send_to_UART
32D 001E0       1954                                LOAD UART_data, character_0
W: value out of range: 0x1e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
32E 2029A       1955                                CALL send_to_UART
32F 001E0       1956                                LOAD UART_data, character_0
W: value out of range: 0x1e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
330 2029A       1957                                CALL send_to_UART
331 202DC       1958                                CALL send_CR
332 202DC       1959                                CALL send_CR
333 25000       1960                                RETURN
                1961                                ;
                1962                                ;
                1963                                ;
                1964                                ;
                1965                                ;
                1966                                ;
                1967                                ; Send DS2432 menu to the UART
                1968                                ;
334 202DC       1969              send_DS2432_menu: CALL send_CR
335 202DC       1970                                CALL send_CR
336 001F0       1971                                LOAD UART_data, character_1
W: value out of range: 0x1f, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xf.
337 2029A       1972                                CALL send_to_UART
338 202E2       1973                                CALL send_minus
339 20395       1974                                CALL send_Write
33A 202DF       1975                                CALL send_space
33B 20374       1976                                CALL send_scratchpad
33C 202DC       1977                                CALL send_CR
33D 00100       1978                                LOAD UART_data, character_2
W: value out of range: 0x20, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x0.
33E 2029A       1979                                CALL send_to_UART
33F 202E2       1980                                CALL send_minus
340 2038F       1981                                CALL send_Read
341 202DF       1982                                CALL send_space
342 20374       1983                                CALL send_scratchpad
343 202DC       1984                                CALL send_CR
344 00110       1985                                LOAD UART_data, character_3
W: value out of range: 0x21, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
345 2029A       1986                                CALL send_to_UART
346 202E2       1987                                CALL send_minus
347 00110       1988                                LOAD UART_data, character_L
E: symbol not defined: `CHARACTER_L'.
348 2029A       1989                                CALL send_to_UART
349 00110       1990                                LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
34A 2029A       1991                                CALL send_to_UART
34B 202EB       1992                                CALL send_a
34C 202EE       1993                                CALL send_d
34D 202DF       1994                                CALL send_space
34E 00120       1995                                LOAD UART_data, character_f
W: value out of range: 0x42, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
34F 2029A       1996                                CALL send_to_UART
350 00150       1997                                LOAD UART_data, character_i
W: value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
351 2029A       1998                                CALL send_to_UART
352 202F1       1999                                CALL send_r
353 202F4       2000                                CALL send_s
354 202E5       2001                                CALL send_t
355 202DF       2002                                CALL send_space
356 20381       2003                                CALL send_secret
357 202DC       2004                                CALL send_CR
358 00120       2005                                LOAD UART_data, character_4
W: value out of range: 0x22, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
359 2029A       2006                                CALL send_to_UART
35A 202E2       2007                                CALL send_minus
35B 2038F       2008                                CALL send_Read
35C 202DF       2009                                CALL send_space
35D 001D0       2010                                LOAD UART_data, character_a
W: value out of range: 0x3d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
35E 2029A       2011                                CALL send_to_UART
35F 001B0       2012                                LOAD UART_data, character_u
W: value out of range: 0x4b, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xb.
360 2029A       2013                                CALL send_to_UART
361 202E5       2014                                CALL send_t
362 00140       2015                                LOAD UART_data, character_h
W: value out of range: 0x44, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
363 2029A       2016                                CALL send_to_UART
364 202DF       2017                                CALL send_space
365 00160       2018                                LOAD UART_data, character_P
W: value out of range: 0x46, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
366 2029A       2019                                CALL send_to_UART
367 202EB       2020                                CALL send_a
368 00130       2021                                LOAD UART_data, character_g
W: value out of range: 0x43, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x3.
369 2029A       2022                                CALL send_to_UART
36A 202E8       2023                                CALL send_e
36B 202DC       2024                                CALL send_CR
36C 25000       2025                                RETURN
                2026                                ;
                2027                                ;
                2028                                ;
                2029                                ; Send carriage return, 'OK' and carriage return to the UART
                2030                                ;
36D 202DC       2031                       send_OK: CALL send_CR
36E 00110       2032                                LOAD UART_data, character_O
E: symbol not defined: `CHARACTER_O'.
36F 2029A       2033                                CALL send_to_UART
370 00110       2034                                LOAD UART_data, character_K
E: symbol not defined: `CHARACTER_K'.
371 2029A       2035                                CALL send_to_UART
372 202DC       2036                                CALL send_CR
373 25000       2037                                RETURN
                2038                                ;
                2039                                ;
                2040                                ; Send 'scratchpad' to the UART
                2041                                ;
374 202F4       2042               send_scratchpad: CALL send_s
375 202F7       2043                                CALL send_c
376 202F1       2044                                CALL send_r
377 202EB       2045                                CALL send_a
378 202E5       2046                                CALL send_t
379 202F7       2047                                CALL send_c
37A 00140       2048                                LOAD UART_data, character_h
W: value out of range: 0x44, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x4.
37B 2029A       2049                                CALL send_to_UART
37C 00160       2050                                LOAD UART_data, character_p
W: value out of range: 0x46, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
37D 2029A       2051                                CALL send_to_UART
37E 202EB       2052                                CALL send_a
37F 202EE       2053                                CALL send_d
380 25000       2054                                RETURN
                2055                                ;
                2056                                ;
                2057                                ; Send 'secret' to the UART
                2058                                ;
381 202F4       2059                   send_secret: CALL send_s
382 202E8       2060                                CALL send_e
383 202F7       2061                                CALL send_c
384 202F1       2062                                CALL send_r
385 202E8       2063                                CALL send_e
386 202E5       2064                                CALL send_t
387 25000       2065                                RETURN
                2066                                ;
                2067                                ;
                2068                                ; Send 'Byte' to the UART
                2069                                ;
388 001E0       2070                     send_Byte: LOAD UART_data, character_B
W: value out of range: 0x3e, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xe.
389 2029A       2071                                CALL send_to_UART
38A 001F0       2072                                LOAD UART_data, character_y
W: value out of range: 0x4f, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xf.
38B 2029A       2073                                CALL send_to_UART
38C 202E5       2074                                CALL send_t
38D 202E8       2075                                CALL send_e
38E 25000       2076                                RETURN
                2077                                ;
                2078                                ;
                2079                                ; Send 'Read' to the UART
                2080                                ;
38F 00180       2081                     send_Read: LOAD UART_data, character_R
W: value out of range: 0x48, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x8.
390 2029A       2082                                CALL send_to_UART
391 202E8       2083                                CALL send_e
392 202EB       2084                                CALL send_a
393 202EE       2085                                CALL send_d
394 25000       2086                                RETURN
                2087                                ;
                2088                                ;
                2089                                ; Send 'Write' to the UART
                2090                                ;
395 001D0       2091                    send_Write: LOAD UART_data, character_W
W: value out of range: 0x4d, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0xd.
396 2029A       2092                                CALL send_to_UART
397 202F1       2093                                CALL send_r
398 00150       2094                                LOAD UART_data, character_i
W: value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
399 2029A       2095                                CALL send_to_UART
39A 202E5       2096                                CALL send_t
39B 202E8       2097                                CALL send_e
39C 25000       2098                                RETURN
                2099                                ;
                2100                                ;
                2101                                ; Send 'Pass' to the UART
                2102                                ;
39D 00160       2103                     send_Pass: LOAD UART_data, character_P
W: value out of range: 0x46, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x6.
39E 2029A       2104                                CALL send_to_UART
39F 202EB       2105                                CALL send_a
3A0 202F4       2106                                CALL send_s
3A1 202F4       2107                                CALL send_s
3A2 202DC       2108                                CALL send_CR
3A3 25000       2109                                RETURN
                2110                                ;
                2111                                ;
                2112                                ; Send 'Fail' to the UART
                2113                                ;
3A4 00120       2114                     send_Fail: LOAD UART_data, character_F
W: value out of range: 0x42, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x2.
3A5 2029A       2115                                CALL send_to_UART
3A6 202EB       2116                                CALL send_a
3A7 00150       2117                                LOAD UART_data, character_i
W: value out of range: 0x45, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x5.
3A8 2029A       2118                                CALL send_to_UART
3A9 00110       2119                                LOAD UART_data, character_l
E: symbol not defined: `CHARACTER_L'.
3AA 2029A       2120                                CALL send_to_UART
3AB 202DC       2121                                CALL send_CR
3AC 25000       2122                                RETURN
                2123                                ;
                2124                                ;
                2125                                ; Send 'address=' to the UART
                2126                                ;
3AD 202DC       2127                  send_address: CALL send_CR
3AE 202EB       2128                                CALL send_a
3AF 202EE       2129                                CALL send_d
3B0 202EE       2130                                CALL send_d
3B1 202F1       2131                                CALL send_r
3B2 202E8       2132                                CALL send_e
3B3 202F4       2133                                CALL send_s
3B4 202F4       2134                                CALL send_s
3B5 00130       2135                   send_equals: LOAD UART_data, character_equals
3B6 2029A       2136                                CALL send_to_UART
3B7 25000       2137                                RETURN
                2138                                ;
                2139                                ;
                2140                                ; Send 'data' to the UART
                2141                                ;
3B8 202DC       2142                     send_data: CALL send_CR
3B9 202EE       2143                                CALL send_d
3BA 202EB       2144                                CALL send_a
3BB 202E5       2145                                CALL send_t
3BC 202EB       2146                                CALL send_a
3BD 25000       2147                                RETURN
                2148                                ;
                2149                                ;
                2150                                ; Send 'E/S=' to the UART
                2151                                ;
3BE 202DC       2152                       send_ES: CALL send_CR
3BF 00110       2153                                LOAD UART_data, character_E
W: value out of range: 0x41, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x1.
3C0 2029A       2154                                CALL send_to_UART
3C1 00110       2155                                LOAD UART_data, character_divide
E: symbol not defined: `CHARACTER_DIVIDE'.
3C2 2029A       2156                                CALL send_to_UART
3C3 00190       2157                                LOAD UART_data, character_S
W: value out of range: 0x49, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x9.
3C4 2029A       2158                                CALL send_to_UART
3C5 223B5       2159                                JUMP send_equals
                2160                                ;
                2161                                ;
                2162                                ; Send 'code=' to the UART
                2163                                ;
3C6 202F7       2164                     send_code: CALL send_c
3C7 00110       2165                                LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
3C8 2029A       2166                                CALL send_to_UART
3C9 202EE       2167                                CALL send_d
3CA 202E8       2168                                CALL send_e
3CB 223B5       2169                                JUMP send_equals
                2170                                ;
                2171                                ;
                2172                                ; Send 's/n=' to the UART
                2173                                ;
3CC 202F4       2174                       send_sn: CALL send_s
3CD 00110       2175                                LOAD UART_data, character_divide
E: symbol not defined: `CHARACTER_DIVIDE'.
3CE 2029A       2176                                CALL send_to_UART
3CF 00110       2177                                LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
3D0 2029A       2178                                CALL send_to_UART
3D1 223B5       2179                                JUMP send_equals
                2180                                ;
                2181                                ;
                2182                                ; Send 'crc=' to the UART
                2183                                ;
3D2 202F7       2184                      send_crc: CALL send_c
3D3 00180       2185                                LOAD UART_data, character_r
W: value out of range: 0x48, allowed range is [0x0,0xf] (trimmed to 4 bits) which makes it 0x8.
3D4 2029A       2186                                CALL send_to_UART
3D5 202F7       2187                                CALL send_c
3D6 223B5       2188                                JUMP send_equals
                2189                                ;
                2190                                ;
                2191                                ;
                2192                                ; Send 'mac=' to the UART
                2193                                ;
3D7 00160       2194                      send_mac: LOAD UART_data, character_m
3D8 2029A       2195                                CALL send_to_UART
3D9 202EB       2196                                CALL send_a
3DA 202F7       2197                                CALL send_c
3DB 223B5       2198                                JUMP send_equals
                2199                                ;
                2200                                ;
                2201                                ;**************************************************************************************
                2202                                ; Interrupt Service Routine (ISR)
                2203                                ;**************************************************************************************
                2204                                ;
                2205                                ; Interrupts are not used in this design. This is a place keeper only.
                2206                                ;
                2207                                ADDRESS 3FE
E: identifier cannot start with a digit: `3FE'.
E: directive ADDRESS requires a single argument.
3DC 29001       2208                           ISR: RETURNI ENABLE
                2209                                ;
                2210                                ;
                2211                                ;**************************************************************************************
                2212                                ; Interrupt Vector
                2213                                ;**************************************************************************************
                2214                                ;
                2215                                ADDRESS 3FF
E: identifier cannot start with a digit: `3FF'.
E: directive ADDRESS requires a single argument.
3DD 223DC       2216                                JUMP ISR
                2217                                ;
                2218                                ;
