                   1                            ; KCPSM3 Program - Control and calculation for Frequency Generator design using the
                   2                            ;                 Spartan-3E Starter Kit.
                   3                            ;
                   4                            ; Interfaces with the rotary encoder and LCD display to enable a frequency to be set.
                   5                            ; Converts the BCD frequency value into a binary integer and then performs the high
                   6                            ; precision calculation necessary to derive the control numbers required by the high
                   7                            ; performance Direct Digital Synthesis (DDS) circuit implemented in hardware.
                   8                            ;
                   9                            ; LEDs are connected and used as edit mode indicators.
                  10                            ;
                  11                            ; Substantial comments are included in line with the code below and should be used
                  12                            ; in conjunction with the documentation provided with the complete reference design.
                  13                            ;
                  14                            ;
                  15                            ;
                  16                            ; Ken Chapman - Xilinx Ltd
                  17                            ;
                  18                            ; Version v1.00 - 13th July 2006
                  19                            ;
                  20                            ;**************************************************************************************
                  21                            ;Port definitions
                  22                            ;**************************************************************************************
                  23                            ;
                  24                            ;
                  25                            ;
                  26                            CONSTANT LED_port, 80               ;8 simple LEDs
                  27                            CONSTANT LED0, 01                   ;     LED 0 - bit0
                  28                            CONSTANT LED1, 02                   ;         1 - bit1
                  29                            CONSTANT LED2, 04                   ;         2 - bit2
                  30                            CONSTANT LED3, 08                   ;         3 - bit3
                  31                            CONSTANT LED4, 10                   ;         4 - bit4
                  32                            CONSTANT LED5, 20                   ;         5 - bit5
                  33                            CONSTANT LED6, 40                   ;         6 - bit6
                  34                            CONSTANT LED7, 80                   ;         7 - bit7
                  35                            ;
                  36                            ;
                  37                            CONSTANT rotary_port, 00            ;Read status of rotary encoder
                  38                            CONSTANT rotary_left, 01            ; Direction of last move Left=1 Right=0  - bit0
                  39                            CONSTANT rotary_press, 02           ;     Centre press contact (active High) - bit1
                  40                            ;
                  41                            ;
                  42                            ;LCD interface ports
                  43                            ;
                  44                            ;The master enable signal is not used by the LCD display itself
                  45                            ;but may be required to confirm that LCD communication is active.
                  46                            ;This is required on the Spartan-3E Starter Kit if the StrataFLASH
                  47                            ;is used because it shares the same data pins and conflicts must be avoided.
                  48                            ;
                  49                            CONSTANT LCD_output_port, 40        ;LCD character module output data and control
                  50                            CONSTANT LCD_E, 01                  ;   active High Enable        E - bit0
                  51                            CONSTANT LCD_RW, 02                 ;   Read=1 Write=0           RW - bit1
                  52                            CONSTANT LCD_RS, 04                 ;   Instruction=0 Data=1     RS - bit2
                  53                            CONSTANT LCD_drive, 08              ;   Master enable (active High) - bit3
                  54                            CONSTANT LCD_DB4, 10                ;   4-bit              Data DB4 - bit4
                  55                            CONSTANT LCD_DB5, 20                ;   interface          Data DB5 - bit5
                  56                            CONSTANT LCD_DB6, 40                ;                      Data DB6 - bit6
                  57                            CONSTANT LCD_DB7, 80                ;                      Data DB7 - bit7
                  58                            ;
                  59                            ;
                  60                            CONSTANT LCD_input_port, 01         ;LCD character module input data
                  61                            CONSTANT LCD_read_DB4, 10           ;    4-bit           Data DB4 - bit4
                  62                            CONSTANT LCD_read_DB5, 20           ;    interface       Data DB5 - bit5
                  63                            CONSTANT LCD_read_DB6, 40           ;                    Data DB6 - bit6
                  64                            CONSTANT LCD_read_DB7, 80           ;                    Data DB7 - bit7
                  65                            ;
                  66                            ;
                  67                            ;
                  68                            ;DDS control ports
                  69                            ;
                  70                            ;DDS control word is 32-bits
                  71                            ;
                  72                            CONSTANT DDS_control0_port, 02      ; dds_control_word(7:0)
                  73                            CONSTANT DDS_control1_port, 04      ; dds_control_word(15:8)
                  74                            CONSTANT DDS_control2_port, 08      ; dds_control_word(23:16)
                  75                            CONSTANT DDS_control3_port, 10      ; dds_control_word(31:24)
                  76                            ;
                  77                            ;Frequency scaling control word is 5-bits
                  78                            ;
                  79                            CONSTANT DDS_scaling_port, 20       ; dds_scaling_word(4:0)
                  80                            ;
                  81                            ;
                  82                            ;**************************************************************************************
                  83                            ;Special Register usage
                  84                            ;**************************************************************************************
                  85                            ;
                  86                            ;**************************************************************************************
                  87                            ;Scratch Pad Memory Locations
                  88                            ;**************************************************************************************
                  89                            ;
                  90                            CONSTANT rotary_status, 00          ;Status of rotary encoder
                  91                            CONSTANT rotary_event, 80           ;  flag set by interrupt in 'rotary_status' - bit7
                  92                            ;
                  93                            CONSTANT ISR_preserve_s0, 01        ;Preserve s0 contents during ISR
                  94                            ;
                  95                            CONSTANT LED_pattern, 02            ;LED pattern used in rotation mode
                  96                            ;
                  97                            ;
                  98                            ;BCD digits representing selected and displayed frequency
                  99                            ;
                 100                            CONSTANT BCD_digit0, 03             ; value           1
                 101                            CONSTANT BCD_digit1, 04             ;                10
                 102                            CONSTANT BCD_digit2, 05             ;               100
                 103                            CONSTANT BCD_digit3, 06             ;             1,000
                 104                            CONSTANT BCD_digit4, 07             ;            10,000
                 105                            CONSTANT BCD_digit5, 08             ;           100,000
                 106                            CONSTANT BCD_digit6, 09             ;         1,000,000
                 107                            CONSTANT BCD_digit7, 0A             ;        10,000,000
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 108                            CONSTANT BCD_digit8, 0B             ;       100,000,000
                 109                            ;
                 110                            ;
                 111                            ;Binary integer representation of BCD value
                 112                            ;
                 113                            CONSTANT frequency0, 0C             ;LS byte
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
                 114                            CONSTANT frequency1, 0D
                 115                            CONSTANT frequency2, 0E
E: identifier cannot start with a digit: `0E'.
E: unexpected end of line.
                 116                            CONSTANT frequency3, 0F             ;MS byte
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
                 117                            ;
                 118                            ;
                 119                            ;Control of frequency selection values
                 120                            ;
                 121                            CONSTANT cursor_position, 10        ; Pointer to edit position on LCD
                 122                            CONSTANT edit_digit_pointer, 11     ; BCD digit to be changed
                 123                            ;
                 124                            ;
                 125                            ;
                 126                            ;80-bit product resulting from 32-bit frequency x 48-bit scaling constant
                 127                            ;
                 128                            CONSTANT product0, 12               ;LS byte
                 129                            CONSTANT product1, 13
                 130                            CONSTANT product2, 14
                 131                            CONSTANT product3, 15
                 132                            CONSTANT product4, 16
                 133                            CONSTANT product5, 17
                 134                            CONSTANT product6, 18
                 135                            CONSTANT product7, 19
                 136                            CONSTANT product8, 1A
E: identifier cannot start with a digit: `1A'.
E: unexpected end of line.
                 137                            CONSTANT product9, 1B               ;MS byte
                 138                            ;
                 139                            ;Local copies of the DDS control word and DDS scaling word
                 140                            ;
                 141                            CONSTANT DDS_control0, 1C           ; dds_control_word(7:0)
E: identifier cannot start with a digit: `1C'.
E: unexpected end of line.
                 142                            CONSTANT DDS_control1, 1D           ; dds_control_word(15:8)
                 143                            CONSTANT DDS_control2, 1E           ; dds_control_word(23:16)
E: identifier cannot start with a digit: `1E'.
E: unexpected end of line.
                 144                            CONSTANT DDS_control3, 1F           ; dds_control_word(31:24)
E: identifier cannot start with a digit: `1F'.
E: unexpected end of line.
                 145                            CONSTANT DDS_scaling, 20            ; dds_scaling_word(4:0)
                 146                            ;
                 147                            ;**************************************************************************************
                 148                            ; Useful data constants
                 149                            ;**************************************************************************************
                 150                            ;
                 151                            ; To convert the frequency into a DDS control value a high precision scaling
                 152                            ; factor is used. This is a 48-bit number which converts the frequency presented
                 153                            ; as an 32-bit integer into the 32-bit value required by the phase accumulator
                 154                            ; to synthesize the desired frequency. The scaling factor is derived using the
                 155                            ; following method. First I will consider the scaling factor which results in the
                 156                            ; desired frequency being generated directly at the output of the phase accumulator
                 157                            ; which is suitable for low frequencies in which a few ns of jitter is acceptable.
                 158                            ;
                 159                            ; 'Fpa' is frequency generated by the MSB of the phase accumulator.
                 160                            ; 'p' is number of phase accumulator which in this case is 32 bits.
                 161                            ; 'clk' is the input clock frequency to the phase accumulator which is 200MHz.
                 162                            ; 'N' is the DDS control word value which is also 'p' bits (32 in this case).
                 163                            ;
                 164                            ; Frequency at MSB of phase accumulator is then
                 165                            ;
                 166                            ;       Fpa = clk x N / (2^p)
                 167                            ;
                 168                            ; Note that the maximum value allowed for 'N' is (2^p)/2 which results in Fpa=clk/2.
                 169                            ;  for 'N' greater than that value 'Fpa' would decrease in frequency (aliasing).
                 170                            ;
                 171                            ;
                 172                            ; By simple reorganisation of the equation we can compute 'N'
                 173                            ;
                 174                            ;       N = Fpa x (2^p) / clk
                 175                            ;
                 176                            ;
                 177                            ; Now it is easier to approach the next step using specific example.
                 178                            ;
                 179                            ; So for a frequency of Fpa = 1MHz then
                 180                            ;       N = 1MHz x (2^32)/200MHz = 21474836.48
                 181                            ;
                 182                            ; We must use the nearest 32-bit integer value 21474836 and this in turn
                 183                            ; is best viewed as the 32-bit hexadecimal value 0147AE14.
                 184                            ;
                 185                            ; In this case the value we have to work with is a 32-bit integer frequency
                 186                            ; value of 1 million which is 000F4240.
                 187                            ;
                 188                            ; So now we need to translate the value 000F4240 into 0147AE14. This is
                 189                            ; where a 48-bit scaling value is used together with a full precision multiplier
                 190                            ; as this ensures adequate accuracy of the final frequency.
                 191                            ;
                 192                            ;        32-bit frequency value                  ffffffff
                 193                            ;        48-bit scaling value              x ssssssssssss
                 194                            ;                                    --------------------
                 195                            ;        80-bit product              nnnnnnnnnnnnnnnnnnnn
                 196                            ;
                 197                            ; The art is to organise the scaling factor into the range where the most is made of
                 198                            ; the 48-bit resolution available but which will result in the correct 32-bit output.
                 199                            ; The way this is achieved is the select an appropriate 32-bits from the available 80-bit
                 200                            ; product for use as 'N' and truncate 'y' least significant bits.
                 201                            ;
                 202                            ; From this we can deduce that for a target frequency 'Ft' at the input then the
                 203                            ; scaling value 'S' is given by
                 204                            ;
                 205                            ;    S = N x (2^y) / Ft    with the condition that S < 2^48 but as large as possible
                 206                            ;
                 207                            ; For best accuracy we calculate 'S' using the full precision value of 'N' divided
                 208                            ; by Ft and then multiply continuously by 2 until we reach the biggest value less
                 209                            ; that 2^48. The number of multiplications by 2 indicating the value of 'y'.
                 210                            ;
                 211                            ; In this case we find that 'y' is 43.....
                 212                            ;       S = 21474836.48 x (2^43) / 1000000 = 21.47483648 x (2^43)
                 213                            ;                                          = 188894659314785.80854784
                 214                            ;
                 215                            ;  ...round to nearest integer and convert to hexadecimal S = ABCC77118462
                 216                            ;
                 217                            ; N will be taken from the 80 bit product by removing the 43 LSBs and the 5 MSBs
                 218                            ; to leave the 32 active bits required. This is best achieved by shifting left
                 219                            ; by 5 places (multiply by 2^5=32) and keeping the upper 32-bits.
                 220                            ;
                 221                            ;
                 222                            ; Sanity check....
                 223                            ;   Note that most calculators do not support >64 bit values to you will either
                 224                            ;   need to decompose your calculation and perform some of it manually or trust
                 225                            ;   the PicoBlaze implementation :-)
                 226                            ;
                 227                            ;     Ft = 1MHz =                         000F4240
                 228                            ;             S =                  x  ABCC77118462
                 229                            ;                             --------------------
                 230                            ;                             000A3D70A3D70A405C80
                 231                            ;
                 232                            ;     shift left 5 places                     x 20
                 233                            ;                             --------------------
                 234                            ;                             0147AE147AE1480B9000
                 235                            ;
                 236                            ; As expected, the most significant 32-bit (4 bytes) are 0147AE14 hex which is
                 237                            ; the DDS control word for 1MHz calculated previously.
                 238                            ;
                 239                            ; ***
                 240                            ;
                 241                            ; Now I will consider how this needs to be modified for the circuit presented
                 242                            ; which has a second DCM connected to the output of the phase accumulator to
                 243                            ; multiply the synthesized frequency and reduce cycle to cycle jitter at
                 244                            ; the same time. There is then a clock divider circuit connected to the output
                 245                            ; of the DCM which allows lower frequencies to be formed a different way (more of
                 246                            ; that later). As a minimum that divider circuit will divide by 2 which ensures that
                 247                            ; a square wave is presented to the clocked put pin. So in this circuit the fundamental
                 248                            ; multiplication factor is 8 formed by a 16 times multiplication by the DCM (256/16) and
                 249                            ; then a divide by 2.
                 250                            ;
                 251                            ; The overall multiplication factor of this sebsequent circuit means that for final
                 252                            ; output from the DCM to be the desired frequency, the output from the phase accumulator
                 253                            ; needs to be the same number of times smaller. This is not a bad thing because the
                 254                            ; percentage jitter of waveforms produced by the phase accumulator is better for lower
                 255                            ; frequencies made from more clock cycles.
                 256                            ;
                 257                            ; So we modify the basic equation to
                 258                            ;
                 259                            ;    Fout = Frequency at output of DCM
                 260                            ;       M = Multiplying factor of DCM
                 261                            ;
                 262                            ;    Fout = M x Fpa = M x clk x N / (2^p)
                 263                            ;
                 264                            ;
                 265                            ; By simple reorganisation of the equation we can compute 'N'
                 266                            ;
                 267                            ;       N = Fout x (2^p) / (clk x M)
                 268                            ;
                 269                            ;
                 270                            ; In this design M=8, p=32, clk=200MHz
                 271                            ;
                 272                            ; So now consider generating a nominal maximum frequency of 100MHz which will require
                 273                            ; the frequency synthesized by the phase accumulator to be 12.5MHz.
                 274                            ;
                 275                            ;       N = 100MHz x (2^32) / (200MHz x 8) = 268435456 = 10000000 Hex
                 276                            ;
                 277                            ; This all seems like a very convenient number but it simply reflects that 12.5MHz
                 278                            ; is a perfect division of the 200MHz clock and that that output from the phase
                 279                            ; accumulator will be formed perfectly of 16 of the 200MHz clock periods every time
                 280                            ; (8 Low and 8 High) with no additional jitter.
                 281                            ;
                 282                            ; So now we work out the scaling factor with the same rules as used previously that
                 283                            ; the scaling factor should be as large as possible within the 48-bits allocated.
                 284                            ;
                 285                            ;    S = N x (2^y) / Ft    with the condition that S < 2^48 but as large as possible
                 286                            ;
                 287                            ; In this case Ft = 100MHz = 055FE100 and the biggest value for S is found when using
                 288                            ; y=46
                 289                            ;
                 290                            ;    S = 268435456 x (2^46) / 100000000 = 2.68435456 x (2^46)
                 291                            ;                                       = 188894659314785.80854784
                 292                            ;
                 293                            ;      round to 188894659314786  = ABCC77118462
                 294                            ;
                 295                            ; Actually this is the exact same scaling constant as previously because the
                 296                            ; frequency to be synthesized by the phase accumulator is 8 times smaller but the
                 297                            ; value of 'S' is deliberate scaled to be as large as possible. In fact, 'S' in this
                 298                            ; case has been scaled up by a factor of 8 to arrive at the same value. So after
                 299                            ; using the scaling constant to form the 80 bit product, this time we will remove
                 300                            ; the 46 LSBs and the 2 MSBs to leave the 32 active bits required. This is best
                 301                            ; achieved by shifting left by 2 places (multiply by 2^2=4) and keeping the upper
                 302                            ; 32-bits (last time we multiplied by 32 which was 8 times more).
                 303                            ;
                 304                            ;
                 305                            ; Sanity check....
                 306                            ;
                 307                            ;     Ft = 100MHz =                         055FE100
                 308                            ;               S =                  x  ABCC77118462
                 309                            ;                               --------------------
                 310                            ;                               04000000000001242200
                 311                            ;
                 312                            ;       shift left 5 places                     x 20
                 313                            ;                               --------------------
                 314                            ;                               1000000000001C908800
                 315                            ;
                 316                            ; As expected, the most significant 32-bit (4 bytes) are 10000000 hex which is
                 317                            ; the DDS control word for 12.5MHz at the phase accumulator output calculated
                 318                            ; previously.
                 319                            ;
                 320                            ;
                 321                            ; ********
                 322                            ;
                 323                            ;
                 324                            ; 48-bit Scaling factor constant to generate the phase accumulator control word
                 325                            ; from the integer frequency value.
                 326                            ;
                 327                            ;   S = AB CC 77 11 84 62
                 328                            ;
                 329                            ; Notes
                 330                            ;
                 331                            ; The 80-bit product must be shifted left 5 times and then most significant 32-bits
                 332                            ; used to provide DDS control word if the frequency required is to be synthesized
                 333                            ; directly at the output of the phase accumulator.
                 334                            ;
                 335                            ; The 80-bit product must be shifted left 2 times and then most significant 32-bits
                 336                            ; used to provide DDS control word if the frequency required is to be synthesized
                 337                            ; by the phase accumulator followed by a multiplying DCM and divider with overall
                 338                            ; frequency gain of 8 times.
                 339                            ;
                 340                            CONSTANT scale_constant0, 62        ;LS byte
                 341                            CONSTANT scale_constant1, 84
                 342                            CONSTANT scale_constant2, 11
                 343                            CONSTANT scale_constant3, 77
                 344                            CONSTANT scale_constant4, CC
                 345                            CONSTANT scale_constant5, AB        ;MS byte
                 346                            ;
                 347                            ;
                 348                            ;
                 349                            ; ************************
                 350                            ;
                 351                            ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                 352                            ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 353                            ;calculation highly predictable. The '6' in the following equation even allows for
                 354                            ;'CALL delay_1us' instruction in the initiating code.
                 355                            ;
                 356                            ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 357                            ;
                 358                            ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 359                            ;For clock rates below 10MHz the value of 1 must be used and the operation will
                 360                            ;become lower than intended.
                 361                            ;
                 362                            CONSTANT delay_1us_constant, 0B
                 363                            ;
                 364                            ;
                 365                            ;
                 366                            ;ASCII table
                 367                            ;
                 368                            CONSTANT character_a, 61
                 369                            CONSTANT character_b, 62
                 370                            CONSTANT character_c, 63
                 371                            CONSTANT character_d, 64
                 372                            CONSTANT character_e, 65
                 373                            CONSTANT character_f, 66
                 374                            CONSTANT character_g, 67
                 375                            CONSTANT character_h, 68
                 376                            CONSTANT character_i, 69
                 377                            CONSTANT character_j, 6A
E: identifier cannot start with a digit: `6A'.
E: unexpected end of line.
                 378                            CONSTANT character_k, 6B
E: identifier cannot start with a digit: `6B'.
E: unexpected end of line.
                 379                            CONSTANT character_l, 6C
E: identifier cannot start with a digit: `6C'.
E: unexpected end of line.
                 380                            CONSTANT character_m, 6D
                 381                            CONSTANT character_n, 6E
E: identifier cannot start with a digit: `6E'.
E: unexpected end of line.
                 382                            CONSTANT character_o, 6F
E: identifier cannot start with a digit: `6F'.
E: unexpected end of line.
                 383                            CONSTANT character_p, 70
                 384                            CONSTANT character_q, 71
                 385                            CONSTANT character_r, 72
                 386                            CONSTANT character_s, 73
                 387                            CONSTANT character_t, 74
                 388                            CONSTANT character_u, 75
                 389                            CONSTANT character_v, 76
                 390                            CONSTANT character_w, 77
                 391                            CONSTANT character_x, 78
                 392                            CONSTANT character_y, 79
                 393                            CONSTANT character_z, 7A
E: identifier cannot start with a digit: `7A'.
E: unexpected end of line.
                 394                            CONSTANT character_A, 41
                 395                            CONSTANT character_B, 42
                 396                            CONSTANT character_C, 43
                 397                            CONSTANT character_D, 44
                 398                            CONSTANT character_E, 45
                 399                            CONSTANT character_F, 46
                 400                            CONSTANT character_G, 47
                 401                            CONSTANT character_H, 48
                 402                            CONSTANT character_I, 49
                 403                            CONSTANT character_J, 4A
E: identifier cannot start with a digit: `4A'.
E: unexpected end of line.
                 404                            CONSTANT character_K, 4B
E: identifier cannot start with a digit: `4B'.
E: unexpected end of line.
                 405                            CONSTANT character_L, 4C
E: identifier cannot start with a digit: `4C'.
E: unexpected end of line.
                 406                            CONSTANT character_M, 4D
                 407                            CONSTANT character_N, 4E
E: identifier cannot start with a digit: `4E'.
E: unexpected end of line.
                 408                            CONSTANT character_O, 4F
E: identifier cannot start with a digit: `4F'.
E: unexpected end of line.
                 409                            CONSTANT character_P, 50
                 410                            CONSTANT character_Q, 51
                 411                            CONSTANT character_R, 52
                 412                            CONSTANT character_S, 53
                 413                            CONSTANT character_T, 54
                 414                            CONSTANT character_U, 55
                 415                            CONSTANT character_V, 56
                 416                            CONSTANT character_W, 57
                 417                            CONSTANT character_X, 58
                 418                            CONSTANT character_Y, 59
                 419                            CONSTANT character_Z, 5A
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
                 420                            CONSTANT character_0, 30
                 421                            CONSTANT character_1, 31
                 422                            CONSTANT character_2, 32
                 423                            CONSTANT character_3, 33
                 424                            CONSTANT character_4, 34
                 425                            CONSTANT character_5, 35
                 426                            CONSTANT character_6, 36
                 427                            CONSTANT character_7, 37
                 428                            CONSTANT character_8, 38
                 429                            CONSTANT character_9, 39
                 430                            CONSTANT character_colon, 3A
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                 431                            CONSTANT character_stop, 2E
E: identifier cannot start with a digit: `2E'.
E: unexpected end of line.
                 432                            CONSTANT character_semi_colon, 3B
E: identifier cannot start with a digit: `3B'.
E: unexpected end of line.
                 433                            CONSTANT character_minus, 2D
                 434                            CONSTANT character_divide, 2F       ;'/'
E: identifier cannot start with a digit: `2F'.
E: unexpected end of line.
                 435                            CONSTANT character_plus, 2B
E: identifier cannot start with a digit: `2B'.
E: unexpected end of line.
                 436                            CONSTANT character_comma, 2C
E: identifier cannot start with a digit: `2C'.
E: unexpected end of line.
                 437                            CONSTANT character_less_than, 3C
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
                 438                            CONSTANT character_greater_than, 3E
E: identifier cannot start with a digit: `3E'.
E: unexpected end of line.
                 439                            CONSTANT character_equals, 3D
                 440                            CONSTANT character_space, 20
                 441                            CONSTANT character_CR, 0D           ;carriage return
                 442                            CONSTANT character_question, 3F     ;'?'
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
                 443                            CONSTANT character_dollar, 24
                 444                            CONSTANT character_exclaim, 21      ;'!'
                 445                            CONSTANT character_BS, 08           ;Back Space command character
                 446                            ;
                 447                            ;
                 448                            ;
                 449                            ;
                 450                            ;
                 451                            ;**************************************************************************************
                 452                            ;Initialise the system
                 453                            ;**************************************************************************************
                 454                            ;
                 455                cold_start: CALL LCD_reset                      ;initialise LCD display
                 456                            ;
                 457                            ;Write 'Frequency Generator' to LCD display and display for 4 seconds
                 458                            ;
                 459                            LOAD s5, 10                         ;Line 1 position 0
                 460                            CALL LCD_cursor
                 461                            CALL disp_Frequency
                 462                            LOAD s5, 22                         ;Line 2 position 2
                 463                            CALL LCD_cursor
                 464                            CALL disp_Generator
                 465                            CALL delay_1s                       ;wait 4 seconds
                 466                            CALL delay_1s
                 467                            CALL delay_1s
                 468                            CALL delay_1s
                 469                            CALL LCD_clear                      ;clear screen
                 470                            ;
                 471                            ;
                 472                            ;Initial frequency of 100MHz
                 473                            ;
                 474                            LOAD s0, 00
                 475                            LOAD s1, 01
                 476                            STORE s0, BCD_digit0
                 477                            STORE s0, BCD_digit1
                 478                            STORE s0, BCD_digit2
                 479                            STORE s0, BCD_digit3
                 480                            STORE s0, BCD_digit4
                 481                            STORE s0, BCD_digit5
                 482                            STORE s0, BCD_digit6
                 483                            STORE s0, BCD_digit7
                 484                            STORE s1, BCD_digit8
                 485                            ;
                 486                            LOAD s0, 04                         ;Start position for editing frequency is 1MHz digit
                 487                            STORE s0, cursor_position
                 488                            LOAD s0, BCD_digit6
                 489                            STORE s0, edit_digit_pointer
                 490                            ;
                 491                            ;
                 492                            ENABLE INTERRUPT                    ;interrupts are used to detect rotary controller
                 493                            CALL delay_1ms
                 494                            LOAD s0, 00                         ;clear the status of any spurious rotary events
                 495                            STORE s0, rotary_status             ;   as a result of system turning on.
                 496                            ;
                 497                            ;**************************************************************************************
                 498                            ; Main program
                 499                            ;**************************************************************************************
                 500                            ;
                 501                            ; The main program is centred on the task of editing the frequency. It waits until the
                 502                            ; rotary control is used and then makes the appropriate changes. If the actual digit
                 503                            ; digit value is changed then the calculation to drive the DDS is performed each time.
                 504                            ;
                 505                            ; The start state is that of allowing the edit cursor position to be moved. Rotary
                 506                            ; inputs are detected by the interrupt service routine and set a flag bit which the
                 507                            ; main program then uses to adjust the cursor position and pointer to the corresponding
                 508                            ; BCD digit in memory.
                 509                            ;
                 510                            ; A press of the rotary control is detected by polling and used to change to the digit
                 511                            ; editing mode.
                 512                            ;
                 513                            ;
                 514                 move_mode: CALL compute_DDS_words              ;compute DDS control values
                 515                            CALL display_freq                   ;refresh display with cursor position shown
                 516                            LOAD s0, LED0                       ;indicate move mode on LEDs
                 517                            OUTPUT s0, LED_port
                 518                 move_wait: INPUT s0, rotary_port               ;read rotary encoder
                 519                            TEST s0, rotary_press               ;test for press of button which changes mode
                 520                            JUMP NZ, edit_mode
                 521                            FETCH s0, rotary_status             ;check for any rotation of rotary control
                 522                            TEST s0, rotary_event
                 523                            JUMP Z, move_wait
                 524                            ;
                 525                            AND s0, 7F                          ;clear flag now that action it is being processed
E: identifier cannot start with a digit: `7F'.
E: unexpected end of line.
                 526                            STORE s0, rotary_status
                 527                            FETCH sA, cursor_position           ;read current position
                 528                            FETCH sB, edit_digit_pointer
                 529                            TEST s0, rotary_left                ;determine direction to move cursor
                 530                            JUMP Z, move_right
                 531                            ;
                 532                 move_left: COMPARE sB, BCD_digit8              ;can not move left of 100MHz digit
                 533                            JUMP Z, move_mode
                 534                            ADD sB, 01                          ;move to next higher BCD digit
                 535                            SUB sA, 01                          ;move cursor to match digit to be edited
                 536                            COMPARE sA, 09                      ;must skip over space separator
                 537                            JUMP Z, skip_left
                 538                            COMPARE sA, 05                      ;must skip over decimal point
                 539                            JUMP NZ, edit_point_update
                 540                 skip_left: SUB sA, 01                          ;move cursor further left
                 541                            JUMP edit_point_update
                 542                            ;
                 543                move_right: COMPARE sB, BCD_digit0              ;can not move right of 1Hz digit
                 544                            JUMP Z, move_mode
                 545                            SUB sB, 01                          ;move to next lower BCD digit
                 546                            ADD sA, 01                          ;move cursor to match digit to be edited
                 547                            COMPARE sA, 09                      ;must skip over space separator
                 548                            JUMP Z, skip_right
                 549                            COMPARE sA, 05                      ;must skip over decimal point
                 550                            JUMP NZ, edit_point_update
                 551                skip_right: ADD sA, 01                          ;move cursor further right
                 552                            ;
                 553         edit_point_update: STORE sA, cursor_position           ;update edit value in memory
                 554                            STORE sB, edit_digit_pointer
                 555                            JUMP move_mode
                 556                            ;
                 557                            ;
                 558                            ; The edit mode is reached by pressing the rotary control. Since this is a simple switch
                 559                            ; a software de-bounce delay is used to wait for the knob to be released fully before
                 560                            ; entering the digit editing mode fully.
                 561                            ;
                 562                            ; In this mode rotations of the detected by the interrupt service routine are used to
                 563                            ; increment or decrement the digit value at the cursor position with carry/borrow to
                 564                            ; the left.
                 565                            ;
                 566                            ; A new press of the rotary control is detected by polling and used to change back to the
                 567                            ; cursor moving mode.
                 568                            ;
                 569                            ;
                 570                 edit_mode: CALL wait_switch_release            ;wait for switch press to end
                 571              edit_display: CALL compute_DDS_words              ;compute DDS control values
                 572                            CALL display_freq                   ;refresh display with new values
                 573                            LOAD s0, LED1                       ;indicate edit mode on LEDs
                 574                            OUTPUT s0, LED_port
                 575                 edit_wait: INPUT s0, rotary_port               ;read rotary encoder
                 576                            TEST s0, rotary_press               ;test for press of button which changes mode
                 577                            JUMP NZ, end_edit_mode
                 578                            FETCH s0, rotary_status             ;check for any rotation of rotary control
                 579                            TEST s0, rotary_event
                 580                            JUMP Z, edit_wait
                 581                            ;
                 582                            AND s0, 7F                          ;clear flag now that action it is being processed
E: identifier cannot start with a digit: `7F'.
E: unexpected end of line.
                 583                            STORE s0, rotary_status
                 584                            FETCH sB, edit_digit_pointer        ;read pointer to BCD digit for initial change
                 585                            TEST s0, rotary_left                ;determine direction to increment or decrement
                 586                            JUMP Z, inc_digit
                 587                            ;
                 588                            ; Decrement the value starting at the current position and borrowing from the left.
                 589                            ; However the value needs to bottom out at all 0's from the editing position.
                 590                            ;
                 591                            ;
                 592                 dec_digit: FETCH sA, (sB)                      ;read digit value at pointer position
                 593                            SUB sA, 01                          ;decrement digit
                 594                            COMPARE sA, FF                      ;test for borrow from next digit
                 595                            JUMP Z, dec_borrow
                 596                            STORE sA, (sB)                      ;store decremented digit value
                 597                            JUMP edit_display                   ;decrement task complete
                 598                dec_borrow: LOAD sA, 09                         ;current digit rolls over to nine
                 599                            STORE sA, (sB)                      ;store '9' digit value
                 600                            COMPARE sB, BCD_digit8              ;check if working on 100MHz digit
                 601                            JUMP Z, set_min_value
                 602                            ADD sB, 01                          ;increment pointer to next most significant digit
                 603                            JUMP dec_digit                      ;decrement next digit up.
                 604                            ;
                 605             set_min_value: FETCH sB, edit_digit_pointer        ;Must fill digits from insert to MS-Digit with 000...
                 606                            LOAD sA, 00
                 607                  fill_min: STORE sA, (sB)
                 608                            COMPARE sB, BCD_digit8              ;check if filled to 100MHz digit
                 609                            JUMP Z, edit_display
                 610                            ADD sB, 01                          ;fill next higher digit
                 611                            JUMP fill_min
                 612                            ;
                 613                            ; Increment the value starting at the current position and carrying to the left.
                 614                            ; However the value needs to saturate to all 9's from the editing position.
                 615                            ;
                 616                 inc_digit: FETCH sA, (sB)                      ;read digit value at pointer position
                 617                            ADD sA, 01                          ;increment digit
                 618                            COMPARE sA, 0A                      ;test for carry to next digit
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
                 619                            JUMP Z, inc_carry
                 620                            STORE sA, (sB)                      ;store incremented digit value
                 621                            JUMP edit_display                   ;increment task complete
                 622                 inc_carry: LOAD sA, 00                         ;current digit rolls over to zero
                 623                            STORE sA, (sB)                      ;store zero digit value
                 624                            COMPARE sB, BCD_digit8              ;check if working on 100MHz digit
                 625                            JUMP Z, set_max_value
                 626                            ADD sB, 01                          ;increment pointer to next most significant digit
                 627                            JUMP inc_digit                      ;increment next digit up.
                 628                            ;
                 629             set_max_value: FETCH sB, edit_digit_pointer        ;Must fill digits from insert to MS-Digit with 999...
                 630                            LOAD sA, 09
                 631                  fill_max: STORE sA, (sB)
                 632                            COMPARE sB, BCD_digit8              ;check if filled to 100MHz digit
                 633                            JUMP Z, edit_display
                 634                            ADD sB, 01                          ;fill next higher digit
                 635                            JUMP fill_max
                 636                            ;
                 637             end_edit_mode: CALL wait_switch_release            ;wait for end of switch press
                 638                            JUMP move_mode                      ;then go to move cursor mode
                 639                            ;
                 640                            ;
                 641                            ; Routine to poll the press switch with de-bounce delay and wait for it to be
                 642                            ; released. Any rotation inputs detected by the interrupt
                 643                            ; service routine are cleared before returning.
                 644                            ;
                 645       wait_switch_release: CALL delay_20ms                     ;delay to aid switch de-bounce
                 646                            INPUT s0, rotary_port               ;read rotary encoder
                 647                            TEST s0, rotary_press               ;test if button is still being pressed
                 648                            JUMP NZ, wait_switch_release
                 649                            LOAD s0, 00                         ;clear flag indicating any rotary events
                 650                            STORE s0, rotary_status
                 651                            RETURN
                 652                            ;
                 653                            ;**************************************************************************************
                 654                            ; Compute DDS control words from currently display frequency value
                 655                            ;**************************************************************************************
                 656                            ;
                 657                            ; This routine reads the current BCD value and converts it into a 32-bit binary
                 658                            ; integer. It then multiplies it by a 48-bit scaling factor (see notes in the
                 659                            ; constants section above) to form a full precision 80-bit product.
                 660                            ;
                 661                            ; From this product the 32-bit DDS control word must be extracted. For frequencies of
                 662                            ; 50MHz or above the DDS control word is formed by shifting the product left by 2 places
                 663                            ; (multiply by 4) and then keeping only the most significant 32-bits (4 bytes).
                 664                            ;
                 665                            ; Also for frequencies of 50MHz and above, there is no additional division performed
                 666                            ; after the DCM which multiplies frequency and reduces the jitter. Therefore the DDS_scaling
                 667                            ; word will be set to zero and the output of the DCM will divide by 2.
                 668                            ;
                 669                            ;   Freq     DDS control word    DDS Scaling      Synthesized Frequency
                 670                            ;                                                  of Phase Accumulator
                 671                            ;
                 672                            ;  50MHz      08000000              00                   6.25MHz
                 673                            ; 100MHz      10000000              00                  12.50MHz
                 674                            ;
                 675                            ; You will notice that for frequencies of 50MHz and above, the upper byte of the
                 676                            ; DDS control word is 08 hex or greater. In other words, bit3 and/or bit4 of that byte
                 677                            ; are High (bits 27 and/or 28 of the full 32-bit word). This is the indication that
                 678                            ; the control words are complete.
                 679                            ;
                 680                            ; For frequencies below 50MHz an additional process is required. The reason for this
                 681                            ; becomes clear if we think about the lowest frequency of 1Hz. In that case the 80-bit
                 682                            ; product is the same as the 48-bit scaling constant 00000000ABCC77118462. Once this
                 683                            ; has been multiplied by 4 (shifted left 2 places) it becomes 00000002AF31DC461188 and the
                 684                            ; most significant 32-bits are only 00000002 hex. If we put this back into the basic
                 685                            ; equations for the phase accumulator we find that the output frequency of the phase
                 686                            ; accumulator would be
                 687                            ;
                 688                            ;    Fout = M x clk x N / (2^p)
                 689                            ;
                 690                            ;         = 8 x 200MHz x 2 / (2^32) = 0.745 Hz
                 691                            ;
                 692                            ; There are two important observations we can make. Firstly we have lost accuracy because
                 693                            ; the resolution of the DDS control word has become too granular at low amplitudes.
                 694                            ; Secondly this would never even work because the frequency synthesized by the phase
                 695                            ; accumulator would be 0.745/8 = 0.0931 Hz which is seriously slow and a way below the
                 696                            ; frequency at which the DCM can even work.
                 697                            ;
                 698                            ; The solution to both of these issues is to ensure that the DDS control word is always
                 699                            ; formed to be in the range that would result in an output of 50MHz or above. In other
                 700                            ; words to keep the phase accumulator output in the range 6.25MHz to 12.5MHz such that
                 701                            ; the DCM is able to work and only has to deal with one octave of input variation. This
                 702                            ; can be achieved by shifting the 80-bit product left more times until bits 27 and 28
                 703                            ; of the most significant 32-bits are not zero.
                 704                            ;
                 705                            ; For each shift left the synthesized frequency is being doubled and therefore the final
                 706                            ; output from the DCM must be divided by a further factor of 2. This is achieved using
                 707                            ; a multiplexer which is guided to select the appropriate output from a simple binary
                 708                            ; counter.
                 709                            ;
                 710                            ; Returning to the example of 1Hz, the 80-bit product will be shifted left by the default
                 711                            ; 2 places (multiplied by 4), but will then need to be shifted left by a further 26 places
                 712                            ; which is like multiplying by 67108864 (04000000 hex).
                 713                            ;
                 714                            ;                            00000000ABCC77118462
                 715                            ;                          x                    4
                 716                            ;                            --------------------
                 717                            ;                            00000002AF31DC461188
                 718                            ;
                 719                            ;
                 720                            ;                          x             04000000
                 721                            ;                            --------------------
                 722                            ;                            0ABCC771184620000000
                 723                            ;
                 724                            ; So now the DDS control word is 0ABCC771 (180143985 decimal)and the frequency synthesized
                 725                            ; by the phase accumulator will be....
                 726                            ;
                 727                            ;   Fpa = clk x N / (2^p) = 200MHz x 180143985 / (2^32) = 8388608Hz
                 728                            ;
                 729                            ; The DCM will multiply this by a factor of 16 to give 134217728Hz and this will then
                 730                            ; be divided by the counter of which the 26th bit selected (26 decimal = 1A hex).
                 731                            ;
                 732                            ;   Fout = Fpa x 16 / (2^(D+1)) =  8388608Hz x 16 / (2^(26+1)) = 0.99999999947 Hz
                 733                            ;
                 734                            ;     'D' is the DDS Scaling factor
                 735                            ;         Note that bit0 of a counter is a clock division by 2 and hence the 'D+1'
                 736                            ;
                 737                            ; Clearly this implementation style has provided much greater accuracy and enables
                 738                            ; the DCM to work for all desired frequencies.
                 739                            ;
                 740                            ;
                 741                            ;   Freq     DDS control word    DDS Scaling      Synthesized Frequency
                 742                            ;                                                  of Phase Accumulator
                 743                            ;
                 744                            ; 100 MHz      10000000              00                  12.50MHz
                 745                            ;  50 MHz      08000000              00                   6.25MHz
                 746                            ;  25 MHz      08000000              01                   6.25MHz
                 747                            ;  12.5 MHz    08000000              02                   6.25MHz
                 748                            ;
                 749                            ;    1Hz       0ABCC771              1A                   8.388608 MHz
                 750                            ;
                 751                            ;
                 752                            ;
                 753                            ; In order to ensure the DCM is always provided with a frequency in an acceptable
                 754                            ; range, the value of absolute zero is never implemented and instead just a very low
                 755                            ; frequency is produced.
                 756                            ;   6.25MHz x 16 / (2^31+1) = 0.0233 Hz
                 757                            ;       which is 1 cycle every 43 seconds and that is pretty slow  :-)
                 758                            ;
                 759                            ;
                 760                            ;
                 761                            ;
                 762         compute_DDS_words: CALL BCD_to_integer                 ;convert BCD display value to 32-bit value
                 763                            CALL scale_frequency                ;80-bit product of 32-bit frequency x 48-bit scaling value
                 764                            FETCH sA, product9                  ;read the upper part of the 80-bit product into [sA,s9,s8,s7,s6,s5,s4]
                 765                            FETCH s9, product8                  ; The least significant 24-bits of the 80-bit product will never
                 766                            FETCH s8, product7                  ; be used for frequencies above 1Hz.
                 767                            FETCH s7, product6                  ;The final 32-bit DDS control word will be formed in
                 768                            FETCH s6, product5                  ; [sA,s9,s8,s7]
                 769                            FETCH s5, product4
                 770                            FETCH s4, product3
                 771                            CALL shift80_left                   ;multiply DDS control word by 4 to achieve default value
                 772                            CALL shift80_left
                 773                            LOAD sB, 00                         ;default scaling factor is 2 (select counter bit0)
                 774            normalise_loop: TEST sA, 18                         ;Test bits 27 and 28 of 32-bit DDS control word
                 775                            JUMP NZ, store_DDS_words            ;DDS control word is normalised to above 50MHz output
                 776                            CALL shift80_left                   ;multiply DDS control word by 2
                 777                            ADD sB, 01                          ;Divide final value by 2 to compensate
                 778                            COMPARE sB, 1F                      ;Test for maximum division factor
E: identifier cannot start with a digit: `1F'.
E: unexpected end of line.
                 779                            JUMP NZ, normalise_loop
                 780                            LOAD sA, 08                         ;Set for minimum frequency
                 781                            LOAD s9, 00                         ; with phase accumulator set to generate 6.25MHz
                 782                            LOAD s8, 00
                 783                            LOAD s7, 00
                 784           store_DDS_words: STORE s7, DDS_control0              ;store local copy of control word
                 785                            STORE s8, DDS_control1              ;store local copy of control word
                 786                            STORE s9, DDS_control2              ;store local copy of control word
                 787                            STORE sA, DDS_control3              ;store local copy of control word
                 788                            STORE sB, DDS_scaling
                 789                            CALL drive_DDS_words                ;output control words to DDS circuit
                 790                            RETURN
                 791                            ;
                 792              shift80_left: SL0 s4                              ;shift (most of the) 80-bit value in
                 793                            SLA s5                              ;  [sA,s9,s8,s7,s6,s5,s4] left 1 place
                 794                            SLA s6
                 795                            SLA s7
                 796                            SLA s8
                 797                            SLA s9
                 798                            SLA sA
                 799                            RETURN
                 800                            ;
                 801                            ;**************************************************************************************
                 802                            ; Set DDS control words
                 803                            ;**************************************************************************************
                 804                            ;
                 805                            ; Because multiple ports are used, the idea is to update all of them in
                 806                            ; rapid succession to avoid too much disturbance in the frequency synthesis.
                 807                            ;
                 808                            ; dds_control_word should be supplied in register set [sA,s9,s8,s7]
                 809                            ; dds_scaling_word should be supplied in register s6.
                 810                            ;
                 811           drive_DDS_words: FETCH s7, DDS_control0
                 812                            FETCH s8, DDS_control1
                 813                            FETCH s9, DDS_control2
                 814                            FETCH sA, DDS_control3
                 815                            FETCH s6, DDS_scaling
                 816                            OUTPUT s7, DDS_control0_port
                 817                            OUTPUT s8, DDS_control1_port
                 818                            OUTPUT s9, DDS_control2_port
                 819                            OUTPUT sA, DDS_control3_port
                 820                            OUTPUT s6, DDS_scaling_port
                 821                            RETURN
                 822                            ;
                 823                            ;
                 824                            ;**************************************************************************************
                 825                            ; Display frequency on top line of the LCD and DDS data on the lower line
                 826                            ;**************************************************************************************
                 827                            ;
                 828                            ; The BCD value should be stored in scratch pad memory in 9 ascending locations
                 829                            ; called BCD_digit0 to BCD_digit8.
                 830                            ;
                 831                            ; The value is displayed in the format      xxx.xxx xxxMHz
                 832                            ;
                 833                            ; However, the most significant 2 digits will be blanked if zero.
                 834                            ;
                 835                            ; registers used s0,s1,s2,s3,s4,s5,s6,s7
                 836                            ;
                 837                            ;
                 838              display_freq: CALL display_DDS_data               ;display DDS information on lower line
                 839                            LOAD s5, 12                         ;Line 1 position 2
                 840                            CALL LCD_cursor
                 841                            FETCH s5, BCD_digit8                ;read 100MHz digit
                 842                            COMPARE s5, 00                      ;test for blanking
                 843                            JUMP Z, blank_100M_digit
                 844                            CALL display_digit                  ;display non zero digit
                 845                            FETCH s5, BCD_digit7                ;read 10MHz digit and display
                 846                            CALL display_digit
                 847                            JUMP disp_1M_digit
                 848                            ;
                 849          blank_100M_digit: CALL display_space                  ;blank 100MHz digit
                 850                            FETCH s5, BCD_digit7                ;read 10MHz digit
                 851                            COMPARE s5, 00                      ;test for blanking
                 852                            JUMP Z, blank_10M_digit
                 853                            CALL display_digit                  ;display non zero digit
                 854                            JUMP disp_1M_digit
                 855                            ;
                 856           blank_10M_digit: CALL display_space                  ;blank 10MHz digit
                 857                            ;
                 858             disp_1M_digit: FETCH s5, BCD_digit6                ;read 1MHz digit and display
                 859                            CALL display_digit
                 860                            LOAD s5, character_stop             ;display decimal point
                 861                            CALL LCD_write_data
                 862                            ;
                 863                            LOAD s2, BCD_digit5                 ;set pointer to 100KHz digit
                 864                            CALL display_3_digits
                 865                            CALL display_space
                 866                            LOAD s2, BCD_digit2                 ;set pointer to 100Hz digit
                 867                            CALL display_3_digits
                 868                            LOAD s5, character_M                ;display 'MHz'
                 869                            CALL LCD_write_data
                 870                            LOAD s5, character_H
                 871                            CALL LCD_write_data
                 872                            LOAD s5, character_z
                 873                            CALL LCD_write_data
                 874                            ;
                 875                            FETCH s5, cursor_position           ;reposition edit cursor on display
                 876                            ADD s5, 10                          ;on line 1
                 877                            CALL LCD_cursor
                 878                            RETURN
                 879                            ;
                 880          display_3_digits: LOAD s3, 03                         ;3 digits to display
                 881               3digit_loop: FETCH s5, (s2)
E: identifier cannot start with a digit: `3digit_loop'.
E: unexpected :.
000 20004        882                            CALL display_digit
001 18110        883                            SUB s2, 01                          ;decrement digit pointer
E: symbol not defined: `S2'.
002 18110        884                            SUB s3, 01                          ;count digits displayed
E: symbol not defined: `S3'.
                 885                            JUMP NZ, 3digit_loop
E: identifier cannot start with a digit: `3digit_loop'.
E: unexpected end of line.
003 25000        886                            RETURN
                 887                            ;
004 101E0        888             display_digit: ADD s5, 30                          ;convert BCD to ASCII character
E: symbol not defined: `S5'.
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
005 2010D        889                            CALL LCD_write_data
006 25000        890                            RETURN
                 891                            ;
007 00110        892             display_space: LOAD s5, character_space
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_SPACE'.
008 2010D        893                            CALL LCD_write_data
009 25000        894                            RETURN
                 895                            ;
                 896                            ;
                 897                            ;**************************************************************************************
                 898                            ; Convert 9 digit BCD frequency into 32-bit binary integer
                 899                            ;**************************************************************************************
                 900                            ;
                 901                            ;Both values are stored in scratch pad memory
                 902                            ;    BCD values in ascending locations BCD_digit0 to BCD_digit8
                 903                            ;    Binary frequency in ascending locations frequency0 to frequency3
                 904                            ;
                 905                            ;Each digit is read in turn and its value is determined by repeated
                 906                            ;decrement until reaching zero. Each decrement causes a value to be added
                 907                            ;to the memory locations forming the frequency value as binary integer.
                 908                            ;The process requires approximately 1600 instructions to convert the highest
                 909                            ;value 999,999,999 which is approximately 64us at 50MHz clock rate.
                 910                            ;
                 911                            ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sA,sB
                 912                            ;
00A 00190        913            BCD_to_integer: LOAD s2, 09                         ;9 digits to convert
E: symbol not defined: `S2'.
00B 00100        914                            LOAD s0, 00                         ;clear frequency value ready to accumulate result
E: symbol not defined: `S0'.
00C 2F101        915                            STORE s0, frequency0
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY0'.
00D 2F101        916                            STORE s0, frequency1
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY1'.
00E 2F101        917                            STORE s0, frequency2
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY2'.
00F 2F101        918                            STORE s0, frequency3
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY3'.
010 00100        919                            LOAD sB, 00                         ;initialise BCD digit weighting [sB,sA,s9,s8] to 1
E: symbol not defined: `SB'.
011 00100        920                            LOAD sA, 00
E: symbol not defined: `SA'.
012 00100        921                            LOAD s9, 00
E: symbol not defined: `S9'.
013 00110        922                            LOAD s8, 01
E: symbol not defined: `S8'.
014 00110        923                            LOAD s3, BCD_digit0                 ;locate LS-digit
E: symbol not defined: `S3'.
E: symbol not defined: `BCD_DIGIT0'.
015 0B101        924     next_BCD_to_int_digit: FETCH s1, (s3)
E: symbol not defined: `S1'.
E: symbol not defined: `S3'.
016 1C100        925         BCD_digit_convert: COMPARE s1, 00                      ;test for zero
E: symbol not defined: `S1'.
017 32026        926                            JUMP Z, next_digit_value
018 0B101        927                            FETCH s0, frequency0                ;add 32-bit digit weighting to memory value
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY0'.
019 10110        928                            ADD s0, s8
E: symbol not defined: `S0'.
E: symbol not defined: `S8'.
01A 2F101        929                            STORE s0, frequency0
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY0'.
01B 0B101        930                            FETCH s0, frequency1
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY1'.
01C 12110        931                            ADDCY s0, s9
E: symbol not defined: `S0'.
E: symbol not defined: `S9'.
01D 2F101        932                            STORE s0, frequency1
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY1'.
01E 0B101        933                            FETCH s0, frequency2
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY2'.
01F 12110        934                            ADDCY s0, sA
E: symbol not defined: `S0'.
E: symbol not defined: `SA'.
020 2F101        935                            STORE s0, frequency2
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY2'.
021 0B101        936                            FETCH s0, frequency3
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY3'.
022 12110        937                            ADDCY s0, sB
E: symbol not defined: `S0'.
E: symbol not defined: `SB'.
023 2F101        938                            STORE s0, frequency3
E: symbol not defined: `S0'.
E: symbol not defined: `FREQUENCY3'.
024 18110        939                            SUB s1, 01                          ;decrement digit value
E: symbol not defined: `S1'.
025 22016        940                            JUMP BCD_digit_convert
                 941                            ;Increase weighting by 10x
026 00110        942          next_digit_value: LOAD s7, sB                         ;copy existing weighting
E: symbol not defined: `S7'.
E: symbol not defined: `SB'.
027 00110        943                            LOAD s6, sA
E: symbol not defined: `S6'.
E: symbol not defined: `SA'.
028 00110        944                            LOAD s5, s9
E: symbol not defined: `S5'.
E: symbol not defined: `S9'.
029 00110        945                            LOAD s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
02A 14106        946                            SL0 s8                              ;multiply weight by 4x (shift left 2 places)
E: symbol not defined: `S8'.
02B 14100        947                            SLA s9
E: symbol not defined: `S9'.
02C 14100        948                            SLA sA
E: symbol not defined: `SA'.
02D 14100        949                            SLA sB
E: symbol not defined: `SB'.
02E 14106        950                            SL0 s8
E: symbol not defined: `S8'.
02F 14100        951                            SLA s9
E: symbol not defined: `S9'.
030 14100        952                            SLA sA
E: symbol not defined: `SA'.
031 14100        953                            SLA sB
E: symbol not defined: `SB'.
032 10110        954                            ADD s8, s4                          ;add previous weight to form 5x multiplication
E: symbol not defined: `S8'.
E: symbol not defined: `S4'.
033 12110        955                            ADDCY s9, s5
E: symbol not defined: `S9'.
E: symbol not defined: `S5'.
034 12110        956                            ADDCY sA, s6
E: symbol not defined: `SA'.
E: symbol not defined: `S6'.
035 12110        957                            ADDCY sB, s7
E: symbol not defined: `SB'.
E: symbol not defined: `S7'.
036 14106        958                            SL0 s8                              ;multiply weight by 2x (shift left 1 places)
E: symbol not defined: `S8'.
037 14100        959                            SLA s9
E: symbol not defined: `S9'.
038 14100        960                            SLA sA
E: symbol not defined: `SA'.
039 14100        961                            SLA sB                              ;weight value is now 10x previous value
E: symbol not defined: `SB'.
03A 10110        962                            ADD s3, 01                          ;move to next digit for conversion
E: symbol not defined: `S3'.
03B 18110        963                            SUB s2, 01
E: symbol not defined: `S2'.
03C 36015        964                            JUMP NZ, next_BCD_to_int_digit
03D 25000        965                            RETURN
                 966                            ;
                 967                            ;
                 968                            ;**************************************************************************************
                 969                            ; 32-bit x 48-bit multiply to scale the integer frequency
                 970                            ;**************************************************************************************
                 971                            ;
                 972                            ;Multiply the 32-bit frequency binary integer by the 48-bit scaling factor
                 973                            ;to form a full precision 80-bit product.
                 974                            ;
                 975                            ;The frequency binary integer is stored in scratch pad memory using ascending
                 976                            ;locations frequency0 to frequency3
                 977                            ;
                 978                            ;The product will be stored in scratch pad memory using ascending
                 979                            ;locations product0 to product9
                 980                            ;
                 981                            ;The scaling factor is provided directly as constants
                 982                            ; scale_constant0 to scale_constant5
                 983                            ;
                 984                            ;The multiplication is performed as a 32-bit 'shift and add' process in which the
                 985                            ;integer frequency is examined LSB first using a register set [sB,sA,s9,s8] and
                 986                            ;a scaling accumulator is formed directly in the 'product' memory locations.
                 987                            ;
                 988                            ;The process requires up to 1772 instructions which is 3544 clock cycle or
                 989                            ;approximately 71us at 50MHz clock rate.
                 990                            ;
                 991                            ;Registers used s0,s1,s8,s9,sA,sB (s1,s8,s9,sA,sB clear on return)
                 992                            ;
03E 00100        993           scale_frequency: LOAD s0, 00                         ;clear accumulator section of 'product'
E: symbol not defined: `S0'.
03F 2F101        994                            STORE s0, product9
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT9'.
040 2F101        995                            STORE s0, product8
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT8'.
041 2F101        996                            STORE s0, product7
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT7'.
042 2F101        997                            STORE s0, product6
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT6'.
043 2F101        998                            STORE s0, product5
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT5'.
044 2F101        999                            STORE s0, product4
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT4'.
045 0B101       1000                            FETCH sB, frequency3                ;read frequency integer value
E: symbol not defined: `SB'.
E: symbol not defined: `FREQUENCY3'.
046 0B101       1001                            FETCH sA, frequency2
E: symbol not defined: `SA'.
E: symbol not defined: `FREQUENCY2'.
047 0B101       1002                            FETCH s9, frequency1
E: symbol not defined: `S9'.
E: symbol not defined: `FREQUENCY1'.
048 0B101       1003                            FETCH s8, frequency0
E: symbol not defined: `S8'.
E: symbol not defined: `FREQUENCY0'.
049 00140       1004                            LOAD s1, 20                         ;32-bit multiply
E: symbol not defined: `S1'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
04A 1410E       1005            scale_mult_bit: SR0 sB                              ;shift right frequency integer
E: symbol not defined: `SB'.
04B 14108       1006                            SRA sA
E: symbol not defined: `SA'.
04C 14108       1007                            SRA s9
E: symbol not defined: `S9'.
04D 14108       1008                            SRA s8
E: symbol not defined: `S8'.
04E 3E061       1009                            JUMP NC, product_shift              ;no add if bit is zero (note carry is zero)
04F 0B101       1010                            FETCH s0, product4                  ;addition of scaling factor to most significant bits of product
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT4'.
050 10110       1011                            ADD s0, scale_constant0
E: symbol not defined: `S0'.
E: symbol not defined: `SCALE_CONSTANT0'.
051 2F101       1012                            STORE s0, product4
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT4'.
052 0B101       1013                            FETCH s0, product5
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT5'.
053 12110       1014                            ADDCY s0, scale_constant1
E: symbol not defined: `S0'.
E: symbol not defined: `SCALE_CONSTANT1'.
054 2F101       1015                            STORE s0, product5
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT5'.
055 0B101       1016                            FETCH s0, product6
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT6'.
056 12110       1017                            ADDCY s0, scale_constant2
E: symbol not defined: `S0'.
E: symbol not defined: `SCALE_CONSTANT2'.
057 2F101       1018                            STORE s0, product6
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT6'.
058 0B101       1019                            FETCH s0, product7
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT7'.
059 12110       1020                            ADDCY s0, scale_constant3
E: symbol not defined: `S0'.
E: symbol not defined: `SCALE_CONSTANT3'.
05A 2F101       1021                            STORE s0, product7
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT7'.
05B 0B101       1022                            FETCH s0, product8
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT8'.
05C 12110       1023                            ADDCY s0, scale_constant4
E: symbol not defined: `S0'.
E: symbol not defined: `SCALE_CONSTANT4'.
05D 2F101       1024                            STORE s0, product8
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT8'.
05E 0B101       1025                            FETCH s0, product9
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT9'.
05F 12110       1026                            ADDCY s0, scale_constant5
E: symbol not defined: `S0'.
E: symbol not defined: `SCALE_CONSTANT5'.
060 2F101       1027                            STORE s0, product9                  ;carry holds any overflow of addition
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT9'.
061 0B101       1028             product_shift: FETCH s0, product9                  ;Divide product by 2 (shift right by 1)
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT9'.
062 14108       1029                            SRA s0                              ;overflow of addition included in shift
E: symbol not defined: `S0'.
063 2F101       1030                            STORE s0, product9
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT9'.
064 0B101       1031                            FETCH s0, product8
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT8'.
065 14108       1032                            SRA s0
E: symbol not defined: `S0'.
066 2F101       1033                            STORE s0, product8
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT8'.
067 0B101       1034                            FETCH s0, product7
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT7'.
068 14108       1035                            SRA s0
E: symbol not defined: `S0'.
069 2F101       1036                            STORE s0, product7
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT7'.
06A 0B101       1037                            FETCH s0, product6
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT6'.
06B 14108       1038                            SRA s0
E: symbol not defined: `S0'.
06C 2F101       1039                            STORE s0, product6
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT6'.
06D 0B101       1040                            FETCH s0, product5
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT5'.
06E 14108       1041                            SRA s0
E: symbol not defined: `S0'.
06F 2F101       1042                            STORE s0, product5
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT5'.
070 0B101       1043                            FETCH s0, product4
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT4'.
071 14108       1044                            SRA s0
E: symbol not defined: `S0'.
072 2F101       1045                            STORE s0, product4
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT4'.
073 0B101       1046                            FETCH s0, product3
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT3'.
074 14108       1047                            SRA s0
E: symbol not defined: `S0'.
075 2F101       1048                            STORE s0, product3
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT3'.
076 0B101       1049                            FETCH s0, product2
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT2'.
077 14108       1050                            SRA s0
E: symbol not defined: `S0'.
078 2F101       1051                            STORE s0, product2
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT2'.
079 0B101       1052                            FETCH s0, product1
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT1'.
07A 14108       1053                            SRA s0
E: symbol not defined: `S0'.
07B 2F101       1054                            STORE s0, product1
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT1'.
07C 0B101       1055                            FETCH s0, product0
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT0'.
07D 14108       1056                            SRA s0
E: symbol not defined: `S0'.
07E 2F101       1057                            STORE s0, product0
E: symbol not defined: `S0'.
E: symbol not defined: `PRODUCT0'.
07F 18110       1058                            SUB s1, 01                          ;move to next bit
E: symbol not defined: `S1'.
080 3604A       1059                            JUMP NZ, scale_mult_bit
081 25000       1060                            RETURN
                1061                            ;
                1062                            ;**************************************************************************************
                1063                            ; Display DDS control information on the lower line of the LCD display.
                1064                            ;**************************************************************************************
                1065                            ;
                1066                            ;Display the 32-bit DDS control word and 8-bit DDS scaling word.
                1067                            ;
082 00140       1068          display_DDS_data: LOAD s5, 20                         ;Line 2 position 0
E: symbol not defined: `S5'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
083 2014A       1069                            CALL LCD_cursor
084 00110       1070                            LOAD s5, character_N
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_N'.
085 2010D       1071                            CALL LCD_write_data
086 00110       1072                            LOAD s5, character_equals
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_EQUALS'.
087 2010D       1073                            CALL LCD_write_data
088 00110       1074                            LOAD s7, DDS_control3               ;pointer to most significant byte in memory
E: symbol not defined: `S7'.
E: symbol not defined: `DDS_CONTROL3'.
089 200A6       1075                            CALL display_hex_32_bit
08A 20007       1076                            CALL display_space
08B 00110       1077                            LOAD s5, character_D
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_D'.
08C 2010D       1078                            CALL LCD_write_data
08D 00110       1079                            LOAD s5, character_equals
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_EQUALS'.
08E 2010D       1080                            CALL LCD_write_data
08F 0B101       1081                            FETCH s0, DDS_scaling
E: symbol not defined: `S0'.
E: symbol not defined: `DDS_SCALING'.
090 200A0       1082                            CALL display_hex_byte
091 25000       1083                            RETURN
                1084                            ;
                1085                            ;**************************************************************************************
                1086                            ; Routines to display hexadecimal values on LCD display
                1087                            ;**************************************************************************************
                1088                            ;
                1089                            ;
                1090                            ; Convert hexadecimal value provided in register s0 into ASCII characters
                1091                            ;
                1092                            ; The value provided must can be any value in the range 00 to FF and will be converted into
                1093                            ; two ASCII characters.
                1094                            ;     The upper nibble will be represented by an ASCII character returned in register s3.
                1095                            ;     The lower nibble will be represented by an ASCII character returned in register s2.
                1096                            ;
                1097                            ; The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1098                            ; added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1099                            ; hexadecimal requiring a further addition of 07 to the 30 already added.
                1100                            ;
                1101                            ; Registers used s0, s2 and s3.
                1102                            ;
092 00110       1103         hex_byte_to_ASCII: LOAD s2, s0                         ;remember value supplied
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
093 1410E       1104                            SR0 s0                              ;isolate upper nibble
E: symbol not defined: `S0'.
094 1410E       1105                            SR0 s0
E: symbol not defined: `S0'.
095 1410E       1106                            SR0 s0
E: symbol not defined: `S0'.
096 1410E       1107                            SR0 s0
E: symbol not defined: `S0'.
097 20001       1108                            CALL hex_to_ASCII                   ;convert
E: symbol not defined: `HEX_TO_ASCII'.
098 00110       1109                            LOAD s3, s0                         ;upper nibble value in s3
E: symbol not defined: `S3'.
E: symbol not defined: `S0'.
099 00110       1110                            LOAD s0, s2                         ;restore complete value
E: symbol not defined: `S0'.
E: symbol not defined: `S2'.
                1111                            AND s0, 0F                          ;isolate lower nibble
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
09A 20001       1112                            CALL hex_to_ASCII                   ;convert
E: symbol not defined: `HEX_TO_ASCII'.
09B 00110       1113                            LOAD s2, s0                         ;lower nibble value in s2
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
09C 25000       1114                            RETURN
                1115                            ;
                1116                            ; Convert hexadecimal value provided in register s0 into ASCII character
                1117                            ;
                1118                            ;Register used s0
                1119                            ;
                1120              hex_to_ASCII: SUB s0, 0A                          ;test if value is in range 0 to 9
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
09D 3A001       1121                            JUMP C, number_char
E: symbol not defined: `NUMBER_CHAR'.
09E 10170       1122                            ADD s0, 07                          ;ASCII char A to F in range 41 to 46
E: symbol not defined: `S0'.
                1123               number_char: ADD s0, 3A                          ;ASCII char 0 to 9 in range 30 to 40
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
09F 25000       1124                            RETURN
                1125                            ;
                1126                            ;
                1127                            ; Display the two character HEX value of the register contents 's0' on the LCD
                1128                            ; at the current cursor position.
                1129                            ;
                1130                            ; Registers used s0, s1, s2, s3, s4, s5
                1131                            ;
0A0 20092       1132          display_hex_byte: CALL hex_byte_to_ASCII
0A1 00110       1133                            LOAD s5, s3
E: symbol not defined: `S5'.
E: symbol not defined: `S3'.
0A2 2010D       1134                            CALL LCD_write_data
0A3 00110       1135                            LOAD s5, s2
E: symbol not defined: `S5'.
E: symbol not defined: `S2'.
0A4 2010D       1136                            CALL LCD_write_data
0A5 25000       1137                            RETURN
                1138                            ;
                1139                            ;
                1140                            ;
                1141                            ; Display the 32-bit value stored in 4 ascending memory locations as an 8 character
                1142                            ; HEX value at the current cursor position. Register s7 must contain the memory
                1143                            ; location of the most significant byte (which is also the highest address).
                1144                            ;
                1145                            ; Registers used s0, s1, s2, s3, s4, s5, s6, s7
                1146                            ;
0A6 00140       1147        display_hex_32_bit: LOAD s6, 04                         ;4 bytes to display
E: symbol not defined: `S6'.
0A7 0B101       1148               disp32_loop: FETCH s0, (s7)                      ;read byte
E: symbol not defined: `S0'.
E: symbol not defined: `S7'.
0A8 200A0       1149                            CALL display_hex_byte               ;display byte
0A9 18110       1150                            SUB s7, 01                          ;decrement pointer
E: symbol not defined: `S7'.
0AA 18110       1151                            SUB s6, 01                          ;count bytes displayed
E: symbol not defined: `S6'.
0AB 31000       1152                            RETURN Z
0AC 220A7       1153                            JUMP disp32_loop
                1154                            ;
                1155                            ;
                1156                            ;**************************************************************************************
                1157                            ;LCD text messages
                1158                            ;**************************************************************************************
                1159                            ;
                1160                            ;
                1161                            ;Display 'Frequency' on LCD at current cursor position
                1162                            ;
0AD 00110       1163            disp_Frequency: LOAD s5, character_F
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_F'.
0AE 2010D       1164                            CALL LCD_write_data
0AF 00110       1165                            LOAD s5, character_r
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_R'.
0B0 2010D       1166                            CALL LCD_write_data
0B1 00110       1167                            LOAD s5, character_e
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_E'.
0B2 2010D       1168                            CALL LCD_write_data
0B3 00110       1169                            LOAD s5, character_q
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_Q'.
0B4 2010D       1170                            CALL LCD_write_data
0B5 00110       1171                            LOAD s5, character_u
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_U'.
0B6 2010D       1172                            CALL LCD_write_data
0B7 00110       1173                            LOAD s5, character_e
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_E'.
0B8 2010D       1174                            CALL LCD_write_data
0B9 00110       1175                            LOAD s5, character_n
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_N'.
0BA 2010D       1176                            CALL LCD_write_data
0BB 00110       1177                            LOAD s5, character_c
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_C'.
0BC 2010D       1178                            CALL LCD_write_data
0BD 00110       1179                            LOAD s5, character_y
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_Y'.
0BE 2010D       1180                            CALL LCD_write_data
0BF 25000       1181                            RETURN
                1182                            ;
                1183                            ;Display 'Generator' on LCD at current cursor position
                1184                            ;
0C0 00110       1185            disp_Generator: LOAD s5, character_G
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_G'.
0C1 2010D       1186                            CALL LCD_write_data
0C2 00110       1187                            LOAD s5, character_e
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_E'.
0C3 2010D       1188                            CALL LCD_write_data
0C4 00110       1189                            LOAD s5, character_n
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_N'.
0C5 2010D       1190                            CALL LCD_write_data
0C6 00110       1191                            LOAD s5, character_e
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_E'.
0C7 2010D       1192                            CALL LCD_write_data
0C8 00110       1193                            LOAD s5, character_r
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_R'.
0C9 2010D       1194                            CALL LCD_write_data
0CA 00110       1195                            LOAD s5, character_a
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_A'.
0CB 2010D       1196                            CALL LCD_write_data
0CC 00110       1197                            LOAD s5, character_t
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_T'.
0CD 2010D       1198                            CALL LCD_write_data
0CE 00110       1199                            LOAD s5, character_o
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_O'.
0CF 2010D       1200                            CALL LCD_write_data
0D0 00110       1201                            LOAD s5, character_r
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_R'.
0D1 2010D       1202                            CALL LCD_write_data
0D2 20007       1203                            CALL display_space
0D3 00110       1204                            LOAD s5, character_v
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_V'.
0D4 2010D       1205                            CALL LCD_write_data
0D5 00110       1206                            LOAD s5, character_1
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_1'.
0D6 2010D       1207                            CALL LCD_write_data
0D7 00110       1208                            LOAD s5, character_stop
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_STOP'.
0D8 2010D       1209                            CALL LCD_write_data
0D9 00110       1210                            LOAD s5, character_2
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_2'.
0DA 2010D       1211                            CALL LCD_write_data
0DB 25000       1212                            RETURN
                1213                            ;
                1214                            ;
                1215                            ;
                1216                            ;
                1217                            ;**************************************************************************************
                1218                            ;Software delay routines
                1219                            ;**************************************************************************************
                1220                            ;
                1221                            ;
                1222                            ;
                1223                            ;Delay of 1us.
                1224                            ;
                1225                            ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1226                            ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1227                            ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1228                            ;
                1229                            ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1230                            ;
                1231                            ;Registers used s0
                1232                            ;
0DC 00110       1233                 delay_1us: LOAD s0, delay_1us_constant
E: symbol not defined: `S0'.
E: symbol not defined: `DELAY_1US_CONSTANT'.
0DD 18110       1234                  wait_1us: SUB s0, 01
E: symbol not defined: `S0'.
0DE 360DD       1235                            JUMP NZ, wait_1us
0DF 25000       1236                            RETURN
                1237                            ;
                1238                            ;Delay of 40us.
                1239                            ;
                1240                            ;Registers used s0, s1
                1241                            ;
0E0 001C0       1242                delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
E: symbol not defined: `S1'.
W: value out of range: 28, allowed range is [0,15] (trimmed to 4 bits) which makes it 12.
0E1 200DC       1243                 wait_40us: CALL delay_1us
0E2 18110       1244                            SUB s1, 01
E: symbol not defined: `S1'.
0E3 360E1       1245                            JUMP NZ, wait_40us
0E4 25000       1246                            RETURN
                1247                            ;
                1248                            ;
                1249                            ;Delay of 1ms.
                1250                            ;
                1251                            ;Registers used s0, s1, s2
                1252                            ;
0E5 00130       1253                 delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
E: symbol not defined: `S2'.
W: value out of range: 19, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
0E6 200E0       1254                  wait_1ms: CALL delay_40us
0E7 18110       1255                            SUB s2, 01
E: symbol not defined: `S2'.
0E8 360E6       1256                            JUMP NZ, wait_1ms
0E9 25000       1257                            RETURN
                1258                            ;
                1259                            ;Delay of 20ms.
                1260                            ;
                1261                            ;Delay of 20ms used during initialisation.
                1262                            ;
                1263                            ;Registers used s0, s1, s2, s3
                1264                            ;
0EA 001E0       1265                delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
E: symbol not defined: `S3'.
0EB 200E5       1266                 wait_20ms: CALL delay_1ms
0EC 18110       1267                            SUB s3, 01
E: symbol not defined: `S3'.
0ED 360EB       1268                            JUMP NZ, wait_20ms
0EE 25000       1269                            RETURN
                1270                            ;
                1271                            ;Delay of approximately 1 second.
                1272                            ;
                1273                            ;Registers used s0, s1, s2, s3, s4
                1274                            ;
0EF 00100       1275                  delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
E: symbol not defined: `S4'.
W: value out of range: 32, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
0F0 200EA       1276                   wait_1s: CALL delay_20ms
0F1 18110       1277                            SUB s4, 01
E: symbol not defined: `S4'.
0F2 360F0       1278                            JUMP NZ, wait_1s
0F3 25000       1279                            RETURN
                1280                            ;
                1281                            ;
                1282                            ;
                1283                            ;**************************************************************************************
                1284                            ;LCD Character Module Routines
                1285                            ;**************************************************************************************
                1286                            ;
                1287                            ;LCD module is a 16 character by 2 line display but all displays are very similar
                1288                            ;The 4-wire data interface will be used (DB4 to DB7).
                1289                            ;
                1290                            ;The LCD modules are relatively slow and software delay loops are used to slow down
                1291                            ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
                1292                            ;a different section (see above in this case).
                1293                            ;
                1294                            ;
                1295                            ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
                1296                            ;
                1297                            ;Register s4 should define the current state of the LCD output port.
                1298                            ;
                1299                            ;Registers used s0, s4
                1300                            ;
0F4 06110       1301               LCD_pulse_E: XOR s4, LCD_E                       ;E=1
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_E'.
0F5 2D101       1302                            OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
0F6 200DC       1303                            CALL delay_1us
0F7 06110       1304                            XOR s4, LCD_E                       ;E=0
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_E'.
0F8 2D101       1305                            OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
0F9 25000       1306                            RETURN
                1307                            ;
                1308                            ;Write 4-bit instruction to LCD display.
                1309                            ;
                1310                            ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
                1311                            ;Note that this routine does not release the master enable but as it is only
                1312                            ;used during initialisation and as part of the 8-bit instruction write it
                1313                            ;should be acceptable.
                1314                            ;
                1315                            ;Registers used s4
                1316                            ;
0FA 02110       1317           LCD_write_inst4: AND s4, F8                          ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F8'.
0FB 2D101       1318                            OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
0FC 200F4       1319                            CALL LCD_pulse_E
0FD 25000       1320                            RETURN
                1321                            ;
                1322                            ;
                1323                            ;Write 8-bit instruction to LCD display.
                1324                            ;
                1325                            ;The 8-bit instruction should be provided in register s5.
                1326                            ;Instructions are written using the following sequence
                1327                            ; Upper nibble
                1328                            ; wait >1us
                1329                            ; Lower nibble
                1330                            ; wait >40us
                1331                            ;
                1332                            ;Registers used s0, s1, s4, s5
                1333                            ;
0FE 00110       1334           LCD_write_inst8: LOAD s4, s5
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
0FF 02110       1335                            AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
100 04110       1336                            OR s4, LCD_drive                    ;Enable=1
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_DRIVE'.
101 200FA       1337                            CALL LCD_write_inst4                ;write upper nibble
102 200DC       1338                            CALL delay_1us                      ;wait >1us
103 00110       1339                            LOAD s4, s5                         ;select lower nibble with
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
104 14107       1340                            SL1 s4                              ;Enable=1
E: symbol not defined: `S4'.
105 14106       1341                            SL0 s4                              ;RS=0 Instruction
E: symbol not defined: `S4'.
106 14106       1342                            SL0 s4                              ;RW=0 Write
E: symbol not defined: `S4'.
107 14106       1343                            SL0 s4                              ;E=0
E: symbol not defined: `S4'.
108 200FA       1344                            CALL LCD_write_inst4                ;write lower nibble
109 200E0       1345                            CALL delay_40us                     ;wait >40us
10A 00110       1346                            LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
10B 2D101       1347                            OUTPUT s4, LCD_output_port          ;Release master enable
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
10C 25000       1348                            RETURN
                1349                            ;
                1350                            ;
                1351                            ;
                1352                            ;Write 8-bit data to LCD display.
                1353                            ;
                1354                            ;The 8-bit data should be provided in register s5.
                1355                            ;Data bytes are written using the following sequence
                1356                            ; Upper nibble
                1357                            ; wait >1us
                1358                            ; Lower nibble
                1359                            ; wait >40us
                1360                            ;
                1361                            ;Registers used s0, s1, s4, s5
                1362                            ;
10D 00110       1363            LCD_write_data: LOAD s4, s5
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
10E 02110       1364                            AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
                1365                            OR s4, 0C                           ;Enable=1 RS=1 Data, RW=0 Write, E=0
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
10F 2D101       1366                            OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
110 200F4       1367                            CALL LCD_pulse_E                    ;write upper nibble
111 200DC       1368                            CALL delay_1us                      ;wait >1us
112 00110       1369                            LOAD s4, s5                         ;select lower nibble with
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
113 14107       1370                            SL1 s4                              ;Enable=1
E: symbol not defined: `S4'.
114 14107       1371                            SL1 s4                              ;RS=1 Data
E: symbol not defined: `S4'.
115 14106       1372                            SL0 s4                              ;RW=0 Write
E: symbol not defined: `S4'.
116 14106       1373                            SL0 s4                              ;E=0
E: symbol not defined: `S4'.
117 2D101       1374                            OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
118 200F4       1375                            CALL LCD_pulse_E                    ;write lower nibble
119 200E0       1376                            CALL delay_40us                     ;wait >40us
11A 00110       1377                            LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
11B 2D101       1378                            OUTPUT s4, LCD_output_port          ;Release master enable
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
11C 25000       1379                            RETURN
                1380                            ;
                1381                            ;
                1382                            ;
                1383                            ;
                1384                            ;Read 8-bit data from LCD display.
                1385                            ;
                1386                            ;The 8-bit data will be read from the current LCD memory address
                1387                            ;and will be returned in register s5.
                1388                            ;It is advisable to set the LCD address (cursor position) before
                1389                            ;using the data read for the first time otherwise the display may
                1390                            ;generate invalid data on the first read.
                1391                            ;
                1392                            ;Data bytes are read using the following sequence
                1393                            ; Upper nibble
                1394                            ; wait >1us
                1395                            ; Lower nibble
                1396                            ; wait >40us
                1397                            ;
                1398                            ;Registers used s0, s1, s4, s5
                1399                            ;
                1400            LCD_read_data8: LOAD s4, 0E                         ;Enable=1 RS=1 Data, RW=1 Read, E=0
E: identifier cannot start with a digit: `0E'.
E: unexpected end of line.
11D 2D101       1401                            OUTPUT s4, LCD_output_port          ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
11E 06110       1402                            XOR s4, LCD_E                       ;E=1
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_E'.
11F 2D101       1403                            OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
120 200DC       1404                            CALL delay_1us                      ;wait >260ns to access data
121 09101       1405                            INPUT s5, LCD_input_port            ;read upper nibble
E: symbol not defined: `S5'.
E: symbol not defined: `LCD_INPUT_PORT'.
122 06110       1406                            XOR s4, LCD_E                       ;E=0
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_E'.
123 2D101       1407                            OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
124 200DC       1408                            CALL delay_1us                      ;wait >1us
125 06110       1409                            XOR s4, LCD_E                       ;E=1
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_E'.
126 2D101       1410                            OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
127 200DC       1411                            CALL delay_1us                      ;wait >260ns to access data
128 09101       1412                            INPUT s0, LCD_input_port            ;read lower nibble
E: symbol not defined: `S0'.
E: symbol not defined: `LCD_INPUT_PORT'.
129 06110       1413                            XOR s4, LCD_E                       ;E=0
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_E'.
12A 2D101       1414                            OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
12B 02110       1415                            AND s5, F0                          ;merge upper and lower nibbles
E: symbol not defined: `S5'.
E: symbol not defined: `F0'.
12C 1410E       1416                            SR0 s0
E: symbol not defined: `S0'.
12D 1410E       1417                            SR0 s0
E: symbol not defined: `S0'.
12E 1410E       1418                            SR0 s0
E: symbol not defined: `S0'.
12F 1410E       1419                            SR0 s0
E: symbol not defined: `S0'.
130 04110       1420                            OR s5, s0
E: symbol not defined: `S5'.
E: symbol not defined: `S0'.
131 00140       1421                            LOAD s4, 04                         ;Enable=0 RS=1 Data, RW=0 Write, E=0
E: symbol not defined: `S4'.
132 2D101       1422                            OUTPUT s4, LCD_output_port          ;Stop reading 5V device and release master enable
E: symbol not defined: `S4'.
E: symbol not defined: `LCD_OUTPUT_PORT'.
133 200E0       1423                            CALL delay_40us                     ;wait >40us
134 25000       1424                            RETURN
                1425                            ;
                1426                            ;
                1427                            ;Reset and initialise display to communicate using 4-bit data mode
                1428                            ;Includes routine to clear the display.
                1429                            ;
                1430                            ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
                1431                            ;following by the 8-bit instructions to set up the display.
                1432                            ;
                1433                            ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
                1434                            ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
                1435                            ;  0E = '00001' Display control, '1' display on, '1' cursor off, '0' cursor blink off
                1436                            ;  01 = '00000001' Display clear
                1437                            ;
                1438                            ;Registers used s0, s1, s2, s3, s4
                1439                            ;
135 200EA       1440                 LCD_reset: CALL delay_20ms                     ;wait more that 15ms for display to be ready
136 001E0       1441                            LOAD s4, 30
E: symbol not defined: `S4'.
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
137 200FA       1442                            CALL LCD_write_inst4                ;send '3'
138 200EA       1443                            CALL delay_20ms                     ;wait >4.1ms
139 200FA       1444                            CALL LCD_write_inst4                ;send '3'
13A 200E5       1445                            CALL delay_1ms                      ;wait >100us
13B 200FA       1446                            CALL LCD_write_inst4                ;send '3'
13C 200E0       1447                            CALL delay_40us                     ;wait >40us
13D 00140       1448                            LOAD s4, 20
E: symbol not defined: `S4'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
13E 200FA       1449                            CALL LCD_write_inst4                ;send '2'
13F 200E0       1450                            CALL delay_40us                     ;wait >40us
140 001C0       1451                            LOAD s5, 28                         ;Function set
E: symbol not defined: `S5'.
W: value out of range: 28, allowed range is [0,15] (trimmed to 4 bits) which makes it 12.
141 200FE       1452                            CALL LCD_write_inst8
142 00160       1453                            LOAD s5, 06                         ;Entry mode
E: symbol not defined: `S5'.
143 200FE       1454                            CALL LCD_write_inst8
                1455                            LOAD s5, 0E                         ;Display control
E: identifier cannot start with a digit: `0E'.
E: unexpected end of line.
144 200FE       1456                            CALL LCD_write_inst8
145 00110       1457                 LCD_clear: LOAD s5, 01                         ;Display clear
E: symbol not defined: `S5'.
146 200FE       1458                            CALL LCD_write_inst8
147 200E5       1459                            CALL delay_1ms                      ;wait >1.64ms for display to clear
148 200E5       1460                            CALL delay_1ms
149 25000       1461                            RETURN
                1462                            ;
                1463                            ;Position the cursor ready for characters to be written.
                1464                            ;The display is formed of 2 lines of 16 characters and each
                1465                            ;position has a corresponding address as indicated below.
                1466                            ;
                1467                            ;                   Character position
                1468                            ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
                1469                            ;
                1470                            ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
                1471                            ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
                1472                            ;
                1473                            ;This routine will set the cursor position using the value provided
                1474                            ;in register s5. The upper nibble will define the line and the lower
                1475                            ;nibble the character position on the line.
                1476                            ; Example s5 = 2B will position the cursor on line 2 position 11
                1477                            ;
                1478                            ;Registers used s0, s1, s2, s3, s4
                1479                            ;
14A 0C1A0       1480                LCD_cursor: TEST s5, 10                         ;test for line 1
E: symbol not defined: `S5'.
14B 32001       1481                            JUMP Z, set_line2
E: symbol not defined: `SET_LINE2'.
                1482                            AND s5, 0F                          ;make address in range 80 to 8F for line 1
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
14C 04100       1483                            OR s5, 80
E: symbol not defined: `S5'.
W: value out of range: 80, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
14D 200FE       1484                            CALL LCD_write_inst8                ;instruction write to set cursor
14E 25000       1485                            RETURN
                1486                 set_line2: AND s5, 0F                          ;make address in range C0 to CF for line 2
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
14F 04110       1487                            OR s5, C0
E: symbol not defined: `S5'.
E: symbol not defined: `C0'.
150 200FE       1488                            CALL LCD_write_inst8                ;instruction write to set cursor
151 25000       1489                            RETURN
                1490                            ;
                1491                            ;This routine will shift the complete display one position to the left.
                1492                            ;The cursor position and LCD memory contents will not change.
                1493                            ;
                1494                            ;
                1495                            ;Registers used s0, s1, s2, s3, s4, s5
                1496                            ;
152 00120       1497            LCD_shift_left: LOAD s5, 18                         ;shift display left
E: symbol not defined: `S5'.
W: value out of range: 18, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
153 200FE       1498                            CALL LCD_write_inst8
154 25000       1499                            RETURN
                1500                            ;
                1501                            ;**************************************************************************************
                1502                            ;Interrupt Service Routine (ISR)
                1503                            ;**************************************************************************************
                1504                            ;
                1505                            ;Interrupts occur when the rotary control has been moved.
                1506                            ;
                1507                            ;The ISR captures the state of the direction which it writes to scratch pad memory (SPM).
                1508                            ;The most significant bit is also set at this location to provide a 'flag' to the
                1509                            ;main body of the program.
                1510                            ;
                1511                            ;
155 2F101       1512                       ISR: STORE s0, ISR_preserve_s0           ;preserve s0
E: symbol not defined: `S0'.
E: symbol not defined: `ISR_PRESERVE_S0'.
156 09101       1513                            INPUT s0, rotary_port               ;read rotary encoder
E: symbol not defined: `S0'.
E: symbol not defined: `ROTARY_PORT'.
157 04110       1514                            OR s0, rotary_event                 ;set flag
E: symbol not defined: `S0'.
E: symbol not defined: `ROTARY_EVENT'.
158 2F101       1515                            STORE s0, rotary_status             ;put result in SCM
E: symbol not defined: `S0'.
E: symbol not defined: `ROTARY_STATUS'.
159 0B101       1516                            FETCH s0, ISR_preserve_s0           ;restore s0
E: symbol not defined: `S0'.
E: symbol not defined: `ISR_PRESERVE_S0'.
15A 29001       1517                            RETURNI ENABLE
                1518                            ;
                1519                            ;
                1520                            ;**************************************************************************************
                1521                            ;Interrupt Vector
                1522                            ;**************************************************************************************
                1523                            ;
                1524                            ADDRESS 3FF
E: identifier cannot start with a digit: `3FF'.
E: directive ADDRESS requires a single argument.
15B 22155       1525                            JUMP ISR
                1526                            ;
                1527                            ;
