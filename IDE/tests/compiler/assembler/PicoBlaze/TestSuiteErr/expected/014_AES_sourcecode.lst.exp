                   1     ;
                   2     ; Copyright Â© 2003..2012 : Henk van Kampen
                   3     ;
                   4     ; This file is part of pBlazASM.
                   5     ;
                   6     ; pBlazASM is free software: you can redistribute it and/or modify
                   7     ; it under the terms of the GNU General Public License as published by
                   8     ; the Free Software Foundation, either version 3 of the License, or
                   9     ; (at your option) any later version.
                  10     ;
                  11     ; pBlazASM is distributed in the hope that it will be useful,
                  12     ; but WITHOUTPUT ANY WARRANTY; without even the implied warranty of
                  13     ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  14     ; GNU General Public License for more details.
                  15     ;
                  16     ; You should have received a copy of the GNU General Public License
                  17     ; along with pBlazASM.  #IF not, see http:;www.gnu.org/licenses.
                  18     ;
                  19
                  20     ;
                  21     ; Rijndael (AES-128) block cipher
                  22     ; this code assumes 128b data and a 128b key so: Nk = Nn = Nc = 4
                  23     ; (c) 2003 .. 2012 Henk van Kampen, www.mediatronix.com
                  24     ;
                  25     ; based on documents by Dr. Brian Gladman,
                  26     ;      http:;gladman.plushost.co.uk/oldsite/cryptography_technology/rijndael/aes.spec.v316.pdf
                  27     ;
                  28     ; test data from [Gladman]
                  29     ;      PLAINPUTTEXT:    3243f6a8885a308d313198a2e0370734 (pi * 2^124)
                  30     ;      KEY:          2b7e151628aed2a6abf7158809cf4f3c ( e * 2^124)
                  31     ; should result in:
                  32     ;      R[10].k_sch   d014f9a8c9ee2589e13f0cc8b6630ca6
                  33     ;      R[10].output  3925841d02dc09fbdc118597196a0b32
                  34     ;
                  35     ; to be done:
                  36     ;      decrypt
                  37     ;
                  38
                  39     ; SBOX I/O device, just a look-up ROM
                  40     SBOX_ROM            EQU       $F0                 ; uSBOX.VHD is instantiated at this port address
E: invalid token: `$F0'.
E: directive EQU requires a single argument.
                  41
                  42     ; key value
                  43     inkey               CODE       $2B, $7E, $15, $16, $28, $AE, $D2, $A6, $AB, $F7, $15, $88, $09, $CF, $4F, $3C
E: invalid token: `$2B'.
E: unexpected ",".
E: invalid token: `$7E'.
E: invalid token: `$15'.
E: invalid token: `$16'.
E: invalid token: `$28'.
E: invalid token: `$AE'.
E: invalid token: `$D2'.
E: invalid token: `$A6'.
E: invalid token: `$AB'.
E: invalid token: `$F7'.
E: invalid token: `$15'.
E: invalid token: `$88'.
E: invalid token: `$09'.
E: invalid token: `$CF'.
E: invalid token: `$4F'.
E: invalid token: `$3C'.
                  44
                  45     ; plaintext, key  and result
                  46     plain               CODE       $32, $43, $F6, $A8, $88, $5A, $30, $8D, $31, $31, $98, $A2, $E0, $37, $07, $34
E: invalid token: `$32'.
E: unexpected ",".
E: invalid token: `$43'.
E: invalid token: `$F6'.
E: invalid token: `$A8'.
E: invalid token: `$88'.
E: invalid token: `$5A'.
E: invalid token: `$30'.
E: invalid token: `$8D'.
E: invalid token: `$31'.
E: invalid token: `$31'.
E: invalid token: `$98'.
E: invalid token: `$A2'.
E: invalid token: `$E0'.
E: invalid token: `$37'.
E: invalid token: `$07'.
E: invalid token: `$34'.
  00010           47     key                 CODE       16
  00010           48     result              CODE       16
                  49
                  50     ; state buffer
  00010           51     state               CODE       16
                  52
                  53     ; special registers
  00001           54     pKey                EQU       s1                  ; key pointer
E: symbol not defined: `S1'.
  00001           55     pState              EQU       s2                  ; state pointer
E: symbol not defined: `S2'.
                  56
                  57     ; constants
                  58     X                   EQU       $01
E: invalid token: `$01'.
E: directive EQU requires a single argument.
                  59     G                   EQU       $1B                 ; 0x11B
E: invalid token: `$1B'.
E: directive EQU requires a single argument.
  00010           60     b128                EQU       128 / 8             ; 128 bytes of 8 bits
                  61
                  62     ; Rijndael encrypt entry
                  63     ; plain  is assumed to be in {plain }, the key in {inkey}
                  64     ; both will be copied, final state will be the result
                  65     Encrypt:
000 20021         66                         CALL      InkeyToKey
001 2001E         67                         CALL      InToState           ; state = in
                  68
002 20012         69                         CALL      XorRoundKey         ; XorRoundKey( state, k[0], Nc )
003 09101         70                         INPUT      sF, X               ; x^(i-1) (i=1)
E: symbol not defined: `SF'.
E: symbol not defined: `X'.
004 09109         71                         INPUT      s3, 9               ; for round = 1 step 1 to Nn - 1
E: symbol not defined: `S3'.
                  72     Round:                                            ;
005 2006B         73                         CALL      SubBytes            ; ..SubBytes( state, Nc )
006 20095         74                         CALL      ShiftRows           ; ..ShiftRows( state, Nc )
007 200AE         75                         CALL      MixColumns          ; ..MixColumns( state, Nc )
008 20035         76                         CALL      NextRoundKey        ; ..XorRoundKey( state, k[ round ], Nc )
009 20012         77                         CALL      XorRoundKey
00A 18110         78                         SUB       s3, 1               ; ..step 1
E: symbol not defined: `S3'.
00B 36005         79                         JUMP      NZ, Round           ; end for
00C 2006B         80                         CALL      SubBytes            ; SubBytes( state, Nc )
00D 20095         81                         CALL      ShiftRows           ; ShiftRows( state, Nc )
00E 20035         82                         CALL      NextRoundKey        ; XorRoundKey( state, k[ round ], Nc )
00F 20012         83                         CALL      XorRoundKey
010 2002B         84                         CALL      StateToOut
011 25000         85                         RETURN                           ; result  is last {state}
                  86
                  87     ; result should be: (Gladman)
                  88     ; R[10].k_sch d014f9a8c9ee2589e13f0cc8b6630ca6
                  89     ; R[10].result  3925841d02dc09fbdc118597196a0b32
                  90
                  91     ; XorRoundKey( state, k, Nc )
                  92
                  93     XorRoundKey:
012 09110         94                         INPUT      pKey, key           ; get pointer to key
013 09110         95                         INPUT      pState, state       ; get pointer to state
                  96
014 09110         97     xor128:             INPUT      s0, b128            ; set up loop count
E: symbol not defined: `S0'.
015 00110         98     xornext:            LOAD        s4, pKey            ; get key byte
E: symbol not defined: `S4'.
016 00110         99                         LOAD        s5, pState          ; get state byte
E: symbol not defined: `S5'.
017 06110        100                         XOR       s4, s5              ; do the xor
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
018 2F101        101                         STORE        s4, pState          ; save new state byte
E: symbol not defined: `S4'.
019 10110        102                         ADD       pKey, 1             ; increment key pointer
01A 10110        103                         ADD       pState, 1           ; increment state pointer
01B 18110        104                         SUB       s0, 1               ; decrement loop counter
E: symbol not defined: `S0'.
01C 36015        105                         JUMP      NZ, xornext         ; loop back if not done 16 times (128/8)
01D 25000        106                         RETURN
                 107
                 108     InToState:
01E 09101        109                         INPUT      pKey, plain         ; get pointer to plain
E: symbol not defined: `PLAIN'.
01F 09110        110                         INPUT      pState, state       ; get pointer to state
020 22023        111                         JUMP      ToScratch128
                 112
                 113     InkeyToKey:
021 09101        114                         INPUT      pKey, inkey         ; get pointer to plain
E: symbol not defined: `INKEY'.
022 09110        115                         INPUT      pState, key         ; get pointer to state
                 116
023 09110        117     ToScratch128:       INPUT      s0, b128            ; set up loop count
E: symbol not defined: `S0'.
024 00110        118     putnext:            LOAD        s4, pKey            ; get plain  byte
E: symbol not defined: `S4'.
025 2F101        119                         STORE        s4, pState          ; save new state byte
E: symbol not defined: `S4'.
026 10110        120                         ADD       pKey, 1             ; increment key pointer
027 10110        121                         ADD       pState, 1           ; increment state pointer
028 18110        122                         SUB       s0, 1               ; decrement loop counter
E: symbol not defined: `S0'.
029 36024        123                         JUMP      NZ, putnext         ; loop back if not done 16 times (128/8)
02A 25000        124                         RETURN
                 125
                 126     StateToOut:
02B 09110        127                         INPUT      pKey, state         ; get pointer to state
02C 09110        128                         INPUT      pState, result      ; get pointer to result
                 129
02D 09110        130                         INPUT      s0, b128            ; set up loop count
E: symbol not defined: `S0'.
02E 00110        131     getnext:            LOAD        s4, pKey            ; get plain  byte
E: symbol not defined: `S4'.
02F 2F101        132                         STORE        s4, pState          ; save new state byte
E: symbol not defined: `S4'.
030 10110        133                         ADD       pKey, 1             ; increment key pointer
031 10110        134                         ADD       pState, 1           ; increment state pointer
032 18110        135                         SUB       s0, 1               ; decrement loop counter
E: symbol not defined: `S0'.
033 3602E        136                         JUMP      NZ, getnext         ; loop back if not done 16 times (128/8)
034 25000        137                         RETURN
                 138
                 139     NextRoundKey:
                 140     ; temp = k[i - 1]
035 001C0        141                         LOAD        s4, key + 12        ; get last word of previous key
E: symbol not defined: `S4'.
W: value out of range: 28, allowed range is [0,15] (trimmed to 4 bits) which makes it 12.
036 001D0        142                         LOAD        s5, key + 13
E: symbol not defined: `S5'.
W: value out of range: 29, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
037 001E0        143                         LOAD        s6, key + 14
E: symbol not defined: `S6'.
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
038 001F0        144                         LOAD        s7, key + 15
E: symbol not defined: `S7'.
W: value out of range: 31, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
                 145
039 09101        146                         INPUT      s8, s4              ; RotWord
E: symbol not defined: `S8'.
E: symbol not defined: `S4'.
03A 09101        147                         INPUT      s4, s5
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
03B 09101        148                         INPUT      s5, s6
E: symbol not defined: `S5'.
E: symbol not defined: `S6'.
03C 09101        149                         INPUT      s6, s7
E: symbol not defined: `S6'.
E: symbol not defined: `S7'.
03D 09101        150                         INPUT      s7, s8
E: symbol not defined: `S7'.
E: symbol not defined: `S8'.
                 151
03E 09101        152                         INPUT      s8, s4              ; temp=SubWord( RotWord( temp ) )
E: symbol not defined: `S8'.
E: symbol not defined: `S4'.
03F 20074        153                         CALL      SBox
040 09101        154                         INPUT      s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
                 155
041 06110        156                         XOR       s4, sF              ; xor Rcon( i / Nk )
E: symbol not defined: `S4'.
E: symbol not defined: `SF'.
042 14106        157                         SL0       sF                  ; x^(i-1) (i+=1)
E: symbol not defined: `SF'.
043 3E045        158                         JUMP      NC, nowrap
044 06110        159                         XOR       sF, G
E: symbol not defined: `SF'.
E: symbol not defined: `G'.
                 160     nowrap:
045 09101        161                         INPUT      s8, s5              ; SubWord( RotWord( temp ) )
E: symbol not defined: `S8'.
E: symbol not defined: `S5'.
046 20074        162                         CALL      SBox
047 09101        163                         INPUT      s5, s8
E: symbol not defined: `S5'.
E: symbol not defined: `S8'.
                 164
048 09101        165                         INPUT      s8, s6              ; SubWord( RotWord( temp ) )
E: symbol not defined: `S8'.
E: symbol not defined: `S6'.
049 20074        166                         CALL      SBox
04A 09101        167                         INPUT      s6, s8
E: symbol not defined: `S6'.
E: symbol not defined: `S8'.
                 168
04B 09101        169                         INPUT      s8, s7              ; SubWord( RotWord( temp ) )
E: symbol not defined: `S8'.
E: symbol not defined: `S7'.
04C 20074        170                         CALL      SBox
04D 09101        171                         INPUT      s7, s8
E: symbol not defined: `S7'.
E: symbol not defined: `S8'.
                 172
04E 09110        173                         INPUT      pKey, key
                 174
04F 09110        175                         INPUT      s0, b128
E: symbol not defined: `S0'.
050 00110        176     key96:              LOAD        s8, pKey            ; k[i]=k[i - Nk] ^ temp
E: symbol not defined: `S8'.
051 06110        177                         XOR       s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
052 2F101        178                         STORE        s4, pKey
E: symbol not defined: `S4'.
053 10110        179                         ADD       pKey, 1
                 180
054 00110        181                         LOAD        s8, pKey            ; k[i]=k[i - Nk] ^ temp
E: symbol not defined: `S8'.
055 06110        182                         XOR       s5, s8
E: symbol not defined: `S5'.
E: symbol not defined: `S8'.
056 2F101        183                         STORE        s5, pKey
E: symbol not defined: `S5'.
057 10110        184                         ADD       pKey, 1
                 185
058 00110        186                         LOAD        s8, pKey            ; k[i]=k[i - Nk] ^ temp
E: symbol not defined: `S8'.
059 06110        187                         XOR       s6, s8
E: symbol not defined: `S6'.
E: symbol not defined: `S8'.
05A 2F101        188                         STORE        s6, pKey
E: symbol not defined: `S6'.
05B 10110        189                         ADD       pKey, 1
                 190
05C 00110        191                         LOAD        s8, pKey            ; k[i]=k[i - Nk] ^ temp
E: symbol not defined: `S8'.
05D 06110        192                         XOR       s7, s8
E: symbol not defined: `S7'.
E: symbol not defined: `S8'.
05E 2F101        193                         STORE        s7, pKey
E: symbol not defined: `S7'.
05F 10110        194                         ADD       pKey, 1
                 195
060 18140        196                         SUB       s0, 4
E: symbol not defined: `S0'.
061 36050        197                         JUMP      NZ, key96
062 25000        198                         RETURN
                 199
                 200     ; Sub bytes of one 32b word pointed at by pKey
                 201     SubWord:
063 09104        202                         INPUT      s0, 4
E: symbol not defined: `S0'.
064 00110        203     SubWord1:           LOAD        s8, pKey
E: symbol not defined: `S8'.
065 20074        204                         CALL      SBox
066 2F101        205                         STORE        s8, pKey
E: symbol not defined: `S8'.
067 10110        206                         ADD       pKey, 1
068 18110        207                         SUB       s0, 1
E: symbol not defined: `S0'.
069 36064        208                         JUMP      NZ, SubWord1
06A 25000        209                         RETURN
                 210
                 211     ; SubBytes( state, Nc )
                 212     SubBytes:
06B 09110        213                         INPUT      pState, state       ; get pointer to state
                 214
06C 09110        215                         INPUT      s0, b128            ; set up loop count
E: symbol not defined: `S0'.
06D 00110        216     sub128:             LOAD        s8, pState          ; get state byte
E: symbol not defined: `S8'.
06E 20074        217                         CALL      SBox
06F 2F101        218                         STORE        s8, pState          ; save new state byte
E: symbol not defined: `S8'.
070 10110        219                         ADD       pState, 1           ; increment state pointer
071 18110        220                         SUB       s0, 1               ; decrement loop counter
E: symbol not defined: `S0'.
072 3606D        221                         JUMP      NZ, sub128          ; loop back if not done 16 times (128/8)
073 25000        222                         RETURN
                 223
                 224     ; SBox( s )
                 225     SBox:
074 2D101        226                         OUTPUT       s8, SBOX_ROM        ; set index
E: symbol not defined: `S8'.
E: symbol not defined: `SBOX_ROM'.
075 09101        227                         INPUT        s8, SBOX_ROM        ; get data
E: symbol not defined: `S8'.
E: symbol not defined: `SBOX_ROM'.
076 25000        228                         RETURN
                 229
                 230     ; soft version of SBOX, very slow
                 231     SBox_Soft:
077 20080        232                         CALL      MulInverse          ; .    x = sbox_affine(mul_inverse(in));
                 233     SBoxAffine:
                 234     ; for(counter = 1; counter > (DEGREE - 1)) | (s << 1); s &= MASK;
078 06110        235                         XOR       s8, s9              ; in ^= s;
E: symbol not defined: `S8'.
E: symbol not defined: `S9'.
079 14102        236                         RL        s9
E: symbol not defined: `S9'.
07A 06110        237                         XOR       s8, s9
E: symbol not defined: `S8'.
E: symbol not defined: `S9'.
07B 14102        238                         RL        s9
E: symbol not defined: `S9'.
07C 06110        239                         XOR       s8, s9
E: symbol not defined: `S8'.
E: symbol not defined: `S9'.
07D 14102        240                         RL        s9
E: symbol not defined: `S9'.
07E 06110        241                         XOR       s8, s9
E: symbol not defined: `S8'.
E: symbol not defined: `S9'.
                 242                         XOR       s8, $63             ; in ^= 0x63;
E: invalid token: `$63'.
E: unexpected end of line.
07F 25000        243                         RETURN                           ; return in;
                 244     ; }
                 245
                 246     ; MulInverse by trial and error
                 247     MulInverse:
080 09100        248                         INPUT      s9, 0               ; int result = 0;
E: symbol not defined: `S9'.
081 04110        249                         OR        s8, s8              ; if (in == 0)
E: symbol not defined: `S8'.
E: symbol not defined: `S8'.
082 31000        250                         RETURN       Z                   ; return 0;
083 10110        251     MulInverse1:        ADD       s9, 1               ; result = 1; result++
E: symbol not defined: `S9'.
084 31000        252                         RETURN       Z                   ; result < MOD
085 09101        253                         INPUT      sC, s8              ; in
E: symbol not defined: `SC'.
E: symbol not defined: `S8'.
086 09101        254                         INPUT      sD, s9              ; result
E: symbol not defined: `SD'.
E: symbol not defined: `S9'.
087 2008B        255                         CALL      GMul                ; gmul( in, result, ...)
088 18110        256                         SUB       sE, 1               ; == 1
E: symbol not defined: `SE'.
089 36083        257                         JUMP      NZ, MulInverse1     ; == 1?
08A 25000        258                         RETURN                           ; return result
                 259
                 260     GMul:
08B 09100        261                         INPUT      sE, 0
E: symbol not defined: `SE'.
                 262     GMul1:
08C 1410E        263                         SR0       sD
E: symbol not defined: `SD'.
08D 3A090        264                         JUMP      C, GMul2           ; ; last bit was 1
08E 31000        265                         RETURN       Z                  ; ; i2 was 0 already ?
08F 22091        266                         JUMP      GMul3
                 267
090 06110        268     GMul2:              XOR       sE, sC
E: symbol not defined: `SE'.
E: symbol not defined: `SC'.
091 14106        269     GMul3:              SL0       sC
E: symbol not defined: `SC'.
092 3E08C        270                         JUMP      NC, GMul1
093 06110        271                         XOR       sC, G              ; ; i1 ^= field;
E: symbol not defined: `SC'.
E: symbol not defined: `G'.
094 2208C        272                         JUMP      GMul1
                 273
                 274     ;; ShiftRows( state, Nc )
                 275     ShiftRows:
095 00110        276                         LOAD        s7, state + 1
E: symbol not defined: `S7'.
W: value out of range: 17, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
096 00150        277                         LOAD        s4, state + 1 + 4
E: symbol not defined: `S4'.
W: value out of range: 21, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
097 00190        278                         LOAD        s5, state + 1 + 4 + 4
E: symbol not defined: `S5'.
W: value out of range: 25, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
098 001D0        279                         LOAD        s6, state + 1 + 4 + 4 + 4
E: symbol not defined: `S6'.
W: value out of range: 29, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
099 2F111        280                         STORE        s4, state + 1
E: symbol not defined: `S4'.
09A 2F115        281                         STORE        s5, state + 1 + 4
E: symbol not defined: `S5'.
09B 2F119        282                         STORE        s6, state + 1 + 4 + 4
E: symbol not defined: `S6'.
09C 2F11D        283                         STORE        s7, state + 1 + 4 + 4 + 4
E: symbol not defined: `S7'.
                 284
09D 00120        285                         LOAD        s6, state + 2
E: symbol not defined: `S6'.
W: value out of range: 18, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
09E 00160        286                         LOAD        s7, state + 2 + 4
E: symbol not defined: `S7'.
W: value out of range: 22, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
09F 001A0        287                         LOAD        s4, state + 2 + 4 + 4
E: symbol not defined: `S4'.
W: value out of range: 26, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
0A0 001E0        288                         LOAD        s5, state + 2 + 4 + 4 + 4
E: symbol not defined: `S5'.
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
0A1 2F112        289                         STORE        s4, state + 2
E: symbol not defined: `S4'.
0A2 2F116        290                         STORE        s5, state + 2 + 4
E: symbol not defined: `S5'.
0A3 2F11A        291                         STORE        s6, state + 2 + 4 + 4
E: symbol not defined: `S6'.
0A4 2F11E        292                         STORE        s7, state + 2 + 4 + 4 + 4
E: symbol not defined: `S7'.
                 293
0A5 00130        294                         LOAD        s5, state + 3
E: symbol not defined: `S5'.
W: value out of range: 19, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
0A6 00170        295                         LOAD        s6, state + 3 + 4
E: symbol not defined: `S6'.
W: value out of range: 23, allowed range is [0,15] (trimmed to 4 bits) which makes it 7.
0A7 001B0        296                         LOAD        s7, state + 3 + 4 + 4
E: symbol not defined: `S7'.
W: value out of range: 27, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
0A8 001F0        297                         LOAD        s4, state + 3 + 4 + 4 + 4
E: symbol not defined: `S4'.
W: value out of range: 31, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
0A9 2F113        298                         STORE        s4, state + 3
E: symbol not defined: `S4'.
0AA 2F117        299                         STORE        s5, state + 3 + 4
E: symbol not defined: `S5'.
0AB 2F11B        300                         STORE        s6, state + 3 + 4 + 4
E: symbol not defined: `S6'.
0AC 2F11F        301                         STORE        s7, state + 3 + 4 + 4 + 4
E: symbol not defined: `S7'.
                 302
0AD 25000        303                         RETURN
                 304
                 305     ;; MixColumns( state, Nc )
                 306     MixColumns:
                 307
0AE 00100        308                         LOAD        s4, state + 0
E: symbol not defined: `S4'.
W: value out of range: 16, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
0AF 00110        309                         LOAD        s5, state + 1
E: symbol not defined: `S5'.
W: value out of range: 17, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
0B0 00120        310                         LOAD        s6, state + 2
E: symbol not defined: `S6'.
W: value out of range: 18, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
0B1 00130        311                         LOAD        s7, state + 3
E: symbol not defined: `S7'.
W: value out of range: 19, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
0B2 200D3        312                         CALL      MixColumn
0B3 2F110        313                         STORE        s4, state + 0
E: symbol not defined: `S4'.
0B4 2F111        314                         STORE        s5, state + 1
E: symbol not defined: `S5'.
0B5 2F112        315                         STORE        s6, state + 2
E: symbol not defined: `S6'.
0B6 2F113        316                         STORE        s7, state + 3
E: symbol not defined: `S7'.
                 317
0B7 00140        318                         LOAD        s4, state + 0 + 4
E: symbol not defined: `S4'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
0B8 00150        319                         LOAD        s5, state + 1 + 4
E: symbol not defined: `S5'.
W: value out of range: 21, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
0B9 00160        320                         LOAD        s6, state + 2 + 4
E: symbol not defined: `S6'.
W: value out of range: 22, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
0BA 00170        321                         LOAD        s7, state + 3 + 4
E: symbol not defined: `S7'.
W: value out of range: 23, allowed range is [0,15] (trimmed to 4 bits) which makes it 7.
0BB 200D3        322                         CALL      MixColumn
0BC 2F114        323                         STORE        s4, state + 0 + 4
E: symbol not defined: `S4'.
0BD 2F115        324                         STORE        s5, state + 1 + 4
E: symbol not defined: `S5'.
0BE 2F116        325                         STORE        s6, state + 2 + 4
E: symbol not defined: `S6'.
0BF 2F117        326                         STORE        s7, state + 3 + 4
E: symbol not defined: `S7'.
                 327
0C0 00180        328                         LOAD        s4, state + 0 + 4 + 4
E: symbol not defined: `S4'.
W: value out of range: 24, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
0C1 00190        329                         LOAD        s5, state + 1 + 4 + 4
E: symbol not defined: `S5'.
W: value out of range: 25, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
0C2 001A0        330                         LOAD        s6, state + 2 + 4 + 4
E: symbol not defined: `S6'.
W: value out of range: 26, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
0C3 001B0        331                         LOAD        s7, state + 3 + 4 + 4
E: symbol not defined: `S7'.
W: value out of range: 27, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
0C4 200D3        332                         CALL      MixColumn
0C5 2F118        333                         STORE        s4, state + 0 + 4 + 4
E: symbol not defined: `S4'.
0C6 2F119        334                         STORE        s5, state + 1 + 4 + 4
E: symbol not defined: `S5'.
0C7 2F11A        335                         STORE        s6, state + 2 + 4 + 4
E: symbol not defined: `S6'.
0C8 2F11B        336                         STORE        s7, state + 3 + 4 + 4
E: symbol not defined: `S7'.
                 337
0C9 001C0        338                         LOAD        s4, state + 0 + 4 + 4 + 4
E: symbol not defined: `S4'.
W: value out of range: 28, allowed range is [0,15] (trimmed to 4 bits) which makes it 12.
0CA 001D0        339                         LOAD        s5, state + 1 + 4 + 4 + 4
E: symbol not defined: `S5'.
W: value out of range: 29, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
0CB 001E0        340                         LOAD        s6, state + 2 + 4 + 4 + 4
E: symbol not defined: `S6'.
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
0CC 001F0        341                         LOAD        s7, state + 3 + 4 + 4 + 4
E: symbol not defined: `S7'.
W: value out of range: 31, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
0CD 200D3        342                         CALL      MixColumn
0CE 2F11C        343                         STORE        s4, state + 0 + 4 + 4 + 4
E: symbol not defined: `S4'.
0CF 2F11D        344                         STORE        s5, state + 1 + 4 + 4 + 4
E: symbol not defined: `S5'.
0D0 2F11E        345                         STORE        s6, state + 2 + 4 + 4 + 4
E: symbol not defined: `S6'.
0D1 2F11F        346                         STORE        s7, state + 3 + 4 + 4 + 4
E: symbol not defined: `S7'.
                 347
0D2 25000        348                         RETURN
                 349
                 350     MixColumn:
0D3 09101        351                         INPUT      s9, s4             ; ; t = c[0] ^ c[3]
E: symbol not defined: `S9'.
E: symbol not defined: `S4'.
0D4 06110        352                         XOR       s9, s7
E: symbol not defined: `S9'.
E: symbol not defined: `S7'.
0D5 09101        353                         INPUT      sA, s5             ; ; u = c[1] ^ c[2]
E: symbol not defined: `SA'.
E: symbol not defined: `S5'.
0D6 06110        354                         XOR       sA, s6
E: symbol not defined: `SA'.
E: symbol not defined: `S6'.
0D7 09101        355                         INPUT      sB, s9            ;  ; v = t ^ u
E: symbol not defined: `SB'.
E: symbol not defined: `S9'.
0D8 06110        356                         XOR       sB, sA
E: symbol not defined: `SB'.
E: symbol not defined: `SA'.
                 357
0D9 09101        358                         INPUT      s8, s4             ; ; c[0] = c[0] ^ v ^ FFmul(0x02, c[0] ^ c[1])
E: symbol not defined: `S8'.
E: symbol not defined: `S4'.
0DA 06110        359                         XOR       s8, s5
E: symbol not defined: `S8'.
E: symbol not defined: `S5'.
0DB 14106        360                         SL0       s8
E: symbol not defined: `S8'.
0DC 3E0DE        361                         JUMP      NC, mcf1
0DD 06110        362                         XOR       s8, G
E: symbol not defined: `S8'.
E: symbol not defined: `G'.
0DE 06110        363     mcf1:               XOR       s8, sB
E: symbol not defined: `S8'.
E: symbol not defined: `SB'.
0DF 06110        364                         XOR       s4, s8
E: symbol not defined: `S4'.
E: symbol not defined: `S8'.
                 365
0E0 09101        366                         INPUT      s8, sA            ;  ; c[1] = c[1] ^ v ^ FFmul(0x02, u)
E: symbol not defined: `S8'.
E: symbol not defined: `SA'.
0E1 14106        367                         SL0       s8
E: symbol not defined: `S8'.
0E2 3E0E4        368                         JUMP      NC, mcf2
0E3 06110        369                         XOR       s8, G
E: symbol not defined: `S8'.
E: symbol not defined: `G'.
0E4 06110        370     mcf2:               XOR       s8, sB
E: symbol not defined: `S8'.
E: symbol not defined: `SB'.
0E5 06110        371                         XOR       s5, s8
E: symbol not defined: `S5'.
E: symbol not defined: `S8'.
                 372
0E6 09101        373                         INPUT      s8, s6             ; ; c[2] = c[2] ^ v ^ FFmul(0x02, c[2] ^ c[3])
E: symbol not defined: `S8'.
E: symbol not defined: `S6'.
0E7 06110        374                         XOR       s8, s7
E: symbol not defined: `S8'.
E: symbol not defined: `S7'.
0E8 14106        375                         SL0       s8
E: symbol not defined: `S8'.
0E9 3E0EB        376                         JUMP      NC, mcf3
0EA 06110        377                         XOR       s8, G
E: symbol not defined: `S8'.
E: symbol not defined: `G'.
0EB 06110        378     mcf3:               XOR       s8, sB
E: symbol not defined: `S8'.
E: symbol not defined: `SB'.
0EC 06110        379                         XOR       s6, s8
E: symbol not defined: `S6'.
E: symbol not defined: `S8'.
                 380
0ED 09101        381                         INPUT      s8, s9             ; ; c[3] = c[3] ^ v ^ FFmul(0x02, t)
E: symbol not defined: `S8'.
E: symbol not defined: `S9'.
0EE 14106        382                         SL0       s8
E: symbol not defined: `S8'.
0EF 3E0F1        383                         JUMP      NC, mcf4
0F0 06110        384                         XOR       s8, G
E: symbol not defined: `S8'.
E: symbol not defined: `G'.
0F1 06110        385     mcf4:               XOR       s8, sB
E: symbol not defined: `S8'.
E: symbol not defined: `SB'.
0F2 06110        386                         XOR       s7, s8
E: symbol not defined: `S7'.
E: symbol not defined: `S8'.
                 387
0F3 25000        388                         RETURN
