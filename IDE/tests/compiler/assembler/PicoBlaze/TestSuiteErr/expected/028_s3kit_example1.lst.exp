                   1                           ; KCPSM3 Program - LED control with Pulse Width Modulation (PWM).
                   2                           ;
                   3                           ; Design provided for use with the design 'low_cost_design_authentication_for_spartan_3e.vhd'
                   4                           ; and the Spartan-3E Starter Kit. This design provides the token 'real' application to be
                   5                           ; protected by design authentication.
                   6                           ;
                   7                           ; Ken Chapman - Xilinx Ltd
                   8                           ;
                   9                           ; Version v1.00 - 9th November 2006
                  10                           ;
                  11                           ; This code automatically sequences the LEDs on the board using PWM to change intensity.
                  12                           ; It also checks for correct design authentication and will perform a different sequence if
                  13                           ; the design is not authorised.
                  14                           ;
                  15                           ;
                  16                           ;**************************************************************************************
                  17                           ; NOTICE:
                  18                           ;
                  19                           ; Copyright Xilinx, Inc. 2006.   This code may be contain portions patented by other
                  20                           ; third parties.  By providing this core as one possible implementation of a standard,
                  21                           ; Xilinx is making no representation that the provided implementation of this standard
                  22                           ; is free from any claims of infringement by any third party.  Xilinx expressly
                  23                           ; disclaims any warranty with respect to the adequacy of the implementation, including
                  24                           ; but not limited to any warranty or representation that the implementation is free
                  25                           ; from claims of any third party.  Furthermore, Xilinx is providing this core as a
                  26                           ; courtesy to you and suggests that you contact all third parties to obtain the
                  27                           ; necessary rights to use this implementation.
                  28                           ;
                  29                           ;
                  30                           ;**************************************************************************************
                  31                           ; Port definitions
                  32                           ;**************************************************************************************
                  33                           ;
                  34                           ;
                  35                           ;
  00050           36                           CONSTANT LED_port, 80               ;8 simple LEDs
  00001           37                           CONSTANT LED0, 01                   ;       LD0 - bit0
  00002           38                           CONSTANT LED1, 02                   ;       LD1 - bit1
  00004           39                           CONSTANT LED2, 04                   ;       LD2 - bit2
  00008           40                           CONSTANT LED3, 08                   ;       LD3 - bit3
  0000A           41                           CONSTANT LED4, 10                   ;       LD4 - bit4
  00014           42                           CONSTANT LED5, 20                   ;       LD5 - bit5
  00028           43                           CONSTANT LED6, 40                   ;       LD6 - bit6
  00050           44                           CONSTANT LED7, 80                   ;       LD7 - bit7
                  45                           ;
  00000           46                           CONSTANT LED_read_port, 00          ;read back of current LED drive values
                  47                           ;
                  48                           ;
  00028           49                           CONSTANT security_request_port, 40  ;Port to stimulate security KCPSM3 processor
  00001           50                           CONSTANT security_interrupt, 01     ; interrupt - bit0
                  51                           ;
                  52                           ;
                  53                           ;A FIFO buffer links the security KCPSM3 processor to the application KCPSM3 processor.
                  54                           ;  This application processor controls and reads the FIFO.
                  55                           ;  The security processor writes to the FIFO.
                  56                           ;
  00014           57                           CONSTANT link_fifo_control_port, 20 ;FIFO control
  00001           58                           CONSTANT link_fifo_reset, 01        ;     reset - bit0
                  59                           ;
  00001           60                           CONSTANT link_FIFO_status_port, 01  ;FIFO status input
  00001           61                           CONSTANT link_FIFO_data_present, 01 ;      half full - bit0
  00002           62                           CONSTANT link_FIFO_half_full, 02    ;           full - bit1
  00004           63                           CONSTANT link_FIFO_full, 04         ;   data present - bit2
                  64                           ;
  00002           65                           CONSTANT link_FIFO_read_port, 02    ;read FIFO data
                  66                           ;
                  67                           ;
                  68                           ;
                  69                           ;**************************************************************************************
                  70                           ; Special Register usage
                  71                           ;**************************************************************************************
                  72                           ;
                  73                           ;
                  74                           ;
                  75                           ;
                  76                           ;**************************************************************************************
                  77                           ;Scratch Pad Memory Locations
                  78                           ;**************************************************************************************
                  79                           ;
  00000           80                           CONSTANT PWM_duty_counter, 00       ;Duty Counter 0 to 255 within 1KHz period (1ms)
  00001           81                           CONSTANT PWM_channel0, 01           ;PWM settings for each channel
  00002           82                           CONSTANT PWM_channel1, 02           ; Channels 0 to 7 = LEDs 0 to 7
  00003           83                           CONSTANT PWM_channel2, 03
  00004           84                           CONSTANT PWM_channel3, 04
  00005           85                           CONSTANT PWM_channel4, 05
  00006           86                           CONSTANT PWM_channel5, 06
  00007           87                           CONSTANT PWM_channel6, 07
  00008           88                           CONSTANT PWM_channel7, 08
  00000           89                           CONSTANT ISR_preserve_s0, 0D        ;preserve register contents during Interrupt Service Routine
                  90                           CONSTANT ISR_preserve_s1, 0E
E: identifier cannot start with a digit: `0E'.
E: unexpected end of line.
                  91                           CONSTANT ISR_preserve_s2, 0F
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
                  92                           ;
                  93                           ;
  0000A           94                           CONSTANT LED0_sequence, 10          ;LED sequence values
  0000B           95                           CONSTANT LED1_sequence, 11
  0000C           96                           CONSTANT LED2_sequence, 12
  0000D           97                           CONSTANT LED3_sequence, 13
  0000E           98                           CONSTANT LED4_sequence, 14
  0000F           99                           CONSTANT LED5_sequence, 15
  00010          100                           CONSTANT LED6_sequence, 16
  00011          101                           CONSTANT LED7_sequence, 17
                 102                           ;
                 103                           ;
                 104                           ;
                 105                           ;**************************************************************************************
                 106                           ;Useful data constants
                 107                           ;**************************************************************************************
                 108                           ;
                 109                           ;
                 110                           ;
                 111                           ;
                 112                           ;
                 113                           ;
                 114                           ;
                 115                           ;**************************************************************************************
                 116                           ;Initialise the system
                 117                           ;**************************************************************************************
                 118                           ;
                 119                           ; All PWM channels initialise to off (zero).
                 120                           ; Simple I/O outputs will remain off at all times.
                 121                           ;
000 00100        122               cold_start: LOAD s0, 00
E: symbol not defined: `S0'.
001 00110        123                           LOAD s1, PWM_channel0
E: symbol not defined: `S1'.
002 2F101        124               clear_loop: STORE s0, (s1)
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
003 1C180        125                           COMPARE s1, PWM_channel7
E: symbol not defined: `S1'.
004 32007        126                           JUMP Z, enable_int
005 10110        127                           ADD s1, 01
E: symbol not defined: `S1'.
006 22002        128                           JUMP clear_loop
                 129                           ;
007 28001        130               enable_int: ENABLE INTERRUPT                    ;interrupts used to set PWM frequency
                 131                           ;
                 132                           ;
                 133                           ; Initialise LED pattern sequence
                 134                           ;
008 00110        135                           LOAD s0, 01                         ;trigger to start wave pattern
E: symbol not defined: `S0'.
009 2F10A        136                           STORE s0, LED0_sequence
E: symbol not defined: `S0'.
00A 00100        137                           LOAD s0, 00
E: symbol not defined: `S0'.
00B 2F10B        138                           STORE s0, LED1_sequence
E: symbol not defined: `S0'.
00C 2F10C        139                           STORE s0, LED2_sequence
E: symbol not defined: `S0'.
00D 2F10D        140                           STORE s0, LED3_sequence
E: symbol not defined: `S0'.
00E 2F10E        141                           STORE s0, LED4_sequence
E: symbol not defined: `S0'.
00F 2F10F        142                           STORE s0, LED5_sequence
E: symbol not defined: `S0'.
010 2F110        143                           STORE s0, LED6_sequence
E: symbol not defined: `S0'.
011 2F111        144                           STORE s0, LED7_sequence
E: symbol not defined: `S0'.
                 145                           ;
                 146                           ;
                 147                           ; Reset authentication check counter
                 148                           ;
012 00100        149                           LOAD sF, 00
E: symbol not defined: `SF'.
                 150                           ;
                 151                           ;
                 152                           ;**************************************************************************************
                 153                           ; Main program
                 154                           ;**************************************************************************************
                 155                           ;
                 156                           ; Provides a pattern of interest on the LEDs :-)
                 157                           ;
                 158                           ; Each LED increases intensity in 8 steps and then decreases intensity in 8 steps until it is off.
                 159                           ; The middle LEDs (LD2 to LD5) each start to turn on when either neighbour is turned half on and increasing
                 160                           ; to provide the effect of a passing a 'wave' of light passing from side to side. The pair of LEDs at each
                 161                           ; (LD0, Ld1 and LD6, LD7) are required to reflect the 'wave' so that the pattern continues.
                 162                           ;
                 163                           ; I'm sure this code cold be written in more elegant way, but I leave that as an exercise to you :-)
                 164                           ;
                 165                           ;
                 166                           ; Using a simple software counter (implemented by register sF) the design occasionally requests an
                 167                           ; authorisation message from the authentication processor. If it receives a PASS message it continues
                 168                           ; normally but if it receives a FAIL message the LED pattern is changed.
                 169                           ;
                 170                           ;
                 171                           ;
013 10110        172               warm_start: ADD sF, 01                          ;authentication check timer
E: symbol not defined: `SF'.
014 3A0B6        173                           JUMP C, authentication_check        ;Check made approximately every 8 seconds.
                 174                           ;
015 00130        175      normal_LED_sequence: LOAD s2, 03                         ;simple delay loop (delay will be increased by ISR processing)
E: symbol not defined: `S2'.
016 00110        176            delay_s2_loop: LOAD s1, FF
E: symbol not defined: `S1'.
E: symbol not defined: `FF'.
017 00110        177            delay_s1_loop: LOAD s0, FF
E: symbol not defined: `S0'.
E: symbol not defined: `FF'.
018 18110        178            delay_s0_loop: SUB s0, 01
E: symbol not defined: `S0'.
019 3E018        179                           JUMP NC, delay_s0_loop
01A 18110        180                           SUB s1, 01
E: symbol not defined: `S1'.
01B 3E017        181                           JUMP NC, delay_s1_loop
01C 18110        182                           SUB s2, 01
E: symbol not defined: `S2'.
01D 3E016        183                           JUMP NC, delay_s2_loop
                 184                           ;
                 185                           ;Pattern generation
                 186                           ;
01E 0B10A        187                           FETCH s0, LED0_sequence             ;read sequence for LED0
E: symbol not defined: `S0'.
01F 1C100        188                           COMPARE s0, 00
E: symbol not defined: `S0'.
020 32026        189                           JUMP Z, test_LED0_start
021 18140        190                           SUB s0, 20                          ;Count longer to ensure end stops then reset count if maximum
E: symbol not defined: `S0'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
022 32029        191                           JUMP Z, update_LED0
023 10140        192                           ADD s0, 20
E: symbol not defined: `S0'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
024 10110        193                 inc_LED0: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
025 22029        194                           JUMP update_LED0
026 0B10B        195          test_LED0_start: FETCH s1, LED1_sequence             ;start LED0 if LED1 = 4
E: symbol not defined: `S1'.
027 1C140        196                           COMPARE s1, 04
E: symbol not defined: `S1'.
028 32024        197                           JUMP Z, inc_LED0
029 2F10A        198              update_LED0: STORE s0, LED0_sequence
E: symbol not defined: `S0'.
02A 200A8        199                           CALL LED_to_duty
02B 2F101        200                           STORE s1, PWM_channel0
E: symbol not defined: `S1'.
                 201                           ;
02C 0B10A        202                           FETCH s1, LED0_sequence             ; refresh LED1 if LED0 = 11 (0B hex) to reflect wave
E: symbol not defined: `S1'.
02D 1C100        203                           COMPARE s1, 0B
E: symbol not defined: `S1'.
02E 36031        204                           JUMP NZ, normal_LED1
02F 00140        205                           LOAD s0, 04
E: symbol not defined: `S0'.
030 2203F        206                           JUMP update_LED1
031 0B10B        207              normal_LED1: FETCH s0, LED1_sequence             ;read sequence for LED1
E: symbol not defined: `S0'.
032 1C100        208                           COMPARE s0, 00
E: symbol not defined: `S0'.
033 32039        209                           JUMP Z, test_LED1_start
034 181A0        210                           SUB s0, 10                          ;reset count if maximum
E: symbol not defined: `S0'.
035 3203F        211                           JUMP Z, update_LED1
036 101A0        212                           ADD s0, 10
E: symbol not defined: `S0'.
037 10110        213                 inc_LED1: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
038 2203F        214                           JUMP update_LED1
039 0B10A        215          test_LED1_start: FETCH s1, LED0_sequence             ;start LED1 if LED0 = 11 (0B hex) to reflect wave
E: symbol not defined: `S1'.
03A 1C100        216                           COMPARE s1, 0B
E: symbol not defined: `S1'.
03B 32037        217                           JUMP Z, inc_LED1
03C 0B10C        218                           FETCH s1, LED2_sequence             ;start LED1 if LED2 = 4
E: symbol not defined: `S1'.
03D 1C140        219                           COMPARE s1, 04
E: symbol not defined: `S1'.
03E 32037        220                           JUMP Z, inc_LED1
03F 2F10B        221              update_LED1: STORE s0, LED1_sequence
E: symbol not defined: `S0'.
040 200A8        222                           CALL LED_to_duty
041 2F102        223                           STORE s1, PWM_channel1
E: symbol not defined: `S1'.
                 224                           ;
042 0B10C        225                           FETCH s0, LED2_sequence             ;read sequence for LED2
E: symbol not defined: `S0'.
043 1C100        226                           COMPARE s0, 00
E: symbol not defined: `S0'.
044 3204A        227                           JUMP Z, test_LED2_start
045 181A0        228                           SUB s0, 10                          ;reset count if maximum
E: symbol not defined: `S0'.
046 32050        229                           JUMP Z, update_LED2
047 101A0        230                           ADD s0, 10
E: symbol not defined: `S0'.
048 10110        231                 inc_LED2: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
049 22050        232                           JUMP update_LED2
04A 0B10B        233          test_LED2_start: FETCH s1, LED1_sequence             ;start LED2 if LED1 = 4
E: symbol not defined: `S1'.
04B 1C140        234                           COMPARE s1, 04
E: symbol not defined: `S1'.
04C 32048        235                           JUMP Z, inc_LED2
04D 0B10D        236                           FETCH s1, LED3_sequence             ;start LED2 if LED3 = 4
E: symbol not defined: `S1'.
04E 1C140        237                           COMPARE s1, 04
E: symbol not defined: `S1'.
04F 32048        238                           JUMP Z, inc_LED2
050 2F10C        239              update_LED2: STORE s0, LED2_sequence
E: symbol not defined: `S0'.
051 200A8        240                           CALL LED_to_duty
052 2F103        241                           STORE s1, PWM_channel2
E: symbol not defined: `S1'.
                 242                           ;
                 243                           ;
053 0B10D        244                           FETCH s0, LED3_sequence             ;read sequence for LED3
E: symbol not defined: `S0'.
054 1C100        245                           COMPARE s0, 00
E: symbol not defined: `S0'.
055 3205B        246                           JUMP Z, test_LED3_start
056 181A0        247                           SUB s0, 10                          ;reset count if maximum
E: symbol not defined: `S0'.
057 32061        248                           JUMP Z, update_LED3
058 101A0        249                           ADD s0, 10
E: symbol not defined: `S0'.
059 10110        250                 inc_LED3: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
05A 22061        251                           JUMP update_LED3
05B 0B10C        252          test_LED3_start: FETCH s1, LED2_sequence             ;start LED3 if LED2 = 4
E: symbol not defined: `S1'.
05C 1C140        253                           COMPARE s1, 04
E: symbol not defined: `S1'.
05D 32059        254                           JUMP Z, inc_LED3
05E 0B10E        255                           FETCH s1, LED4_sequence             ;start LED3 if LED4 = 4
E: symbol not defined: `S1'.
05F 1C140        256                           COMPARE s1, 04
E: symbol not defined: `S1'.
060 32059        257                           JUMP Z, inc_LED3
061 2F10D        258              update_LED3: STORE s0, LED3_sequence
E: symbol not defined: `S0'.
062 200A8        259                           CALL LED_to_duty
063 2F104        260                           STORE s1, PWM_channel3
E: symbol not defined: `S1'.
                 261                           ;
064 0B10E        262                           FETCH s0, LED4_sequence             ;read sequence for LED4
E: symbol not defined: `S0'.
065 1C100        263                           COMPARE s0, 00
E: symbol not defined: `S0'.
066 3206C        264                           JUMP Z, test_LED4_start
067 181A0        265                           SUB s0, 10                          ;reset count if maximum
E: symbol not defined: `S0'.
068 32072        266                           JUMP Z, update_LED4
069 101A0        267                           ADD s0, 10
E: symbol not defined: `S0'.
06A 10110        268                 inc_LED4: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
06B 22072        269                           JUMP update_LED4
06C 0B10D        270          test_LED4_start: FETCH s1, LED3_sequence             ;start LED4 if LED3 = 4
E: symbol not defined: `S1'.
06D 1C140        271                           COMPARE s1, 04
E: symbol not defined: `S1'.
06E 3206A        272                           JUMP Z, inc_LED4
06F 0B10F        273                           FETCH s1, LED5_sequence             ;start LED4 if LED5 = 4
E: symbol not defined: `S1'.
070 1C140        274                           COMPARE s1, 04
E: symbol not defined: `S1'.
071 3206A        275                           JUMP Z, inc_LED4
072 2F10E        276              update_LED4: STORE s0, LED4_sequence
E: symbol not defined: `S0'.
073 200A8        277                           CALL LED_to_duty
074 2F105        278                           STORE s1, PWM_channel4
E: symbol not defined: `S1'.
                 279                           ;
075 0B10F        280                           FETCH s0, LED5_sequence             ;read sequence for LED5
E: symbol not defined: `S0'.
076 1C100        281                           COMPARE s0, 00
E: symbol not defined: `S0'.
077 3207D        282                           JUMP Z, test_LED5_start
078 181A0        283                           SUB s0, 10                          ;reset count if maximum
E: symbol not defined: `S0'.
079 32083        284                           JUMP Z, update_LED5
07A 101A0        285                           ADD s0, 10
E: symbol not defined: `S0'.
07B 10110        286                 inc_LED5: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
07C 22083        287                           JUMP update_LED5
07D 0B10E        288          test_LED5_start: FETCH s1, LED4_sequence             ;start LED5 if LED4 = 4
E: symbol not defined: `S1'.
07E 1C140        289                           COMPARE s1, 04
E: symbol not defined: `S1'.
07F 3207B        290                           JUMP Z, inc_LED5
080 0B110        291                           FETCH s1, LED6_sequence             ;start LED5 if LED6 = 4
E: symbol not defined: `S1'.
081 1C140        292                           COMPARE s1, 04
E: symbol not defined: `S1'.
082 3207B        293                           JUMP Z, inc_LED5
083 2F10F        294              update_LED5: STORE s0, LED5_sequence
E: symbol not defined: `S0'.
084 200A8        295                           CALL LED_to_duty
085 2F106        296                           STORE s1, PWM_channel5
E: symbol not defined: `S1'.
                 297                           ;
086 0B111        298                           FETCH s1, LED7_sequence             ; refresh LED6 if LED7 = 11 (0B hex) to reflect wave
E: symbol not defined: `S1'.
087 1C100        299                           COMPARE s1, 0B
E: symbol not defined: `S1'.
088 3608B        300                           JUMP NZ, normal_LED6
089 00140        301                           LOAD s0, 04
E: symbol not defined: `S0'.
08A 22096        302                           JUMP update_LED6
08B 0B110        303              normal_LED6: FETCH s0, LED6_sequence             ;read sequence for LED6
E: symbol not defined: `S0'.
08C 1C100        304                           COMPARE s0, 00
E: symbol not defined: `S0'.
08D 32093        305                           JUMP Z, test_LED6_start
08E 181A0        306                           SUB s0, 10                          ;reset count if maximum
E: symbol not defined: `S0'.
08F 32096        307                           JUMP Z, update_LED6
090 101A0        308                           ADD s0, 10
E: symbol not defined: `S0'.
091 10110        309                 inc_LED6: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
092 22096        310                           JUMP update_LED6
093 0B10F        311          test_LED6_start: FETCH s1, LED5_sequence             ;start LED6 if LED5 = 4
E: symbol not defined: `S1'.
094 1C140        312                           COMPARE s1, 04
E: symbol not defined: `S1'.
095 32091        313                           JUMP Z, inc_LED6
096 2F110        314              update_LED6: STORE s0, LED6_sequence
E: symbol not defined: `S0'.
097 200A8        315                           CALL LED_to_duty
098 2F107        316                           STORE s1, PWM_channel6
E: symbol not defined: `S1'.
                 317                           ;
099 0B111        318                           FETCH s0, LED7_sequence             ;read sequence for LED7
E: symbol not defined: `S0'.
09A 1C100        319                           COMPARE s0, 00
E: symbol not defined: `S0'.
09B 320A1        320                           JUMP Z, test_LED7_start
09C 18140        321                           SUB s0, 20                          ;Count longer to ensure end stops then reset count if maximum
E: symbol not defined: `S0'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
09D 320A4        322                           JUMP Z, update_LED7
09E 10140        323                           ADD s0, 20
E: symbol not defined: `S0'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
09F 10110        324                 inc_LED7: ADD s0, 01                          ;increment counter
E: symbol not defined: `S0'.
0A0 220A4        325                           JUMP update_LED7
0A1 0B110        326          test_LED7_start: FETCH s1, LED6_sequence             ;start LED7 if LED6 = 4
E: symbol not defined: `S1'.
0A2 1C140        327                           COMPARE s1, 04
E: symbol not defined: `S1'.
0A3 3209F        328                           JUMP Z, inc_LED7
0A4 2F111        329              update_LED7: STORE s0, LED7_sequence
E: symbol not defined: `S0'.
0A5 200A8        330                           CALL LED_to_duty
0A6 2F108        331                           STORE s1, PWM_channel7
E: symbol not defined: `S1'.
0A7 22013        332                           JUMP warm_start
                 333                           ;
                 334                           ;
                 335                           ; Convert LED sequence number into PWM intensity figure
                 336                           ;
                 337                           ; LEDs duty cycle values are 0,1,2,4,8,16,32 and 64 because they appear to give what
                 338                           ; appears to be a fairly liner change in intensity and provides a simple way to set
                 339                           ; the duty value.
                 340                           ;
                 341                           ; Provide sequence value in register s0 and intensity will be
                 342                           ; returned in register s1.
                 343                           ;
                 344                           ; s0   s1
                 345                           ; 00   00
                 346                           ; 01   01
                 347                           ; 02   02
                 348                           ; 03   04
                 349                           ; 04   08
                 350                           ; 05   10
                 351                           ; 06   20
                 352                           ; 07   40
                 353                           ; 08   80
                 354                           ; 09   40
                 355                           ; 0A   20
                 356                           ; 0B   10
                 357                           ; 0C   08
                 358                           ; 0D   04
                 359                           ; 0E   02
                 360                           ; 0F   01
                 361                           ; 10   00  and zero for all larger values of s0
                 362                           ;
0A8 00100        363              LED_to_duty: LOAD s1, 00
E: symbol not defined: `S1'.
0A9 1C100        364                           COMPARE s0, 00                      ;test for zero
E: symbol not defined: `S0'.
0AA 31000        365                           RETURN Z
0AB 00110        366                           LOAD s1, 01                         ;inject '1'
E: symbol not defined: `S1'.
0AC 18110        367               go_up_loop: SUB s0, 01
E: symbol not defined: `S0'.
0AD 31000        368                           RETURN Z
0AE 14106        369                           SL0 s1                              ;multiply by 2
E: symbol not defined: `S1'.
0AF 3A0B1        370                           JUMP C, go_down
0B0 220AC        371                           JUMP go_up_loop
0B1 00180        372                  go_down: LOAD s1, 40
E: symbol not defined: `S1'.
W: value out of range: 40, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
0B2 18110        373             go_down_loop: SUB s0, 01
E: symbol not defined: `S0'.
0B3 31000        374                           RETURN Z
0B4 1410E        375                           SR0 s1                              ;divide by 2
E: symbol not defined: `S1'.
0B5 220B2        376                           JUMP go_down_loop
                 377                           ;
                 378                           ;
                 379                           ;
                 380                           ;**************************************************************************************
                 381                           ; Authentication Check and fail procedure
                 382                           ;**************************************************************************************
                 383                           ;
                 384                           ; The authentication check is performed by issuing and interrupt to the authentication
                 385                           ; processor and then observing the simple text string that it returns via the link FIFO
                 386                           ; buffer.
                 387                           ;
                 388                           ; PASS - Design is authorised to work.
                 389                           ; FAIL - Design is not authorised and should stop working normally.
                 390                           ;
                 391                           ;
                 392                           ;ASCII character values that are used in messages
                 393                           ;
  00029          394                           CONSTANT character_A, 41
  0002E          395                           CONSTANT character_F, 46
  00031          396                           CONSTANT character_I, 49
                 397                           CONSTANT character_L, 4C
E: identifier cannot start with a digit: `4C'.
E: unexpected end of line.
  00032          398                           CONSTANT character_P, 50
  00035          399                           CONSTANT character_S, 53
                 400                           ;
                 401                           ;
0B6 00110        402     authentication_check: LOAD s0, link_fifo_reset            ;clear link FIFO to ensure no unexpected characters
E: symbol not defined: `S0'.
0B7 2D114        403                           OUTPUT s0, link_fifo_control_port
E: symbol not defined: `S0'.
0B8 00100        404                           LOAD s0, 00
E: symbol not defined: `S0'.
0B9 2D114        405                           OUTPUT s0, link_fifo_control_port
E: symbol not defined: `S0'.
                 406                           ;
0BA 00110        407                           LOAD s0, security_interrupt         ;generate interrupt to authentication processor
E: symbol not defined: `S0'.
0BB 2D128        408                           OUTPUT s0, security_request_port
E: symbol not defined: `S0'.
0BC 00100        409                           LOAD s0, 00
E: symbol not defined: `S0'.
0BD 2D128        410                           OUTPUT s0, security_request_port
E: symbol not defined: `S0'.
                 411                           ;
0BE 200F9        412                           CALL read_link_FIFO                 ;read each character and compare
0BF 1C120        413                           COMPARE s0, character_P
E: symbol not defined: `S0'.
W: value out of range: 50, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
0C0 360CB        414                           JUMP NZ, fail_confirm
0C1 200F9        415                           CALL read_link_FIFO
0C2 1C190        416                           COMPARE s0, character_A
E: symbol not defined: `S0'.
W: value out of range: 41, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
0C3 360CB        417                           JUMP NZ, fail_confirm
0C4 200F9        418                           CALL read_link_FIFO
0C5 1C150        419                           COMPARE s0, character_S
E: symbol not defined: `S0'.
W: value out of range: 53, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
0C6 360CB        420                           JUMP NZ, fail_confirm
0C7 200F9        421                           CALL read_link_FIFO
0C8 1C150        422                           COMPARE s0, character_S
E: symbol not defined: `S0'.
W: value out of range: 53, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
0C9 360CB        423                           JUMP NZ, fail_confirm
0CA 22015        424                           JUMP normal_LED_sequence            ;Continue normal operation for PASS message
                 425                           ;
                 426                           ;
                 427                           ; To confirm that the authentication is really a FAIL message
                 428                           ; another request is made to the authentication processor and tested.
                 429                           ;
0CB 00110        430             fail_confirm: LOAD s0, FF                         ;short delay to ensure authentication processor is ready
E: symbol not defined: `S0'.
E: symbol not defined: `FF'.
0CC 18110        431            request_delay: SUB s0, 01                          ;   to respond to new interrupt request
E: symbol not defined: `S0'.
0CD 360CC        432                           JUMP NZ, request_delay
                 433                           ;
0CE 00110        434                           LOAD s0, link_fifo_reset            ;clear link FIFO to ensure no unexpected characters
E: symbol not defined: `S0'.
0CF 2D114        435                           OUTPUT s0, link_fifo_control_port
E: symbol not defined: `S0'.
0D0 00100        436                           LOAD s0, 00
E: symbol not defined: `S0'.
0D1 2D114        437                           OUTPUT s0, link_fifo_control_port
E: symbol not defined: `S0'.
                 438                           ;
0D2 00110        439                           LOAD s0, security_interrupt         ;generate interrupt to authentication processor
E: symbol not defined: `S0'.
0D3 2D128        440                           OUTPUT s0, security_request_port
E: symbol not defined: `S0'.
0D4 00100        441                           LOAD s0, 00
E: symbol not defined: `S0'.
0D5 2D128        442                           OUTPUT s0, security_request_port
E: symbol not defined: `S0'.
                 443                           ;
0D6 200F9        444                           CALL read_link_FIFO                 ;read each character and compare
0D7 1C1E0        445                           COMPARE s0, character_F
E: symbol not defined: `S0'.
W: value out of range: 46, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
0D8 36015        446                           JUMP NZ, normal_LED_sequence
0D9 200F9        447                           CALL read_link_FIFO
0DA 1C190        448                           COMPARE s0, character_A
E: symbol not defined: `S0'.
W: value out of range: 41, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
0DB 36015        449                           JUMP NZ, normal_LED_sequence
0DC 200F9        450                           CALL read_link_FIFO
0DD 1C110        451                           COMPARE s0, character_I
E: symbol not defined: `S0'.
W: value out of range: 49, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
0DE 36015        452                           JUMP NZ, normal_LED_sequence
0DF 200F9        453                           CALL read_link_FIFO
0E0 1C110        454                           COMPARE s0, character_L
E: symbol not defined: `S0'.
E: symbol not defined: `CHARACTER_L'.
0E1 36015        455                           JUMP NZ, normal_LED_sequence
                 456                           ;
                 457                           ;
                 458                           ; When the design fails to authenticate the LEDs will appear to
                 459                           ; turn on and then slowly fade to off using PWM.
                 460                           ;
0E2 00110        461      failed_LED_sequence: LOAD s0, FF                         ;maximum intensity on all LEDs
E: symbol not defined: `S0'.
E: symbol not defined: `FF'.
0E3 00100        462                           LOAD s4, 00                         ;reset fade rate control
E: symbol not defined: `S4'.
0E4 00110        463             all_LED_fade: LOAD s1, PWM_channel0
E: symbol not defined: `S1'.
0E5 2F101        464        all_LED_fade_loop: STORE s0, (s1)
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
0E6 1C180        465                           COMPARE s1, PWM_channel7
E: symbol not defined: `S1'.
0E7 320EA        466                           JUMP Z, decay_LEDs
0E8 10110        467                           ADD s1, 01
E: symbol not defined: `S1'.
0E9 220E5        468                           JUMP all_LED_fade_loop
0EA 00110        469               decay_LEDs: LOAD s1, s4                         ;software delay starts quickly and slows down because LEDs are non-linear.
E: symbol not defined: `S1'.
E: symbol not defined: `S4'.
0EB 00120        470                  wait_s1: LOAD s2, 18
E: symbol not defined: `S2'.
W: value out of range: 18, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
0EC 00110        471                  wait_s2: LOAD s3, FF
E: symbol not defined: `S3'.
E: symbol not defined: `FF'.
0ED 18110        472                  wait_s3: SUB s3, 01
E: symbol not defined: `S3'.
0EE 360ED        473                           JUMP NZ, wait_s3
0EF 18110        474                           SUB s2, 01
E: symbol not defined: `S2'.
0F0 360EC        475                           JUMP NZ, wait_s2
0F1 18110        476                           SUB s1, 01
E: symbol not defined: `S1'.
0F2 360EB        477                           JUMP NZ, wait_s1
0F3 1C100        478                           COMPARE s0, 00                      ;test for fully off
E: symbol not defined: `S0'.
0F4 320F8        479                           JUMP Z, stop_completely
0F5 18110        480                           SUB s0, 01                          ;fade LEDs
E: symbol not defined: `S0'.
0F6 10110        481                           ADD s4, 01                          ;slow fade rate as intensity decreases
E: symbol not defined: `S4'.
0F7 220E4        482                           JUMP all_LED_fade
                 483                           ;
0F8 220F8        484          stop_completely: JUMP stop_completely
                 485                           ;
                 486                           ;**************************************************************************************
                 487                           ; Read Byte from Link FIFO
                 488                           ;**************************************************************************************
                 489                           ;
                 490                           ; The routine first tests the FIFO buffer to see if data is present.
                 491                           ; If the FIFO is empty, the routine waits until there is a character to read.
                 492                           ; the read value is returned in register s0.
                 493                           ;
                 494                           ;
0F9 09101        495           read_link_FIFO: INPUT s0, link_FIFO_status_port     ;test FIFO buffer
E: symbol not defined: `S0'.
0FA 0C110        496                           TEST s0, link_FIFO_data_present     ;wait if empty
E: symbol not defined: `S0'.
0FB 320F9        497                           JUMP Z, read_link_FIFO
0FC 09102        498                           INPUT s0, link_FIFO_read_port       ;read data from FIFO
E: symbol not defined: `S0'.
0FD 25000        499                           RETURN
                 500                           ;
                 501                           ;
                 502                           ;**************************************************************************************
                 503                           ; Interrupt Service Routine (ISR)
                 504                           ;**************************************************************************************
                 505                           ;
                 506                           ; Interrupts occur at 3.92us intervals and are used to generate the PWM pulses generated
                 507                           ; at a PRF of 1KHz. The 3.92us interrupt rate corresponds with a resolution of 256 steps
                 508                           ; over the 1ms associated with the 1KHz PRF.
                 509                           ;
                 510                           ; The ISR is self contained and all registers used are preserved. Scratch pad memory
                 511                           ; locations are used to determine the desired duty factor for each of 8 channels.
                 512                           ;
                 513                           ; Note that an interrupt is generated every 196 clock cycles. This means that there is
                 514                           ; only time to execute 98 instructions between each interrupt. This ISR is 35 instructions
                 515                           ; long. A further 3 instructions are also consumed by the interrupt process
                 516                           ; (abandoned instruction, virtual CALL to 3FF and the interrupt vector JUMP) and hence
                 517                           ; PicoBlaze has approximately 63% of its time available for other tasks in the main program.
                 518                           ;
                 519                           ; Although a loop would normal be employed in software to process each of 8 channels,
                 520                           ; the implementation of a loop would increase the number of instructions which needed to
                 521                           ; be executed significantly reduce the time available for the main program to operate.
                 522                           ; Consequently the code is written out in a linear fashion which consumes more program
                 523                           ; space but which executes faster.
                 524                           ;
0FE 2F100        525                      ISR: STORE s0, ISR_preserve_s0           ;preserve registers to be used
E: symbol not defined: `S0'.
0FF 2F101        526                           STORE s1, ISR_preserve_s1
E: symbol not defined: `S1'.
E: symbol not defined: `ISR_PRESERVE_S1'.
100 2F101        527                           STORE s2, ISR_preserve_s2
E: symbol not defined: `S2'.
E: symbol not defined: `ISR_PRESERVE_S2'.
                 528                           ;Determine the number of steps currently through the 1ms PWM cycle
101 0B100        529                           FETCH s1, PWM_duty_counter          ;read 8-bit counter of steps
E: symbol not defined: `S1'.
102 10110        530                           ADD s1, 01                          ;increment counter (will roll over to zero)
E: symbol not defined: `S1'.
103 2F100        531                           STORE s1, PWM_duty_counter          ;update count value in memory for next interrupt.
E: symbol not defined: `S1'.
                 532                           ;Read duty factor for each channel and compare it with the duty counter and set or
                 533                           ;reset a bit in register s2 accordingly.
104 0B108        534                           FETCH s0, PWM_channel7              ;read desired setting of pulse width
E: symbol not defined: `S0'.
105 1C110        535                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
106 14100        536                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
107 0B107        537                           FETCH s0, PWM_channel6              ;read desired setting of pulse width
E: symbol not defined: `S0'.
108 1C110        538                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
109 14100        539                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
10A 0B106        540                           FETCH s0, PWM_channel5              ;read desired setting of pulse width
E: symbol not defined: `S0'.
10B 1C110        541                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
10C 14100        542                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
10D 0B105        543                           FETCH s0, PWM_channel4              ;read desired setting of pulse width
E: symbol not defined: `S0'.
10E 1C110        544                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
10F 14100        545                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
110 0B104        546                           FETCH s0, PWM_channel3              ;read desired setting of pulse width
E: symbol not defined: `S0'.
111 1C110        547                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
112 14100        548                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
113 0B103        549                           FETCH s0, PWM_channel2              ;read desired setting of pulse width
E: symbol not defined: `S0'.
114 1C110        550                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
115 14100        551                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
116 0B102        552                           FETCH s0, PWM_channel1              ;read desired setting of pulse width
E: symbol not defined: `S0'.
117 1C110        553                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
118 14100        554                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
119 0B101        555                           FETCH s0, PWM_channel0              ;read desired setting of pulse width
E: symbol not defined: `S0'.
11A 1C110        556                           COMPARE s1, s0                      ;set carry flag if duty factor > duty counter
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
11B 14100        557                           SLA s2                              ;shift carry into register s2
E: symbol not defined: `S2'.
11C 2D150        558                           OUTPUT s2, LED_port                 ;drive LEDs
E: symbol not defined: `S2'.
11D 0B100        559                           FETCH s0, ISR_preserve_s0           ;restore register values
E: symbol not defined: `S0'.
11E 0B101        560                           FETCH s1, ISR_preserve_s1
E: symbol not defined: `S1'.
E: symbol not defined: `ISR_PRESERVE_S1'.
11F 0B101        561                           FETCH s2, ISR_preserve_s2
E: symbol not defined: `S2'.
E: symbol not defined: `ISR_PRESERVE_S2'.
120 29001        562                           RETURNI ENABLE
                 563                           ;
                 564                           ;
                 565                           ;**************************************************************************************
                 566                           ; Interrupt Vector
                 567                           ;**************************************************************************************
                 568                           ;
                 569                           ADDRESS 3FF
E: identifier cannot start with a digit: `3FF'.
E: directive ADDRESS requires a single argument.
121 220FE        570                           JUMP ISR
                 571                           ;
                 572                           ;
