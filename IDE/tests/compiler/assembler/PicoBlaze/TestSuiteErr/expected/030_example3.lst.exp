                   1                              ; KCPSM3 Program - Security control and design authentication.
                   2                               ;
                   3                               ; This program is provided for use with the reference design
                   4                               ; 'low_cost_design_authentication_for_spartan_3e.vhd' implemented on the Spartan-3E Starter
                   5                               ; Kit. The program provides design authentication control over the 'real' application as well
                   6                               ; as providing features to enable evaluation of the design authentication method.
                   7                               ;
                   8                               ; Ken Chapman - Xilinx Ltd
                   9                               ;
                  10                               ; Version v1.00 - 1st November 2006
                  11                               ;
                  12                               ; This code communicates with the StrataFLASH memory to implement a design authentication
                  13                               ; algorithm which then enables the main application design in various ways. To facilitate
                  14                               ; evaluation of design authentication this design also interacts with the LCD display
                  15                               ; and PC (via UART based RS232 link) to indicate authentication status and allow control
                  16                               ; over the authentication validity of the design. Therefore this program includes:-
                  17                               ;
                  18                               ; 1) Code required to check authorisation which would be included in a production design.
                  19                               ; 2) Code required to program the authentication value into FLASH memory which would
                  20                               ;    typically only be implemented in a special design used at a secure programming
                  21                               ;    facility as part of the production programming procedure.
                  22                               ; 3) Code to allow you to see what is happening at all stages which is code that should
                  23                               ;    never be included in a real production design as it reveals secrets that should remain
                  24                               ;    hidden in order to make the task of breaking the security as difficult as possible.
                  25                               ;
                  26                               ; IMPORTANT - Feel free to use this code as a reference for your own security scheme but
                  27                               ;             never use this code unmodified.
                  28                               ;
                  29                               ;
                  30                               ;**************************************************************************************
                  31                               ; NOTICE:
                  32                               ;
                  33                               ; Copyright Xilinx, Inc. 2006.   This code may be contain portions patented by other
                  34                               ; third parties.  By providing this core as one possible implementation of a standard,
                  35                               ; Xilinx is making no representation that the provided implementation of this standard
                  36                               ; is free from any claims of infringement by any third party.  Xilinx expressly
                  37                               ; disclaims any warranty with respect to the adequacy of the implementation, including
                  38                               ; but not limited to any warranty or representation that the implementation is free
                  39                               ; from claims of any third party.  Furthermore, Xilinx is providing this core as a
                  40                               ; courtesy to you and suggests that you contact all third parties to obtain the
                  41                               ; necessary rights to use this implementation.
                  42                               ;
                  43                               ;
                  44                               ;**************************************************************************************
                  45                               ; Port definitions
                  46                               ;**************************************************************************************
                  47                               ;
                  48                               ;
                  49                               ; UART ports
                  50                               ;
                  51                               ; Connection to PC to allow display of progress information and to operate simple
                  52                               ; menu of commands.
                  53                               ;
  00000           54                               CONSTANT status_port, 00                 ;UART and memory status
  00001           55                               CONSTANT tx_half_full, 01                ;  Transmitter     half full - bit0
  00002           56                               CONSTANT tx_full, 02                     ;    FIFO            tx_full - bit1
  00004           57                               CONSTANT rx_data_present, 04             ;  Receiver     data present - bit2
  00008           58                               CONSTANT rx_half_full, 08                ;    FIFO          half full - bit3
  0000A           59                               CONSTANT rx_full, 10                     ;                    rx_full - bit4
  00014           60                               CONSTANT spare1, 20                      ;                  spare '0' - bit5
  00028           61                               CONSTANT spare2, 40                      ;                  spare '0' - bit6
  00050           62                               CONSTANT strataflash_sts, 80             ;  StrataFLASH           STS - bit7
                  63                               ;
  00001           64                               CONSTANT UART_read_port, 01              ;UART Rx data input
                  65                               ;
  00008           66                               CONSTANT UART_write_port, 08             ;UART Tx data output
                  67                               ;
                  68                               ;
                  69                               ; LCD Display
                  70                               ;
                  71                               ;The master enable signal is not used by the LCD display itself
                  72                               ;but is used to prevent any contention with the StrataFLASH memory that
                  73                               ;is connected to the same data pins. In this design the StrataFLASH memory is
                  74                               ;used in 8-bit mode so not contention should exist but this master enable
                  75                               ;facilty is then available for anyone wanting to modify the design for use
                  76                               ;with a 16-bit interface.
                  77                               ;
  00014           78                               CONSTANT LCD_output_port, 20             ;LCD character module output data and control
  00001           79                               CONSTANT LCD_E, 01                       ;   active High Enable        E - bit0
  00002           80                               CONSTANT LCD_RW, 02                      ;   Read=1 Write=0           RW - bit1
  00004           81                               CONSTANT LCD_RS, 04                      ;   Instruction=0 Data=1     RS - bit2
  00008           82                               CONSTANT LCD_drive, 08                   ;   Master enable (active High) - bit3
  0000A           83                               CONSTANT LCD_DB4, 10                     ;   4-bit              Data DB4 - bit4
  00014           84                               CONSTANT LCD_DB5, 20                     ;   interface          Data DB5 - bit5
  00028           85                               CONSTANT LCD_DB6, 40                     ;                      Data DB6 - bit6
  00050           86                               CONSTANT LCD_DB7, 80                     ;                      Data DB7 - bit7
                  87                               ;
                  88                               ;
  00003           89                               CONSTANT LCD_input_port, 03              ;LCD character module input data
  00001           90                               CONSTANT LCD_read_spare0, 01             ;    Spare bits               - bit0
  00002           91                               CONSTANT LCD_read_spare1, 02             ;    are zero                 - bit1
  00004           92                               CONSTANT LCD_read_spare2, 04             ;                             - bit2
  00008           93                               CONSTANT LCD_read_spare3, 08             ;                             - bit3
  0000A           94                               CONSTANT LCD_read_DB4, 10                ;    4-bit           Data DB4 - bit4
  00014           95                               CONSTANT LCD_read_DB5, 20                ;    interface       Data DB5 - bit5
  00028           96                               CONSTANT LCD_read_DB6, 40                ;                    Data DB6 - bit6
  00050           97                               CONSTANT LCD_read_DB7, 80                ;                    Data DB7 - bit7
                  98                               ;
                  99                               ;
                 100                               ;
                 101                               ; StrataFLASH memory ports
                 102                               ;
                 103                               ; The FLASH memory is used to hold the authentication value as well as provide the
                 104                               ; unique serial number from which the authentication algorithm computes the value.
                 105                               ; In practice, the FLASH will also hold the configuration image for the Spartan device.
                 106                               ;
                 107                               ;
  00002          108                               CONSTANT SF_data_in_port, 02             ;Read data from StrataFLASH device
                 109                               ;
  00050          110                               CONSTANT SF_data_out_port, 80            ;Data to write into StrataFLASH device
                 111                               ;
  00053          112                               CONSTANT SF_addr_hi_port, 83             ;StrataFLASH address[21:16] (6 LSB's)
  00052          113                               CONSTANT SF_addr_mi_port, 82             ;StrataFLASH address[15:8]
  00051          114                               CONSTANT SF_addr_lo_port, 81             ;StrataFLASH address[7:0]
                 115                               ;
  00028          116                               CONSTANT SF_control_port, 40             ;StrataFLASH control
  00001          117                               CONSTANT SF_read, 01                     ;         active High read - bit0
  00002          118                               CONSTANT SF_ce, 02                       ; active Low device enable - bit1
  00004          119                               CONSTANT SF_we, 04                       ;         active Low write - bit2
                 120                               ;
                 121                               ;
                 122                               ; Design Authentication enable/disable signals.
                 123                               ;
                 124                               ; Hardware controls over the 'real' application.
                 125                               ;
  0000A          126                               CONSTANT authentication_control_port, 10 ;Design disable control port
  00001          127                               CONSTANT security_disable_interrupts, 01 ;   active High disable of interrupt generation - bit0
  00002          128                               CONSTANT security_disable_outputs, 02    ;            active High disable of output pins - bit1
                 129                               ;
                 130                               ; Pseudo Random number generator
                 131                               ;
  00004          132                               CONSTANT random_value_port, 04           ;read LFSR counter value
                 133                               ;
                 134                               ;
                 135                               ; Link FIFO buffer
                 136                               ;
                 137                               ; Provides a connection to the 'real' application such that 'soft tokens' in the
                 138                               ; form of short messages to be passed to the 'real' application to enable or disable
                 139                               ; it depending on the authentication status.
                 140                               ;
  00004          141                               CONSTANT link_FIFO_write_port, 04        ;write data to FIFO
                 142                               ;
                 143                               ;
                 144                               ;**************************************************************************************
                 145                               ; Special Register usage
                 146                               ;**************************************************************************************
                 147                               ;
  00001          148                               NAMEREG sF, UART_data                    ;used to pass data to and from the UART
E: symbol not defined: `SF'.
                 149                               ;
                 150                               ;
                 151                               ;
                 152                               ;**************************************************************************************
                 153                               ;Scratch Pad Memory Locations
                 154                               ;**************************************************************************************
                 155                               ;
  00000          156                               CONSTANT ISR_preserve_s0, 00             ;preserve register contents during Interrupt Service Routine
                 157                               ;
                 158                               ;
  0000A          159                               CONSTANT serial_number0, 10              ;64-bit serial number of StrataFlash
  0000B          160                               CONSTANT serial_number1, 11              ;LS-Byte first
  0000C          161                               CONSTANT serial_number2, 12
  0000D          162                               CONSTANT serial_number3, 13
  0000E          163                               CONSTANT serial_number4, 14
  0000F          164                               CONSTANT serial_number5, 15
  00010          165                               CONSTANT serial_number6, 16
  00011          166                               CONSTANT serial_number7, 17
                 167                               ;
                 168                               ;
  00012          169                               CONSTANT computed_CRC0, 18               ;computed 16-bit CRC based on the
  00013          170                               CONSTANT computed_CRC1, 19               ;  StrataFlash unique serial number (LS-Byte first)
                 171                               ;
                 172                               ;
                 173                               CONSTANT authentication_CRC0, 1A         ;16-bit CRC value read from authentication
E: identifier cannot start with a digit: `1A'.
E: unexpected end of line.
  00001          174                               CONSTANT authentication_CRC1, 1B         ;  area of StrataFLASH memory (LS-Byte first)
                 175                               ;
                 176                               ;
                 177                               CONSTANT authentication_status, 1C       ;Status of design authentication
E: identifier cannot start with a digit: `1C'.
E: unexpected end of line.
                 178                               ;
                 179                               ;
                 180                               ;**************************************************************************************
                 181                               ;Useful data constants
                 182                               ;**************************************************************************************
                 183                               ;
                 184                               ;
                 185                               ;
                 186                               ;Constant to define a software delay of 1us. This must be adjusted to reflect the
                 187                               ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
                 188                               ;calculation highly predictable. The '6' in the following equation even allows for
                 189                               ;'CALL delay_1us' instruction in the initiating code.
                 190                               ;
                 191                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                 192                               ;
                 193                               ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
                 194                               ;For clock rates below 10MHz the value of 1 must be used and the operation will
                 195                               ;become lower than intended.
                 196                               ;
  00000          197                               CONSTANT delay_1us_constant, 0B
                 198                               ;
                 199                               ;
                 200                               ;
                 201                               ;
                 202                               ;ASCII table
                 203                               ;
  0003D          204                               CONSTANT character_a, 61
  0003E          205                               CONSTANT character_b, 62
  0003F          206                               CONSTANT character_c, 63
  00040          207                               CONSTANT character_d, 64
  00041          208                               CONSTANT character_e, 65
  00042          209                               CONSTANT character_f, 66
  00043          210                               CONSTANT character_g, 67
  00044          211                               CONSTANT character_h, 68
  00045          212                               CONSTANT character_i, 69
                 213                               CONSTANT character_j, 6A
E: identifier cannot start with a digit: `6A'.
E: unexpected end of line.
                 214                               CONSTANT character_k, 6B
E: identifier cannot start with a digit: `6B'.
E: unexpected end of line.
                 215                               CONSTANT character_l, 6C
E: identifier cannot start with a digit: `6C'.
E: unexpected end of line.
  00006          216                               CONSTANT character_m, 6D
                 217                               CONSTANT character_n, 6E
E: identifier cannot start with a digit: `6E'.
E: unexpected end of line.
                 218                               CONSTANT character_o, 6F
E: identifier cannot start with a digit: `6F'.
E: unexpected end of line.
  00046          219                               CONSTANT character_p, 70
  00047          220                               CONSTANT character_q, 71
  00048          221                               CONSTANT character_r, 72
  00049          222                               CONSTANT character_s, 73
  0004A          223                               CONSTANT character_t, 74
  0004B          224                               CONSTANT character_u, 75
  0004C          225                               CONSTANT character_v, 76
  0004D          226                               CONSTANT character_w, 77
  0004E          227                               CONSTANT character_x, 78
  0004F          228                               CONSTANT character_y, 79
                 229                               CONSTANT character_z, 7A
E: identifier cannot start with a digit: `7A'.
E: unexpected end of line.
                 230                               CONSTANT character_A, 41
E: symbol already defined: "CHARACTER_A".
                 231                               CONSTANT character_B, 42
E: symbol already defined: "CHARACTER_B".
                 232                               CONSTANT character_C, 43
E: symbol already defined: "CHARACTER_C".
                 233                               CONSTANT character_D, 44
E: symbol already defined: "CHARACTER_D".
                 234                               CONSTANT character_E, 45
E: symbol already defined: "CHARACTER_E".
                 235                               CONSTANT character_F, 46
E: symbol already defined: "CHARACTER_F".
                 236                               CONSTANT character_G, 47
E: symbol already defined: "CHARACTER_G".
                 237                               CONSTANT character_H, 48
E: symbol already defined: "CHARACTER_H".
                 238                               CONSTANT character_I, 49
E: symbol already defined: "CHARACTER_I".
                 239                               CONSTANT character_J, 4A
E: identifier cannot start with a digit: `4A'.
E: unexpected end of line.
                 240                               CONSTANT character_K, 4B
E: identifier cannot start with a digit: `4B'.
E: unexpected end of line.
                 241                               CONSTANT character_L, 4C
E: identifier cannot start with a digit: `4C'.
E: unexpected end of line.
                 242                               CONSTANT character_M, 4D
E: symbol already defined: "CHARACTER_M".
                 243                               CONSTANT character_N, 4E
E: identifier cannot start with a digit: `4E'.
E: unexpected end of line.
                 244                               CONSTANT character_O, 4F
E: identifier cannot start with a digit: `4F'.
E: unexpected end of line.
                 245                               CONSTANT character_P, 50
E: symbol already defined: "CHARACTER_P".
                 246                               CONSTANT character_Q, 51
E: symbol already defined: "CHARACTER_Q".
                 247                               CONSTANT character_R, 52
E: symbol already defined: "CHARACTER_R".
                 248                               CONSTANT character_S, 53
E: symbol already defined: "CHARACTER_S".
                 249                               CONSTANT character_T, 54
E: symbol already defined: "CHARACTER_T".
                 250                               CONSTANT character_U, 55
E: symbol already defined: "CHARACTER_U".
                 251                               CONSTANT character_V, 56
E: symbol already defined: "CHARACTER_V".
                 252                               CONSTANT character_W, 57
E: symbol already defined: "CHARACTER_W".
                 253                               CONSTANT character_X, 58
E: symbol already defined: "CHARACTER_X".
                 254                               CONSTANT character_Y, 59
E: symbol already defined: "CHARACTER_Y".
                 255                               CONSTANT character_Z, 5A
E: identifier cannot start with a digit: `5A'.
E: unexpected end of line.
  0001E          256                               CONSTANT character_0, 30
  0001F          257                               CONSTANT character_1, 31
  00020          258                               CONSTANT character_2, 32
  00021          259                               CONSTANT character_3, 33
  00022          260                               CONSTANT character_4, 34
  00023          261                               CONSTANT character_5, 35
  00024          262                               CONSTANT character_6, 36
  00025          263                               CONSTANT character_7, 37
  00026          264                               CONSTANT character_8, 38
  00027          265                               CONSTANT character_9, 39
                 266                               CONSTANT character_colon, 3A
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
                 267                               CONSTANT character_fullstop, 2E
E: identifier cannot start with a digit: `2E'.
E: unexpected end of line.
                 268                               CONSTANT character_semi_colon, 3B
E: identifier cannot start with a digit: `3B'.
E: unexpected end of line.
  00002          269                               CONSTANT character_minus, 2D
                 270                               CONSTANT character_divide, 2F            ;'/'
E: identifier cannot start with a digit: `2F'.
E: unexpected end of line.
                 271                               CONSTANT character_plus, 2B
E: identifier cannot start with a digit: `2B'.
E: unexpected end of line.
                 272                               CONSTANT character_comma, 2C
E: identifier cannot start with a digit: `2C'.
E: unexpected end of line.
                 273                               CONSTANT character_less_than, 3C
E: identifier cannot start with a digit: `3C'.
E: unexpected end of line.
                 274                               CONSTANT character_greater_than, 3E
E: identifier cannot start with a digit: `3E'.
E: unexpected end of line.
  00003          275                               CONSTANT character_equals, 3D
  00014          276                               CONSTANT character_space, 20
  00000          277                               CONSTANT character_CR, 0D                ;carriage return
                 278                               CONSTANT character_question, 3F          ;'?'
E: identifier cannot start with a digit: `3F'.
E: unexpected end of line.
  00018          279                               CONSTANT character_dollar, 24
  00015          280                               CONSTANT character_exclaim, 21           ;'!'
  00008          281                               CONSTANT character_BS, 08                ;Back Space command character
                 282                               ;
                 283                               ;
                 284                               ;
                 285                               ;
                 286                               ;
                 287                               ;**************************************************************************************
                 288                               ;Initialise the system
                 289                               ;**************************************************************************************
                 290                               ;
000 200D5        291                   cold_start: CALL SF_init                             ;initialise StrataFLASH controls
001 00100        292                               LOAD s0, 00                              ;Start with application enabled in hardware
E: symbol not defined: `S0'.
002 2D10A        293                               OUTPUT s0, authentication_control_port
E: symbol not defined: `S0'.
003 00160        294                               LOAD s0, character_P                     ;start with design enabled by software (see ISR)
E: symbol not defined: `S0'.
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
004 2F101        295                               STORE s0, authentication_status
E: symbol not defined: `S0'.
E: symbol not defined: `AUTHENTICATION_STATUS'.
005 20346        296                               CALL delay_1s                            ;delay to allow system to settle
006 20316        297                               CALL LCD_reset                           ;Initialise the LCD
                 298                               ;
007 28001        299                               ENABLE INTERRUPT                         ;interrupts to provide software enable to application
                 300                               ;
                 301                               ;**************************************************************************************
                 302                               ; Main program
                 303                               ;**************************************************************************************
                 304                               ;
                 305                               ; The main program follows a logical sequence of events describing the power on and
                 306                               ; authentication process of a design. This process will is either successfully authorises
                 307                               ; the 'real' application to operate or fail to authenticate and disable the 'real'
                 308                               ; application in a similar way to a production design. The only difference that it keeps
                 309                               ; you informed about what it is doing on both the LCD display and PC terminal via the UART.
                 310                               ; A real production design should keep all details hidden.
                 311                               ;
                 312                               ; Following the authentication check and control over the 'real' application a simple menu
                 313                               ; is provided on the PC terminal to allow you to read, write and erase the authentication
                 314                               ; area of the StrataFLASH memory and therefore evaluate the design authentication security
                 315                               ; of this reference design.
                 316                               ;
                 317                               ;
                 318                               ;
                 319                               ; Write welcome message to LCD display
                 320                               ;
008 001C0        321                   warm_start: LOAD s5, 12                              ;Line 1 position 2
E: symbol not defined: `S5'.
009 2032B        322                               CALL LCD_cursor
00A 2034F        323                               CALL disp_PicoBlaze                      ;Display 'PicoBlaze'
00B 00190        324                               LOAD s5, 25                              ;Line 2 position 5
E: symbol not defined: `S5'.
W: value out of range: 25, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
00C 2032B        325                               CALL LCD_cursor
00D 20362        326                               CALL disp_Security                       ;Display 'Security'
                 327                               ;
                 328                               ; Write welcome message to PC via UART
                 329                               ;
00E 20154        330                               CALL send_welcome
                 331                               ;
                 332                               ;
                 333                               ; Display 'Copyright Ken Chapman 2006' via the UART.
                 334                               ;
                 335                               ; This message is significant because it demonstrates that the design now has a 'watermark'.
                 336                               ; The ASCII codes for this string are part of the PicoBlaze program stored in a Block
                 337                               ; Memory and therefore are also part of the configuration bit stream. If someone tries to
                 338                               ; change or delete this copyright message the hardware design will detect the change to the
                 339                               ; Block memory contents and also inhibit the design.
                 340                               ;
00F 201A4        341                               CALL send_Copyright
                 342                               ;
                 343                               ;
                 344                               ;
                 345                               ; Delay of 10 seconds before performing any security checks.
                 346                               ;
                 347                               ; This allows the design to work for a short time which could be important for
                 348                               ; production testing.
                 349                               ;
                 350                               ; Having a significant time delay (days or weeks) before security checks means that someone
                 351                               ; attempting to clone the product may not be aware that there is any form of design security
                 352                               ; at all until products are in the field are failing. A time delay also impedes the ability to
                 353                               ; attempt to break the security and confirm if an attempt is or is not successful.
                 354                               ;
                 355                               LOAD s5, 0A                              ;delay of 10 seconds.
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
010 2034B        356                               CALL delay_Ns
                 357                               ;
                 358                               ;
                 359                               ;
                 360                               ; Read serial number of the StrataFLASH memory.
                 361                               ; The whole principle of low cost design security is based on this unique number. Clearly this
                 362                               ; number is not a secret, but what we then go on to do with it should normally be kept secret.
                 363                               ;
011 200E6        364                               CALL read_SF_serial_number               ;read serial number from FLASH memory
012 20062        365                               CALL send_serial_number                  ;send value to UART for display on PC
013 2006D        366                               CALL disp_serial_number                  ;display serial number on LCD display.
014 20144        367                               CALL send_CR
                 368                               ;
                 369                               ;
                 370                               ;
                 371                               LOAD s5, 0A                              ;delay of 10 seconds to read messages.
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
015 2034B        372                               CALL delay_Ns
                 373                               ;
                 374                               ;
                 375                               ;
                 376                               ; Compute the 16-bit CRC for the serial number as an authentication value for the design.
                 377                               ; The CRC value is formed in register pair [sE,sD]. To complicate the authentication value
                 378                               ; the initial contents of the registers are seeded with a 'secret' number.
                 379                               ; Hint 1 - The CRC computation could be implemented in hardware where it is less visible.
                 380                               ; Hint 2 - There are more secure algorithms such as SHA-1 which could be used to generate
                 381                               ;          authentication values that are extremely difficult to decode.
                 382                               ;
                 383                               ;
016 001F0        384                               LOAD sE, 15                              ;seed CRC register with an initial value provided by my daughter when asked :-)
E: symbol not defined: `SE'.
                 385                               LOAD sD, 8E
E: identifier cannot start with a digit: `8E'.
E: unexpected end of line.
017 2007C        386                               CALL compute_seeded_CRC                  ;compute CRC for serial number and configuration memory
                 387                               ;
                 388                               ; Store CRC value in scratch pad memory and display computed CRC value on the PC via UART.
                 389                               ;
018 2F112        390                               STORE sD, computed_CRC0                  ;store CRC value
E: symbol not defined: `SD'.
019 2F113        391                               STORE sE, computed_CRC1
E: symbol not defined: `SE'.
01A 20242        392                               CALL send_Computed_CRC                   ;display computed CRC value on PC via UART
01B 00110        393                               LOAD s0, sE
E: symbol not defined: `S0'.
E: symbol not defined: `SE'.
01C 20130        394                               CALL send_hex_byte
01D 00110        395                               LOAD s0, sD
E: symbol not defined: `S0'.
E: symbol not defined: `SD'.
01E 20130        396                               CALL send_hex_byte
01F 20144        397                               CALL send_CR
                 398                               ;
                 399                               ;
                 400                               ;
                 401                               ; Read the authenticated CRC value stored in StrataFLASH memory.
                 402                               ; 16-bit value is hidden in 256 bytes of random numbers to make it more difficult
                 403                               ; for an attacker to identify.
                 404                               ; Read value is stored in scratch pad memory and displayed on the PC via UART.
                 405                               ;
020 20091        406                               CALL read_authentication                 ;read StrataFLASH memory into [sB,sA]
021 2F101        407                               STORE sA, authentication_CRC0            ;store CRC value
E: symbol not defined: `SA'.
E: symbol not defined: `AUTHENTICATION_CRC0'.
022 2F101        408                               STORE sB, authentication_CRC1
E: symbol not defined: `SB'.
023 20238        409                               CALL send_FLASH_CRC                      ;display CRC value from FLASH on PC via UART
024 00110        410                               LOAD s0, sB
E: symbol not defined: `S0'.
E: symbol not defined: `SB'.
025 20130        411                               CALL send_hex_byte
026 00110        412                               LOAD s0, sA
E: symbol not defined: `S0'.
E: symbol not defined: `SA'.
027 20130        413                               CALL send_hex_byte
028 20144        414                               CALL send_CR
                 415                               ;
                 416                               ;
                 417                               ; Compare the computed CRC value with the authentication value stored in StrataFLASH
                 418                               ; and determine if the design is authenticated. Then decide course of action.
                 419                               ;
029 20326        420                               CALL LCD_clear                           ;clear LCD display
02A 20394        421                               CALL disp_Authentication                 ;prepare LCD display for result of authentication
02B 20222        422                               CALL send_Authentication                 ;prepare PC display for result of authentication
                 423                               ;
02C 1C110        424                               COMPARE sA, sD                           ;Perform comparison of CRC values
E: symbol not defined: `SA'.
E: symbol not defined: `SD'.
02D 36033        425                               JUMP NZ, auth_failure
02E 1C110        426                               COMPARE sB, sE
E: symbol not defined: `SB'.
E: symbol not defined: `SE'.
02F 36033        427                               JUMP NZ, auth_failure
                 428                               ;
                 429                               ;
                 430                               ; Authentication Successful Process
                 431                               ;
                 432                               ; In this mode the design continues to operate and for evaluation
                 433                               ; purposes this design transfers control to the simple menu immediately.
                 434                               ;
030 203B3        435                  auth_passed: CALL disp_Passed                         ;display successful authentication on LCD display
031 2028D        436                               CALL send_PASSED                         ;display successful authentication on PC via UART
032 22039        437                               JUMP Menu
                 438                               ;
                 439                               ; Authentication Failure Process
                 440                               ;
                 441                               ; When the authentication fails two hardware based disable methods are demonstrated. Then
                 442                               ; the failed status is remembered for future software token messages to demonstrate software
                 443                               ; based disabling of the 'real' application. Finally the simple menu of options is presented
                 444                               ; to allow evaluation to continue.
                 445                               ;
                 446                               ;
033 203C1        447                 auth_failure: CALL disp_Failed                         ;display failure to authenticate on LCD display
034 2027F        448                               CALL send_FAILED                         ;display failure to authenticate on PC via UART
035 20144        449                               CALL send_CR
036 20053        450                               CALL disable_app_hardware                ;sequence hardware disable signals
037 00120        451                               LOAD s0, character_F                     ;change authentication status to 'F' for failed.
E: symbol not defined: `S0'.
W: value out of range: 66, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
038 2F101        452                               STORE s0, authentication_status          ; so that application software disable is demonstrated
E: symbol not defined: `S0'.
E: symbol not defined: `AUTHENTICATION_STATUS'.
                 453                               ;
                 454                               ;
                 455                               ;
                 456                               ; Menu of options for authentication processing
                 457                               ;
039 202AC        458                         Menu: CALL send_Menu                           ;display menu and prompt
03A 20111        459                               CALL read_from_UART                      ;read character from PC
03B 2011D        460                               CALL upper_case                          ;convert to upper case
03C 1C180        461                               COMPARE UART_data, character_R
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
03D 32043        462                               JUMP Z, read_command
03E 1C110        463                               COMPARE UART_data, character_E
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
03F 32048        464                               JUMP Z, erase_command
040 1C1D0        465                               COMPARE UART_data, character_A
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
041 3204C        466                               JUMP Z, authorise_command
042 22039        467                               JUMP Menu                                ;repeat menu for invalid selection
                 468                               ;
                 469                               ;
                 470                               ;
043 20144        471                 read_command: CALL send_CR
044 200A8        472                               CALL send_auth_page
045 20144        473                               CALL send_CR
046 20144        474                               CALL send_CR
047 22039        475                               JUMP Menu
                 476                               ;
                 477                               ;
                 478                               ;
048 2025F        479                erase_command: CALL send_Erase_in_progress
049 200D2        480                               CALL erase_authentication
04A 20279        481                               CALL send_OK
04B 22039        482                               JUMP Menu
                 483                               ;
                 484                               ;
                 485                               ;
04C 2029A        486            authorise_command: CALL send_Writing                        ;Send 'Writing Authorisation' message
04D 20144        487                               CALL send_CR
04E 0B112        488                               FETCH sD, computed_CRC0                  ;fetch computed CRC value
E: symbol not defined: `SD'.
04F 0B113        489                               FETCH sE, computed_CRC1
E: symbol not defined: `SE'.
050 200B7        490                               CALL write_authentication                ;write computed CRC to FLASH with random data
051 20279        491                               CALL send_OK
052 22039        492                               JUMP Menu
                 493                               ;
                 494                               ;
                 495                               ;**************************************************************************************
                 496                               ; Drive failure signals to the application.
                 497                               ;**************************************************************************************
                 498                               ;
                 499                               ; When the design fails to authorise, these controls cause the application to behave in
                 500                               ; a strange way!
                 501                               ;
                 502                               ;
                 503                               ; Disable interrupts to application PicoBlaze to stop PWM generation completely for 5 seconds
                 504                               ;
053 00110        505         disable_app_hardware: LOAD s0, security_disable_interrupts
E: symbol not defined: `S0'.
054 2D10A        506                               OUTPUT s0, authentication_control_port
E: symbol not defined: `S0'.
055 00150        507                               LOAD s5, 05
E: symbol not defined: `S5'.
056 2034B        508                               CALL delay_Ns
                 509                               ;
                 510                               ; Enable application for 5 seconds
                 511                               ;
057 00100        512                               LOAD s0, 00
E: symbol not defined: `S0'.
058 2D10A        513                               OUTPUT s0, authentication_control_port
E: symbol not defined: `S0'.
059 00150        514                               LOAD s5, 05
E: symbol not defined: `S5'.
05A 2034B        515                               CALL delay_Ns
                 516                               ;
                 517                               ; Disable and/or scramble outputs connected to application PicoBlaze for 5 seconds
                 518                               ;
05B 00120        519                               LOAD s0, security_disable_outputs
E: symbol not defined: `S0'.
05C 2D10A        520                               OUTPUT s0, authentication_control_port
E: symbol not defined: `S0'.
05D 00150        521                               LOAD s5, 05
E: symbol not defined: `S5'.
05E 2034B        522                               CALL delay_Ns
                 523                               ;
                 524                               ;
                 525                               ; Enable application in hardware so that software disable function can then be
                 526                               ; demonstrated until the design is reconfigured and authentication test repeated.
                 527                               ;
05F 00100        528                               LOAD s0, 00
E: symbol not defined: `S0'.
060 2D10A        529                               OUTPUT s0, authentication_control_port
E: symbol not defined: `S0'.
061 25000        530                               RETURN
                 531                               ;
                 532                               ;
                 533                               ;
                 534                               ;**************************************************************************************
                 535                               ; Send the 64-bit serial number stored in scratch pad memory to the UART
                 536                               ;**************************************************************************************
                 537                               ;
                 538                               ; The serial number should previously have been copied into the 8 ascending scratch pad
                 539                               ; memory locations called 'serial_number0' through to 'serial_number7'.
                 540                               ;
                 541                               ; The serial number is displayed MS-Byte first.
                 542                               ;
                 543                               ; Registers used s0,s1,s2,s3
                 544                               ;
062 201E2        545           send_serial_number: CALL send_FLASH_Serial_Number            ;display text message
063 00110        546                               LOAD s3, serial_number7                  ;pointer to scratch pad memory
E: symbol not defined: `S3'.
W: value out of range: 17, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
064 0B101        547                 send_SN_loop: FETCH s0, (s3)                           ;read serial number byte
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
065 20130        548                               CALL send_hex_byte                       ;display byte
066 20147        549                               CALL send_space                          ;display byte
067 1C1A0        550                               COMPARE s3, serial_number0               ;check for 8 bytes sent to UART
E: symbol not defined: `S3'.
068 3206B        551                               JUMP Z, end_send_SN
069 18110        552                               SUB s3, 01                               ;increment memory pointer
E: symbol not defined: `S3'.
06A 22064        553                               JUMP send_SN_loop
                 554                               ;
06B 20144        555                  end_send_SN: CALL send_CR
06C 25000        556                               RETURN
                 557                               ;
                 558                               ;
                 559                               ;
                 560                               ;**************************************************************************************
                 561                               ; Display the 64-bit serial number stored in scratch pad memory on the LCD display
                 562                               ;**************************************************************************************
                 563                               ;
                 564                               ; The serial number should previously have been copied into the 8 ascending scratch pad
                 565                               ; memory locations called 'serial_number0' through to 'serial_number7'.
                 566                               ;
                 567                               ; The serial number is displayed MS-Byte first.
                 568                               ;
                 569                               ; Registers used s0,s1,s2,s3,s4,s5,s6
                 570                               ;
06D 20326        571           disp_serial_number: CALL LCD_clear                           ;clear LCD display
06E 001A0        572                               LOAD s5, 10                              ;Line 1 position 0
E: symbol not defined: `S5'.
06F 2032B        573                               CALL LCD_cursor
070 20373        574                               CALL disp_FLASH_Serial_No                ;display text message
071 00140        575                               LOAD s5, 20                              ;Line 2 position 0
E: symbol not defined: `S5'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
072 2032B        576                               CALL LCD_cursor
073 00110        577                               LOAD s6, serial_number7                  ;pointer to scratch pad memory
E: symbol not defined: `S6'.
W: value out of range: 17, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
074 0B101        578                 disp_SN_loop: FETCH s0, (s6)                           ;read serial number byte
E: symbol not defined: `S0'.
E: symbol not defined: `S6'.
075 2013D        579                               CALL disp_hex_byte                       ;display byte
076 1C1A0        580                               COMPARE s6, serial_number0               ;check for 8 bytes sent to UART
E: symbol not defined: `S6'.
077 3207A        581                               JUMP Z, end_disp_SN
078 18110        582                               SUB s6, 01                               ;increment memory pointer
E: symbol not defined: `S6'.
079 22074        583                               JUMP disp_SN_loop
                 584                               ;
07A 20144        585                  end_disp_SN: CALL send_CR
07B 25000        586                               RETURN
                 587                               ;
                 588                               ;
                 589                               ;**************************************************************************************
                 590                               ; Compute a 16-bit CRC value for the StrataFLASH 64-bit serial number.
                 591                               ;**************************************************************************************
                 592                               ;
                 593                               ; This routing performs a 16-bit CRC calculation for the 64-bit unique serial number
                 594                               ; of the StrataFLASH memory which forms the authentication value for the design.
                 595                               ;
                 596                               ; The 16-bit CRC value returned in register pair [sE,sD] will be reflective of the unique
                 597                               ; serial number. This will be used as the authentication value for the design which is
                 598                               ; stored at known locations in the FLASH memory.
                 599                               ;
                 600                               ; A direct copy of the FLASH contents will not authorise a design to operate because the
                 601                               ; authentication value will not match the CRC value generated from the different serial number.
                 602                               ;
                 603                               ; To complicate the CRC value generation the CRC register can be seeded with a value rather
                 604                               ; than starting with a clear register.
                 605                               ;
                 606                               ;
                 607                               ; Registers used s0,s1,s2,s3
                 608                               ;
07C 001A0        609           compute_seeded_CRC: LOAD s4, serial_number0                  ;pointer to scratch pad memory holding serial number
E: symbol not defined: `S4'.
07D 0B101        610                CRC_send_loop: FETCH s3, (s4)                           ;read serial number byte
E: symbol not defined: `S3'.
E: symbol not defined: `S4'.
07E 20083        611                               CALL compute_CRC16                       ;compute CRC for value in 's3'
07F 1C110        612                               COMPARE s4, serial_number7               ;check for 8 bytes processed
E: symbol not defined: `S4'.
W: value out of range: 17, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
080 31000        613                               RETURN Z
081 10110        614                               ADD s4, 01                               ;increment memory pointer
E: symbol not defined: `S4'.
082 2207D        615                               JUMP CRC_send_loop
                 616                               ;
                 617                               ;
                 618                               ;**************************************************************************************
                 619                               ; Compute 16-bit CRC using the polynomial X16 + X15 + X2 + 1.
                 620                               ;**************************************************************************************
                 621                               ;
                 622                               ;
                 623                               ; This routine computes a 16-bit CRC in the register pair [sE,sD] and these
                 624                               ; registers must not be disturbed between calls of this routine.
                 625                               ;
                 626                               ; This routine has been written such that the CRC can be computed one
                 627                               ; byte at a time. The byte to be processed should be provided in register 's3'
                 628                               ; and the contents of this register are preserved.
                 629                               ;
                 630                               ; Before starting a CRC computation either clear or pre-load (seed) the register pair
                 631                               ; [sE,sD] and do not disturb the value of the register pair between calling this routine.
                 632                               ;
                 633                               ; Registers used s0,s1,s3,sD,sE
                 634                               ;    s3 is preserved.
                 635                               ;    sD and sE should not be disturbed between calls if CRC value is required.
                 636                               ;
                 637                               ;
                 638                               ;
083 00180        639                compute_CRC16: LOAD s1, 08                              ;8-bits to shift
E: symbol not defined: `S1'.
084 00110        640                   crc16_loop: LOAD s0, sD                              ;copy current CRC value
E: symbol not defined: `S0'.
E: symbol not defined: `SD'.
085 06110        641                               XOR s0, s3                               ;Need to know LSB XOR next input bit
E: symbol not defined: `S0'.
E: symbol not defined: `S3'.
086 0C110        642                               TEST s0, 01                              ;test result of XOR in LSB
E: symbol not defined: `S0'.
087 3E08A        643                               JUMP NC, crc16_shift
088 06120        644                               XOR sD, 02                               ;compliment bit 1 of CRC
E: symbol not defined: `SD'.
089 06180        645                               XOR sE, 40                               ;compliment bit 14 of CRC
E: symbol not defined: `SE'.
W: value out of range: 40, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
08A 1410E        646                  crc16_shift: SR0 s0                                   ;Carry gets LSB XOR next input bit
E: symbol not defined: `S0'.
08B 14108        647                               SRA sE                                   ;shift Carry into MSB to form new CRC value
E: symbol not defined: `SE'.
08C 14108        648                               SRA sD
E: symbol not defined: `SD'.
08D 1410C        649                               RR s3                                    ;shift input value
E: symbol not defined: `S3'.
08E 18110        650                               SUB s1, 01                               ;count bits
E: symbol not defined: `S1'.
08F 36084        651                               JUMP NZ, crc16_loop                      ;next bit
090 25000        652                               RETURN
                 653                               ;
                 654                               ;
                 655                               ;**************************************************************************************
                 656                               ; Read 256 bytes of StrataFLASH memory including the authentication value.
                 657                               ;**************************************************************************************
                 658                               ;
                 659                               ; This routine reads the authentication value from the StrataFLASH memory. In this
                 660                               ; design the authentication value is only 2 bytes which once read will be returned
                 661                               ; in the register pair [sB,sA].
                 662                               ;
                 663                               ; To make the authentication value more difficult to identify, it is hidden in 256 bytes
                 664                               ; of pseudo random values which will also appear different in each FLASH device inspected.
                 665                               ; This routine deliberately reads all 256 bytes that are stored and abstracts the required
                 666                               ; 2 bytes of information from them otherwise it would be easy to observe which addresses
                 667                               ; of the block were being accessed.
                 668                               ;
                 669                               ; Another way that an attacker may deduce which address locations are important would be to
                 670                               ; observe the time between read accesses and note when there is any difference. In this case
                 671                               ; the attacker is attempting to detect when PicoBlaze takes slightly longer to execute the
                 672                               ; instructions which store the important bytes in scratch pad memory. So to avoid this
                 673                               ; detection this routine inserts an additional random delay between reads to mask any code
                 674                               ; execution differences.
                 675                               ;
                 676                               ; The 256 bytes are stored at addresses 060000 to 0600FF hex (the first block above the
                 677                               ; XC3S500E configuration image which occupies 000000 to 04547F hex). The 2 bytes forming the
                 678                               ; actual authentication value are stored as 4-bit nibbles in 4 different locations in this range.
                 679                               ;
                 680                               ;
                 681                               ;                             High Order Nibble           Low Order Nibble
                 682                               ;                               (NNNNxxxx)                  (xxxxNNNN)
                 683                               ;
                 684                               ; LS-Byte in 'sA'              Addr=060010                 Addr=06007F
                 685                               ; MS-Byte in 'sB'              Addr=060025                 Addr=0600FA
                 686                               ;
                 687                               ;
091 00160        688          read_authentication: LOAD s9, 06                              ;start address in FLASH
E: symbol not defined: `S9'.
092 00100        689                               LOAD s8, 00
E: symbol not defined: `S8'.
093 00100        690                               LOAD s7, 00
E: symbol not defined: `S7'.
094 200F5        691               auth_read_loop: CALL SF_byte_read                        ;read byte from FLASH into s0
095 1C1A0        692                               COMPARE s7, 10                           ;check for bytes/nibbles that contain real information
E: symbol not defined: `S7'.
096 36099        693                               JUMP NZ, auth_check2
097 00110        694                               LOAD sA, s0                              ;isolate upper order nibble for LS-Byte
E: symbol not defined: `SA'.
E: symbol not defined: `S0'.
098 02110        695                               AND sA, F0
E: symbol not defined: `SA'.
E: symbol not defined: `F0'.
099 1C190        696                  auth_check2: COMPARE s7, 25
E: symbol not defined: `S7'.
W: value out of range: 25, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
09A 36001        697                               JUMP NZ, auth_check3
E: symbol not defined: `AUTH_CHECK3'.
09B 00110        698                               LOAD sB, s0                              ;isolate upper order nibble for MS-Byte
E: symbol not defined: `SB'.
E: symbol not defined: `S0'.
09C 02110        699                               AND sB, F0
E: symbol not defined: `SB'.
E: symbol not defined: `F0'.
                 700                  auth_check3: COMPARE s7, 7F
E: identifier cannot start with a digit: `7F'.
E: unexpected end of line.
09D 3609F        701                               JUMP NZ, auth_check4
                 702                               AND s0, 0F                               ;isolate lower order nibble for LS-Byte
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
09E 04110        703                               OR sA, s0                                ;  and merge with upper order nibble
E: symbol not defined: `SA'.
E: symbol not defined: `S0'.
09F 1C110        704                  auth_check4: COMPARE s7, FA
E: symbol not defined: `S7'.
E: symbol not defined: `FA'.
0A0 360A2        705                               JUMP NZ, next_auth_read
                 706                               AND s0, 0F                               ;isolate lower order nibble for MS-Byte
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
0A1 04110        707                               OR sB, s0                                ;  and merge with upper order nibble
E: symbol not defined: `SB'.
E: symbol not defined: `S0'.
0A2 10110        708               next_auth_read: ADD s7, 01                               ;increment address
E: symbol not defined: `S7'.
0A3 31000        709                               RETURN Z                                 ;complete after 256 reads
0A4 09104        710                               INPUT s0, random_value_port              ;random delay between reads
E: symbol not defined: `S0'.
0A5 18110        711              auth_read_delay: SUB s0, 01
E: symbol not defined: `S0'.
0A6 360A5        712                               JUMP NZ, auth_read_delay
0A7 22094        713                               JUMP auth_read_loop
                 714                               ;
                 715                               ;
                 716                               ;**************************************************************************************
                 717                               ; Read 256 bytes (page) of StrataFLASH memory containing the authentication value.
                 718                               ;**************************************************************************************
                 719                               ;
                 720                               ; This routine reads the StrataFLASH memory and displays the contents on the PC display
                 721                               ; via the UART. The display will be 256 bytes from address range 060000 to 0600FF displayed
                 722                               ; as 16 lines of 16 bytes with each line commencing with the address of the first byte.
                 723                               ;
0A8 00160        724               send_auth_page: LOAD s9, 06                              ;start address in FLASH
E: symbol not defined: `S9'.
0A9 00100        725                               LOAD s8, 00
E: symbol not defined: `S8'.
0AA 00100        726                               LOAD s7, 00
E: symbol not defined: `S7'.
0AB 20144        727               auth_line_loop: CALL send_CR
0AC 20136        728                               CALL send_hex_3bytes                     ;display address
0AD 20147        729                               CALL send_space
0AE 20147        730               auth_byte_loop: CALL send_space
0AF 200F5        731                               CALL SF_byte_read                        ;read byte into s0
0B0 20130        732                               CALL send_hex_byte                       ;display byte
0B1 10110        733                               ADD s7, 01                               ;increment FLASH address
E: symbol not defined: `S7'.
                 734                               TEST s7, 0F                              ;test for 16 byte boundary
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
0B2 360AE        735                               JUMP NZ, auth_byte_loop
0B3 0C110        736                               TEST s7, FF                              ;test for roll over of 256 bytes
E: symbol not defined: `S7'.
E: symbol not defined: `FF'.
0B4 360AB        737                               JUMP NZ, auth_line_loop
0B5 20144        738                               CALL send_CR
0B6 25000        739                               RETURN
                 740                               ;
                 741                               ;
                 742                               ;
                 743                               ;
                 744                               ;**************************************************************************************
                 745                               ; Write 256 bytes of StrataFLASH memory including the authentication value.
                 746                               ;**************************************************************************************
                 747                               ;
                 748                               ; This routine writes the authentication value to the StrataFLASH memory. This routine
                 749                               ; would normally be part of a production programming mechanism and not part of the
                 750                               ; final design which only reads and confirms authentication. This routine does not
                 751                               ; require and special measures to confuse an attacker if it is only used in a secure
                 752                               ; production environment.
                 753                               ;
                 754                               ; The 2 bytes forming the actual authentication value are stored as 4-bit nibbles in
                 755                               ; 4 different locations in the address range 600000 to 6000FF hex (256 bytes) with
                 756                               ; all remaining locations filled with pseudo random values.
                 757                               ;
                 758                               ; The authentication value to be stored in StrataFLASH memory should be provided in
                 759                               ; the register pair [sE,sD] and will be stored in the following locations.
                 760                               ;
                 761                               ;                             High Order Nibble           Low Order Nibble
                 762                               ;                               (NNNNxxxx)                  (xxxxNNNN)
                 763                               ;
                 764                               ; LS-Byte in 'sD'              Addr=060010                 Addr=06007F
                 765                               ; MS-Byte in 'sE'              Addr=060025                 Addr=0600FA
                 766                               ;
                 767                               ;
0B7 00160        768         write_authentication: LOAD s9, 06                              ;start address in FLASH
E: symbol not defined: `S9'.
0B8 00100        769                               LOAD s8, 00
E: symbol not defined: `S8'.
0B9 00100        770                               LOAD s7, 00
E: symbol not defined: `S7'.
0BA 09104        771              auth_write_loop: INPUT s0, random_value_port              ;Obtain random value
E: symbol not defined: `S0'.
0BB 1C1A0        772                               COMPARE s7, 10                           ;check for bytes/nibbles that need to be real information
E: symbol not defined: `S7'.
0BC 360C0        773                               JUMP NZ, auth_write_check2
0BD 00110        774                               LOAD s1, sD                              ;merge upper order nibble for LS-Byte with random
E: symbol not defined: `S1'.
E: symbol not defined: `SD'.
0BE 02110        775                               AND s1, F0
E: symbol not defined: `S1'.
E: symbol not defined: `F0'.
                 776                               AND s0, 0F
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
0BF 04110        777                               OR s0, s1
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
0C0 1C190        778            auth_write_check2: COMPARE s7, 25
E: symbol not defined: `S7'.
W: value out of range: 25, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
0C1 36001        779                               JUMP NZ, auth_write_check3
E: symbol not defined: `AUTH_WRITE_CHECK3'.
0C2 00110        780                               LOAD s1, sE                              ;merge upper order nibble for MS-Byte with random
E: symbol not defined: `S1'.
E: symbol not defined: `SE'.
0C3 02110        781                               AND s1, F0
E: symbol not defined: `S1'.
E: symbol not defined: `F0'.
                 782                               AND s0, 0F
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
0C4 04110        783                               OR s0, s1
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                 784            auth_write_check3: COMPARE s7, 7F
E: identifier cannot start with a digit: `7F'.
E: unexpected end of line.
0C5 360C9        785                               JUMP NZ, auth_write_check4
0C6 00110        786                               LOAD s1, sD                              ;merge lower order nibble for LS-Byte with random
E: symbol not defined: `S1'.
E: symbol not defined: `SD'.
                 787                               AND s1, 0F
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
0C7 02110        788                               AND s0, F0
E: symbol not defined: `S0'.
E: symbol not defined: `F0'.
0C8 04110        789                               OR s0, s1
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
0C9 1C110        790            auth_write_check4: COMPARE s7, FA
E: symbol not defined: `S7'.
E: symbol not defined: `FA'.
0CA 360CE        791                               JUMP NZ, write_auth
0CB 00110        792                               LOAD s1, sE                              ;merge lower order nibble for MS-Byte with random
E: symbol not defined: `S1'.
E: symbol not defined: `SE'.
                 793                               AND s1, 0F
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
0CC 02110        794                               AND s0, F0
E: symbol not defined: `S0'.
E: symbol not defined: `F0'.
0CD 04110        795                               OR s0, s1
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
0CE 200E0        796                   write_auth: CALL SF_single_byte_write                ;write byte to FLASH
0CF 10110        797                               ADD s7, 01                               ;increment address
E: symbol not defined: `S7'.
0D0 31000        798                               RETURN Z                                 ;complete after 256 writes
0D1 220BA        799                               JUMP auth_write_loop
                 800                               ;
                 801                               ;
                 802                               ;**************************************************************************************
                 803                               ; Erase authentication value from StrataFLASH memory.
                 804                               ;**************************************************************************************
                 805                               ;
                 806                               ; Erase block 3 of the StrataFLASH memory which covers the address range 060000 to 07FFFF.
                 807                               ; This erases the area containing the authentication value and random values which helps
                 808                               ; to hide it.
                 809                               ;
0D2 00160        810         erase_authentication: LOAD s9, 06                              ;set address to 06xxxx hex which defines block 3 (060000 to 07FFFF)
E: symbol not defined: `S9'.
0D3 200D8        811                               CALL SF_erase_block
0D4 25000        812                               RETURN
                 813                               ;
                 814                               ;
                 815                               ;**************************************************************************************
                 816                               ; Initialise the StrataFlash Memory control signals.
                 817                               ;**************************************************************************************
                 818                               ;
                 819                               ; SF_read = 0   - Output enable off
                 820                               ; SF_ce = 1     - Deselect StrataFLASH memory
                 821                               ; SF_we = 1     - Write enable off
                 822                               ;
                 823                               ; Register used s0
                 824                               ;
0D5 00160        825                      SF_init: LOAD s0, 06
E: symbol not defined: `S0'.
0D6 2D128        826                               OUTPUT s0, SF_control_port
E: symbol not defined: `S0'.
0D7 25000        827                               RETURN
                 828                               ;
                 829                               ;
                 830                               ;
                 831                               ;**************************************************************************************
                 832                               ; StrataFLASH Block Erase
                 833                               ;**************************************************************************************
                 834                               ;
                 835                               ; This routine will erase one 128k-byte block of the StrataFLASH memory.
                 836                               ; The block to be erased is specified by the contents of register 's9'.
                 837                               ;
                 838                               ; s9=06 erases Block 3 (address range 060000 to 07FFFF)
                 839                               ;
                 840                               ;
                 841                               ; To erase a block the 24-bit address must be set and then the block erase command
                 842                               ; (20 hex) written to the memory followed by the write confirm command (D0 hex).
                 843                               ;
                 844                               ; The act of erasing a block may take up to 1 second to complete. This routine
                 845                               ; waits for the memory to be ready before restoring the normal read array mode and
                 846                               ; returning.
                 847                               ;
                 848                               ; Registers used s0,s1,s7,s8,s9
                 849                               ;
0D8 00100        850               SF_erase_block: LOAD s8, 00                              ;define lower address of block = xx0000
E: symbol not defined: `S8'.
0D9 00100        851                               LOAD s7, 00
E: symbol not defined: `S7'.
0DA 00140        852                               LOAD s1, 20                              ;block erase command
E: symbol not defined: `S1'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
0DB 200FF        853                               CALL SF_byte_write
0DC 00110        854                               LOAD s1, D0                              ;write confirm command
E: symbol not defined: `S1'.
E: symbol not defined: `D0'.
0DD 200FF        855                               CALL SF_byte_write
0DE 2010C        856                               CALL wait_SF_ready                       ;wait for erase to complete
0DF 25000        857                               RETURN
                 858                               ;
                 859                               ;
                 860                               ;**************************************************************************************
                 861                               ; Write a single byte to StrataFlash Memory
                 862                               ;**************************************************************************************
                 863                               ;
                 864                               ; To write a single byte to StrataFLASH memory the address must be set and the
                 865                               ; single-word/byte program command (40 hex) sent to the memory. Then the data byte can
                 866                               ; be written to the memory using the same address.
                 867                               ;
                 868                               ; The 24-bit address should be supplied in register set [s9,s8,s7].
                 869                               ; Register s0 should contain the byte data to be written to the memory.
                 870                               ;
                 871                               ; The act of writing the memory array may take up to 175us to complete. This routine
                 872                               ; waits for the memory to be ready before restoring the normal read array mode and
                 873                               ; returning.
                 874                               ;
                 875                               ; Registers used s0,s1,s7,s8,s9   (s7,s8,s9 not changed)
                 876                               ;
                 877                               ; Registers used s0,s1,s7,s8,s9
                 878                               ;
0E0 00180        879         SF_single_byte_write: LOAD s1, 40                              ;command for single byte program
E: symbol not defined: `S1'.
W: value out of range: 40, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
0E1 200FF        880                               CALL SF_byte_write
0E2 00110        881                               LOAD s1, s0                              ;write data to be programmed
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
0E3 200FF        882                               CALL SF_byte_write
0E4 2010C        883                               CALL wait_SF_ready                       ;wait for program to complete
0E5 25000        884                               RETURN
                 885                               ;
                 886                               ;
                 887                               ;
                 888                               ;**************************************************************************************
                 889                               ; Read the unique 64-bit serial number of the StrataFLASH FLASH memory
                 890                               ;**************************************************************************************
                 891                               ;
                 892                               ; To read the device information the Read device information command (90)
                 893                               ; must be written to the memory. The information is read back from address 000102
                 894                               ; to 000109 (note these are byte access addresses).
                 895                               ;
                 896                               ; The serial number is copied to 8 ascending scratch pad memory locations called
                 897                               ; 'serial_number0' through to 'serial_number7' for future use.
                 898                               ;
                 899                               ; After reading the device information the read array command is written to the
                 900                               ; device to put it back to normal read mode.
                 901                               ;
                 902                               ; Registers used s0,s1,s2,s7,s8,s9
                 903                               ;
0E6 00100        904        read_SF_serial_number: LOAD s9, 00                              ;StrataFLASH address to read serial number = 000102
E: symbol not defined: `S9'.
0E7 00110        905                               LOAD s8, 01
E: symbol not defined: `S8'.
0E8 00120        906                               LOAD s7, 02
E: symbol not defined: `S7'.
0E9 001A0        907                               LOAD s2, serial_number0                  ;pointer to scratch pad memory
E: symbol not defined: `S2'.
0EA 001A0        908                               LOAD s1, 90                              ;command to read device information
E: symbol not defined: `S1'.
W: value out of range: 90, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
0EB 200FF        909                               CALL SF_byte_write
0EC 200F5        910                 read_SN_loop: CALL SF_byte_read                        ;read serial number value
0ED 2F101        911                               STORE s0, (s2)
E: symbol not defined: `S0'.
E: symbol not defined: `S2'.
0EE 1C110        912                               COMPARE s2, serial_number7               ;check for 8 bytes copied
E: symbol not defined: `S2'.
W: value out of range: 17, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
0EF 320F3        913                               JUMP Z, end_read_SN
0F0 10110        914                               ADD s7, 01                               ;increment StrataFLASH address
E: symbol not defined: `S7'.
0F1 10110        915                               ADD s2, 01                               ;increment memory pointer
E: symbol not defined: `S2'.
0F2 220EC        916                               JUMP read_SN_loop
                 917                               ;
0F3 20109        918                  end_read_SN: CALL set_SF_read_array_mode              ;restore normal read array mode
0F4 25000        919                               RETURN
                 920                               ;
                 921                               ;
                 922                               ;
                 923                               ;**************************************************************************************
                 924                               ; Read a byte from StrataFlash Memory
                 925                               ;**************************************************************************************
                 926                               ;
                 927                               ; The 24-bit address should be supplied in register set [s9,s8,s7].
                 928                               ; Register s0 will return the byte data retrieved from the memory.
                 929                               ;
                 930                               ; To read a byte, the address needs to be set up on the address lines
                 931                               ; and the controls set as follows
                 932                               ;    SF_read = 1 - disable Spartan data outputs and enable StrataFlash outputs (OE=0)
                 933                               ;      SF_ce = 0 - enable StrataFLASH memory
                 934                               ;      SF_we = 1 - Write enable off
                 935                               ;
                 936                               ; The access time of the memory is 75ns. This is equivalent to 3.75 clock cycles at
                 937                               ; 50MHz. Since each KCPSM3 instruction takes 2 clock cycles to execute, two instructions
                 938                               ; provides adequate delay for the memory to be accessed.
                 939                               ;
                 940                               ; Registers used s0,s1,s7,s8,s9
                 941                               ;
0F5 2D153        942                 SF_byte_read: OUTPUT s9, SF_addr_hi_port               ;set 24-bit address
E: symbol not defined: `S9'.
0F6 2D152        943                               OUTPUT s8, SF_addr_mi_port
E: symbol not defined: `S8'.
0F7 2D151        944                               OUTPUT s7, SF_addr_lo_port
E: symbol not defined: `S7'.
0F8 00150        945                               LOAD s1, 05                              ;set controls
E: symbol not defined: `S1'.
0F9 2D128        946                               OUTPUT s1, SF_control_port
E: symbol not defined: `S1'.
0FA 00160        947                               LOAD s1, 06                              ;>75ns delay
E: symbol not defined: `S1'.
0FB 00160        948                               LOAD s1, 06                              ;but do something useful!
E: symbol not defined: `S1'.
0FC 09102        949                               INPUT s0, SF_data_in_port                ;read data byte
E: symbol not defined: `S0'.
0FD 2D128        950                               OUTPUT s1, SF_control_port               ;clear controls
E: symbol not defined: `S1'.
0FE 25000        951                               RETURN
                 952                               ;
                 953                               ;
                 954                               ;**************************************************************************************
                 955                               ; Write data or command byte to StrataFlash Memory
                 956                               ;**************************************************************************************
                 957                               ;
                 958                               ; The 24-bit address should be supplied in register set [s9,s8,s7].
                 959                               ; Register s1 should contain the byte to be written to the memory.
                 960                               ;
                 961                               ; To write a byte, the address needs to be set up on the address lines
                 962                               ; and the controls set as follows
                 963                               ;    SF_read = 0 - enable Spartan data outputs and disable StrataFlash outputs (OE=1)
                 964                               ;      SF_ce = 0 - enable StrataFLASH memory
                 965                               ;      SF_we = 0 - Write enable on
                 966                               ;
                 967                               ; The setup time of the memory is 60ns. This is equivalent to 3 clock cycles at
                 968                               ; 50MHz. Since each KCPSM3 instruction takes 2 clock cycles to execute, two instructions
                 969                               ; provides adequate delay for the memory.
                 970                               ;
                 971                               ; Registers used s1,s7,s8,s9
                 972                               ;
0FF 2D153        973                SF_byte_write: OUTPUT s9, SF_addr_hi_port               ;set 24-bit address
E: symbol not defined: `S9'.
100 2D152        974                               OUTPUT s8, SF_addr_mi_port
E: symbol not defined: `S8'.
101 2D151        975                               OUTPUT s7, SF_addr_lo_port
E: symbol not defined: `S7'.
102 2D150        976                               OUTPUT s1, SF_data_out_port              ;set data byte to be written
E: symbol not defined: `S1'.
103 00100        977                               LOAD s1, 00                              ;set controls
E: symbol not defined: `S1'.
104 2D128        978                               OUTPUT s1, SF_control_port
E: symbol not defined: `S1'.
105 00160        979                               LOAD s1, 06                              ;>60ns delay
E: symbol not defined: `S1'.
106 00160        980                               LOAD s1, 06                              ;but do something useful!
E: symbol not defined: `S1'.
107 2D128        981                               OUTPUT s1, SF_control_port               ;clear controls
E: symbol not defined: `S1'.
108 25000        982                               RETURN
                 983                               ;
                 984                               ;
                 985                               ;**************************************************************************************
                 986                               ; Set 'Read Array' mode on StrataFLASH
                 987                               ;**************************************************************************************
                 988                               ;
                 989                               ; The read array mode is the default mode of the memory and allows the contents
                 990                               ; of the memory to be read based on the supplied address.
                 991                               ;
                 992                               ; Read array is the default mode of the device, but it must also be placed back
                 993                               ; into this mode after programming, erasing or reading the status register.
                 994                               ;
                 995                               ; The read array command (FF hex) is written to the Strata flash memory.
                 996                               ;
                 997                               ; Registers used s1,s7,s8,s9
                 998                               ;
109 00110        999       set_SF_read_array_mode: LOAD s1, FF                              ;command to read array
E: symbol not defined: `S1'.
E: symbol not defined: `FF'.
10A 200FF       1000                               CALL SF_byte_write
10B 25000       1001                               RETURN
                1002                               ;
                1003                               ;
                1004                               ;**************************************************************************************
                1005                               ; Wait for StrataFLASH to be ready
                1006                               ;**************************************************************************************
                1007                               ;
                1008                               ; This routine will typically be used after instigating a program or erase
                1009                               ; command. It continuously reads the StrataFLASH status register and tests the
                1010                               ; information provided by bit7 which indicates if the memory is busy(0) or ready(1).
                1011                               ; The routine waits for the ready condition before sending a read array command
                1012                               ; which puts the memory back to normal read mode.
                1013                               ;
                1014                               ;
                1015                               ; Registers used s0,s1,s7,s8,s9   (s7,s8,s9 not changed)
                1016                               ;
                1017                               ;
10C 200F5       1018                wait_SF_ready: CALL SF_byte_read                        ;read status register into s0
10D 0C100       1019                               TEST s0, 80                              ;test ready/busy flag
E: symbol not defined: `S0'.
W: value out of range: 80, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
10E 3210C       1020                               JUMP Z, wait_SF_ready
10F 20109       1021                               CALL set_SF_read_array_mode              ;restore normal read array mode
110 25000       1022                               RETURN
                1023                               ;
                1024                               ;
                1025                               ;
                1026                               ;
                1027                               ;**************************************************************************************
                1028                               ; UART communication routines
                1029                               ;**************************************************************************************
                1030                               ;
                1031                               ; Read one character from the UART
                1032                               ;
                1033                               ; Character read will be returned in a register called 'UART_data'.
                1034                               ;
                1035                               ; The routine first tests the receiver FIFO buffer to see if data is present.
                1036                               ; If the FIFO is empty, the routine waits until there is a character to read.
                1037                               ; As this could take any amount of time the wait loop could include a call to a
                1038                               ; subroutine which performs a useful function.
                1039                               ;
                1040                               ;
                1041                               ; Registers used s0 and UART_data
                1042                               ;
111 09100       1043               read_from_UART: INPUT s0, status_port                    ;test Rx_FIFO buffer
E: symbol not defined: `S0'.
112 0C140       1044                               TEST s0, rx_data_present                 ;wait if empty
E: symbol not defined: `S0'.
113 36115       1045                               JUMP NZ, read_character
114 22111       1046                               JUMP read_from_UART
115 09101       1047               read_character: INPUT UART_data, UART_read_port          ;read from FIFO
116 25000       1048                               RETURN
                1049                               ;
                1050                               ;
                1051                               ;
                1052                               ; Transmit one character to the UART
                1053                               ;
                1054                               ; Character supplied in register called 'UART_data'.
                1055                               ;
                1056                               ; The routine first tests the transmit FIFO buffer to see if it is full.
                1057                               ; If the FIFO is full, then the routine waits until it there is space.
                1058                               ;
                1059                               ; Registers used s0
                1060                               ;
117 09100       1061                 send_to_UART: INPUT s0, status_port                    ;test Tx_FIFO buffer
E: symbol not defined: `S0'.
118 0C120       1062                               TEST s0, tx_full                         ;wait if full
E: symbol not defined: `S0'.
119 3211B       1063                               JUMP Z, UART_write
11A 22117       1064                               JUMP send_to_UART
11B 2D108       1065                   UART_write: OUTPUT UART_data, UART_write_port
11C 25000       1066                               RETURN
                1067                               ;
                1068                               ;
                1069                               ;
                1070                               ;**************************************************************************************
                1071                               ;Useful ASCII conversion and handling routines
                1072                               ;**************************************************************************************
                1073                               ;
                1074                               ;
                1075                               ;
                1076                               ;Convert character to upper case
                1077                               ;
                1078                               ;The character supplied in register UART_data.
                1079                               ;If the character is in the range 'a' to 'z', it is converted
                1080                               ;to the equivalent upper case character in the range 'A' to 'Z'.
                1081                               ;All other characters remain unchanged.
                1082                               ;
                1083                               ;Registers used s0.
                1084                               ;
11D 1C1D0       1085                   upper_case: COMPARE UART_data, 61                    ;eliminate character codes below 'a' (61 hex)
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
11E 39000       1086                               RETURN C
                1087                               COMPARE UART_data, 7B                    ;eliminate character codes above 'z' (7A hex)
E: identifier cannot start with a digit: `7B'.
E: unexpected end of line.
11F 3D000       1088                               RETURN NC
120 02110       1089                               AND UART_data, DF                        ;mask bit5 to convert to upper case
E: symbol not defined: `DF'.
121 25000       1090                               RETURN
                1091                               ;
                1092                               ;
                1093                               ;Convert hexadecimal value provided in register s0 into ASCII characters
                1094                               ;
                1095                               ;The value provided must can be any value in the range 00 to FF and will be converted into
                1096                               ;two ASCII characters.
                1097                               ;     The upper nibble will be represented by an ASCII character returned in register s2.
                1098                               ;     The lower nibble will be represented by an ASCII character returned in register s1.
                1099                               ;
                1100                               ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
                1101                               ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
                1102                               ;hexadecimal requiring a further addition of 07 to the 30 already added.
                1103                               ;
                1104                               ;Registers used s0, s1 and s2.
                1105                               ;
122 00110       1106            hex_byte_to_ASCII: LOAD s1, s0                              ;remember value supplied
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
123 1410E       1107                               SR0 s0                                   ;isolate upper nibble
E: symbol not defined: `S0'.
124 1410E       1108                               SR0 s0
E: symbol not defined: `S0'.
125 1410E       1109                               SR0 s0
E: symbol not defined: `S0'.
126 1410E       1110                               SR0 s0
E: symbol not defined: `S0'.
127 20001       1111                               CALL hex_to_ASCII                        ;convert
E: symbol not defined: `HEX_TO_ASCII'.
128 00110       1112                               LOAD s2, s0                              ;upper nibble value in s2
E: symbol not defined: `S2'.
E: symbol not defined: `S0'.
129 00110       1113                               LOAD s0, s1                              ;restore complete value
E: symbol not defined: `S0'.
E: symbol not defined: `S1'.
                1114                               AND s0, 0F                               ;isolate lower nibble
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
12A 20001       1115                               CALL hex_to_ASCII                        ;convert
E: symbol not defined: `HEX_TO_ASCII'.
12B 00110       1116                               LOAD s1, s0                              ;lower nibble value in s1
E: symbol not defined: `S1'.
E: symbol not defined: `S0'.
12C 25000       1117                               RETURN
                1118                               ;
                1119                               ;Convert hexadecimal value provided in register s0 into ASCII character
                1120                               ;
                1121                               ;Register used s0
                1122                               ;
                1123                 hex_to_ASCII: SUB s0, 0A                               ;test if value is in range 0 to 9
E: identifier cannot start with a digit: `0A'.
E: unexpected end of line.
12D 3A001       1124                               JUMP C, number_char
E: symbol not defined: `NUMBER_CHAR'.
12E 10170       1125                               ADD s0, 07                               ;ASCII char A to F in range 41 to 46
E: symbol not defined: `S0'.
                1126                  number_char: ADD s0, 3A                               ;ASCII char 0 to 9 in range 30 to 40
E: identifier cannot start with a digit: `3A'.
E: unexpected end of line.
12F 25000       1127                               RETURN
                1128                               ;
                1129                               ;
                1130                               ;Send the two character HEX value of the register contents 's0' to the UART
                1131                               ;
                1132                               ;Registers used s0, s1, s2
                1133                               ;
130 20122       1134                send_hex_byte: CALL hex_byte_to_ASCII
131 00110       1135                               LOAD UART_data, s2
E: symbol not defined: `S2'.
132 20117       1136                               CALL send_to_UART
133 00110       1137                               LOAD UART_data, s1
E: symbol not defined: `S1'.
134 20117       1138                               CALL send_to_UART
135 25000       1139                               RETURN
                1140                               ;
                1141                               ;
                1142                               ;Send the six character HEX value of the register contents [s9,s8,s7] to the UART
                1143                               ;
                1144                               ;Registers used s0, s1, s2
                1145                               ;
136 00110       1146              send_hex_3bytes: LOAD s0, s9
E: symbol not defined: `S0'.
E: symbol not defined: `S9'.
137 20130       1147                               CALL send_hex_byte
138 00110       1148                               LOAD s0, s8
E: symbol not defined: `S0'.
E: symbol not defined: `S8'.
139 20130       1149                               CALL send_hex_byte
13A 00110       1150                               LOAD s0, s7
E: symbol not defined: `S0'.
E: symbol not defined: `S7'.
13B 20130       1151                               CALL send_hex_byte
13C 25000       1152                               RETURN
                1153                               ;
                1154                               ;
                1155                               ;Display the two character HEX value of the register contents 's0' on the LCD display
                1156                               ;
                1157                               ;Registers used s0,s1,s2,s3,s4,s5
                1158                               ;
13D 20122       1159                disp_hex_byte: CALL hex_byte_to_ASCII
13E 00110       1160                               LOAD s3, s1                              ;remember least significant digit
E: symbol not defined: `S3'.
E: symbol not defined: `S1'.
13F 00110       1161                               LOAD s5, s2
E: symbol not defined: `S5'.
E: symbol not defined: `S2'.
140 202EE       1162                               CALL LCD_write_data                      ;display most significant digit
141 00110       1163                               LOAD s5, s3
E: symbol not defined: `S5'.
E: symbol not defined: `S3'.
142 202EE       1164                               CALL LCD_write_data                      ;display least significant digit
143 25000       1165                               RETURN
                1166                               ;
                1167                               ;
                1168                               ;
                1169                               ;**************************************************************************************
                1170                               ; UART Text messages
                1171                               ;**************************************************************************************
                1172                               ;
                1173                               ;
                1174                               ;Send Carriage Return to the UART
                1175                               ;
144 00100       1176                      send_CR: LOAD UART_data, character_CR
145 20117       1177                               CALL send_to_UART
146 25000       1178                               RETURN
                1179                               ;
                1180                               ;Send a space to the UART
                1181                               ;
147 00140       1182                   send_space: LOAD UART_data, character_space
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
148 20117       1183                               CALL send_to_UART
149 25000       1184                               RETURN
                1185                               ;
                1186                               ;
                1187                               ;Send an equals sign to the UART with a space each side
                1188                               ;
14A 20147       1189                  send_equals: CALL send_space
14B 00130       1190                               LOAD UART_data, character_equals
14C 20117       1191                               CALL send_to_UART
14D 20147       1192                               CALL send_space
14E 25000       1193                               RETURN
                1194                               ;
                1195                               ;
                1196                               ;
                1197                               ;Send an minus sign (dash) to the UART with a space each side
                1198                               ;
14F 20147       1199                    send_dash: CALL send_space
150 00120       1200                               LOAD UART_data, character_minus
151 20117       1201                               CALL send_to_UART
152 20147       1202                               CALL send_space
153 25000       1203                               RETURN
                1204                               ;
                1205                               ;
                1206                               ;Send 'PicoBlaze Low Cost Design Security v1.00' string to the UART
                1207                               ;
154 20144       1208                 send_welcome: CALL send_CR
155 20144       1209                               CALL send_CR
156 00160       1210                               LOAD UART_data, character_P
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
157 20117       1211                               CALL send_to_UART
158 00150       1212                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
159 20117       1213                               CALL send_to_UART
15A 001F0       1214                               LOAD UART_data, character_c
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
15B 20117       1215                               CALL send_to_UART
15C 00110       1216                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
15D 20117       1217                               CALL send_to_UART
15E 001E0       1218                               LOAD UART_data, character_B
W: value out of range: 62, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
15F 20117       1219                               CALL send_to_UART
160 00110       1220                               LOAD UART_data, character_l
E: symbol not defined: `CHARACTER_L'.
161 20117       1221                               CALL send_to_UART
162 001D0       1222                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
163 20117       1223                               CALL send_to_UART
164 00110       1224                               LOAD UART_data, character_z
E: symbol not defined: `CHARACTER_Z'.
165 20117       1225                               CALL send_to_UART
166 00110       1226                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
167 20117       1227                               CALL send_to_UART
168 20147       1228                               CALL send_space
169 00110       1229                               LOAD UART_data, character_L
E: symbol not defined: `CHARACTER_L'.
16A 20117       1230                               CALL send_to_UART
16B 00110       1231                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
16C 20117       1232                               CALL send_to_UART
16D 001D0       1233                               LOAD UART_data, character_w
W: value out of range: 77, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
16E 20117       1234                               CALL send_to_UART
16F 20147       1235                               CALL send_space
170 001F0       1236                               LOAD UART_data, character_C
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
171 20117       1237                               CALL send_to_UART
172 00110       1238                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
173 20117       1239                               CALL send_to_UART
174 00190       1240                               LOAD UART_data, character_s
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
175 20117       1241                               CALL send_to_UART
176 001A0       1242                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
177 20117       1243                               CALL send_to_UART
178 20147       1244                               CALL send_space
179 00100       1245                               LOAD UART_data, character_D
W: value out of range: 64, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
17A 20117       1246                               CALL send_to_UART
17B 00110       1247                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
17C 20117       1248                               CALL send_to_UART
17D 00190       1249                               LOAD UART_data, character_s
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
17E 20117       1250                               CALL send_to_UART
17F 00150       1251                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
180 20117       1252                               CALL send_to_UART
181 00130       1253                               LOAD UART_data, character_g
W: value out of range: 67, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
182 20117       1254                               CALL send_to_UART
183 00110       1255                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
184 20117       1256                               CALL send_to_UART
185 20147       1257                               CALL send_space
186 00190       1258                               LOAD UART_data, character_S
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
187 20117       1259                               CALL send_to_UART
188 00110       1260                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
189 20117       1261                               CALL send_to_UART
18A 001F0       1262                               LOAD UART_data, character_c
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
18B 20117       1263                               CALL send_to_UART
18C 001B0       1264                               LOAD UART_data, character_u
W: value out of range: 75, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
18D 20117       1265                               CALL send_to_UART
18E 00180       1266                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
18F 20117       1267                               CALL send_to_UART
190 00150       1268                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
191 20117       1269                               CALL send_to_UART
192 001A0       1270                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
193 20117       1271                               CALL send_to_UART
194 001F0       1272                               LOAD UART_data, character_y
W: value out of range: 79, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
195 20117       1273                               CALL send_to_UART
196 20147       1274                               CALL send_space
197 001C0       1275                               LOAD UART_data, character_v
W: value out of range: 76, allowed range is [0,15] (trimmed to 4 bits) which makes it 12.
198 20117       1276                               CALL send_to_UART
199 001F0       1277                               LOAD UART_data, character_1
W: value out of range: 31, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
19A 20117       1278                               CALL send_to_UART
19B 00110       1279                               LOAD UART_data, character_fullstop
E: symbol not defined: `CHARACTER_FULLSTOP'.
19C 20117       1280                               CALL send_to_UART
19D 001E0       1281                               LOAD UART_data, character_0
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
19E 20117       1282                               CALL send_to_UART
19F 001E0       1283                               LOAD UART_data, character_0
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
1A0 20117       1284                               CALL send_to_UART
1A1 20144       1285                               CALL send_CR
1A2 20144       1286                               CALL send_CR
1A3 25000       1287                               RETURN
                1288                               ;
                1289                               ;
                1290                               ;
                1291                               ;Send 'Copyright Ken Chapman 2006' string to the UART
                1292                               ;
                1293                               ;This message is significant because it demonstrates that the design
                1294                               ;now has a 'watermark'. The ASCII codes for this string will be
                1295                               ;stored in the design configuration bit stream somewhere as well as
                1296                               ;being played out by the UART. If someone tries to change or delete
                1297                               ;this message the contents of the BRAM will change and the hardware
                1298                               ;check of the BRAM contents will fail to match the expected value and
                1299                               ;the design will again be disabled.
                1300                               ;
1A4 001F0       1301               send_Copyright: LOAD UART_data, character_C
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
1A5 20117       1302                               CALL send_to_UART
1A6 00110       1303                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
1A7 20117       1304                               CALL send_to_UART
1A8 00160       1305                               LOAD UART_data, character_p
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
1A9 20117       1306                               CALL send_to_UART
1AA 001F0       1307                               LOAD UART_data, character_y
W: value out of range: 79, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
1AB 20117       1308                               CALL send_to_UART
1AC 00180       1309                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
1AD 20117       1310                               CALL send_to_UART
1AE 00150       1311                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
1AF 20117       1312                               CALL send_to_UART
1B0 00130       1313                               LOAD UART_data, character_g
W: value out of range: 67, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
1B1 20117       1314                               CALL send_to_UART
1B2 00140       1315                               LOAD UART_data, character_h
W: value out of range: 68, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
1B3 20117       1316                               CALL send_to_UART
1B4 001A0       1317                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
1B5 20117       1318                               CALL send_to_UART
1B6 20147       1319                               CALL send_space
1B7 00110       1320                               LOAD UART_data, character_K
E: symbol not defined: `CHARACTER_K'.
1B8 20117       1321                               CALL send_to_UART
1B9 00110       1322                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
1BA 20117       1323                               CALL send_to_UART
1BB 00110       1324                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
1BC 20117       1325                               CALL send_to_UART
1BD 20147       1326                               CALL send_space
1BE 001F0       1327                               LOAD UART_data, character_C
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
1BF 20117       1328                               CALL send_to_UART
1C0 00140       1329                               LOAD UART_data, character_h
W: value out of range: 68, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
1C1 20117       1330                               CALL send_to_UART
1C2 001D0       1331                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
1C3 20117       1332                               CALL send_to_UART
1C4 00160       1333                               LOAD UART_data, character_p
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
1C5 20117       1334                               CALL send_to_UART
1C6 00160       1335                               LOAD UART_data, character_m
1C7 20117       1336                               CALL send_to_UART
1C8 001D0       1337                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
1C9 20117       1338                               CALL send_to_UART
1CA 00110       1339                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
1CB 20117       1340                               CALL send_to_UART
1CC 20147       1341                               CALL send_space
1CD 00100       1342                               LOAD UART_data, character_2
W: value out of range: 32, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
1CE 20117       1343                               CALL send_to_UART
1CF 001E0       1344                               LOAD UART_data, character_0
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
1D0 20117       1345                               CALL send_to_UART
1D1 20117       1346                               CALL send_to_UART
1D2 00140       1347                               LOAD UART_data, character_6
W: value out of range: 36, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
1D3 20117       1348                               CALL send_to_UART
1D4 20144       1349                               CALL send_CR
1D5 20144       1350                               CALL send_CR
1D6 25000       1351                               RETURN
                1352                               ;
                1353                               ;
                1354                               ;
                1355                               ;Send 'FLASH ' string to the UART
                1356                               ;
1D7 00120       1357                   send_FLASH: LOAD UART_data, character_F
W: value out of range: 66, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
1D8 20117       1358                               CALL send_to_UART
1D9 00110       1359                               LOAD UART_data, character_L
E: symbol not defined: `CHARACTER_L'.
1DA 20117       1360                               CALL send_to_UART
1DB 001D0       1361                               LOAD UART_data, character_A
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
1DC 20117       1362                               CALL send_to_UART
1DD 00190       1363                               LOAD UART_data, character_S
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
1DE 20117       1364                               CALL send_to_UART
1DF 00140       1365                               LOAD UART_data, character_H
W: value out of range: 68, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
1E0 20117       1366                               CALL send_to_UART
1E1 25000       1367                               RETURN
                1368                               ;
                1369                               ;
                1370                               ;
                1371                               ;Send 'FLASH Serial Number = ' string to the UART
                1372                               ;
1E2 201D7       1373     send_FLASH_Serial_Number: CALL send_FLASH
1E3 20147       1374                               CALL send_space
1E4 00190       1375                               LOAD UART_data, character_S
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
1E5 20117       1376                               CALL send_to_UART
1E6 00110       1377                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
1E7 20117       1378                               CALL send_to_UART
1E8 00180       1379                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
1E9 20117       1380                               CALL send_to_UART
1EA 00150       1381                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
1EB 20117       1382                               CALL send_to_UART
1EC 001D0       1383                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
1ED 20117       1384                               CALL send_to_UART
1EE 00110       1385                               LOAD UART_data, character_l
E: symbol not defined: `CHARACTER_L'.
1EF 20117       1386                               CALL send_to_UART
1F0 20147       1387                               CALL send_space
1F1 00110       1388                               LOAD UART_data, character_N
E: symbol not defined: `CHARACTER_N'.
1F2 20117       1389                               CALL send_to_UART
1F3 001B0       1390                               LOAD UART_data, character_u
W: value out of range: 75, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
1F4 20117       1391                               CALL send_to_UART
1F5 00160       1392                               LOAD UART_data, character_m
1F6 20117       1393                               CALL send_to_UART
1F7 001E0       1394                               LOAD UART_data, character_b
W: value out of range: 62, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
1F8 20117       1395                               CALL send_to_UART
1F9 00110       1396                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
1FA 20117       1397                               CALL send_to_UART
1FB 00180       1398                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
1FC 20117       1399                               CALL send_to_UART
1FD 2014A       1400                               CALL send_equals
1FE 25000       1401                               RETURN
                1402                               ;
                1403                               ;
                1404                               ;Send 'Auth' string to the UART
                1405                               ;
1FF 001D0       1406                    send_Auth: LOAD UART_data, character_A
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
200 20117       1407                               CALL send_to_UART
201 001B0       1408                               LOAD UART_data, character_u
W: value out of range: 75, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
202 20117       1409                               CALL send_to_UART
203 001A0       1410                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
204 20117       1411                               CALL send_to_UART
205 00140       1412                               LOAD UART_data, character_h
W: value out of range: 68, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
206 20117       1413                               CALL send_to_UART
207 25000       1414                               RETURN
                1415                               ;
                1416                               ;Send 'Authoris' to the UART
                1417                               ;
208 201FF       1418                send_Authoris: CALL send_Auth
209 00110       1419                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
20A 20117       1420                               CALL send_to_UART
20B 00180       1421                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
20C 20117       1422                               CALL send_to_UART
20D 00150       1423                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
20E 20117       1424                               CALL send_to_UART
20F 00190       1425                               LOAD UART_data, character_s
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
210 20117       1426                               CALL send_to_UART
211 25000       1427                               RETURN
                1428                               ;
                1429                               ;Send 'Authorisation' to the UART
                1430                               ;
212 20208       1431           send_Authorisation: CALL send_Authoris
213 001D0       1432                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
214 20117       1433                               CALL send_to_UART
215 001A0       1434                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
216 20117       1435                               CALL send_to_UART
217 00150       1436                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
218 20117       1437                               CALL send_to_UART
219 00110       1438                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
21A 20117       1439                               CALL send_to_UART
21B 00110       1440                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
21C 20117       1441                               CALL send_to_UART
21D 25000       1442                               RETURN
                1443                               ;
                1444                               ;Send 'Authorise' to the UART
                1445                               ;
21E 20208       1446               send_Authorise: CALL send_Authoris
21F 00110       1447                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
220 20117       1448                               CALL send_to_UART
221 25000       1449                               RETURN
                1450                               ;
                1451                               ;Send 'Authentication' string to the UART
                1452                               ;
222 201FF       1453          send_Authentication: CALL send_Auth
223 00110       1454                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
224 20117       1455                               CALL send_to_UART
225 00110       1456                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
226 20117       1457                               CALL send_to_UART
227 001A0       1458                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
228 20117       1459                               CALL send_to_UART
229 00150       1460                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
22A 20117       1461                               CALL send_to_UART
22B 001F0       1462                               LOAD UART_data, character_c
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
22C 20117       1463                               CALL send_to_UART
22D 001D0       1464                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
22E 20117       1465                               CALL send_to_UART
22F 001A0       1466                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
230 20117       1467                               CALL send_to_UART
231 00150       1468                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
232 20117       1469                               CALL send_to_UART
233 00110       1470                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
234 20117       1471                               CALL send_to_UART
235 00110       1472                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
236 20117       1473                               CALL send_to_UART
237 25000       1474                               RETURN
                1475                               ;
                1476                               ;
                1477                               ;Send 'FLASH CRC = ' string to the UART
                1478                               ;
238 201D7       1479               send_FLASH_CRC: CALL send_FLASH
                1480                               ;
                1481                               ;
                1482                               ;Send ' CRC = ' string to the UART
                1483                               ;
239 20147       1484                     send_CRC: CALL send_space
23A 001F0       1485                               LOAD UART_data, character_C
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
23B 20117       1486                               CALL send_to_UART
23C 00180       1487                               LOAD UART_data, character_R
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
23D 20117       1488                               CALL send_to_UART
23E 001F0       1489                               LOAD UART_data, character_C
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
23F 20117       1490                               CALL send_to_UART
240 2014A       1491                               CALL send_equals
241 25000       1492                               RETURN
                1493                               ;
                1494                               ;
                1495                               ;
                1496                               ;Send 'Computed CRC = ' string to the UART
                1497                               ;
242 001F0       1498            send_Computed_CRC: LOAD UART_data, character_C
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
243 20117       1499                               CALL send_to_UART
244 00110       1500                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
245 20117       1501                               CALL send_to_UART
246 00160       1502                               LOAD UART_data, character_m
247 20117       1503                               CALL send_to_UART
248 00160       1504                               LOAD UART_data, character_p
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
249 20117       1505                               CALL send_to_UART
24A 001B0       1506                               LOAD UART_data, character_u
W: value out of range: 75, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
24B 20117       1507                               CALL send_to_UART
24C 001A0       1508                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
24D 20117       1509                               CALL send_to_UART
24E 00110       1510                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
24F 20117       1511                               CALL send_to_UART
250 00100       1512                               LOAD UART_data, character_d
W: value out of range: 64, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
251 20117       1513                               CALL send_to_UART
252 22239       1514                               JUMP send_CRC
                1515                               ;
                1516                               ;
                1517                               ;Send 'Erase ' string to the UART
                1518                               ;
253 00110       1519                   send_Erase: LOAD UART_data, character_E
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
254 20117       1520                               CALL send_to_UART
255 00180       1521                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
256 20117       1522                               CALL send_to_UART
257 001D0       1523                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
258 20117       1524                               CALL send_to_UART
259 00190       1525                               LOAD UART_data, character_s
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
25A 20117       1526                               CALL send_to_UART
25B 00110       1527                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
25C 20117       1528                               CALL send_to_UART
25D 20147       1529                               CALL send_space
25E 25000       1530                               RETURN
                1531                               ;
                1532                               ;
                1533                               ;Send 'Erase Authorisation in progress' string to the UART
                1534                               ;
25F 20144       1535       send_Erase_in_progress: CALL send_CR
260 20253       1536                               CALL send_Erase
261 20212       1537                               CALL send_Authorisation
262 20147       1538                               CALL send_space
263 00150       1539                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
264 20117       1540                               CALL send_to_UART
265 00110       1541                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
266 20117       1542                               CALL send_to_UART
267 20147       1543                               CALL send_space
268 00160       1544                               LOAD UART_data, character_P
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
269 20117       1545                               CALL send_to_UART
26A 00180       1546                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
26B 20117       1547                               CALL send_to_UART
26C 00110       1548                               LOAD UART_data, character_o
E: symbol not defined: `CHARACTER_O'.
26D 20117       1549                               CALL send_to_UART
26E 00130       1550                               LOAD UART_data, character_g
W: value out of range: 67, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
26F 20117       1551                               CALL send_to_UART
270 00180       1552                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
271 20117       1553                               CALL send_to_UART
272 00110       1554                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
273 20117       1555                               CALL send_to_UART
274 00190       1556                               LOAD UART_data, character_s
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
275 20117       1557                               CALL send_to_UART
276 20117       1558                               CALL send_to_UART
277 20144       1559                               CALL send_CR
278 25000       1560                               RETURN
                1561                               ;
                1562                               ;
                1563                               ;Send 'OK' to the UART
                1564                               ;
279 00110       1565                      send_OK: LOAD UART_data, character_O
E: symbol not defined: `CHARACTER_O'.
27A 20117       1566                               CALL send_to_UART
27B 00110       1567                               LOAD UART_data, character_K
E: symbol not defined: `CHARACTER_K'.
27C 20117       1568                               CALL send_to_UART
27D 20144       1569                               CALL send_CR
27E 25000       1570                               RETURN
                1571                               ;
                1572                               ;
                1573                               ;Send ' FAILED' to the UART
                1574                               ;
27F 20147       1575                  send_FAILED: CALL send_space
280 00120       1576                               LOAD UART_data, character_F
W: value out of range: 66, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
281 20117       1577                               CALL send_to_UART
282 001D0       1578                               LOAD UART_data, character_A
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
283 20117       1579                               CALL send_to_UART
284 00150       1580                               LOAD UART_data, character_I
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
285 20117       1581                               CALL send_to_UART
286 00110       1582                               LOAD UART_data, character_L
E: symbol not defined: `CHARACTER_L'.
287 20117       1583                               CALL send_to_UART
288 00110       1584                               LOAD UART_data, character_E
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
289 20117       1585                               CALL send_to_UART
28A 00100       1586                               LOAD UART_data, character_D
W: value out of range: 64, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
28B 20117       1587                               CALL send_to_UART
28C 25000       1588                               RETURN
                1589                               ;
                1590                               ;
                1591                               ;Send ' PASSED' to the UART
                1592                               ;
28D 20147       1593                  send_PASSED: CALL send_space
28E 00160       1594                               LOAD UART_data, character_P
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
28F 20117       1595                               CALL send_to_UART
290 001D0       1596                               LOAD UART_data, character_A
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
291 20117       1597                               CALL send_to_UART
292 00190       1598                               LOAD UART_data, character_S
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
293 20117       1599                               CALL send_to_UART
294 20117       1600                               CALL send_to_UART
295 00110       1601                               LOAD UART_data, character_E
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
296 20117       1602                               CALL send_to_UART
297 00100       1603                               LOAD UART_data, character_D
W: value out of range: 64, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
298 20117       1604                               CALL send_to_UART
299 25000       1605                               RETURN
                1606                               ;
                1607                               ;
                1608                               ;
                1609                               ;Send 'Writing Authorisation' to the UART
                1610                               ;
29A 20144       1611                 send_Writing: CALL send_CR
29B 001D0       1612                               LOAD UART_data, character_W
W: value out of range: 77, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
29C 20117       1613                               CALL send_to_UART
29D 00180       1614                               LOAD UART_data, character_r
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
29E 20117       1615                               CALL send_to_UART
29F 00150       1616                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
2A0 20117       1617                               CALL send_to_UART
2A1 001A0       1618                               LOAD UART_data, character_t
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
2A2 20117       1619                               CALL send_to_UART
2A3 00150       1620                               LOAD UART_data, character_i
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
2A4 20117       1621                               CALL send_to_UART
2A5 00110       1622                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
2A6 20117       1623                               CALL send_to_UART
2A7 00130       1624                               LOAD UART_data, character_g
W: value out of range: 67, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
2A8 20117       1625                               CALL send_to_UART
2A9 20147       1626                               CALL send_space
2AA 20212       1627                               CALL send_Authorisation
2AB 25000       1628                               RETURN
                1629                               ;
                1630                               ;Send simple menu of options to the UART
                1631                               ;
                1632                               ;
2AC 20144       1633                    send_Menu: CALL send_CR
2AD 20144       1634                               CALL send_CR
2AE 00160       1635                               LOAD UART_data, character_M
2AF 20117       1636                               CALL send_to_UART
2B0 00110       1637                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
2B1 20117       1638                               CALL send_to_UART
2B2 00110       1639                               LOAD UART_data, character_n
E: symbol not defined: `CHARACTER_N'.
2B3 20117       1640                               CALL send_to_UART
2B4 001B0       1641                               LOAD UART_data, character_u
W: value out of range: 75, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
2B5 20117       1642                               CALL send_to_UART
2B6 20144       1643                               CALL send_CR
2B7 20144       1644                               CALL send_CR
2B8 00180       1645                               LOAD UART_data, character_R
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
2B9 20117       1646                               CALL send_to_UART
2BA 2014F       1647                               CALL send_dash
2BB 00180       1648                               LOAD UART_data, character_R
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
2BC 20117       1649                               CALL send_to_UART
2BD 00110       1650                               LOAD UART_data, character_e
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
2BE 20117       1651                               CALL send_to_UART
2BF 001D0       1652                               LOAD UART_data, character_a
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
2C0 20117       1653                               CALL send_to_UART
2C1 00100       1654                               LOAD UART_data, character_d
W: value out of range: 64, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
2C2 20117       1655                               CALL send_to_UART
2C3 20147       1656                               CALL send_space
2C4 20212       1657                               CALL send_Authorisation
2C5 20144       1658                               CALL send_CR
2C6 00110       1659                               LOAD UART_data, character_E
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
2C7 20117       1660                               CALL send_to_UART
2C8 2014F       1661                               CALL send_dash
2C9 20253       1662                               CALL send_Erase
2CA 20212       1663                               CALL send_Authorisation
2CB 20144       1664                               CALL send_CR
2CC 001D0       1665                               LOAD UART_data, character_A
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
2CD 20117       1666                               CALL send_to_UART
2CE 2014F       1667                               CALL send_dash
2CF 2021E       1668                               CALL send_Authorise
2D0 20144       1669                               CALL send_CR
2D1 20144       1670                               CALL send_CR
2D2 00110       1671                               LOAD UART_data, character_greater_than   ;prompt for input
E: symbol not defined: `CHARACTER_GREATER_THAN'.
2D3 20117       1672                               CALL send_to_UART
2D4 25000       1673                               RETURN
                1674                               ;
                1675                               ;**************************************************************************************
                1676                               ;LCD Character Module Routines
                1677                               ;**************************************************************************************
                1678                               ;
                1679                               ;LCD module is a 16 character by 2 line display but all displays are very similar
                1680                               ;The 4-wire data interface will be used (DB4 to DB7).
                1681                               ;
                1682                               ;The LCD modules are relatively slow and software delay loops are used to slow down
                1683                               ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
                1684                               ;a different section (see above in this case).
                1685                               ;
                1686                               ;
                1687                               ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
                1688                               ;
                1689                               ;Register s4 should define the current state of the LCD output port.
                1690                               ;
                1691                               ;Registers used s0, s4
                1692                               ;
2D5 06110       1693                  LCD_pulse_E: XOR s4, LCD_E                            ;E=1
E: symbol not defined: `S4'.
2D6 2D114       1694                               OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
2D7 20333       1695                               CALL delay_1us
2D8 06110       1696                               XOR s4, LCD_E                            ;E=0
E: symbol not defined: `S4'.
2D9 2D114       1697                               OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
2DA 25000       1698                               RETURN
                1699                               ;
                1700                               ;Write 4-bit instruction to LCD display.
                1701                               ;
                1702                               ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
                1703                               ;Note that this routine does not release the master enable but as it is only
                1704                               ;used during initialisation and as part of the 8-bit instruction write it
                1705                               ;should be acceptable.
                1706                               ;
                1707                               ;Registers used s4
                1708                               ;
2DB 02110       1709              LCD_write_inst4: AND s4, F8                               ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F8'.
2DC 2D114       1710                               OUTPUT s4, LCD_output_port               ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
2DD 202D5       1711                               CALL LCD_pulse_E
2DE 25000       1712                               RETURN
                1713                               ;
                1714                               ;
                1715                               ;Write 8-bit instruction to LCD display.
                1716                               ;
                1717                               ;The 8-bit instruction should be provided in register s5.
                1718                               ;Instructions are written using the following sequence
                1719                               ; Upper nibble
                1720                               ; wait >1us
                1721                               ; Lower nibble
                1722                               ; wait >40us
                1723                               ;
                1724                               ;Registers used s0, s1, s4, s5
                1725                               ;
2DF 00110       1726              LCD_write_inst8: LOAD s4, s5
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
2E0 02110       1727                               AND s4, F0                               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
2E1 04180       1728                               OR s4, LCD_drive                         ;Enable=1
E: symbol not defined: `S4'.
2E2 202DB       1729                               CALL LCD_write_inst4                     ;write upper nibble
2E3 20333       1730                               CALL delay_1us                           ;wait >1us
2E4 00110       1731                               LOAD s4, s5                              ;select lower nibble with
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
2E5 14107       1732                               SL1 s4                                   ;Enable=1
E: symbol not defined: `S4'.
2E6 14106       1733                               SL0 s4                                   ;RS=0 Instruction
E: symbol not defined: `S4'.
2E7 14106       1734                               SL0 s4                                   ;RW=0 Write
E: symbol not defined: `S4'.
2E8 14106       1735                               SL0 s4                                   ;E=0
E: symbol not defined: `S4'.
2E9 202DB       1736                               CALL LCD_write_inst4                     ;write lower nibble
2EA 20337       1737                               CALL delay_40us                          ;wait >40us
2EB 00110       1738                               LOAD s4, F0                              ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
2EC 2D114       1739                               OUTPUT s4, LCD_output_port               ;Release master enable
E: symbol not defined: `S4'.
2ED 25000       1740                               RETURN
                1741                               ;
                1742                               ;
                1743                               ;
                1744                               ;Write 8-bit data to LCD display.
                1745                               ;
                1746                               ;The 8-bit data should be provided in register s5.
                1747                               ;Data bytes are written using the following sequence
                1748                               ; Upper nibble
                1749                               ; wait >1us
                1750                               ; Lower nibble
                1751                               ; wait >40us
                1752                               ;
                1753                               ;Registers used s0, s1, s4, s5
                1754                               ;
2EE 00110       1755               LCD_write_data: LOAD s4, s5
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
2EF 02110       1756                               AND s4, F0                               ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
                1757                               OR s4, 0C                                ;Enable=1 RS=1 Data, RW=0 Write, E=0
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
2F0 2D114       1758                               OUTPUT s4, LCD_output_port               ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
2F1 202D5       1759                               CALL LCD_pulse_E                         ;write upper nibble
2F2 20333       1760                               CALL delay_1us                           ;wait >1us
2F3 00110       1761                               LOAD s4, s5                              ;select lower nibble with
E: symbol not defined: `S4'.
E: symbol not defined: `S5'.
2F4 14107       1762                               SL1 s4                                   ;Enable=1
E: symbol not defined: `S4'.
2F5 14107       1763                               SL1 s4                                   ;RS=1 Data
E: symbol not defined: `S4'.
2F6 14106       1764                               SL0 s4                                   ;RW=0 Write
E: symbol not defined: `S4'.
2F7 14106       1765                               SL0 s4                                   ;E=0
E: symbol not defined: `S4'.
2F8 2D114       1766                               OUTPUT s4, LCD_output_port               ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
2F9 202D5       1767                               CALL LCD_pulse_E                         ;write lower nibble
2FA 20337       1768                               CALL delay_40us                          ;wait >40us
2FB 00110       1769                               LOAD s4, F0                              ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
E: symbol not defined: `S4'.
E: symbol not defined: `F0'.
2FC 2D114       1770                               OUTPUT s4, LCD_output_port               ;Release master enable
E: symbol not defined: `S4'.
2FD 25000       1771                               RETURN
                1772                               ;
                1773                               ;
                1774                               ;
                1775                               ;
                1776                               ;Read 8-bit data from LCD display.
                1777                               ;
                1778                               ;The 8-bit data will be read from the current LCD memory address
                1779                               ;and will be returned in register s5.
                1780                               ;It is advisable to set the LCD address (cursor position) before
                1781                               ;using the data read for the first time otherwise the display may
                1782                               ;generate invalid data on the first read.
                1783                               ;
                1784                               ;Data bytes are read using the following sequence
                1785                               ; Upper nibble
                1786                               ; wait >1us
                1787                               ; Lower nibble
                1788                               ; wait >40us
                1789                               ;
                1790                               ;Registers used s0, s1, s4, s5
                1791                               ;
                1792               LCD_read_data8: LOAD s4, 0E                              ;Enable=1 RS=1 Data, RW=1 Read, E=0
E: identifier cannot start with a digit: `0E'.
E: unexpected end of line.
2FE 2D114       1793                               OUTPUT s4, LCD_output_port               ;set up RS and RW >40ns before enable pulse
E: symbol not defined: `S4'.
2FF 06110       1794                               XOR s4, LCD_E                            ;E=1
E: symbol not defined: `S4'.
300 2D114       1795                               OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
301 20333       1796                               CALL delay_1us                           ;wait >260ns to access data
302 09103       1797                               INPUT s5, LCD_input_port                 ;read upper nibble
E: symbol not defined: `S5'.
303 06110       1798                               XOR s4, LCD_E                            ;E=0
E: symbol not defined: `S4'.
304 2D114       1799                               OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
305 20333       1800                               CALL delay_1us                           ;wait >1us
306 06110       1801                               XOR s4, LCD_E                            ;E=1
E: symbol not defined: `S4'.
307 2D114       1802                               OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
308 20333       1803                               CALL delay_1us                           ;wait >260ns to access data
309 09103       1804                               INPUT s0, LCD_input_port                 ;read lower nibble
E: symbol not defined: `S0'.
30A 06110       1805                               XOR s4, LCD_E                            ;E=0
E: symbol not defined: `S4'.
30B 2D114       1806                               OUTPUT s4, LCD_output_port
E: symbol not defined: `S4'.
30C 02110       1807                               AND s5, F0                               ;merge upper and lower nibbles
E: symbol not defined: `S5'.
E: symbol not defined: `F0'.
30D 1410E       1808                               SR0 s0
E: symbol not defined: `S0'.
30E 1410E       1809                               SR0 s0
E: symbol not defined: `S0'.
30F 1410E       1810                               SR0 s0
E: symbol not defined: `S0'.
310 1410E       1811                               SR0 s0
E: symbol not defined: `S0'.
311 04110       1812                               OR s5, s0
E: symbol not defined: `S5'.
E: symbol not defined: `S0'.
312 00140       1813                               LOAD s4, 04                              ;Enable=0 RS=1 Data, RW=0 Write, E=0
E: symbol not defined: `S4'.
313 2D114       1814                               OUTPUT s4, LCD_output_port               ;Stop reading 5V device and release master enable
E: symbol not defined: `S4'.
314 20337       1815                               CALL delay_40us                          ;wait >40us
315 25000       1816                               RETURN
                1817                               ;
                1818                               ;
                1819                               ;Reset and initialise display to communicate using 4-bit data mode
                1820                               ;Includes routine to clear the display.
                1821                               ;
                1822                               ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
                1823                               ;following by the 8-bit instructions to set up the display.
                1824                               ;
                1825                               ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
                1826                               ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
                1827                               ;  0C = '00001' Display control, '1' display on, '0' cursor off, '0' cursor blink off
                1828                               ;  01 = '00000001' Display clear
                1829                               ;
                1830                               ;Registers used s0, s1, s2, s3, s4
                1831                               ;
316 20341       1832                    LCD_reset: CALL delay_20ms                          ;wait more that 15ms for display to be ready
317 001E0       1833                               LOAD s4, 30
E: symbol not defined: `S4'.
W: value out of range: 30, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
318 202DB       1834                               CALL LCD_write_inst4                     ;send '3'
319 20341       1835                               CALL delay_20ms                          ;wait >4.1ms
31A 202DB       1836                               CALL LCD_write_inst4                     ;send '3'
31B 2033C       1837                               CALL delay_1ms                           ;wait >100us
31C 202DB       1838                               CALL LCD_write_inst4                     ;send '3'
31D 20337       1839                               CALL delay_40us                          ;wait >40us
31E 00140       1840                               LOAD s4, 20
E: symbol not defined: `S4'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
31F 202DB       1841                               CALL LCD_write_inst4                     ;send '2'
320 20337       1842                               CALL delay_40us                          ;wait >40us
321 001C0       1843                               LOAD s5, 28                              ;Function set
E: symbol not defined: `S5'.
W: value out of range: 28, allowed range is [0,15] (trimmed to 4 bits) which makes it 12.
322 202DF       1844                               CALL LCD_write_inst8
323 00160       1845                               LOAD s5, 06                              ;Entry mode
E: symbol not defined: `S5'.
324 202DF       1846                               CALL LCD_write_inst8
                1847                               LOAD s5, 0C                              ;Display control
E: identifier cannot start with a digit: `0C'.
E: unexpected end of line.
325 202DF       1848                               CALL LCD_write_inst8
326 00110       1849                    LCD_clear: LOAD s5, 01                              ;Display clear
E: symbol not defined: `S5'.
327 202DF       1850                               CALL LCD_write_inst8
328 2033C       1851                               CALL delay_1ms                           ;wait >1.64ms for display to clear
329 2033C       1852                               CALL delay_1ms
32A 25000       1853                               RETURN
                1854                               ;
                1855                               ;Position the cursor ready for characters to be written.
                1856                               ;The display is formed of 2 lines of 16 characters and each
                1857                               ;position has a corresponding address as indicated below.
                1858                               ;
                1859                               ;                   Character position
                1860                               ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
                1861                               ;
                1862                               ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
                1863                               ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
                1864                               ;
                1865                               ;This routine will set the cursor position using the value provided
                1866                               ;in register s5. The upper nibble will define the line and the lower
                1867                               ;nibble the character position on the line.
                1868                               ; Example s5 = 2B will position the cursor on line 2 position 11
                1869                               ;
                1870                               ;Registers used s0, s1, s2, s3, s4
                1871                               ;
32B 0C1A0       1872                   LCD_cursor: TEST s5, 10                              ;test for line 1
E: symbol not defined: `S5'.
32C 32001       1873                               JUMP Z, set_line2
E: symbol not defined: `SET_LINE2'.
                1874                               AND s5, 0F                               ;make address in range 80 to 8F for line 1
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
32D 04100       1875                               OR s5, 80
E: symbol not defined: `S5'.
W: value out of range: 80, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
32E 202DF       1876                               CALL LCD_write_inst8                     ;instruction write to set cursor
32F 25000       1877                               RETURN
                1878                    set_line2: AND s5, 0F                               ;make address in range C0 to CF for line 2
E: identifier cannot start with a digit: `0F'.
E: unexpected end of line.
330 04110       1879                               OR s5, C0
E: symbol not defined: `S5'.
E: symbol not defined: `C0'.
331 202DF       1880                               CALL LCD_write_inst8                     ;instruction write to set cursor
332 25000       1881                               RETURN
                1882                               ;
                1883                               ;**************************************************************************************
                1884                               ;Software delay routines
                1885                               ;**************************************************************************************
                1886                               ;
                1887                               ;
                1888                               ;
                1889                               ;Delay of 1us.
                1890                               ;
                1891                               ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
                1892                               ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
                1893                               ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
                1894                               ;
                1895                               ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
                1896                               ;
                1897                               ;Registers used s0
                1898                               ;
333 00100       1899                    delay_1us: LOAD s0, delay_1us_constant
E: symbol not defined: `S0'.
334 18110       1900                     wait_1us: SUB s0, 01
E: symbol not defined: `S0'.
335 36334       1901                               JUMP NZ, wait_1us
336 25000       1902                               RETURN
                1903                               ;
                1904                               ;Delay of 40us.
                1905                               ;
                1906                               ;Registers used s0, s1
                1907                               ;
337 001C0       1908                   delay_40us: LOAD s1, 28                              ;40 x 1us = 40us
E: symbol not defined: `S1'.
W: value out of range: 28, allowed range is [0,15] (trimmed to 4 bits) which makes it 12.
338 20333       1909                    wait_40us: CALL delay_1us
339 18110       1910                               SUB s1, 01
E: symbol not defined: `S1'.
33A 36338       1911                               JUMP NZ, wait_40us
33B 25000       1912                               RETURN
                1913                               ;
                1914                               ;
                1915                               ;Delay of 1ms.
                1916                               ;
                1917                               ;Registers used s0, s1, s2
                1918                               ;
33C 00130       1919                    delay_1ms: LOAD s2, 19                              ;25 x 40us = 1ms
E: symbol not defined: `S2'.
W: value out of range: 19, allowed range is [0,15] (trimmed to 4 bits) which makes it 3.
33D 20337       1920                     wait_1ms: CALL delay_40us
33E 18110       1921                               SUB s2, 01
E: symbol not defined: `S2'.
33F 3633D       1922                               JUMP NZ, wait_1ms
340 25000       1923                               RETURN
                1924                               ;
                1925                               ;Delay of 20ms.
                1926                               ;
                1927                               ;Delay of 20ms used during initialisation.
                1928                               ;
                1929                               ;Registers used s0, s1, s2, s3
                1930                               ;
341 001E0       1931                   delay_20ms: LOAD s3, 14                              ;20 x 1ms = 20ms
E: symbol not defined: `S3'.
342 2033C       1932                    wait_20ms: CALL delay_1ms
343 18110       1933                               SUB s3, 01
E: symbol not defined: `S3'.
344 36342       1934                               JUMP NZ, wait_20ms
345 25000       1935                               RETURN
                1936                               ;
                1937                               ;Delay of approximately 1 second.
                1938                               ;
                1939                               ;Registers used s0, s1, s2, s3, s4
                1940                               ;
346 00100       1941                     delay_1s: LOAD s4, 32                              ;50 x 20ms = 1000ms
E: symbol not defined: `S4'.
W: value out of range: 32, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
347 20341       1942                      wait_1s: CALL delay_20ms
348 18110       1943                               SUB s4, 01
E: symbol not defined: `S4'.
349 36347       1944                               JUMP NZ, wait_1s
34A 25000       1945                               RETURN
                1946                               ;
                1947                               ;
                1948                               ;Delay of approximately N seconds where 'N' is provided in register s5.
                1949                               ;
                1950                               ;Registers used s0, s1, s2, s3, s4, s5
                1951                               ;
34B 20346       1952                     delay_Ns: CALL delay_1s
34C 18110       1953                               SUB s5, 01
E: symbol not defined: `S5'.
34D 3634B       1954                               JUMP NZ, delay_Ns
34E 25000       1955                               RETURN
                1956                               ;
                1957                               ;
                1958                               ;
                1959                               ;**************************************************************************************
                1960                               ;LCD text messages
                1961                               ;**************************************************************************************
                1962                               ;
                1963                               ;
                1964                               ;
                1965                               ;Display 'PicoBlaze' on LCD at current cursor position
                1966                               ;
                1967                               ;
34F 00160       1968               disp_PicoBlaze: LOAD s5, character_P
E: symbol not defined: `S5'.
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
350 202EE       1969                               CALL LCD_write_data
351 00150       1970                               LOAD s5, character_i
E: symbol not defined: `S5'.
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
352 202EE       1971                               CALL LCD_write_data
353 001F0       1972                               LOAD s5, character_c
E: symbol not defined: `S5'.
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
354 202EE       1973                               CALL LCD_write_data
355 00110       1974                               LOAD s5, character_o
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_O'.
356 202EE       1975                               CALL LCD_write_data
357 001E0       1976                               LOAD s5, character_B
E: symbol not defined: `S5'.
W: value out of range: 62, allowed range is [0,15] (trimmed to 4 bits) which makes it 14.
358 202EE       1977                               CALL LCD_write_data
359 00110       1978                               LOAD s5, character_l
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_L'.
35A 202EE       1979                               CALL LCD_write_data
35B 001D0       1980                               LOAD s5, character_a
E: symbol not defined: `S5'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
35C 202EE       1981                               CALL LCD_write_data
35D 00110       1982                               LOAD s5, character_z
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_Z'.
35E 202EE       1983                               CALL LCD_write_data
35F 00110       1984                               LOAD s5, character_e
E: symbol not defined: `S5'.
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
360 202EE       1985                               CALL LCD_write_data
361 25000       1986                               RETURN
                1987                               ;
                1988                               ;
                1989                               ;Display 'Security' on LCD at current cursor position
                1990                               ;
                1991                               ;
362 00190       1992                disp_Security: LOAD s5, character_S
E: symbol not defined: `S5'.
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
363 202EE       1993                               CALL LCD_write_data
364 00110       1994                               LOAD s5, character_e
E: symbol not defined: `S5'.
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
365 202EE       1995                               CALL LCD_write_data
366 001F0       1996                               LOAD s5, character_c
E: symbol not defined: `S5'.
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
367 202EE       1997                               CALL LCD_write_data
368 001B0       1998                               LOAD s5, character_u
E: symbol not defined: `S5'.
W: value out of range: 75, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
369 202EE       1999                               CALL LCD_write_data
36A 00180       2000                               LOAD s5, character_r
E: symbol not defined: `S5'.
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
36B 202EE       2001                               CALL LCD_write_data
36C 00150       2002                               LOAD s5, character_i
E: symbol not defined: `S5'.
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
36D 202EE       2003                               CALL LCD_write_data
36E 001A0       2004                               LOAD s5, character_t
E: symbol not defined: `S5'.
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
36F 202EE       2005                               CALL LCD_write_data
370 001F0       2006                               LOAD s5, character_y
E: symbol not defined: `S5'.
W: value out of range: 79, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
371 202EE       2007                               CALL LCD_write_data
372 25000       2008                               RETURN
                2009                               ;
                2010                               ;
                2011                               ;Display 'FLASH Serial No.' on LCD at current cursor position
                2012                               ;
                2013                               ;
373 00120       2014         disp_FLASH_Serial_No: LOAD s5, character_F
E: symbol not defined: `S5'.
W: value out of range: 66, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
374 202EE       2015                               CALL LCD_write_data
375 00110       2016                               LOAD s5, character_L
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_L'.
376 202EE       2017                               CALL LCD_write_data
377 001D0       2018                               LOAD s5, character_A
E: symbol not defined: `S5'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
378 202EE       2019                               CALL LCD_write_data
379 00190       2020                               LOAD s5, character_S
E: symbol not defined: `S5'.
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
37A 202EE       2021                               CALL LCD_write_data
37B 00140       2022                               LOAD s5, character_H
E: symbol not defined: `S5'.
W: value out of range: 68, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
37C 202EE       2023                               CALL LCD_write_data
37D 00140       2024                               LOAD s5, character_space
E: symbol not defined: `S5'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
37E 202EE       2025                               CALL LCD_write_data
37F 00190       2026                               LOAD s5, character_S
E: symbol not defined: `S5'.
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
380 202EE       2027                               CALL LCD_write_data
381 00110       2028                               LOAD s5, character_e
E: symbol not defined: `S5'.
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
382 202EE       2029                               CALL LCD_write_data
383 00180       2030                               LOAD s5, character_r
E: symbol not defined: `S5'.
W: value out of range: 72, allowed range is [0,15] (trimmed to 4 bits) which makes it 8.
384 202EE       2031                               CALL LCD_write_data
385 00150       2032                               LOAD s5, character_i
E: symbol not defined: `S5'.
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
386 202EE       2033                               CALL LCD_write_data
387 001D0       2034                               LOAD s5, character_a
E: symbol not defined: `S5'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
388 202EE       2035                               CALL LCD_write_data
389 00110       2036                               LOAD s5, character_l
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_L'.
38A 202EE       2037                               CALL LCD_write_data
38B 00140       2038                               LOAD s5, character_space
E: symbol not defined: `S5'.
W: value out of range: 20, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
38C 202EE       2039                               CALL LCD_write_data
38D 00110       2040                               LOAD s5, character_N
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_N'.
38E 202EE       2041                               CALL LCD_write_data
38F 00110       2042                               LOAD s5, character_o
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_O'.
390 202EE       2043                               CALL LCD_write_data
391 00110       2044                               LOAD s5, character_fullstop
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_FULLSTOP'.
392 202EE       2045                               CALL LCD_write_data
393 25000       2046                               RETURN
                2047                               ;
                2048                               ;
                2049                               ;
                2050                               ;Display 'Authentication' on top line of the LCD
                2051                               ;
                2052                               ;
394 001B0       2053          disp_Authentication: LOAD s5, 11                              ;Line 1 position 1
E: symbol not defined: `S5'.
395 2032B       2054                               CALL LCD_cursor
396 001D0       2055                               LOAD s5, character_A
E: symbol not defined: `S5'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
397 202EE       2056                               CALL LCD_write_data
398 001B0       2057                               LOAD s5, character_u
E: symbol not defined: `S5'.
W: value out of range: 75, allowed range is [0,15] (trimmed to 4 bits) which makes it 11.
399 202EE       2058                               CALL LCD_write_data
39A 001A0       2059                               LOAD s5, character_t
E: symbol not defined: `S5'.
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
39B 202EE       2060                               CALL LCD_write_data
39C 00140       2061                               LOAD s5, character_h
E: symbol not defined: `S5'.
W: value out of range: 68, allowed range is [0,15] (trimmed to 4 bits) which makes it 4.
39D 202EE       2062                               CALL LCD_write_data
39E 00110       2063                               LOAD s5, character_e
E: symbol not defined: `S5'.
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
39F 202EE       2064                               CALL LCD_write_data
3A0 00110       2065                               LOAD s5, character_n
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_N'.
3A1 202EE       2066                               CALL LCD_write_data
3A2 001A0       2067                               LOAD s5, character_t
E: symbol not defined: `S5'.
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
3A3 202EE       2068                               CALL LCD_write_data
3A4 00150       2069                               LOAD s5, character_i
E: symbol not defined: `S5'.
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
3A5 202EE       2070                               CALL LCD_write_data
3A6 001F0       2071                               LOAD s5, character_c
E: symbol not defined: `S5'.
W: value out of range: 63, allowed range is [0,15] (trimmed to 4 bits) which makes it 15.
3A7 202EE       2072                               CALL LCD_write_data
3A8 001D0       2073                               LOAD s5, character_a
E: symbol not defined: `S5'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
3A9 202EE       2074                               CALL LCD_write_data
3AA 001A0       2075                               LOAD s5, character_t
E: symbol not defined: `S5'.
W: value out of range: 74, allowed range is [0,15] (trimmed to 4 bits) which makes it 10.
3AB 202EE       2076                               CALL LCD_write_data
3AC 00150       2077                               LOAD s5, character_i
E: symbol not defined: `S5'.
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
3AD 202EE       2078                               CALL LCD_write_data
3AE 00110       2079                               LOAD s5, character_o
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_O'.
3AF 202EE       2080                               CALL LCD_write_data
3B0 00110       2081                               LOAD s5, character_n
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_N'.
3B1 202EE       2082                               CALL LCD_write_data
3B2 25000       2083                               RETURN
                2084                               ;
                2085                               ;
                2086                               ;
                2087                               ;
                2088                               ;Display 'Passed' on lower line of the LCD
                2089                               ;
                2090                               ;
3B3 00190       2091                  disp_Passed: LOAD s5, 25                              ;Line 2 position 5
E: symbol not defined: `S5'.
W: value out of range: 25, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
3B4 2032B       2092                               CALL LCD_cursor
3B5 00160       2093                               LOAD s5, character_P
E: symbol not defined: `S5'.
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
3B6 202EE       2094                               CALL LCD_write_data
3B7 001D0       2095                               LOAD s5, character_a
E: symbol not defined: `S5'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
3B8 202EE       2096                               CALL LCD_write_data
3B9 00190       2097                               LOAD s5, character_s
E: symbol not defined: `S5'.
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
3BA 202EE       2098                               CALL LCD_write_data
3BB 202EE       2099                               CALL LCD_write_data
3BC 00110       2100                               LOAD s5, character_e
E: symbol not defined: `S5'.
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
3BD 202EE       2101                               CALL LCD_write_data
3BE 00100       2102                               LOAD s5, character_d
E: symbol not defined: `S5'.
W: value out of range: 64, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
3BF 202EE       2103                               CALL LCD_write_data
3C0 25000       2104                               RETURN
                2105                               ;
                2106                               ;
                2107                               ;
                2108                               ;
                2109                               ;
                2110                               ;Display 'Failed' on lower line of the LCD
                2111                               ;
                2112                               ;
3C1 00190       2113                  disp_Failed: LOAD s5, 25                              ;Line 2 position 5
E: symbol not defined: `S5'.
W: value out of range: 25, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
3C2 2032B       2114                               CALL LCD_cursor
3C3 00120       2115                               LOAD s5, character_F
E: symbol not defined: `S5'.
W: value out of range: 66, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
3C4 202EE       2116                               CALL LCD_write_data
3C5 001D0       2117                               LOAD s5, character_a
E: symbol not defined: `S5'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
3C6 202EE       2118                               CALL LCD_write_data
3C7 00150       2119                               LOAD s5, character_i
E: symbol not defined: `S5'.
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
3C8 202EE       2120                               CALL LCD_write_data
3C9 00110       2121                               LOAD s5, character_l
E: symbol not defined: `S5'.
E: symbol not defined: `CHARACTER_L'.
3CA 202EE       2122                               CALL LCD_write_data
3CB 00110       2123                               LOAD s5, character_e
E: symbol not defined: `S5'.
W: value out of range: 65, allowed range is [0,15] (trimmed to 4 bits) which makes it 1.
3CC 202EE       2124                               CALL LCD_write_data
3CD 00100       2125                               LOAD s5, character_d
E: symbol not defined: `S5'.
W: value out of range: 64, allowed range is [0,15] (trimmed to 4 bits) which makes it 0.
3CE 202EE       2126                               CALL LCD_write_data
3CF 25000       2127                               RETURN
                2128                               ;
                2129                               ;
                2130                               ;**************************************************************************************
                2131                               ; Interrupt Service Routine (ISR)
                2132                               ;**************************************************************************************
                2133                               ;
                2134                               ; Interrupts occur when the application processor is requesting a design authorisation
                2135                               ; message. Therefore an interrupt results in a message being sent to the Link FIFO
                2136                               ; depending on the authentication status.
                2137                               ;
3D0 2F100       2138                          ISR: STORE s0, ISR_preserve_s0                ;save register contents
E: symbol not defined: `S0'.
                2139                               ;
3D1 0B101       2140                               FETCH s0, authentication_status          ;read authentication status
E: symbol not defined: `S0'.
E: symbol not defined: `AUTHENTICATION_STATUS'.
3D2 1C160       2141                               COMPARE s0, character_P                  ;test for pass 'P' or fail 'F'
E: symbol not defined: `S0'.
W: value out of range: 70, allowed range is [0,15] (trimmed to 4 bits) which makes it 6.
3D3 323DD       2142                               JUMP Z, pass_token
                2143                               ;
3D4 00120       2144                               LOAD s0, character_F                     ;send FAIL to link FIFO
E: symbol not defined: `S0'.
W: value out of range: 66, allowed range is [0,15] (trimmed to 4 bits) which makes it 2.
3D5 2D104       2145                               OUTPUT s0, link_FIFO_write_port
E: symbol not defined: `S0'.
3D6 001D0       2146                               LOAD s0, character_A
E: symbol not defined: `S0'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
3D7 2D104       2147                               OUTPUT s0, link_FIFO_write_port
E: symbol not defined: `S0'.
3D8 00150       2148                               LOAD s0, character_I
E: symbol not defined: `S0'.
W: value out of range: 69, allowed range is [0,15] (trimmed to 4 bits) which makes it 5.
3D9 2D104       2149                               OUTPUT s0, link_FIFO_write_port
E: symbol not defined: `S0'.
3DA 00110       2150                               LOAD s0, character_L
E: symbol not defined: `S0'.
E: symbol not defined: `CHARACTER_L'.
3DB 2D104       2151                               OUTPUT s0, link_FIFO_write_port
E: symbol not defined: `S0'.
3DC 223E3       2152                               JUMP end_ISR
                2153                               ;
3DD 2D104       2154                   pass_token: OUTPUT s0, link_FIFO_write_port          ;send PASS to link FIFO
E: symbol not defined: `S0'.
3DE 001D0       2155                               LOAD s0, character_A
E: symbol not defined: `S0'.
W: value out of range: 61, allowed range is [0,15] (trimmed to 4 bits) which makes it 13.
3DF 2D104       2156                               OUTPUT s0, link_FIFO_write_port
E: symbol not defined: `S0'.
3E0 00190       2157                               LOAD s0, character_S
E: symbol not defined: `S0'.
W: value out of range: 73, allowed range is [0,15] (trimmed to 4 bits) which makes it 9.
3E1 2D104       2158                               OUTPUT s0, link_FIFO_write_port
E: symbol not defined: `S0'.
3E2 2D104       2159                               OUTPUT s0, link_FIFO_write_port
E: symbol not defined: `S0'.
                2160                               ;
3E3 0B100       2161                      end_ISR: FETCH s0, ISR_preserve_s0                ;restore register contents
E: symbol not defined: `S0'.
3E4 29001       2162                               RETURNI ENABLE
                2163                               ;
                2164                               ;
                2165                               ;**************************************************************************************
                2166                               ; Interrupt Vector
                2167                               ;**************************************************************************************
                2168                               ;
                2169                               ADDRESS 3FF
E: identifier cannot start with a digit: `3FF'.
E: directive ADDRESS requires a single argument.
3E5 223D0       2170                               JUMP ISR
                2171                               ;
                2172                               ;
                2173                               ;**************************************************************************************
                2174                               ; End of Program
                2175                               ;**************************************************************************************
