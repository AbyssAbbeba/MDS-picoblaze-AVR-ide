
Programmer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000032  00800100  0000059a  0000062e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000059a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000008f  00800132  00800132  00000660  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000660  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000090  00000000  00000000  00000d2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000020  00000000  00000000  00000dbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000278  00000000  00000000  00000ddc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000418  00000000  00000000  00001054  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000000fd  00000000  00000000  0000146c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000060d  00000000  00000000  00001569  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000d0  00000000  00000000  00001b78  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028e  00000000  00000000  00001c48  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000029  00000000  00000000  00001ed6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 0000001e  00000000  00000000  00001eff  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  2c:	0c 94 82 02 	jmp	0x504	; 0x504 <__vector_11>
  30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  44:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	d5 e0       	ldi	r29, 0x05	; 5
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
  b8:	11 e0       	ldi	r17, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	ea e9       	ldi	r30, 0x9A	; 154
  c0:	f5 e0       	ldi	r31, 0x05	; 5
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
  c4:	05 90       	lpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	a2 33       	cpi	r26, 0x32	; 50
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
  ce:	11 e0       	ldi	r17, 0x01	; 1
  d0:	a2 e3       	ldi	r26, 0x32	; 50
  d2:	b1 e0       	ldi	r27, 0x01	; 1
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	a1 3c       	cpi	r26, 0xC1	; 193
  da:	b1 07       	cpc	r27, r17
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	0e 94 de 01 	call	0x3bc	; 0x3bc <main>
  e2:	0c 94 cb 02 	jmp	0x596	; 0x596 <_exit>

000000e6 <__bad_interrupt>:
  e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <endpoint_selection>:
#define endpoint_disable()					(UECONX &= ~(1<<EPEN))		// Disable
																		// 
					
void endpoint_selection(unsigned char endp)								// selects endpoint to manage
{
	if (endp == 0)						// endp 0   - never
  ea:	88 23       	and	r24, r24
  ec:	61 f4       	brne	.+24     	; 0x106 <endpoint_selection+0x1c>
	{
		( UENUM &= ~(1<<UENUM_0)); 
  ee:	e9 ee       	ldi	r30, 0xE9	; 233
  f0:	f0 e0       	ldi	r31, 0x00	; 0
  f2:	90 81       	ld	r25, Z
  f4:	9e 7f       	andi	r25, 0xFE	; 254
  f6:	90 83       	st	Z, r25
		( UENUM &= ~(1<<UENUM_1)); 
  f8:	90 81       	ld	r25, Z
  fa:	9d 7f       	andi	r25, 0xFD	; 253
  fc:	90 83       	st	Z, r25
		( UENUM &= ~(1<<UENUM_2)); 
  fe:	90 81       	ld	r25, Z
 100:	9b 7f       	andi	r25, 0xFB	; 251
 102:	90 83       	st	Z, r25
 104:	1c c0       	rjmp	.+56     	; 0x13e <endpoint_selection+0x54>
	}
	
	if (endp == 1)						// endp 1
 106:	81 30       	cpi	r24, 0x01	; 1
 108:	61 f4       	brne	.+24     	; 0x122 <endpoint_selection+0x38>
	{
		(UENUM |= (1<<UENUM_0)); 
 10a:	e9 ee       	ldi	r30, 0xE9	; 233
 10c:	f0 e0       	ldi	r31, 0x00	; 0
 10e:	90 81       	ld	r25, Z
 110:	91 60       	ori	r25, 0x01	; 1
 112:	90 83       	st	Z, r25
		(UENUM &= ~(1<<UENUM_1)); 
 114:	90 81       	ld	r25, Z
 116:	9d 7f       	andi	r25, 0xFD	; 253
 118:	90 83       	st	Z, r25
		(UENUM &= ~(1<<UENUM_2)); 
 11a:	90 81       	ld	r25, Z
 11c:	9b 7f       	andi	r25, 0xFB	; 251
 11e:	90 83       	st	Z, r25
 120:	1c c0       	rjmp	.+56     	; 0x15a <endpoint_selection+0x70>
	}
	if (endp == 2)						// endp 2
 122:	82 30       	cpi	r24, 0x02	; 2
 124:	61 f4       	brne	.+24     	; 0x13e <endpoint_selection+0x54>
	{
		(UENUM &= ~(1<<UENUM_0)); 
 126:	e9 ee       	ldi	r30, 0xE9	; 233
 128:	f0 e0       	ldi	r31, 0x00	; 0
 12a:	80 81       	ld	r24, Z
 12c:	8e 7f       	andi	r24, 0xFE	; 254
 12e:	80 83       	st	Z, r24
		(UENUM  |= (1<<UENUM_1));
 130:	80 81       	ld	r24, Z
 132:	82 60       	ori	r24, 0x02	; 2
 134:	80 83       	st	Z, r24
		(UENUM &= ~(1<<UENUM_2)); 
 136:	80 81       	ld	r24, Z
 138:	8b 7f       	andi	r24, 0xFB	; 251
 13a:	80 83       	st	Z, r24
 13c:	08 95       	ret
	}
		if (endp == 3)						// endp 3
 13e:	83 30       	cpi	r24, 0x03	; 3
 140:	61 f4       	brne	.+24     	; 0x15a <endpoint_selection+0x70>
	{
		(UENUM  |= (1<<UENUM_0)); 
 142:	e9 ee       	ldi	r30, 0xE9	; 233
 144:	f0 e0       	ldi	r31, 0x00	; 0
 146:	80 81       	ld	r24, Z
 148:	81 60       	ori	r24, 0x01	; 1
 14a:	80 83       	st	Z, r24
		(UENUM  |= (1<<UENUM_1));
 14c:	80 81       	ld	r24, Z
 14e:	82 60       	ori	r24, 0x02	; 2
 150:	80 83       	st	Z, r24
		(UENUM &= ~(1<<UENUM_2)); 
 152:	80 81       	ld	r24, Z
 154:	8b 7f       	andi	r24, 0xFB	; 251
 156:	80 83       	st	Z, r24
 158:	08 95       	ret
	}
		if (endp == 4)						// endp 4
 15a:	84 30       	cpi	r24, 0x04	; 4
 15c:	59 f4       	brne	.+22     	; 0x174 <endpoint_selection+0x8a>
	{
		(UENUM &= ~(1<<UENUM_0)); 
 15e:	e9 ee       	ldi	r30, 0xE9	; 233
 160:	f0 e0       	ldi	r31, 0x00	; 0
 162:	80 81       	ld	r24, Z
 164:	8e 7f       	andi	r24, 0xFE	; 254
 166:	80 83       	st	Z, r24
		(UENUM &= ~(1<<UENUM_1)); 
 168:	80 81       	ld	r24, Z
 16a:	8d 7f       	andi	r24, 0xFD	; 253
 16c:	80 83       	st	Z, r24
		(UENUM  |= (1<<UENUM_2));
 16e:	80 81       	ld	r24, Z
 170:	84 60       	ori	r24, 0x04	; 4
 172:	80 83       	st	Z, r24
 174:	08 95       	ret

00000176 <set_interrupt_endpoint_type>:
					
																		
//				 UECFG0X REGISTR																		
void set_interrupt_endpoint_type(void)									// Selected endpoint type will be INTERRUPT
{
	(UECFG0X |= (1<<EPTYPE0));
 176:	ec ee       	ldi	r30, 0xEC	; 236
 178:	f0 e0       	ldi	r31, 0x00	; 0
 17a:	80 81       	ld	r24, Z
 17c:	80 64       	ori	r24, 0x40	; 64
 17e:	80 83       	st	Z, r24
	(UECFG0X |= (1<<EPTYPE1));
 180:	80 81       	ld	r24, Z
 182:	80 68       	ori	r24, 0x80	; 128
 184:	80 83       	st	Z, r24

}
 186:	08 95       	ret

00000188 <set_endpoint_size_64>:
																		
//               UECFG1X  REGISTR	
																	
void set_endpoint_size_64(void)											// Set this bit according to the endpoint size:
{																		// EPSIZE2 : EPSIZE1 : EPSIZE0
	(UECFG1X &= ~(1<<EPSIZE2));											//	000b: 8 bytes		100b: 128 bytes
 188:	ed ee       	ldi	r30, 0xED	; 237
 18a:	f0 e0       	ldi	r31, 0x00	; 0
 18c:	80 81       	ld	r24, Z
 18e:	8f 7b       	andi	r24, 0xBF	; 191
 190:	80 83       	st	Z, r24
	(UECFG1X |= (1<<EPSIZE0));											//	001b: 16 bytes		101b: 256 bytes
 192:	80 81       	ld	r24, Z
 194:	80 61       	ori	r24, 0x10	; 16
 196:	80 83       	st	Z, r24
	(UECFG1X |= (1<<EPSIZE1));											//	010b: 32 bytes		110b: 512 bytes
 198:	80 81       	ld	r24, Z
 19a:	80 62       	ori	r24, 0x20	; 32
 19c:	80 83       	st	Z, r24
}																		//	011b: 64 bytes		111b: Reserved. Do not use this configuration.
 19e:	08 95       	ret

000001a0 <set_one_bank>:


void set_one_bank(void)													// Set this field according to the endpoint size:
{
	(UECFG1X &= ~(1<<EPBK0));											// 00b: One bank
 1a0:	ed ee       	ldi	r30, 0xED	; 237
 1a2:	f0 e0       	ldi	r31, 0x00	; 0
 1a4:	80 81       	ld	r24, Z
 1a6:	8b 7f       	andi	r24, 0xFB	; 251
 1a8:	80 83       	st	Z, r24
	(UECFG1X &= ~(1<<EPBK1));											// 01b: Double bank
 1aa:	80 81       	ld	r24, Z
 1ac:	87 7f       	andi	r24, 0xF7	; 247
 1ae:	80 83       	st	Z, r24
}																	
 1b0:	08 95       	ret

000001b2 <PLL_inicialization>:

unsigned int interrupt_status;

void PLL_inicialization(void)
{																
		(PLLFRQ |= (1<<PINMUX));									// 8 MHz osc. input to PLL
 1b2:	82 b7       	in	r24, 0x32	; 50
 1b4:	80 68       	ori	r24, 0x80	; 128
 1b6:	82 bf       	out	0x32, r24	; 50
		(PLLFRQ &= ~(1<<PLLUSB));		
 1b8:	82 b7       	in	r24, 0x32	; 50
 1ba:	8f 7b       	andi	r24, 0xBF	; 191
 1bc:	82 bf       	out	0x32, r24	; 50
		(PLLCSR &= ~(1<<PINDIV));									// select 8 MHz input clock for PLL				
 1be:	89 b5       	in	r24, 0x29	; 41
 1c0:	8f 7e       	andi	r24, 0xEF	; 239
 1c2:	89 bd       	out	0x29, r24	; 41
		(PLLCSR |= (1<<PLLE));										// enables PLL				
 1c4:	89 b5       	in	r24, 0x29	; 41
 1c6:	82 60       	ori	r24, 0x02	; 2
 1c8:	89 bd       	out	0x29, r24	; 41
			while ( !( PLLCSR & (1<<PLOCK)) );						//	=== PLL locked?	PLOCK = 1		!!!!!!!!!!!!	
 1ca:	09 b4       	in	r0, 0x29	; 41
 1cc:	00 fe       	sbrs	r0, 0
 1ce:	fd cf       	rjmp	.-6      	; 0x1ca <PLL_inicialization+0x18>
}
 1d0:	08 95       	ret

000001d2 <usb_inicialization>:

void usb_inicialization (void)
{
 1d2:	cf 93       	push	r28
 1d4:	df 93       	push	r29
	USB_regulator_enable();										//Power On the USB interface
 1d6:	e7 ed       	ldi	r30, 0xD7	; 215
 1d8:	f0 e0       	ldi	r31, 0x00	; 0
 1da:	80 81       	ld	r24, Z
 1dc:	81 60       	ori	r24, 0x01	; 1
 1de:	80 83       	st	Z, r24
	USB_VBUS_pad_enable();										//• Power-On USB pads regulator
 1e0:	c8 ed       	ldi	r28, 0xD8	; 216
 1e2:	d0 e0       	ldi	r29, 0x00	; 0
 1e4:	88 81       	ld	r24, Y
 1e6:	80 61       	ori	r24, 0x10	; 16
 1e8:	88 83       	st	Y, r24
	USB_full_speed_mode();										//• Configure PLL interface
 1ea:	e0 ee       	ldi	r30, 0xE0	; 224
 1ec:	f0 e0       	ldi	r31, 0x00	; 0
 1ee:	80 81       	ld	r24, Z
 1f0:	8b 7f       	andi	r24, 0xFB	; 251
 1f2:	80 83       	st	Z, r24
																//• Enable PLL
	PLL_inicialization();										//• Check PLL lock
 1f4:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <PLL_inicialization>
																//• Enable USB interface
	USB_enable();												//• Configure USB interface (USB speed, Endpoints configuration...)
 1f8:	88 81       	ld	r24, Y
 1fa:	80 68       	ori	r24, 0x80	; 128
 1fc:	88 83       	st	Y, r24
	USB_clock_freeze_disable();									//• Wait for USB VBUS information connection
 1fe:	88 81       	ld	r24, Y
 200:	8f 7d       	andi	r24, 0xDF	; 223
 202:	88 83       	st	Y, r24
																//• Attach USB device	
}
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	08 95       	ret

0000020a <endpoint_activation>:



void endpoint_activation(void)
{
 20a:	ef 92       	push	r14
 20c:	ff 92       	push	r15
 20e:	0f 93       	push	r16
 210:	1f 93       	push	r17
 212:	cf 93       	push	r28
 214:	df 93       	push	r29
		endpoint_selection(1);
 216:	81 e0       	ldi	r24, 0x01	; 1
 218:	0e 94 75 00 	call	0xea	; 0xea <endpoint_selection>
	endpoint_enable();
 21c:	cb ee       	ldi	r28, 0xEB	; 235
 21e:	d0 e0       	ldi	r29, 0x00	; 0
 220:	88 81       	ld	r24, Y
 222:	81 60       	ori	r24, 0x01	; 1
 224:	88 83       	st	Y, r24
	set_interrupt_endpoint_type();
 226:	0e 94 bb 00 	call	0x176	; 0x176 <set_interrupt_endpoint_type>
	endpoint_type_IN();
 22a:	0c ee       	ldi	r16, 0xEC	; 236
 22c:	10 e0       	ldi	r17, 0x00	; 0
 22e:	f8 01       	movw	r30, r16
 230:	80 81       	ld	r24, Z
 232:	81 60       	ori	r24, 0x01	; 1
 234:	80 83       	st	Z, r24
	set_endpoint_size_64();
 236:	0e 94 c4 00 	call	0x188	; 0x188 <set_endpoint_size_64>
	set_one_bank();
 23a:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <set_one_bank>
	allocate_endpoint_memory();	
 23e:	0f 2e       	mov	r0, r31
 240:	fd ee       	ldi	r31, 0xED	; 237
 242:	ef 2e       	mov	r14, r31
 244:	ff 24       	eor	r15, r15
 246:	f0 2d       	mov	r31, r0
 248:	f7 01       	movw	r30, r14
 24a:	80 81       	ld	r24, Z
 24c:	82 60       	ori	r24, 0x02	; 2
 24e:	80 83       	st	Z, r24
	
		endpoint_selection(2);
 250:	82 e0       	ldi	r24, 0x02	; 2
 252:	0e 94 75 00 	call	0xea	; 0xea <endpoint_selection>
	endpoint_enable();
 256:	88 81       	ld	r24, Y
 258:	81 60       	ori	r24, 0x01	; 1
 25a:	88 83       	st	Y, r24
	set_interrupt_endpoint_type();
 25c:	0e 94 bb 00 	call	0x176	; 0x176 <set_interrupt_endpoint_type>
	endpoint_type_OUT();
 260:	f8 01       	movw	r30, r16
 262:	80 81       	ld	r24, Z
 264:	8e 7f       	andi	r24, 0xFE	; 254
 266:	80 83       	st	Z, r24
	set_endpoint_size_64();
 268:	0e 94 c4 00 	call	0x188	; 0x188 <set_endpoint_size_64>
	set_one_bank();
 26c:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <set_one_bank>
	allocate_endpoint_memory();	
 270:	f7 01       	movw	r30, r14
 272:	80 81       	ld	r24, Z
 274:	82 60       	ori	r24, 0x02	; 2
 276:	80 83       	st	Z, r24
	
		endpoint_selection(3);
 278:	83 e0       	ldi	r24, 0x03	; 3
 27a:	0e 94 75 00 	call	0xea	; 0xea <endpoint_selection>
	endpoint_enable();
 27e:	88 81       	ld	r24, Y
 280:	81 60       	ori	r24, 0x01	; 1
 282:	88 83       	st	Y, r24
	set_interrupt_endpoint_type();
 284:	0e 94 bb 00 	call	0x176	; 0x176 <set_interrupt_endpoint_type>
	endpoint_type_IN();
 288:	f8 01       	movw	r30, r16
 28a:	80 81       	ld	r24, Z
 28c:	81 60       	ori	r24, 0x01	; 1
 28e:	80 83       	st	Z, r24
	set_endpoint_size_64();
 290:	0e 94 c4 00 	call	0x188	; 0x188 <set_endpoint_size_64>
	set_one_bank();
 294:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <set_one_bank>
	allocate_endpoint_memory();	
 298:	f7 01       	movw	r30, r14
 29a:	80 81       	ld	r24, Z
 29c:	82 60       	ori	r24, 0x02	; 2
 29e:	80 83       	st	Z, r24
	
		endpoint_selection(4);
 2a0:	84 e0       	ldi	r24, 0x04	; 4
 2a2:	0e 94 75 00 	call	0xea	; 0xea <endpoint_selection>
	endpoint_enable();
 2a6:	88 81       	ld	r24, Y
 2a8:	81 60       	ori	r24, 0x01	; 1
 2aa:	88 83       	st	Y, r24
	set_interrupt_endpoint_type();
 2ac:	0e 94 bb 00 	call	0x176	; 0x176 <set_interrupt_endpoint_type>
	endpoint_type_OUT();
 2b0:	f8 01       	movw	r30, r16
 2b2:	80 81       	ld	r24, Z
 2b4:	8e 7f       	andi	r24, 0xFE	; 254
 2b6:	80 83       	st	Z, r24
	set_endpoint_size_64();
 2b8:	0e 94 c4 00 	call	0x188	; 0x188 <set_endpoint_size_64>
	set_one_bank();
 2bc:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <set_one_bank>
	allocate_endpoint_memory();		
 2c0:	f7 01       	movw	r30, r14
 2c2:	80 81       	ld	r24, Z
 2c4:	82 60       	ori	r24, 0x02	; 2
 2c6:	80 83       	st	Z, r24
}
 2c8:	df 91       	pop	r29
 2ca:	cf 91       	pop	r28
 2cc:	1f 91       	pop	r17
 2ce:	0f 91       	pop	r16
 2d0:	ff 90       	pop	r15
 2d2:	ef 90       	pop	r14
 2d4:	08 95       	ret

000002d6 <interrupt_configuration>:

void interrupt_configuration(void)
{
		(UEIENX |= (1<<NAKOUTE));									// enable an endpoint interrupt (EPINTx) when NAKOUTI is set.
 2d6:	e0 ef       	ldi	r30, 0xF0	; 240
 2d8:	f0 e0       	ldi	r31, 0x00	; 0
 2da:	80 81       	ld	r24, Z
 2dc:	80 61       	ori	r24, 0x10	; 16
 2de:	80 83       	st	Z, r24
		(UEIENX |= (1<<NAKINE));									//Set to enable an endpoint interrupt (EPINTx) when NAKINI is set.
 2e0:	80 81       	ld	r24, Z
 2e2:	80 64       	ori	r24, 0x40	; 64
 2e4:	80 83       	st	Z, r24
		(UEIENX |= (1<<RXSTPE));									//Set to enable an endpoint interrupt (EPINTx) when RXSTPI is sent.
 2e6:	80 81       	ld	r24, Z
 2e8:	88 60       	ori	r24, 0x08	; 8
 2ea:	80 83       	st	Z, r24
		(UEIENX |= (1<<RXOUTE));									//Set to enable an endpoint interrupt (EPINTx) when RXOUTI is sent.
 2ec:	80 81       	ld	r24, Z
 2ee:	84 60       	ori	r24, 0x04	; 4
 2f0:	80 83       	st	Z, r24
		(UEIENX |= (1<<TXINE));										//Set to enable an endpoint interrupt (EPINTx) when TXINI is sent.
 2f2:	80 81       	ld	r24, Z
 2f4:	81 60       	ori	r24, 0x01	; 1
 2f6:	80 83       	st	Z, r24
}
 2f8:	08 95       	ret

000002fa <which_int_source>:
//	• 6 - NAKINI - NAK IN Received Interrupt Flag
//Set by hardware when a NAK handshake has been sent in response of a IN request from the
//host. This triggers an USB interrupt if NAKINE is sent.
//Shall be cleared by software. Setting by software has no effect.

 if (UEINTX &= (1<<NAKINI))				//  interrupt source nakini? 
 2fa:	e8 ee       	ldi	r30, 0xE8	; 232
 2fc:	f0 e0       	ldi	r31, 0x00	; 0
 2fe:	80 81       	ld	r24, Z
 300:	80 74       	andi	r24, 0x40	; 64
 302:	80 83       	st	Z, r24
 304:	80 81       	ld	r24, Z
 306:	88 23       	and	r24, r24
 308:	49 f0       	breq	.+18     	; 0x31c <which_int_source+0x22>
{
	interrupt_status = 1;
 30a:	81 e0       	ldi	r24, 0x01	; 1
 30c:	90 e0       	ldi	r25, 0x00	; 0
 30e:	90 93 34 01 	sts	0x0134, r25
 312:	80 93 33 01 	sts	0x0133, r24
	(UEINTX &= ~(1<<NAKINI));			// ack interrupt source	
 316:	80 81       	ld	r24, Z
 318:	8f 7b       	andi	r24, 0xBF	; 191
 31a:	80 83       	st	Z, r24
//• 4 - NAKOUTI - NAK OUT Received Interrupt Flag
//Set by hardware when a NAK handshake has been sent in response of a OUT/PING request
//from the host. This triggers an USB interrupt if NAKOUTE is sent.
//Shall be cleared by software. Setting by software has no effect.

 if (UEINTX &= (1<<NAKOUTI))				//  interrupt source NAKOUTI? 
 31c:	e8 ee       	ldi	r30, 0xE8	; 232
 31e:	f0 e0       	ldi	r31, 0x00	; 0
 320:	80 81       	ld	r24, Z
 322:	80 71       	andi	r24, 0x10	; 16
 324:	80 83       	st	Z, r24
 326:	80 81       	ld	r24, Z
 328:	88 23       	and	r24, r24
 32a:	49 f0       	breq	.+18     	; 0x33e <which_int_source+0x44>
{
	interrupt_status = 2;
 32c:	82 e0       	ldi	r24, 0x02	; 2
 32e:	90 e0       	ldi	r25, 0x00	; 0
 330:	90 93 34 01 	sts	0x0134, r25
 334:	80 93 33 01 	sts	0x0133, r24
	(UEINTX &= ~(1<<NAKOUTI));			// ack interrupt source	
 338:	80 81       	ld	r24, Z
 33a:	8f 7e       	andi	r24, 0xEF	; 239
 33c:	80 83       	st	Z, r24
//Set by hardware to signal that the current bank contains a new valid SETUP packet. An interrupt
//(EPINTx) is triggered (if enabled).
//Shall be cleared by software to handshake the interrupt. Setting by software has no effect.
//This bit is inactive (cleared) if the endpoint is an IN endpoint.

 if (UEINTX &= (1<<RXSTPI))				//  interrupt source RXSTPI? 
 33e:	e8 ee       	ldi	r30, 0xE8	; 232
 340:	f0 e0       	ldi	r31, 0x00	; 0
 342:	80 81       	ld	r24, Z
 344:	88 70       	andi	r24, 0x08	; 8
 346:	80 83       	st	Z, r24
 348:	80 81       	ld	r24, Z
 34a:	88 23       	and	r24, r24
 34c:	31 f0       	breq	.+12     	; 0x35a <which_int_source+0x60>
{
	interrupt_status = 3;
 34e:	83 e0       	ldi	r24, 0x03	; 3
 350:	90 e0       	ldi	r25, 0x00	; 0
 352:	90 93 34 01 	sts	0x0134, r25
 356:	80 93 33 01 	sts	0x0133, r24
//• 2 - RXOUTI / KILLBK - Received OUT Data Interrupt Flag
//Set by hardware to signal that the current bank contains a new packet. An interrupt (EPINTx) is
//triggered (if enabled).
//Shall be cleared by software to handshake the interrupt. Setting by software has no effect.

 if (UEINTX &= (1<<RXOUTI))				//  interrupt source RXOUTI)? 
 35a:	e8 ee       	ldi	r30, 0xE8	; 232
 35c:	f0 e0       	ldi	r31, 0x00	; 0
 35e:	80 81       	ld	r24, Z
 360:	84 70       	andi	r24, 0x04	; 4
 362:	80 83       	st	Z, r24
 364:	80 81       	ld	r24, Z
 366:	88 23       	and	r24, r24
 368:	49 f0       	breq	.+18     	; 0x37c <which_int_source+0x82>
{
	interrupt_status = 4;
 36a:	84 e0       	ldi	r24, 0x04	; 4
 36c:	90 e0       	ldi	r25, 0x00	; 0
 36e:	90 93 34 01 	sts	0x0134, r25
 372:	80 93 33 01 	sts	0x0133, r24
	(UEINTX &= ~(1<<RXOUTI));			// ack interrupt source	,  send handshake
 376:	80 81       	ld	r24, Z
 378:	8b 7f       	andi	r24, 0xFB	; 251
 37a:	80 83       	st	Z, r24
//Set by hardware to signal that the current bank is free and can be filled. An interrupt (EPINTx) is
//triggered (if enabled).
//Shall be cleared by software to handshake the interrupt. Setting by software has no effect.
//This bit is inactive (cleared) if the endpoint is an OUT endpoint.

 if (UEINTX &= (1<<TXINI))				//  interrupt source TXINI? 
 37c:	e8 ee       	ldi	r30, 0xE8	; 232
 37e:	f0 e0       	ldi	r31, 0x00	; 0
 380:	80 81       	ld	r24, Z
 382:	81 70       	andi	r24, 0x01	; 1
 384:	80 83       	st	Z, r24
 386:	80 81       	ld	r24, Z
 388:	88 23       	and	r24, r24
 38a:	49 f0       	breq	.+18     	; 0x39e <which_int_source+0xa4>
{
	interrupt_status = 5;
 38c:	85 e0       	ldi	r24, 0x05	; 5
 38e:	90 e0       	ldi	r25, 0x00	; 0
 390:	90 93 34 01 	sts	0x0134, r25
 394:	80 93 33 01 	sts	0x0133, r24
	(UEINTX &= ~(1<<TXINI));			// ack interrupt source	,  send handshake
 398:	80 81       	ld	r24, Z
 39a:	8e 7f       	andi	r24, 0xFE	; 254
 39c:	80 83       	st	Z, r24
 39e:	08 95       	ret

000003a0 <send_zlp>:
}


void send_zlp(void)
{
	while ( !( UEINTX & (1<<TXINI)) );
 3a0:	e8 ee       	ldi	r30, 0xE8	; 232
 3a2:	f0 e0       	ldi	r31, 0x00	; 0
 3a4:	80 81       	ld	r24, Z
 3a6:	80 ff       	sbrs	r24, 0
 3a8:	fd cf       	rjmp	.-6      	; 0x3a4 <send_zlp+0x4>
	
	(UEINTX &= ~(1<<TXINI));
 3aa:	e8 ee       	ldi	r30, 0xE8	; 232
 3ac:	f0 e0       	ldi	r31, 0x00	; 0
 3ae:	80 81       	ld	r24, Z
 3b0:	8e 7f       	andi	r24, 0xFE	; 254
 3b2:	80 83       	st	Z, r24
	(UEINTX &= ~(1<<FIFOCON));							// send packet
 3b4:	80 81       	ld	r24, Z
 3b6:	8f 77       	andi	r24, 0x7F	; 127
 3b8:	80 83       	st	Z, r24
}
 3ba:	08 95       	ret

000003bc <main>:




int main(void)
{
 3bc:	1f 93       	push	r17
 3be:	cf 93       	push	r28
 3c0:	df 93       	push	r29
	// DODELAT MEGA INICIALIZACI
	// VYRESIT ZLP
	// prozkoumat pouziti TXINI
	usb_inicialization();
 3c2:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <usb_inicialization>
	interrupt_configuration();
 3c6:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <interrupt_configuration>
	USB_detach_disabled();
 3ca:	e0 ee       	ldi	r30, 0xE0	; 224
 3cc:	f0 e0       	ldi	r31, 0x00	; 0
 3ce:	80 81       	ld	r24, Z
 3d0:	8e 7f       	andi	r24, 0xFE	; 254
 3d2:	80 83       	st	Z, r24
	sei();
 3d4:	78 94       	sei
	case 4:
				N_out = UEBCLX;												// find out number of bytes
				
					for (i = 0; i <= N_out; i++ )							// read data from bank
					{
						data_out[i] = UEDATX;
 3d6:	a1 ef       	ldi	r26, 0xF1	; 241
 3d8:	b0 e0       	ldi	r27, 0x00	; 0
 3da:	4e e7       	ldi	r20, 0x7E	; 126
 3dc:	51 e0       	ldi	r21, 0x01	; 1
					}
					
				(UEINTX &= ~(1<<FIFOCON));							// stop sending NAK, ready for another OUT !
 3de:	e8 ee       	ldi	r30, 0xE8	; 232
 3e0:	f0 e0       	ldi	r31, 0x00	; 0
					N_in = bytes_to_send;
					
				
					for (i = 0; i <= N_in; i++ )							// push data into bank
					{
						UEDATX = data_in[i];
 3e2:	2b e3       	ldi	r18, 0x3B	; 59
 3e4:	31 e0       	ldi	r19, 0x01	; 1
	
	
		 while(1)
		 {
			 
    		switch (interrupt_status)
 3e6:	80 91 33 01 	lds	r24, 0x0133
 3ea:	90 91 34 01 	lds	r25, 0x0134
 3ee:	83 30       	cpi	r24, 0x03	; 3
 3f0:	91 05       	cpc	r25, r1
 3f2:	79 f0       	breq	.+30     	; 0x412 <main+0x56>
 3f4:	83 30       	cpi	r24, 0x03	; 3
 3f6:	91 05       	cpc	r25, r1
 3f8:	40 f0       	brcs	.+16     	; 0x40a <main+0x4e>
 3fa:	84 30       	cpi	r24, 0x04	; 4
 3fc:	91 05       	cpc	r25, r1
 3fe:	09 f4       	brne	.+2      	; 0x402 <main+0x46>
 400:	49 c0       	rjmp	.+146    	; 0x494 <main+0xd8>
 402:	85 30       	cpi	r24, 0x05	; 5
 404:	91 05       	cpc	r25, r1
 406:	99 f7       	brne	.-26     	; 0x3ee <main+0x32>
 408:	5f c0       	rjmp	.+190    	; 0x4c8 <main+0x10c>
	case 1:
				interrupt_status = 0;
	case 2:
				
				
				interrupt_status = 0;
 40a:	10 92 34 01 	sts	0x0134, r1
 40e:	10 92 33 01 	sts	0x0133, r1
				
	case 3:		//Once the OUT status stage has been received, the USB controller waits for a SETUP request.
				//The SETUP request have priority over any other request and has to be ACK’ed. This means that
				//	any other flag should be cleared and the fifo reset when a SETUP is received.
		
		(UEIENX &= ~(1<<NAKOUTE));														// turn off interrupts !
 412:	e0 ef       	ldi	r30, 0xF0	; 240
 414:	f0 e0       	ldi	r31, 0x00	; 0
 416:	80 81       	ld	r24, Z
 418:	8f 7e       	andi	r24, 0xEF	; 239
 41a:	80 83       	st	Z, r24
		(UEIENX &= ~(1<<NAKINE));
 41c:	80 81       	ld	r24, Z
 41e:	8f 7b       	andi	r24, 0xBF	; 191
 420:	80 83       	st	Z, r24
		(UEIENX &= ~(1<<RXOUTE));
 422:	80 81       	ld	r24, Z
 424:	8b 7f       	andi	r24, 0xFB	; 251
 426:	80 83       	st	Z, r24
		(UEIENX &= ~(1<<TXINE));	
 428:	80 81       	ld	r24, Z
 42a:	8e 7f       	andi	r24, 0xFE	; 254
 42c:	80 83       	st	Z, r24
						//while (RXOUTI != 1)												// waiting for data0 to be sent
							//{
							//// flash led for example 
							//}
																						// read data from bank
								bmRequestType = UEDATX;
 42e:	e1 ef       	ldi	r30, 0xF1	; 241
 430:	f0 e0       	ldi	r31, 0x00	; 0
 432:	80 81       	ld	r24, Z
 434:	80 93 37 01 	sts	0x0137, r24
								
								bRequest = UEDATX;
 438:	80 81       	ld	r24, Z
 43a:	80 93 c0 01 	sts	0x01C0, r24
								
								wValue_lsb = UEDATX;
 43e:	90 81       	ld	r25, Z
 440:	90 93 bf 01 	sts	0x01BF, r25
								wValue_msb = UEDATX;
 444:	90 81       	ld	r25, Z
 446:	90 93 7b 01 	sts	0x017B, r25
								
								wIndex_lsb = UEDATX;
 44a:	90 81       	ld	r25, Z
 44c:	90 93 36 01 	sts	0x0136, r25
								wIndex_msb = UEDATX;
 450:	90 81       	ld	r25, Z
 452:	90 93 3a 01 	sts	0x013A, r25
								
								wLength_lsb = UEDATX;
 456:	90 81       	ld	r25, Z
 458:	90 93 35 01 	sts	0x0135, r25
								wLength_msb = UEDATX;
 45c:	90 81       	ld	r25, Z
 45e:	90 93 7d 01 	sts	0x017D, r25
					(UEINTX &= ~(1<<RXSTPI));												// ack interrupt source	, send handshake																			
 462:	e8 ee       	ldi	r30, 0xE8	; 232
 464:	f0 e0       	ldi	r31, 0x00	; 0
 466:	90 81       	ld	r25, Z
 468:	97 7f       	andi	r25, 0xF7	; 247
 46a:	90 83       	st	Z, r25
					// CHOOSE REQUEST TYPE
								switch (bRequest)
 46c:	88 23       	and	r24, r24
 46e:	11 f0       	breq	.+4      	; 0x474 <main+0xb8>
 470:	85 30       	cpi	r24, 0x05	; 5
 472:	51 f4       	brne	.+20     	; 0x488 <main+0xcc>
											case 0:												// GET_STATUS
											
											
											case 5:												// SET_ADDRESS

											UDADDR = wValue_lsb;								// copy adress from host to uC register UDADDR
 474:	80 91 bf 01 	lds	r24, 0x01BF
 478:	c3 ee       	ldi	r28, 0xE3	; 227
 47a:	d0 e0       	ldi	r29, 0x00	; 0
 47c:	88 83       	st	Y, r24
											send_zlp();											// send zero length packet
 47e:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <send_zlp>
											(UDADDR |= (1<<ADDEN));								// enable adress 
 482:	88 81       	ld	r24, Y
 484:	80 68       	ori	r24, 0x80	; 128
 486:	88 83       	st	Y, r24
								
								
								
								
					
						(UEINTX &= ~(1<<RXOUTI));			// ack ack data stage, ready for IN or OUT data
 488:	e8 ee       	ldi	r30, 0xE8	; 232
 48a:	f0 e0       	ldi	r31, 0x00	; 0
 48c:	80 81       	ld	r24, Z
 48e:	8b 7f       	andi	r24, 0xFB	; 251
 490:	80 83       	st	Z, r24
 492:	ff cf       	rjmp	.-2      	; 0x492 <main+0xd6>
				
				interrupt_status = 0;
				interrupt_configuration();									// TURN interrupts back ON	
				/////////////////////////////////////////////////////////////////
	case 4:
				N_out = UEBCLX;												// find out number of bytes
 494:	c2 ef       	ldi	r28, 0xF2	; 242
 496:	d0 e0       	ldi	r29, 0x00	; 0
 498:	78 81       	ld	r23, Y
 49a:	70 93 39 01 	sts	0x0139, r23
				
					for (i = 0; i <= N_out; i++ )							// read data from bank
 49e:	10 92 7c 01 	sts	0x017C, r1
 4a2:	60 e0       	ldi	r22, 0x00	; 0
					{
						data_out[i] = UEDATX;
 4a4:	1c 91       	ld	r17, X
 4a6:	ca 01       	movw	r24, r20
 4a8:	86 0f       	add	r24, r22
 4aa:	91 1d       	adc	r25, r1
 4ac:	ec 01       	movw	r28, r24
 4ae:	18 83       	st	Y, r17
				interrupt_configuration();									// TURN interrupts back ON	
				/////////////////////////////////////////////////////////////////
	case 4:
				N_out = UEBCLX;												// find out number of bytes
				
					for (i = 0; i <= N_out; i++ )							// read data from bank
 4b0:	6f 5f       	subi	r22, 0xFF	; 255
 4b2:	60 93 7c 01 	sts	0x017C, r22
 4b6:	76 17       	cp	r23, r22
 4b8:	a8 f7       	brcc	.-22     	; 0x4a4 <main+0xe8>
					{
						data_out[i] = UEDATX;
					}
					
				(UEINTX &= ~(1<<FIFOCON));							// stop sending NAK, ready for another OUT !
 4ba:	80 81       	ld	r24, Z
 4bc:	8f 77       	andi	r24, 0x7F	; 127
 4be:	80 83       	st	Z, r24
				interrupt_status = 0;
 4c0:	10 92 34 01 	sts	0x0134, r1
 4c4:	10 92 33 01 	sts	0x0133, r1
				/////////////////////////////////////////////////////////////////
	case 5:
					N_in = bytes_to_send;
 4c8:	80 91 be 01 	lds	r24, 0x01BE
 4cc:	80 93 38 01 	sts	0x0138, r24
					
				
					for (i = 0; i <= N_in; i++ )							// push data into bank
 4d0:	10 92 7c 01 	sts	0x017C, r1
 4d4:	80 e0       	ldi	r24, 0x00	; 0
					{
						UEDATX = data_in[i];
 4d6:	b9 01       	movw	r22, r18
 4d8:	68 0f       	add	r22, r24
 4da:	71 1d       	adc	r23, r1
 4dc:	eb 01       	movw	r28, r22
 4de:	88 81       	ld	r24, Y
 4e0:	8c 93       	st	X, r24
				/////////////////////////////////////////////////////////////////
	case 5:
					N_in = bytes_to_send;
					
				
					for (i = 0; i <= N_in; i++ )							// push data into bank
 4e2:	80 91 7c 01 	lds	r24, 0x017C
 4e6:	8f 5f       	subi	r24, 0xFF	; 255
 4e8:	80 93 7c 01 	sts	0x017C, r24
 4ec:	90 91 38 01 	lds	r25, 0x0138
 4f0:	98 17       	cp	r25, r24
 4f2:	88 f7       	brcc	.-30     	; 0x4d6 <main+0x11a>
					{
						UEDATX = data_in[i];
					}
				
				
				(UEINTX &= ~(1<<FIFOCON));							// stop sending NAK, send data and be ready for another IN !
 4f4:	80 81       	ld	r24, Z
 4f6:	8f 77       	andi	r24, 0x7F	; 127
 4f8:	80 83       	st	Z, r24
				interrupt_status = 0;
 4fa:	10 92 34 01 	sts	0x0134, r1
 4fe:	10 92 33 01 	sts	0x0133, r1
 502:	71 cf       	rjmp	.-286    	; 0x3e6 <main+0x2a>

00000504 <__vector_11>:
}	
	

	
ISR (USB_COM_vect)														// endpoint interrupt routine
{
 504:	1f 92       	push	r1
 506:	0f 92       	push	r0
 508:	0f b6       	in	r0, 0x3f	; 63
 50a:	0f 92       	push	r0
 50c:	11 24       	eor	r1, r1
 50e:	2f 93       	push	r18
 510:	3f 93       	push	r19
 512:	4f 93       	push	r20
 514:	5f 93       	push	r21
 516:	6f 93       	push	r22
 518:	7f 93       	push	r23
 51a:	8f 93       	push	r24
 51c:	9f 93       	push	r25
 51e:	af 93       	push	r26
 520:	bf 93       	push	r27
 522:	ef 93       	push	r30
 524:	ff 93       	push	r31
 if (UEINT &= (1<<EPINT0))				// endpoint 0 interrupt
 526:	e4 ef       	ldi	r30, 0xF4	; 244
 528:	f0 e0       	ldi	r31, 0x00	; 0
 52a:	80 81       	ld	r24, Z
 52c:	81 70       	andi	r24, 0x01	; 1
 52e:	80 83       	st	Z, r24
 530:	80 81       	ld	r24, Z
 532:	88 23       	and	r24, r24
 534:	29 f0       	breq	.+10     	; 0x540 <__vector_11+0x3c>
{
	endpoint_selection(0);
 536:	80 e0       	ldi	r24, 0x00	; 0
 538:	0e 94 75 00 	call	0xea	; 0xea <endpoint_selection>
	which_int_source();			
 53c:	0e 94 7d 01 	call	0x2fa	; 0x2fa <which_int_source>
}	

/////////////////////////////////////////////

 if (UEINT &= (1<<EPINT1))				// endpoint 1 interrupt (IN)
 540:	e4 ef       	ldi	r30, 0xF4	; 244
 542:	f0 e0       	ldi	r31, 0x00	; 0
 544:	80 81       	ld	r24, Z
 546:	82 70       	andi	r24, 0x02	; 2
 548:	80 83       	st	Z, r24
 54a:	80 81       	ld	r24, Z
 54c:	88 23       	and	r24, r24
 54e:	29 f0       	breq	.+10     	; 0x55a <__vector_11+0x56>
{
	endpoint_selection(1);	
 550:	81 e0       	ldi	r24, 0x01	; 1
 552:	0e 94 75 00 	call	0xea	; 0xea <endpoint_selection>
	which_int_source();			
 556:	0e 94 7d 01 	call	0x2fa	; 0x2fa <which_int_source>
}	

////////////////////////////////////////////

 if (UEINT &= (1<<EPINT2))				// endpoint 2 interrupt (OUT)
 55a:	e4 ef       	ldi	r30, 0xF4	; 244
 55c:	f0 e0       	ldi	r31, 0x00	; 0
 55e:	80 81       	ld	r24, Z
 560:	84 70       	andi	r24, 0x04	; 4
 562:	80 83       	st	Z, r24
 564:	80 81       	ld	r24, Z
 566:	88 23       	and	r24, r24
 568:	29 f0       	breq	.+10     	; 0x574 <__vector_11+0x70>
{
	endpoint_selection(2);	
 56a:	82 e0       	ldi	r24, 0x02	; 2
 56c:	0e 94 75 00 	call	0xea	; 0xea <endpoint_selection>
	which_int_source();			
 570:	0e 94 7d 01 	call	0x2fa	; 0x2fa <which_int_source>
}
	
}
 574:	ff 91       	pop	r31
 576:	ef 91       	pop	r30
 578:	bf 91       	pop	r27
 57a:	af 91       	pop	r26
 57c:	9f 91       	pop	r25
 57e:	8f 91       	pop	r24
 580:	7f 91       	pop	r23
 582:	6f 91       	pop	r22
 584:	5f 91       	pop	r21
 586:	4f 91       	pop	r20
 588:	3f 91       	pop	r19
 58a:	2f 91       	pop	r18
 58c:	0f 90       	pop	r0
 58e:	0f be       	out	0x3f, r0	; 63
 590:	0f 90       	pop	r0
 592:	1f 90       	pop	r1
 594:	18 95       	reti

00000596 <_exit>:
 596:	f8 94       	cli

00000598 <__stop_program>:
 598:	ff cf       	rjmp	.-2      	; 0x598 <__stop_program>
